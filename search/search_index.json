{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"camply","text":"<p><code>camply</code>, the campsite finder \u26fa\ufe0f, is a tool to help you book a campsite online. Finding reservations at sold out campgrounds can be tough. That's where camply comes in. It searches thousands of campgrounds across the ~~USA~~ world via the APIs of booking services like https://recreation.gov. It continuously checks for cancellations and availabilities to pop up - once a campsite becomes available, camply sends you a notification to book your spot!</p> <p> </p>"},{"location":"#table-of-contents","title":"Table of Contents","text":"<ul> <li>Installation<ul> <li>PyPI</li> <li>Docker</li> </ul> </li> <li>Providers<ul> <li>RecreationDotGov</li> <li>Yellowstone</li> <li>GoingToCamp</li> <li>RecDotGov Tours + Tickets + Timed Entry</li> </ul> </li> <li>Command Line Usage<ul> <li>Simple Examples</li> <li>providers</li> <li>campsites</li> <li>recreation-areas</li> <li>campgrounds</li> <li>configure</li> <li>test-notifications</li> <li>list-campsites</li> <li>tui</li> <li>Examples<ul> <li>Searching for a Campsite</li> <li>Searching for a Campsite by Campground ID</li> <li>Searching for a Specific Campsite by ID</li> <li>Continuously Searching for A Campsite</li> <li>Searching Across Multiple Time Windows</li> <li>Continue Looking After The First Match Is Found</li> <li>Send a Push Notification</li> <li>Send a Text Message</li> <li>Send a Notification to Different Services</li> <li>Searching for Specific Weekdays</li> <li>Send a Notification Using Apprise-Compatible Services</li> <li>Look for Weekend Campsite Availabilities</li> <li>Look for Consecutive Nights at the Same Campsite</li> <li>Look for a Campsite Inside of Yellowstone</li> <li>Look for a Campsite from GoingToCamp</li> <li>Searching GoingToCamp Using Equipment</li> <li>Look for a Campsite Across Multiple Recreation areas</li> <li>Using a YAML Configuration file to search for campsites</li> <li>Searching for a Campsite That Fits Your Equipment</li> <li>Saving the Results of a Search</li> <li>Search for Recreation Areas by Query String</li> <li>Look for Specific Campgrounds Within a Recreation Area</li> <li>Look for Specific Campgrounds by Query String</li> <li>Searching for Tickets and Timed Entries<ul> <li>Tickets + Tours</li> <li>Timed Entry</li> <li>Using the Daily Providers</li> </ul> </li> <li>Search ReserveCalifornia</li> <li>Run camply as a CRON Job</li> </ul> </li> </ul> </li> <li>How to Run Camply<ul> <li>Run Modes<ul> <li>non-continuous</li> <li>continuous</li> <li>search-forever</li> <li>search-once</li> </ul> </li> <li>Running in Docker<ul> <li>Environment Variables</li> </ul> </li> </ul> </li> <li>Finding Recreation Areas IDs and Campground IDs To Search Without Using the Command Line</li> <li>Object-Oriented Usage (Python)<ul> <li>Search for a Recreation.gov Campsite</li> <li>Continuously Search for Recreation.gov Campsites</li> </ul> </li> <li>Dependencies</li> </ul> <p>Recreation data provided by Recreation.gov</p> <p></p> <p><p> </p></p>"},{"location":"cli/","title":"Command Line Interface","text":""},{"location":"cli/#documentation","title":"Documentation","text":""},{"location":"cli/#camply","title":"camply","text":"<p>Welcome to camply, the campsite finder.</p> <p>Finding reservations at sold out campgrounds can be tough. That's where camply comes in. It searches the APIs of booking services like https://recreation.gov (which indexes thousands of campgrounds across the USA) to continuously check for cancellations and availabilities to pop up. Once a campsite becomes available, camply sends you a notification to book your spot!</p> <p>visit the camply documentation at https://juftin.com/camply</p> <p>Usage:</p> <pre><code>camply [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--debug</code> / <code>--no-debug</code> boolean Enable extra debugging output None <code>--provider</code> choice (<code>RecreationDotGov</code> | <code>Yellowstone</code> | <code>GoingToCamp</code> | <code>ReserveCalifornia</code> | <code>AlabamaStateParks</code> | <code>ArizonaStateParks</code> | <code>FloridaStateParks</code> | <code>MinnesotaStateParks</code> | <code>MissouriStateParks</code> | <code>OhioStateParks</code> | <code>VirginiaStateParks</code> | <code>NorthernTerritory</code> | <code>FairfaxCountyParks</code> | <code>MaricopaCountyParks</code> | <code>OregonMetro</code> | <code>RecreationDotGovTicket</code> | <code>RecreationDotGovTimedEntry</code> | <code>RecreationDotGovDailyTicket</code> | <code>RecreationDotGovDailyTimedEntry</code>) Camping Search Provider. Defaults to 'RecreationDotGov' None <code>--version</code> boolean Show the version and exit. <code>False</code> <code>--help</code> boolean Show this message and exit. <code>False</code> <p>Subcommands</p> <ul> <li>campgrounds: </li> <li>campsites: </li> <li>configure: </li> <li>equipment-types: </li> <li>list-campsites: </li> <li>providers: </li> <li>recreation-areas: </li> <li>test-notifications: </li> <li>tui: Open Textual TUI.</li> </ul>"},{"location":"cli/#camply-campgrounds","title":"camply campgrounds","text":"<p>Search for Campgrounds (inside of Recreation Areas) and list them</p> <p>Search for Campgrounds and their IDs. Campgrounds are facilities inside of Recreation Areas that contain campsites. Most 'campgrounds' are areas made up of multiple campsites, others are facilities like fire towers or cabins that might only contain a single 'campsite' to book.</p> <p>Usage:</p> <pre><code>camply campgrounds [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--search</code> text Search for Campgrounds or Recreation Areas by search string. None <code>--state</code> text Filter by US state code. None <code>--rec-area</code> text Add Recreation Areas (comprised of campgrounds) by ID. None <code>--campground</code> text Add individual Campgrounds by ID. None <code>--campsite</code> text Add individual Campsites by ID. None <code>--provider</code> choice (<code>RecreationDotGov</code> | <code>Yellowstone</code> | <code>GoingToCamp</code> | <code>ReserveCalifornia</code> | <code>AlabamaStateParks</code> | <code>ArizonaStateParks</code> | <code>FloridaStateParks</code> | <code>MinnesotaStateParks</code> | <code>MissouriStateParks</code> | <code>OhioStateParks</code> | <code>VirginiaStateParks</code> | <code>NorthernTerritory</code> | <code>FairfaxCountyParks</code> | <code>MaricopaCountyParks</code> | <code>OregonMetro</code> | <code>RecreationDotGovTicket</code> | <code>RecreationDotGovTimedEntry</code> | <code>RecreationDotGovDailyTicket</code> | <code>RecreationDotGovDailyTimedEntry</code>) Camping Search Provider. Defaults to 'RecreationDotGov' None <code>--debug</code> / <code>--no-debug</code> boolean Enable extra debugging output None <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#camply-campsites","title":"camply campsites","text":"<p>Find Available Campsites with Custom Search Criteria</p> <p>Search for a campsite within camply. Campsites are returned based on the search criteria provided. Campsites contain properties like booking date, site type (tent, RV, cabin, etc), capacity, price, and a link to make the booking. Required parameters include <code>--start-date</code>, <code>--end-date</code>, <code>--rec-area</code> / <code>--campground</code>. Constant searching functionality can be enabled with  <code>--continuous</code> and notifications can be enabled using <code>--notifications</code>.</p> <p>Usage:</p> <pre><code>camply campsites [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--rec-area</code> text Add Recreation Areas (comprised of campgrounds) by ID. None <code>--campground</code> text Add individual Campgrounds by ID. None <code>--campsite</code> text Add individual Campsites by ID. None <code>--start-date</code> text (YYYY-MM-DD) Start of Search window. You will be arriving this day. None <code>--end-date</code> text (YYYY-MM-DD) End of Search window. You will be checking out this day. None <code>--nights</code> integer Search for campsite stays with consecutive nights. Defaults to 1 which returns all campsites found. <code>1</code> <code>--weekends</code> boolean Only search for weekend bookings (Fri/Sat nights). <code>False</code> <code>--day</code> choice (<code>Monday</code> | <code>Tuesday</code> | <code>Wednesday</code> | <code>Thursday</code> | <code>Friday</code> | <code>Saturday</code> | <code>Sunday</code> | <code>MON</code> | <code>TUE</code> | <code>TUES</code> | <code>WED</code> | <code>THU</code> | <code>THUR</code> | <code>THURS</code> | <code>FRI</code> | <code>SAT</code> | <code>SUN</code>) Day(s) of the Week to search. None <code>--notifications</code> choice (<code>pushover</code> | <code>email</code> | <code>ntfy</code> | <code>apprise</code> | <code>pushbullet</code> | <code>slack</code> | <code>telegram</code> | <code>twilio</code> | <code>silent</code>) Enables continuous searching. Types of notifications to receive. Options available are <code>pushover</code>, <code>email</code>, <code>ntfy</code>, <code>apprise</code>, <code>pushbullet</code>, <code>slack</code>, <code>telegram</code>, <code>twilio</code>, <code>silent</code>. Defaults to <code>silent</code> - which just logs messages to console. <code>[]</code> <code>--continuous</code> boolean Continuously check for a campsite to become available, and quit once at least one campsite is found. <code>False</code> <code>--search-forever</code> text Enables continuous searching. This method continues to search after the first availability has been found. The one caveat is that it will never notify about the same identical campsite for the same booking date. <code>False</code> <code>--yaml-config</code>, <code>--yml-config</code> file Rather than provide arguments to the command line utility, instead pass a file path to a YAML configuration file. See the documentation for more information on how to structure your configuration file. None <code>--offline-search</code> boolean When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. <code>False</code> <code>--offline-search-path</code> file Enables offline search. This is the name of the file to be saved/loaded. Campsites can be saved as a serialized pickle file or a JSON file, depending on the file extension. When not specified, the filename will default to <code>camply_campsites.json</code> None <code>--search-once</code> boolean Enables continuous searching features - but doesn't actually search continuously. This option is only useful when you want to run camply periodically in a CRON job fashion but still receive notifications - it's strongly recommended you enable offline searching as well to save results between searches. <code>False</code> <code>--polling-interval</code> integer Enables continuous searching. How often to wait in between checks (in minutes). Defaults to 10, cannot be less than 5. None <code>--notify-first-try</code> text Enables continuous searching. Whether to send all non-silent notifications if more than 5 matching campsites are found on the first try. Defaults to False which only sends the first 5. <code>False</code> <code>--equipment</code> text Search for campsites compatible with your camping equipment. This argument accepts two options, the equipment name and its length If you don't want to filter based on length provide a length of 0. Accepted equipment names include <code>Tent</code>, <code>RV</code>. <code>Trailer</code>, <code>Vehicle</code> and are not case-sensitive. None <code>--equipment-id</code> text Search for campsites compatible with specific equipment categories. Going To Camp uses equipment category IDs for filtering campsites by equipment. Every recreation area has equipment categories unique to it. Use <code>camply equipment-types --provider GoingToCamp --rec-area &lt;rec area id&gt;</code> to get a listing of equipment for an area. None <code>--provider</code> choice (<code>RecreationDotGov</code> | <code>Yellowstone</code> | <code>GoingToCamp</code> | <code>ReserveCalifornia</code> | <code>AlabamaStateParks</code> | <code>ArizonaStateParks</code> | <code>FloridaStateParks</code> | <code>MinnesotaStateParks</code> | <code>MissouriStateParks</code> | <code>OhioStateParks</code> | <code>VirginiaStateParks</code> | <code>NorthernTerritory</code> | <code>FairfaxCountyParks</code> | <code>MaricopaCountyParks</code> | <code>OregonMetro</code> | <code>RecreationDotGovTicket</code> | <code>RecreationDotGovTimedEntry</code> | <code>RecreationDotGovDailyTicket</code> | <code>RecreationDotGovDailyTimedEntry</code>) Camping Search Provider. Defaults to 'RecreationDotGov' None <code>--debug</code> / <code>--no-debug</code> boolean Enable extra debugging output None <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#camply-configure","title":"camply configure","text":"<p>Set up camply configuration file with an interactive console</p> <p>In order to send notifications through camply you must set up some authorization values. Whether you need to set up pushover notifications (push notifications on your phone, your pushover account can be set up at https://pushover.net) or Email messages, everything can be done through the configure command. The end result is a file called .camply in your home folder.</p> <p>Usage:</p> <pre><code>camply configure [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--debug</code> / <code>--no-debug</code> boolean Enable extra debugging output None <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#camply-equipment-types","title":"camply equipment-types","text":"<p>Get a list of supported equipment</p> <p>This command returns supported equipment for the current provider/recreation area. Equipment are camping equipment that can be used at a campsite. Different providers and recreation areas have different types of equipment for which reservations can be made.</p> <p>Usage:</p> <pre><code>camply equipment-types [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--rec-area</code> text Add Recreation Areas (comprised of campgrounds) by ID. None <code>--provider</code> choice (<code>RecreationDotGov</code> | <code>Yellowstone</code> | <code>GoingToCamp</code> | <code>ReserveCalifornia</code> | <code>AlabamaStateParks</code> | <code>ArizonaStateParks</code> | <code>FloridaStateParks</code> | <code>MinnesotaStateParks</code> | <code>MissouriStateParks</code> | <code>OhioStateParks</code> | <code>VirginiaStateParks</code> | <code>NorthernTerritory</code> | <code>FairfaxCountyParks</code> | <code>MaricopaCountyParks</code> | <code>OregonMetro</code> | <code>RecreationDotGovTicket</code> | <code>RecreationDotGovTimedEntry</code> | <code>RecreationDotGovDailyTicket</code> | <code>RecreationDotGovDailyTimedEntry</code>) Camping Search Provider. Defaults to 'RecreationDotGov' None <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#camply-list-campsites","title":"camply list-campsites","text":"<p>List campsite IDs for a given campground or recreation area</p> <p>Usage:</p> <pre><code>camply list-campsites [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--rec-area</code> text Add Recreation Areas (comprised of campgrounds) by ID. None <code>--campground</code> text Add individual Campgrounds by ID. None <code>--provider</code> choice (<code>RecreationDotGov</code> | <code>Yellowstone</code> | <code>GoingToCamp</code> | <code>ReserveCalifornia</code> | <code>AlabamaStateParks</code> | <code>ArizonaStateParks</code> | <code>FloridaStateParks</code> | <code>MinnesotaStateParks</code> | <code>MissouriStateParks</code> | <code>OhioStateParks</code> | <code>VirginiaStateParks</code> | <code>NorthernTerritory</code> | <code>FairfaxCountyParks</code> | <code>MaricopaCountyParks</code> | <code>OregonMetro</code> | <code>RecreationDotGovTicket</code> | <code>RecreationDotGovTimedEntry</code> | <code>RecreationDotGovDailyTicket</code> | <code>RecreationDotGovDailyTimedEntry</code>) Camping Search Provider. Defaults to 'RecreationDotGov' None <code>--debug</code> / <code>--no-debug</code> boolean Enable extra debugging output None <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#camply-providers","title":"camply providers","text":"<p>List the different camply providers</p> <p>Usage:</p> <pre><code>camply providers [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--debug</code> / <code>--no-debug</code> boolean Enable extra debugging output None <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#camply-recreation-areas","title":"camply recreation-areas","text":"<p>Search for Recreation Areas and list them</p> <p>Search for Recreation Areas and their IDs. Recreation Areas are places like National Parks and National Forests that can contain one or many campgrounds.</p> <p>Usage:</p> <pre><code>camply recreation-areas [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--search</code> text Search for Campgrounds or Recreation Areas by search string. None <code>--state</code> text Filter by US state code. None <code>--debug</code> / <code>--no-debug</code> boolean Enable extra debugging output None <code>--provider</code> choice (<code>RecreationDotGov</code> | <code>Yellowstone</code> | <code>GoingToCamp</code> | <code>ReserveCalifornia</code> | <code>AlabamaStateParks</code> | <code>ArizonaStateParks</code> | <code>FloridaStateParks</code> | <code>MinnesotaStateParks</code> | <code>MissouriStateParks</code> | <code>OhioStateParks</code> | <code>VirginiaStateParks</code> | <code>NorthernTerritory</code> | <code>FairfaxCountyParks</code> | <code>MaricopaCountyParks</code> | <code>OregonMetro</code> | <code>RecreationDotGovTicket</code> | <code>RecreationDotGovTimedEntry</code> | <code>RecreationDotGovDailyTicket</code> | <code>RecreationDotGovDailyTimedEntry</code>) Camping Search Provider. Defaults to 'RecreationDotGov' None <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#camply-test-notifications","title":"camply test-notifications","text":"<p>Test your notification provider setup</p> <p>Usage:</p> <pre><code>camply test-notifications [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--notifications</code> choice (<code>pushover</code> | <code>email</code> | <code>ntfy</code> | <code>apprise</code> | <code>pushbullet</code> | <code>slack</code> | <code>telegram</code> | <code>twilio</code> | <code>silent</code>) Types of notifications to receive. Options available are <code>pushover</code>, <code>email</code>, <code>ntfy</code>, <code>apprise</code>, <code>pushbullet</code>, <code>slack</code>, <code>telegram</code>, <code>twilio</code>, <code>silent</code>. Defaults to <code>silent</code> - which just logs messages to console. _required <code>--debug</code> / <code>--no-debug</code> boolean Enable extra debugging output None <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#camply-tui","title":"camply tui","text":"<p>Open Textual TUI.</p> <p>Usage:</p> <pre><code>camply tui [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"command_line_usage/","title":"Command Line Usage","text":"<p>When installed, <code>camply</code>'s command line utility can be invoked with the command, <code>camply</code>. The CLI tool accepts one of six sub-arguments: <code>campsites</code>, <code>recreation-areas</code>, <code>campgrounds</code>, <code>providers</code>, <code>equipment-types</code>, and <code>configure</code>.</p> <p>Important</p> <p>The multi-line commands in this documentation correspond to running <code>camply</code> on a MacOS or Linux Shell. If you are a Windows user take note that multi-line commands on Windows Shells use the <code>^</code> character instead of <code>\\</code> to escape new lines.</p> <pre><code>\u276f camply --help\n Usage: camply [OPTIONS] COMMAND [ARGS]...\n Welcome to camply, the campsite finder.\n Finding reservations at sold out campgrounds can be tough. That's where camply comes in. It searches the\n APIs of booking services like https://recreation.gov (which indexes thousands of campgrounds across the\n USA) to continuously check for cancellations and availabilities to pop up. Once a campsite becomes\n available, camply sends you a notification to book your spot!\n visit the camply documentation at https://juftin.com/camply\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502                                                                                                        \u2502\n\u2502  --debug/--no-debug             Enable extra debugging output                                          \u2502\n\u2502  --provider              TEXT   Camping Search Provider. Defaults to 'RecreationDotGov'                \u2502\n\u2502  --version                      Show the version and exit.                                             \u2502\n\u2502  --help                         Show this message and exit.                                            \u2502\n\u2502                                                                                                        \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Commands \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502                                                                                                        \u2502\n\u2502  campgrounds              Search for Campgrounds (inside of Recreation Areas) and list them            \u2502\n\u2502  campsites                Find Available Campsites with Custom Search Criteria                         \u2502\n\u2502  configure                Set up camply configuration file with an interactive console                 \u2502\n\u2502  equipment-types          Get a list of supported equipment                                            \u2502\n\u2502  list-campsites           List campsite IDs for a given campground or recreation area                  \u2502\n\u2502  providers                List the different camply providers                                          \u2502\n\u2502  recreation-areas         Search for Recreation Areas and list them                                    \u2502\n\u2502  test-notifications       Test your notification provider setup                                        \u2502\n\u2502  tui                      Open Textual TUI.                                                            \u2502\n\u2502                                                                                                        \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"command_line_usage/#simple-examples","title":"Simple Examples","text":"<p>Search for a specific recreation area (recreation areas contain campgrounds):</p> <pre><code>camply recreation-areas --search \"Glacier National Park\"\n</code></pre> <p>Search for campgrounds (campgrounds contain campsites):</p> <pre><code>camply campgrounds --search \"Fire Lookout Towers\" --state CA\n</code></pre> <p>Search for available campsites, get an notification whenever one becomes available, and continue searching after the first one is found:</p> <pre><code>camply campsites \\\n    --rec-area 2725 \\\n    --start-date 2023-07-10 \\\n    --end-date 2023-07-18 \\\n    --notifications email \\\n    --search-forever\n</code></pre>"},{"location":"command_line_usage/#providers","title":"providers","text":"<p>List the various providers that camply works with.</p> <pre><code>camply providers\n</code></pre> <p>Note</p> <p>If no provider is specified, camply will use the default provider, <code>RecreationDotGov</code>, which searches for recreation areas, campgrounds, and campsites listed on https://recreation.gov</p>"},{"location":"command_line_usage/#campsites","title":"campsites","text":"<p>Search for a campsite within camply. Campsites are returned based on the search criteria provided. Campsites contain properties like booking date, site type (tent, RV, cabin, etc), capacity, price, and a link to make the booking. Required parameters include <code>--start-date</code>, <code>--end-date</code>, <code>--rec-area</code> / <code>--campground</code> / <code>--campsite</code>. Constant searching functionality can be enabled with <code>--continuous</code> and notifications can be enabled using <code>--notifications</code> (see the Send a Push Notification section for more information).</p>"},{"location":"command_line_usage/#arguments","title":"Arguments","text":"<ul> <li><code>--rec-area</code>: <code>RECREATION_AREA_ID</code><ul> <li>Add Recreation Areas (comprised of campgrounds) by ID.     **example</li> </ul> </li> <li><code>--campground</code>: <code>CAMPGROUND_ID</code><ul> <li>Add individual Campgrounds by ID.     **example</li> </ul> </li> <li><code>--campsite</code>: <code>CAMPSITE_ID</code><ul> <li>Add individual Campsites by ID.     **example</li> </ul> </li> <li><code>--start-date</code>: <code>START_DATE</code><ul> <li><code>YYYY-MM-DD</code>: Start of Search window. You will be arriving this day.     **example</li> </ul> </li> <li><code>--end-date</code>: <code>END_DATE</code><ul> <li><code>YYYY-MM-DD</code>: End of Search window. You will be checking out this day..     **example</li> </ul> </li> <li><code>--day</code><ul> <li>Day(s) of the Week to search.     **example</li> </ul> </li> <li><code>--weekends</code><ul> <li>Only search for weekend bookings (Fri/Sat nights).     **example</li> </ul> </li> <li><code>--nights</code><ul> <li>Search for campsite stays with consecutive nights. Defaults to 1 which returns all campsites     found.     **example</li> </ul> </li> <li><code>--provider</code>: <code>PROVIDER</code><ul> <li>Camping Search Provider. Defaults to 'RecreationDotGov', not case-sensitive. Options include:     RecreationDotGov, Yellowstone,     GoingToCamp, RecreationDotGovDailyTicket,     RecreationDotGovDailyTimedEntry, RecreationDotGovTicket,     RecreationDotGovTimedEntry.     **example</li> </ul> </li> <li><code>--continuous</code><ul> <li>Continuously check for a campsite to become available, and quit once at least one campsite is     found.     **example</li> </ul> </li> <li><code>--search-forever</code><ul> <li>Enables continuous searching. This method continues to search after the first availability     has been found. The one caveat is that it will never notify about the same identical campsite     for the same booking date.     **example</li> </ul> </li> <li><code>--notifications</code>: <code>NOTIFICATIONS</code><ul> <li>Enables continuous searching. Types of notifications to receive. Options available     are <code>pushover</code>, <code>email</code>, <code>ntfy</code>, <code>apprise</code>, <code>pushbullet</code>, <code>slack</code>, <code>telegram</code>, <code>twilio</code>, <code>silent</code>.     Defaults to <code>silent</code> - which just logs messages to console.     **example</li> </ul> </li> <li><code>--equipment</code><ul> <li>Search for campsites compatible with your camping equipment. This argument accepts two     options, the equipment name and its length If you don't want to filter based on length provide     a length of 0. Accepted equipment names include <code>Tent</code>, <code>RV</code>. <code>Trailer</code>, <code>Vehicle</code> and are     not case-sensitive.     **example</li> </ul> </li> <li><code>--equipment-id</code><ul> <li>Search for campsites campaitble with specific equipment categories. Going To Camp     uses equipment category IDs for filtering campsites by equipment. Every recreation     area has equipment categories unique to it.     **example</li> </ul> </li> <li><code>--notify-first-try</code><ul> <li>Enables continuous searching. Whether to send all non-silent notifications if more than 5     matching campsites are found on the first try. Defaults to false which only sends the first5.     **example</li> </ul> </li> <li><code>--polling-interval</code>: <code>POLLING_INTERVAL</code><ul> <li>Enables continuous searching. How often to wait in between checks (in minutes). Defaults to     10, cannot be less than 5.     **example</li> </ul> </li> <li><code>--yaml-config</code><ul> <li>Rather than provide arguments to the command line utility, instead pass a file path to a YAML     configuration file. See the documentation for more information on how to structure your     configuration file.     **example</li> </ul> </li> <li><code>--offline-search</code><ul> <li>When set to True, the campsite search will both save the results of the campsites it's     found, but also load those campsites before beginning a search for other campsites.     **example</li> </ul> </li> <li><code>--offline-search-path</code><ul> <li>Enables offline search. This is the name of the file to be saved/loaded. Campsites can be saved as     a serialized pickle file or a JSON file, depending on the file extension. When not specified,     the filename will default to <code>camply_campsites.json</code>.     **example</li> </ul> </li> <li><code>--search-once</code><ul> <li>Enables continuous searching features - but doesn't actually search continuously. This option     is only useful when you want to run camply periodically in a CRON job fashion but still     receive notifications - it's strongly recommended you enable offline searching as     well to save results between searches.     **example</li> </ul> </li> </ul> <pre><code>camply campsites \\\n    --rec-area 2725 \\\n    --start-date 2023-07-10 \\\n    --end-date 2023-07-18\n</code></pre>"},{"location":"command_line_usage/#recreation-areas","title":"recreation-areas","text":"<p>Search for Recreation Areas and their IDs. Recreation Areas are places like National Parks and National Forests that can contain one or many campgrounds.</p>"},{"location":"command_line_usage/#arguments_1","title":"Arguments","text":"<ul> <li><code>--search</code> <code>SEARCH</code><ul> <li>Search for Campgrounds or Recreation Areas by search string.</li> </ul> </li> <li><code>--state</code> <code>STATE</code><ul> <li>Filter by US state code.</li> </ul> </li> </ul> <pre><code>camply recreation-areas --search \"Yosemite National Park\"\n</code></pre> <p>**see the examples for more information</p>"},{"location":"command_line_usage/#campgrounds","title":"campgrounds","text":"<p>Search for Campgrounds and their IDs. Campgrounds are facilities inside of Recreation Areas that contain campsites. Most 'campgrounds' are areas made up of multiple campsites, others are facilities like fire towers or cabins that might only contain a single 'campsite' to book.</p>"},{"location":"command_line_usage/#arguments_2","title":"Arguments","text":"<ul> <li><code>--search</code> <code>SEARCH</code><ul> <li>Search for Campgrounds or Recreation Areas by search string.</li> </ul> </li> <li><code>--state</code> <code>STATE</code><ul> <li>Filter by US state code.</li> </ul> </li> <li><code>--rec-area</code>: <code>RECREATION_AREA_ID</code><ul> <li>Add Recreation Areas (comprised of campgrounds) by ID.</li> </ul> </li> <li><code>--campground</code>: <code>CAMPGROUND_ID</code><ul> <li>Add individual Campgrounds by ID.</li> </ul> </li> </ul> <pre><code>camply campgrounds --search \"Fire Tower Lookout\" --state CA\n</code></pre> <p>**see the examples for more information</p>"},{"location":"command_line_usage/#configure","title":"configure","text":"<p>Set up <code>camply</code> configuration file with an interactive console</p> <p>In order to send notifications through <code>camply</code> you must set up some authorization values. Whether you need to set up Pushover notifications , PushBullet, Telegram, or Email messages, everything can be done through the <code>configure</code> command. The end result is a file called <code>.camply</code> in your home folder. See the Running in Docker section to see how you can use environment variables instead of a config file.</p> <pre><code>camply configure\n</code></pre>"},{"location":"command_line_usage/#test-notifications","title":"test-notifications","text":"<p>Test your notification provider setup.</p> <p>If you want to send yourself a test notification via camply, the <code>test-notifiactions</code> command is for you. See the Send a Push Notification section for more details on how to set up the notification provider of your choice.</p> <pre><code>camply test-notifications --notifications email\n</code></pre>"},{"location":"command_line_usage/#list-campsites","title":"list-campsites","text":"<p>When searching for a specific campsite by ID, it can be useful to list the campsites that were found. This command will list the campsites that were found given specific camground / recreation area ID.</p> <pre><code>camply list-campsites --campground 598 --provider ReserveCalifornia\n</code></pre> <p>That search above would tell you that <code>Premium Campsite #88</code> has ID #43473. Using that information you can then search for that specific campsite by ID:</p> <pre><code>camply campsites \\\n  --provider ReserveCalifornia \\\n  --campground 598 \\\n  --campsite 43473 \\\n  --start-date 2023-07-13 \\\n  --end-date 2023-07-14\n</code></pre> <p>Note</p> <p>Some providers require that you pass a campsite ID and and a campground ID, while others only require a campsite ID.</p>"},{"location":"command_line_usage/#tui","title":"tui","text":"<p>Camply has an optional TUI interface thanks to textual and trogon. A TUI is a text-based user interface that allows you to interact with camply in a more visual way, it's a visual application that runs in your terminal. The TUI config is a great way to set up your camp search with your mouse and keyboard, and then run camply like you normally would.</p> <p>Note</p> <p>Camply's TUI command requires that the <code>tui</code> extra is installed. To install camply with the TUI extra, run <code>pipx install \"camply[tui]\"</code>.</p> <pre><code>camply tui\n</code></pre> <p></p>"},{"location":"command_line_usage/#examples","title":"Examples","text":"<p>Read through the examples below to get a better understanding of <code>camply</code>, its features, and the functionality of the different arguments provided to the CLI.</p>"},{"location":"command_line_usage/#searching-for-a-campsite","title":"Searching for a Campsite","text":"<p>The below search looks for campsites inside of Recreation Area ID #2725 (Glacier National Park) between 2023-07-10 and 2023-07-17. The search will be performed once and any results will be logged to the console. camply searches for campsites inside of search windows in increments of one night. <code>--start-date</code> and <code>--end-date</code> define the bounds of the search window, you will be leaving the day after <code>--end-date</code>.</p> <pre><code>camply campsites \\\n    --rec-area 2725 \\\n    --start-date 2023-07-10 \\\n    --end-date 2023-07-18\n</code></pre>"},{"location":"command_line_usage/#searching-for-a-campsite-by-campground-id","title":"Searching for a Campsite by Campground ID","text":"<p>The below search looks for across three campgrounds (all inside Glacier National Park) between 2023-07-10 and 2023-07-17. Multiple Campgrounds (and Recreation Areas too) can be found by supplying the arguments more than once.</p> <pre><code>camply campsites \\\n    --campground 232493 \\\n    --campground 251869 \\\n    --campground 232492 \\\n    --start-date 2023-07-10 \\\n    --end-date 2023-07-18\n</code></pre>"},{"location":"command_line_usage/#searching-for-a-specific-campsite-by-id","title":"Searching for a Specific Campsite by ID","text":"<p>Sometimes you have a favorite campsite inside your favorite campground. To search for just a specific campsite (and not just all campsites within a campground) you can give its ID to <code>camply</code> with the <code>--campsite</code> argument. For example, site <code>R035</code> in Many Glacier Campground, MT is close to a trailhead. Its URL is https://www.recreation.gov/camping/campsites/98363 , here we can see that it's ID is <code>98363</code>. You can search for one or many campsites by ID by supplying the <code>--campsite</code> argument. You can provide the <code>--campsite</code> argument once or multiple times to search for different campsites.</p> <p>Note</p> <p>For RecreationDotGov, <code>--campsite</code> arguments override any <code>--rec-area</code> or <code>--campground</code> options provided. And <code>--campground</code> will override the <code>--rec-area</code> option.</p> <p>However other providers may need you to provide both a <code>--campground</code> and <code>--campsite</code> ID. See the list-campsites example for more information.</p> <pre><code>camply campsites \\\n    --campsite 98363 \\\n    --start-date 2023-07-10 \\\n    --end-date 2023-07-18\n</code></pre>"},{"location":"command_line_usage/#continuously-searching-for-a-campsite","title":"Continuously Searching for A Campsite","text":"<p>Most of the time you want to look for campgrounds until an eventual match is found. The below snippet will search for matching campsites until it finds a match. It also sends a notification via <code>pushover</code> once matches are found. Alternate notification methods are listed in the Send a Push Notification example.</p> <p>Note</p> <p>The use of <code>--continuous</code> in the below example isn't actually necessary. Continuous searching is enabled when any of the following options are provided: <code>--continuous</code>, <code>--notifications</code>, <code>--search-forever</code>, <code>--polling-interval</code>, <code>--notify-first-try</code>.</p> <pre><code>camply campsites \\\n    --rec-area 2725 \\\n    --start-date 2023-07-12 \\\n    --end-date 2023-07-13 \\\n    --continuous \\\n    --notifications pushover \\\n    --notify-first-try\n</code></pre> <p>Warning</p> <p>When <code>camply</code> is told to running continuously with non-silent notifications set up and it finds more than 5 matching campsites on the first try, it will only send notifications for the first 5 campsites. This is to prevent thousands of campsites flooding your notifications. It's always encouraged to perform an initial online search before setting up a <code>camply</code> search. To bypass this behavior and send all notifications, pass the <code>--notify-first-try</code> argument.</p>"},{"location":"command_line_usage/#searching-across-multiple-time-windows","title":"Searching Across Multiple Time Windows","text":"<p>There might be an occasion where you're looking to search for a campsite across multiple date ranges, i.e. any Monday in July. <code>camply</code> supports this quite nicely by passing multiple <code>--start-date</code> and <code>--end-date</code> options.</p> <p>Note</p> <p>The important rule about multiple <code>--start-date</code> and <code>--end-date</code> options is that ordering matters. If you provide multiple start dates and multiple end dates the first end date will correspond to the first start date, and so on and so forth.</p> <pre><code>camply campsites \\\n    --rec-area 2725 \\\n    --start-date 2023-07-12 \\\n    --end-date 2023-07-13 \\\n    --start-date 2023-07-19 \\\n    --end-date 2023-07-20 \\\n    --start-date 2023-07-26 \\\n    --end-date 2023-07-27\n</code></pre>"},{"location":"command_line_usage/#continue-looking-after-the-first-match-is-found","title":"Continue Looking After The First Match Is Found","text":"<p>Sometimes you want to search for all possible matches up until your arrival date. No problem. Add the <code>--search-forever</code> and <code>camply</code> won't stop sending notifications after the first match is found.</p> <p>Note</p> <p><code>camply</code> will save and store all previous notifications when <code>--search-forever</code> is enabled, so it won't notify you about the exact same campsite availability twice. This can be problematic when certain campsites become available more than once.</p> <pre><code>camply campsites \\\n    --rec-area 2725 \\\n    --start-date 2023-07-01 \\\n    --end-date 2023-08-01 \\\n    --notifications pushover \\\n    --search-forever\n</code></pre>"},{"location":"command_line_usage/#send-a-push-notification","title":"Send a Push Notification","text":"<p>camply supports notifications via a number of services:</p> <ul> <li>Pushover</li> <li>Email</li> <li>Ntfy</li> <li>Apprise</li> <li>Pushbullet</li> <li>Slack</li> <li>Telegram</li> <li>Twilio (SMS)</li> <li>Silent</li> </ul> <pre><code>camply campsites \\\n    --rec-area 2991 \\\n    --start-date 2023-09-10 \\\n    --end-date 2023-09-21 \\\n    --notifications pushover\n</code></pre> <p>Like all providers, <code>Pushover</code> requires that you share credentials/authentication - for <code>Pushover</code> this involves sharing your \"Pushover User Key\" with camply through a configuration file (via the <code>camply configure</code> command) or though environment variables (<code>PUSHOVER_PUSH_USER</code>). See the Environment Variables section for a list of relevant environment variables per notification provider.</p> <p>Info</p> <p>When searching continuously <code>camply</code> uses the <code>silent</code> notification provider unless you expictly specify another notification provider to use. The <code>silent</code> notification provider simply prints logs to your console when matching campsites are found.</p> <p>Note</p> <p>I personally use Pushover notifications - it's built for push notifications, easy to set up, and includes a 30-day trial and a one-time fee of $5 after that to unlock lifetime programmatic push notifications. There are other notification providers like <code>Ntfy</code>, <code>Slack</code> and <code>Email</code> that are free to use if that's more your style.</p>"},{"location":"command_line_usage/#send-a-text-message","title":"Send a Text Message","text":"<p>If you want to sign up for a Twilio account, camply also supports sending text messages via SMS. You can set up your Twilio configuration via <code>camply configure</code>. You will need to set the following config values for Twilio: <code>TWILIO_ACCOUNT_SID</code>, <code>TWILIO_AUTH_TOKEN</code>, <code>TWILIO_SOURCE_NUMBER</code>, <code>TWILIO_DEST_NUMBERS</code>.</p> <p>Sending text messages via Twilio also requires the <code>twilio</code> extras:</p> <pre><code>pip install camply[twilio]\n</code></pre> <pre><code>camply campsites \\\n    --rec-area 2991 \\\n    --start-date 2023-09-10 \\\n    --end-date 2023-09-21 \\\n    --notifications twilio\n</code></pre>"},{"location":"command_line_usage/#send-a-notification-to-different-services","title":"Send a Notification to Different Services","text":"<p>camply supports notifications from different providers. To send notifications to multiple providers you can pass the --notifications parameter multiple times. YAML config entries also accept an array as well.</p> <pre><code>camply campsites \\\n    --rec-area 2991 \\\n    --start-date 2023-09-10 \\\n    --end-date 2023-09-21 \\\n    --notifications email \\\n    --notifications pushover\n</code></pre>"},{"location":"command_line_usage/#send-a-notification-using-apprise-compatible-services","title":"Send a Notification Using Apprise-Compatible Services","text":"<p>In addition to the built-in notification providers, you can also send notifications using one of the many popular services supported by Apprise. You'll need to set up a supported notification URL using the <code>APPRISE_URL</code> config value; Refer to the Apprise documentation to learn how to format a URL to fit your needs.</p> <p>Using Apprise notifications requires the <code>apprise</code> extras:</p> <pre><code>pip install camply[apprise]\n</code></pre>"},{"location":"command_line_usage/#searching-for-specific-weekdays","title":"Searching for Specific Weekdays","text":"<p>The below search spans across a three-month time window, but it only looks for campsites that are available on a Tuesday or Wednesday night.</p> <p>Note</p> <p>You can use the day's full spelling or an abbreviation - and neither is case sensitive.</p> <pre><code>camply campsites \\\n    --campground 232446 \\\n    --start-date 2023-05-01 \\\n    --end-date 2023-08-01 \\\n    --day Tuesday \\\n    --day Wednesday\n</code></pre>"},{"location":"command_line_usage/#look-for-weekend-campsite-availabilities","title":"Look for Weekend Campsite Availabilities","text":"<p>This below search looks across larger periods of time, but only if a campground is available to book on a Friday or Saturday night (<code>--weekends</code>). It also uses the <code>--polling-interval</code> argument which checks every 5 minutes instead of the default 10 minutes.</p> <pre><code>camply campsites \\\n    --rec-area 2991 \\\n    --start-date 2023-05-01 \\\n    --end-date 2023-08-01 \\\n    --weekends \\\n    --notifications email \\\n    --polling-interval 5\n</code></pre> <p>Note</p> <p>Using the <code>--weekends</code> option is the same as specifying <code>--day Friday</code> + <code>--day Saturday</code>.</p>"},{"location":"command_line_usage/#look-for-consecutive-nights-at-the-same-campsite","title":"Look for Consecutive Nights at the Same Campsite","text":"<p>A lot of times you need to search for consecutive nights at the same campsite. By default, any and all campsites with a single nights booking are returned by camply. To search for campsites with consecutive night stays, pass the <code>--nights</code> argument.</p> <p>Note</p> <p>The <code>--nights</code> argument handles issues with improper search parameters. For example, if you set the <code>--weekends</code> parameter the maximum number of consecutive nights possible is 2. If you supply more than this your <code>--nights</code> parameter will be overwritten to 2.</p> <pre><code>camply campsites \\\n    --rec-area 2991 \\\n    --start-date 2023-05-01 \\\n    --end-date 2023-08-01 \\\n    --nights 4\n</code></pre>"},{"location":"command_line_usage/#look-for-a-campsite-inside-of-yellowstone","title":"Look for a Campsite Inside of Yellowstone","text":"<p>Yellowstone doesn't use https://recreation.gov to manage its campgrounds, instead it uses its own proprietary system. In order to search the Yellowstone API for campsites, make sure to pass the <code>--provider \"yellowstone\"</code> argument. This flag disables <code>--rec-area</code> argument.</p> <p>To learn more about using <code>camply</code> to find campsites at Yellowstone, check out this discussion.</p> <pre><code>camply campsites \\\n    --provider yellowstone \\\n    --start-date 2023-07-09 \\\n    --end-date 2023-07-17 \\\n    --continuous\n</code></pre>"},{"location":"command_line_usage/#look-for-a-campsite-from-goingtocamp","title":"Look for a Campsite from GoingToCamp","text":"<p>The <code>GoingToCamp</code> provider requires that you specify both a Recreation Area and a Campground in your search. First you'll need to find your Recreation Area ID:</p> <pre><code>camply recreation-areas --provider goingtocamp\n</code></pre> <p>For this example we'll search Washington State Parks which corresponds to Recreation Area ID #4. Next we'll list the Campgrounds within the Recreation Area:</p> <pre><code>camply campgrounds --provider goingtocamp --rec-area 4\n</code></pre> <p>The above command will list all of the campgrounds within our Recreation Area. For the next example we'll search for an availability at Bay Bridge State Park, which is in our Recreation Area and corresponds to Campground ID #-2147483645 (GoingToCamp regularly uses negative ID numbers).</p> <pre><code>camply campsites \\\n  --provider goingtocamp \\\n  --rec-area 4 \\\n  --campground -2147483645 \\\n  --start-date 2023-09-01 \\\n  --end-date 2023-09-02\n</code></pre>"},{"location":"command_line_usage/#searching-goingtocamp-using-equipment","title":"Searching GoingToCamp Using Equipment","text":"<p>In the previous GoingToCamp example we were searching Recreation Area ID #4 and Campground ID #-2147483645. GoingToCamp also allows us to search for campsites using equipment filters. In order to find the corresponding equipment IDs, you'll use the <code>equipment-types</code> command and pass in the Recreation Area ID:</p> <pre><code>camply equipment-types --provider goingtocamp --rec-area 4\n</code></pre> <p>The previous command will list all of the Equipment IDs for your Recreation Area. For our example we will use Equipment ID #-32763 which corresponds to an <code>RV/Trailer up to 25'</code>. Next we can use that Equipment ID in our search:</p> <pre><code>camply campsites \\\n  --provider goingtocamp \\\n  --rec-area 4 \\\n  --campground -2147483645 \\\n  --start-date 2023-09-01 \\\n  --end-date 2023-09-02 \\\n  --equipment-id -32763\n</code></pre>"},{"location":"command_line_usage/#look-for-a-campsite-across-multiple-recreation-areas","title":"Look for a Campsite Across Multiple Recreation areas","text":"<p>You don't have to confine your search to a single Recreation or Campground ID. Adding multiple arguments to the command line will search across multiple IDs. Keep in mind that any <code>--campground</code> arguments will overwrite all <code>--rec-area</code> arguments.</p> <pre><code>camply campsites \\\n    --rec-area 2991 \\\n    --rec-area 1074 \\\n    --start-date 2023-07-09 \\\n    --end-date 2023-07-17 \\\n    --nights 5\n</code></pre>"},{"location":"command_line_usage/#using-a-yaml-configuration-file-to-search-for-campsites","title":"Using a YAML Configuration file to search for campsites","text":"<p>Sometimes, using a YAML configuration file is easier to manage all of your search options. See the below YAML example file and corresponding camply command:</p> <pre><code>provider: RecreationDotGov # RecreationDotGov IF NOT PROVIDED\nrecreation_area: # (LIST OR SINGLE ENTRY)\n- 2991 # Yosemite National Park, CA (All Campgrounds)\n- 1074 # Sierra National Forest, CA (All Campgrounds)\ncampgrounds: # ENTIRE FIELD CAN BE OMITTED IF NOT USED - (LIST OR SINGLE ENTRY)\ncampsites: # OVERRIDES CAMPGROUNDS / RECREATION AREA - (LIST OR SINGLE ENTRY)\nstart_date: 2023-09-12 # YYYY-MM-DD - (LIST OR SINGLE ENTRY)\nend_date: 2023-09-13 # YYYY-MM-DD - (LIST OR SINGLE ENTRY)\ndays: # Array of day names - DEFAULTS TO `null`\nweekends: false # FALSE BY DEFAULT\nnights: 1 # 1 BY DEFAULT\ncontinuous: true # DEFAULTS TO TRUE\npolling_interval: 5 # DEFAULTS TO 10 , CAN'T BE LESS THAN 5\nnotifications: email # (silent, email, pushover, pushbullet, and telegram), DEFAULTS TO `silent`\nsearch_forever: true # FALSE BY DEFAULT\nsearch_once: false # FALSE BY DEFAULT\nnotify_first_try: false # FALSE BY DEFAULT\nequipment: # Array of Equipment Search Lists - DEFAULTS TO `null`\noffline_search: false # FALSE BY DEFAULT\noffline_search_path: camply_campsites.json # Defaults to `camply_campsites.json`\n</code></pre> <pre><code>camply campsites --yaml-config example_search.yaml\n</code></pre> <p>Note</p> <p>A JSON Schema for the YAML configuration file can be found at docs/yaml_search.json</p>"},{"location":"command_line_usage/#searching-for-a-campsite-that-fits-your-equipment","title":"Searching for a Campsite That Fits Your Equipment","text":"<p>Camply can help you filter campsites to fit your specific equipment, like a Trailer or an RV. Most likely, you care that the campsite fits the length of your RV so you can specify that as well. To search for specific equipment and its length provide the <code>--equipment</code> option with two arguments, the equipment name and the equipment length. If you don't want to filter based on length provide a length of zero. If you provide multiple <code>--equipment</code> options, sites matching any of your search equipment will be returned.</p> <p>Current supported equipment names are <code>Vehicle</code>, <code>Tent</code>, <code>RV</code>, and <code>Trailer</code>. Be careful when filtering on <code>Tents</code> and <code>Vehicle</code> length, sometimes Recreation.gov doesn't provide that information, it is safer to set length to 0.</p> <pre><code>camply campsites \\\n    --rec-area 2991 \\\n    --start-date 2023-07-09 \\\n    --end-date 2023-07-17 \\\n    --nights 5 \\\n    --equipment RV 25\n</code></pre> <p>Here's what the above search would look like on a YAML Config:</p> <pre><code>recreation_area:\n- 2991\nstart_date: 2023-07-09\nend_date: 2023-07-17\nnights: 5\nequipment:\n- [RV, 25]\n</code></pre> <p>Finally, here's a search that accommodates trailers of all lengths:</p> <pre><code>camply campsites \\\n    --rec-area 2991 \\\n    --start-date 2023-07-09 \\\n    --end-date 2023-07-17 \\\n    --nights 5 \\\n    --equipment Trailer 0\n</code></pre>"},{"location":"command_line_usage/#saving-the-results-of-a-search","title":"Saving the Results of a Search","text":"<p>In some cases, you might want to save all the campsites found during one search and load them into a new search, so you don't receive duplicate notifications. This can be achieved by passing the <code>--offline-search</code> flag. By default, camply will save the results in a file called <code>camply_campsites.json</code>.</p> <p>Alternatively, you can also path the <code>--offline-search-path</code> flag to specify a certain file path to save the results as. When a file path with a <code>.json</code> extension is passed camply will export the results as a JSON file. When the <code>.pkl</code> or <code>.pickle</code> extension is used, camply will use a serialized Pickle file.</p> <pre><code>camply \\\n  campsites \\\n  --campground 232064 \\\n  --start-date 2023-09-01 \\\n  --end-date 2023-10-01 \\\n  --continuous \\\n  --offline-search\n</code></pre> <pre><code>camply \\\n  campsites \\\n  --campground 232064 \\\n  --start-date 2023-09-01 \\\n  --end-date 2023-10-01 \\\n  --continuous \\\n  --offline-search-path campsites.pkl\n</code></pre>"},{"location":"command_line_usage/#search-for-recreation-areas-by-query-string","title":"Search for Recreation Areas by Query String","text":"<p>Just need to find what your local Recreation Area ID number is? This simple command allows you to search and list recreation areas. It accepts <code>--search</code> and <code>--state</code> arguments.</p> <pre><code>camply recreation-areas --search \"Yosemite National Park\"\n</code></pre>"},{"location":"command_line_usage/#look-for-specific-campgrounds-within-a-recreation-area","title":"Look for Specific Campgrounds Within a Recreation Area","text":"<p>Need to get even more specific and search for a particular campground? This search lists campgrounds attached to a recreation area id <code>--rec-area</code>. It also accepts <code>--search</code> and <code>--state</code> arguments.</p> <pre><code>camply campgrounds --rec-area 2991\n</code></pre>"},{"location":"command_line_usage/#look-for-specific-campgrounds-by-query-string","title":"Look for Specific Campgrounds by Query String","text":"<p>The below search looks for Fire Lookout Towers to stay in inside of California.</p> <pre><code>camply campgrounds --search \"Fire Tower Lookout\" --state CA\n</code></pre>"},{"location":"command_line_usage/#searching-for-tickets-and-timed-entries","title":"Searching for Tickets and Timed Entries","text":"<p>The Recreation.gov Tickets, Tours, &amp; Timed-Entry Providers support \"campgrounds\" that are actually resources like timed entry appointments and tickets to recreation activities.</p>"},{"location":"command_line_usage/#tickets-tours","title":"Tickets + Tours","text":"<p>Let's say you're going on vacation in Hawaii and you're interested in what hiking tickets are available:</p> <pre><code>camply campgrounds \\\n    --provider RecreationDotGovTicket \\\n    --state HI\n</code></pre> <p>Nice, there are some great options there. Let's say we've decided on the Haleakala National Park Summit Sunrise Reservations. This \"campground\" has ID #253731. These reservations are hard to snag but they do pop up!</p> <pre><code>camply campsites \\\n  --provider RecreationDotGovTicket \\\n  --start-date 2023-06-09 \\\n  --end-date 2023-06-10 \\\n  --campground 253731 \\\n  --search-forever \\\n  --notifications email\n</code></pre>"},{"location":"command_line_usage/#timed-entry","title":"Timed Entry","text":"<p>Let's say you're visiting Oregon and wanting to visit the Lava River Cave. They've recently implemented a Timed Reservation System - so we'd use the <code>RecreationDotGovTimedEntry</code> provider:</p> <pre><code>camply campgrounds \\\n    --provider RecreationDotGovTimedEntry \\\n    --state OR\n</code></pre> <p>Using the above command we can see that the campground ID we want is #10089508:</p> <pre><code>camply campsites \\\n  --provider RecreationDotGovTimedEntry \\\n  --start-date 2023-06-09 \\\n  --end-date 2023-06-10 \\\n  --campground 10089508 \\\n  --search-forever \\\n  --notifications email\n</code></pre>"},{"location":"command_line_usage/#using-the-daily-providers","title":"Using the Daily Providers","text":"<p>You'll also notice that there are alternative daily providers for our tours and timed entry providers: <code>RecreationDotGovTicket</code> -&gt; <code>RecreationDotGovDailyTicket</code> and <code>RecreationDotGovTimedEntry</code> -&gt; <code>RecreationDotGovDailyTimedEntry</code>. These providers search the same recreation activities as their non-daily counterparts but there are scenarios where you might want to use the daily provider.</p> <p>When you use the daily provider it issues an API request for each day in your search range, instead of once per month with the non-daily providers. This means that you can make as many as 31x more API requests compared to the non-daily counterpart. <code>camply</code> needs to be respectful of recreation.gov so always use the non-daily version when you have a large search window.</p> <p>It's suspected that the non-daily providers return \"cached\" results and can take longer to reflect actual inventory. When you have a small search window, or if you need to use the <code>--equipment</code> filtering functionality, then you should use the daily provider.</p> <p>In the following scenario we'll search for tickets to a great attraction, the Keys Ranch Tour, in Joshua Tree National Park.</p> <p>Here's how you could search for that and retrieve its campground ID, #300004:</p> <pre><code>camply campgrounds \\\n    --provider RecreationDotGovDailyTicket \\\n    --search \"Keys Ranch Tour\"\n</code></pre> <p>Great, now let's search:</p> <pre><code>camply campsites \\\n  --provider RecreationDotGovDailyTicket \\\n  --start-date 2023-07-06 \\\n  --end-date 2023-07-07 \\\n  --campground 300004\n</code></pre> <p>Let's take it even a step further, let's say you need 4 spots in their 1:00PM time slot. In this case we can search for that timeslot using the <code>--equipment</code> option and providing the time and minimum spots needed (<code>1300</code> and <code>4</code>):</p> <pre><code>camply campsites \\\n  --provider RecreationDotGovDailyTicket \\\n  --start-date 2023-07-06 \\\n  --end-date 2023-07-07 \\\n  --campground 300004 \\\n  --equipment 1300 4\n</code></pre> <p>Here's another example of searching for a specific time, this time for the timed-entry Tuweep Area Day Use Passes in Grand Canyon National Park (ID #10089462). In this example we're looking for any number of spots in their 8:00AM-5:00PM time slot:</p> <pre><code>camply campsites \\\n  --provider RecreationDotGovDailyTimedEntry \\\n  --start-date 2023-07-06 \\\n  --end-date 2023-07-07 \\\n  --campground 10089462 \\\n  --equipment 0800 0\n</code></pre>"},{"location":"command_line_usage/#search-reservecalifornia","title":"Search ReserveCalifornia","text":"<p>ReserveCalifornia is the online booking provider for California State Parks and it works a lot like <code>RecreationDotGov</code>.</p> <p>Note</p> <p>ReserveCalifornia is one of many providers that use the UseDirect API. The following providers are also supported:</p> <ul> <li><code>AlabamaStateParks</code>: Searches on ReserveAlaPark.com for Campsites</li> <li><code>ArizonaStateParks</code>: Searches on AZStateParks.com for Campsites</li> <li><code>FloridaStateParks</code>: Searches on FloridaStateParks.org for Campsites</li> <li><code>MinnesotaStateParks</code>: Searches on ReserveMN.usedirect.com for Campsites</li> <li><code>MissouriStateParks</code>: Searches on icampmo1.usedirect.com for Campsites</li> <li><code>OhioStateParks</code>: Searches on ReserveOhio.com for Campsites</li> <li><code>VirginiaStateParks</code>: Searches on ReserveVAParks.com for Campsites</li> <li><code>NorthernTerritory</code>: Searches the Australian Northern Territory for Campsites</li> <li><code>FairfaxCountyParks</code>: Searches on fairfax.usedirect.com for Campsites (Virginia)</li> <li><code>MaricopaCountyParks</code>: Searches on MaricopaCountyParks.org for Campsites (Arizona)</li> <li><code>OregonMetro</code>: Searches on OregonMetro.gov for Campsites (Portland Metro)</li> </ul> <p>If you wanted to look for recreation areas (groupings of campgrounds):</p> <pre><code>camply recreation-areas --provider ReserveCalifornia --search \"Los Angeles\"\n</code></pre> <p>If you want to look for more specific campgrounds to search:</p> <pre><code>camply campgrounds --provider ReserveCalifornia --search \"Sonoma Coast\"\n</code></pre> <p>And finally, searching for a campsite is very similar to RecreationDotGov:</p> <pre><code>camply campsites \\\n    --provider ReserveCalifornia \\\n    --start-date 2023-07-01 \\\n    --end-date 2023-08-01 \\\n    --rec-area 718 \\\n    --weekends\n</code></pre> <p>Note</p> <p><code>ReserveCalifornia</code> doesn't yet support searching / filtering by equipment.</p>"},{"location":"command_line_usage/#run-camply-as-a-cron-job","title":"Run camply as a CRON Job","text":"<p>In some instances you don't want to run camply as a continuous, blocking Python process. Instead you might want to run camply as a CRON job that checks for a campsite every 30 minutes (<code>*/30 * * * *</code>). In this case you would use the <code>--search-once</code> option which enables continuous searching functionality (like sending notifications) without actually searching continuously.</p> <p>Make sure to save your search results offline if running camply as a CRON job, this allows camply to save any campsites it finds between searches so that it only sends you a notification once:</p> <pre><code>camply campsites \\\n    --rec-area 2725 \\\n    --start-date 2023-07-10 \\\n    --end-date 2023-07-18 \\\n    --notifications email \\\n    --search-once \\\n    --offline-search\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#quickstart","title":"Quickstart","text":"<pre><code>pipx install pre-commit\npipx install hatch\npre-commit install\nhatch env create\nhatch shell\n</code></pre>"},{"location":"contributing/#tools","title":"Tools","text":"<p>This project makes use of a couple tools to streamline the development process: pre-commit and hatch.</p>"},{"location":"contributing/#pre-commit","title":"pre-commit","text":"<p>pre-commit is a tool to manage git-hooks scripts, which are useful for identifying simple issues before submission to code review.</p> <pre><code>pipx install pre-commit\npre-commit install\n</code></pre> <p>To use pre-commit, you must first install it. pipx is preferred, but you can also install with <code>pip</code>. Once pre-commit is installed, run <code>pre-commit install</code> to install the git-hooks scripts into the local repository. Done, now pre-commit will run automatically on git commit. To run it manually on your changed files run <code>pre-commit run</code> on your command line.</p>"},{"location":"contributing/#hatch","title":"hatch","text":"<p>hatch is a tool to manage the packaging and distribution of Python packages. It also used to manage the virtual environment for the project and running common scripts.</p> <pre><code>pipx install hatch\nhatch env create\nhatch run test\n</code></pre>"},{"location":"contributing/#commit-message-format","title":"Commit Message Format","text":"<p>Releases for this project are handled entirely by CI/CD via Pull requests being merged into the <code>main</code> branch. Contributions follow the gitmoji standards with conventional commits, orchestration is handled by the semantic-release tool.</p> <p>While you can denote other changes on your commit messages with gitmoji, the following commit message emoji prefixes are the only ones to trigger new releases:</p> Emoji Shortcode Description Semver \ud83d\udca5 :boom: Introduce breaking changes. Major \u2728 :sparkles: Introduce new features. Minor \ud83d\udc1b :bug: Fix a bug. Patch \ud83d\ude91 :ambulance: Critical hotfix. Patch \ud83d\udd12 :lock: Fix security issues. Patch <p>Most features can be squash merged into a single commit. If you're working on a feature, your commit message might look like:</p> <pre><code>\u2728 New Feature Description\n</code></pre> <p>Bug fix commits would look like this:</p> <pre><code>\ud83d\udc1b Bug Fix Description\n</code></pre>"},{"location":"contributing/#scripts","title":"Scripts","text":"<p>All common scripts for this repository are managed by hatch.</p> <pre><code>hatch run &lt;script&gt;\n</code></pre> Script Script Description <code>format</code> Code Formatting black and ruff <code>lint</code> Code Linting black and ruff <code>check</code> Type Checking with mypy <code>test</code> Unit Testing with pytest <code>all</code> Run multiple scripts: <code>format</code>, <code>lint</code>, <code>check</code>, <code>test</code> <code>docs-serve</code> Documentation Serving MkDocs and mkdocs-material <code>requirements</code> Lock File Updates with pip-tools <p>Note</p> <p>While the camply codebase is undergoing some refactoring, the <code>check</code> script is not required. Once the codebase is fully typed, the <code>check</code> script will be required to pass before a Pull Request can be merged. In the meantime, please use type annotations on any new changes.</p>"},{"location":"contributing/#dependencies","title":"Dependencies","text":"<p>Dependencies are managed by pip-tools / pip-compile. After updating dependencies in the <code>pyproject.toml</code> file, run the following to update the underlying <code>requirements.txt</code> files:</p> <pre><code>hatch run requirements\n</code></pre>"},{"location":"dependencies/","title":"Dependencies","text":"<p><code>camply</code> is compatible with any Python version &gt;= <code>3.8</code>. Here are the current dependencies:</p> <ul> <li>click<ul> <li>The <code>click</code> package is used to leverage it's simple Command Line Interface     API for camply</li> </ul> </li> <li>requests<ul> <li>The <code>requests</code> package is used to fetch data from the APIs of Camping Booking Providers.</li> </ul> </li> <li>pandas<ul> <li>The <code>pandas</code> package is to group and aggregate across large data sets of campsites,     campgrounds, and recreation areas.</li> </ul> </li> <li>tenacity<ul> <li>The <code>tenacity</code> package is used for retrying data searches on the underlying campsite APIs.     This retrying methodology handles exceptions allowing for API downtime and facilitating     exponential backoff.</li> </ul> </li> <li>rich<ul> <li>Colorizing the CLI (also using rich-click to     colorize <code>click</code>)</li> </ul> </li> <li>python-dotenv<ul> <li>The <code>python-dotenv</code> package reads key-value pairs from a <code>.env</code> file and can set them as     environment variables - this helps with the <code>.camply</code> configuration file.</li> </ul> </li> <li>pydantic<ul> <li>The <code>pydantic</code> package performs data validation against API responses and assists with fancy     data containers for <code>camply</code> objects.</li> </ul> </li> <li>PyYAML<ul> <li>PyYAML is a YAML parsing library - this helps with the YAML file campsite searches.</li> </ul> </li> <li>ratelimit<ul> <li>The <code>ratelimit</code> package is used for limiting the frequency of our API calls to external     APIs so we can be good partners to our friends who run the campsite booking services.</li> </ul> </li> <li>fake-useragent<ul> <li><code>fake-useragent</code> makes it easy for us to mock the latest browsers when interacting with     certain API providers.</li> </ul> </li> </ul>"},{"location":"how_to_run/","title":"How to Run Camply","text":""},{"location":"how_to_run/#run-modes","title":"Run Modes","text":""},{"location":"how_to_run/#non-continuous","title":"non-continuous","text":"<p>camply's default run-mode is \"non-continuous\". This means that camply runs a search with your custom campsite query once. Once this search is complete camply will exit whether it found any matching campsites or not. **example</p>"},{"location":"how_to_run/#continuous","title":"continuous","text":"<p>Second, camply has a \"continuous\" mode. Differently from the \"non-continuous\" mode, camply will continue to search until it finds at least one matching campsite. camply sleeps in between searches so we don't overload our friends who run the camping APIs. **example</p> <p>Note</p> <p>This mode is enabled when any of the following options are provided: <code>--continuous</code>, <code>--notifications</code>, <code>--search-forever</code>, <code>--polling-interval</code>, <code>--notify-first-try</code>.</p> <p>Important</p> <p>When you run camply in \"continuous\" or \"search-forever\" mode it needs to run as a continuous Python process in your terminal. This means that you need an always-on computer to run your search.</p> <p>A small computing device like a Raspberry Pi is perfect for something like this. If you're looking to achieve this with a device like a laptop, make sure you've prevented the computer from sleeping.</p>"},{"location":"how_to_run/#search-forever","title":"search-forever","text":"<p>Third, camply has its \"search-forever\" mode. This is slightly different from the \"continuous\" mode because it will continue to run even after it's found its first matching campsite. camply remembers which campsites it's found before and won't notify you for the same campsite twice. **example</p> <p>Note</p> <p>This mode is enabled with the <code>--search-forever</code> option.</p>"},{"location":"how_to_run/#search-once","title":"search-once","text":"<p>Lastly, camply has its \"search-once\" mode. This enables some features of continuous searching, like the ability to send notifications, but without actually running continuously. This is useful if you're interested in running camply as a CRON job instead of as a blocking python process. **example</p> <p>Note</p> <p>This mode is enabled with the <code>--search-once</code> option.</p>"},{"location":"how_to_run/#running-in-docker","title":"Running in Docker","text":"<p>Docker is a great solution to run camply wherever you are. There is an official docker image published alongside camply's PyPI distribution that makes running camply in the background as a detached container really easy.</p> <pre><code>docker pull juftin/camply\n</code></pre> <p>Here's an example of a detached container searching in the background (notice the <code>-d</code> flag, the container will run detached).</p> <pre><code>docker run --rm -d \\\n  --name camply-detached-example \\\n  --env PUSHOVER_PUSH_TOKEN=${PUSHOVER_PUSH_TOKEN} \\\n  --env PUSHOVER_PUSH_USER=${PUSHOVER_PUSH_USER} \\\n  --env TZ=\"America/Denver\" \\\n  juftin/camply \\\n  camply campsites \\\n      --rec-area 2991 \\\n      --start-date 2023-08-01 \\\n      --end-date 2023-09-01 \\\n      --search-forever \\\n      --notifications pushover\n</code></pre> <p>See the Environment Variables section for a list of environment variables camply uses. Alternatively, if you have already run <code>camply configure</code> locally, you can share your <code>.camply</code> file inside the docker container.</p> <pre><code>docker run --rm \\\n  --name camply-file-share-example \\\n  --env TZ=\"America/Denver\" \\\n  --volume ${HOME}/.camply:/home/camply/.camply \\\n  juftin/camply \\\n  camply campsites \\\n      --provider yellowstone \\\n      --start-date 2023-07-22 \\\n      --end-date 2023-07-27 \\\n      --search-forever \\\n      --notifications email\n</code></pre> <p>To manage multiple searches (with different notification preferences) I like to use YAML configuration files:</p> <pre><code>docker run --rm -d \\\n  --name camply-email-example \\\n  --env TZ=\"America/Denver\" \\\n  --env EMAIL_TO_ADDRESS=${EMAIL_TO_ADDRESS} \\\n  --env EMAIL_USERNAME=${EMAIL_USERNAME} \\\n  --env EMAIL_PASSWORD=${EMAIL_PASSWORD} \\\n  --volume example_search.yaml:/home/camply/example_search.yaml \\\n  juftin/camply:latest \\\n  camply campsites \\\n      --yaml-config /home/camply/example_search.yaml\n</code></pre> <p>A docker-compose example of the above YAML Config is also available.</p>"},{"location":"how_to_run/#environment-variables","title":"Environment Variables","text":"<ul> <li>Pushover Notifications<ul> <li><code>PUSHOVER_PUSH_USER</code></li> </ul> </li> <li>Apprise Notifications<ul> <li><code>APPRISE_URL</code></li> </ul> </li> <li>Email Notifications<ul> <li><code>EMAIL_TO_ADDRESS</code></li> <li><code>EMAIL_USERNAME</code></li> <li><code>EMAIL_PASSWORD</code></li> <li><code>EMAIL_FROM_ADDRESS</code> (defaults to \"camply@juftin.com\")</li> <li><code>EMAIL_SUBJECT_LINE</code> (defaults to \"camply Notification\")</li> <li><code>EMAIL_SMTP_SERVER</code> (defaults to \"smtp.gmail.com\")</li> <li><code>EMAIL_SMTP_PORT</code> (defaults to 465)</li> </ul> </li> <li>Ntfy Notifications<ul> <li><code>NTFY_TOPIC</code></li> </ul> </li> <li>Pushbullet Notifications<ul> <li><code>PUSHBULLET_API_TOKEN</code></li> </ul> </li> <li>Twilio Notifications<ul> <li><code>TWILIO_ACCOUNT_SID</code></li> <li><code>TWILIO_AUTH_TOKEN</code></li> <li><code>TWILIO_SOURCE_NUMBER</code></li> <li><code>TWILIO_DEST_NUMBERS</code></li> </ul> </li> <li>Slack Notifications<ul> <li><code>SLACK_WEBHOOK</code></li> </ul> </li> <li>Telegram Notifications<ul> <li><code>TELEGRAM_BOT_TOKEN</code></li> <li><code>TELEGRAM_CHAT_ID</code></li> </ul> </li> <li>Optional Environment Variables<ul> <li><code>LOG_LEVEL</code> (sets logging level, defaults to \"INFO\")</li> <li><code>PUSHOVER_PUSH_TOKEN</code> (Personal Pushover App Token)</li> <li><code>RIDB_API_KEY</code> (Personal API Key     for Recreation.gov API)</li> <li><code>TZ</code> (TZ Database Name for     logging, defaults to UTC)</li> </ul> </li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#python","title":"Python","text":"<pre><code>pipx install camply\n</code></pre> <p>Note</p> <p>If you're using camply on your command line - it's recommended that you use a tool like pipx to easily manage the application in an isolated virtual environment. However you can always <code>pip install camply</code> as well.</p> <p>PyPI Link</p>"},{"location":"installation/#docker","title":"Docker","text":"<pre><code>docker pull juftin/camply\n</code></pre> <p>Docker Hub Link</p> <p>**see Running in Docker.</p>"},{"location":"providers/","title":"Providers","text":"<p>camply works with a number of providers. A \"provider\" is an Online Booking Service that lists camping and recreation inventory.</p> <p>Info</p> <p>Rather than specifiying provider with the <code>--provider</code> option on the command line you can also set the <code>CAMPLY_PROVIDER</code> environnment variable.</p>"},{"location":"providers/#recreationgov","title":"Recreation.gov","text":"<p>Recreation.gov is (so far) the largest and most widely supported provider. This provider spans over thousands of campgrounds across the USA including most of our National parks.</p> <p>You can find the best documentation for searching for campsites over at the main documentation page: Command Line Usage</p> <pre><code>camply campgrounds --provider RecreationDotGov --state CA --search \"Fire Towers\"\n</code></pre>"},{"location":"providers/#yellowstone","title":"Yellowstone","text":"<p>Yellowstone is one of the few National Parks that uses a Campsite Booking provider other than Recreation.gov. A number of the campgrounds in Yellowstone can be booked through YellowstoneNationalParkLodges.com. Read more about using camply to search this provider on the documentation.</p> <pre><code>camply --provider Yellowstone campgrounds\n</code></pre> <p>The Yellowstone Provider currently supports the following Campgrounds:</p> <ul> <li>Bridge Bay Campground (YLYB:RV)</li> <li>Canyon Campground (YLYC:RV)</li> <li>Fishing Bridge RV Park (YLYF:RV)</li> <li>Grant Campground (YLYG:RV)</li> <li>Madison Campground (YLYM:RV)</li> </ul>"},{"location":"providers/#goingtocamp","title":"GoingToCamp","text":"<p>GoingToCamp provides campground listing and booking services for several US state and Canadian provincial parks.</p> <p>To get a listing of GoingToCamp recreation areas</p> <pre><code>camply --provider goingtocamp recreation-areas\n</code></pre> <p>Unlike other camply providers, when using GoingToCamp you must restrict campground and campsites searches to a single recreation area. Since recreation areas may list every campground in a state or provincial park system, it feels natural to filter searches by recreation area when using GoingToCamp.</p> <p>The GoingToCamp Provider currently contains the following Recreation Areas:</p> <ul> <li>Algonquin Highlands, Ontario, CA (#8)</li> <li>BC Parks, British Columbia, CA (#12)</li> <li>Gatineau Park, Ottawa-Gatineau, Ontario-Quebec, CA (#10)</li> <li>Long Point Region, Ontario, CA (#1)</li> <li>Maitland Valley, Ontario, CA (#4)</li> <li>Maryland State Parks, Maryland, USA (#9)</li> <li>Newfoundland &amp; Labrador Provincial Parks, Newfoundland and Labrador, CA (#11)</li> <li>Nova Scotia Parks, Nova Scotia, CA (#13)</li> <li>Parks Canada, Canada (#14) (https://reservation.pc.gc.ca/)</li> <li>Saugeen Valley, Ontario, CA (#5)</li> <li>St. Clair Region, Ontario, CA (#2)</li> <li>Tacoma Power Parks, Washington, USA (#6)</li> <li>Washington State Parks, Washington, USA (#3)</li> <li>Wisconsin State Parks, Wisconsin, USA (#7)</li> </ul> <p>Check out the following documentation examples for more details on searching GoingToCamp recreation areas:</p> <ul> <li>Look for a Campsite from GoingToCamp</li> <li>Searching GoingToCamp Using Equipment</li> </ul>"},{"location":"providers/#recreationgov-tickets-tours-timed-entry","title":"Recreation.gov Tickets, Tours, &amp; Timed-Entry","text":"<p>Apart from reservations for campsites, Recreation.gov also supports reserving tickets &amp; tours there are thousands of tickets and tours options available around the USA.</p> <p>Search for Tickets, Tours, &amp; Timed-Entry Online</p>"},{"location":"providers/#tours-tickets","title":"Tours &amp; Tickets","text":"<pre><code>camply campgrounds --provider RecreationDotGovTicket --state HI\n</code></pre>"},{"location":"providers/#timed-entry","title":"Timed Entry","text":"<pre><code>camply campgrounds --provider RecreationDotGovTimedEntry --state OR\n</code></pre> <ul> <li>Searching for Tickets and Timed Entries<ul> <li>Tickets + Tours</li> <li>Timed Entry</li> <li>Using the Daily Providers</li> </ul> </li> </ul>"},{"location":"providers/#state-parks","title":"State Parks","text":""},{"location":"providers/#reservecalifornia","title":"ReserveCalifornia","text":"<p>ReserveCalifornia is the Online Booking provider for California State Parks. With 279 park units, over 340 miles of coastline, 970 miles of lake and river frontage, 15,000 campsites, 5,200 miles of trails, the California Department of Parks and Recreation (State Parks) contains the largest and most diverse recreational holdings of any state agency in the nation.</p> <pre><code>camply recreation-areas --provider ReserveCalifornia --search \"Los Angeles\"\n</code></pre> <pre><code>camply campgrounds --provider ReserveCalifornia --search \"Sonoma Coast\"\n</code></pre> <pre><code>camply campsites \\\n    --provider ReserveCalifornia \\\n    --start-date 2023-07-01 \\\n    --end-date 2023-08-01 \\\n    --rec-area 718 \\\n    --weekends\n</code></pre> <ul> <li>Search ReserveCalifornia</li> </ul>"},{"location":"providers/#other-usedirect-providers","title":"Other UseDirect Providers","text":"<p>ReserveCalifornia is one of many providers that use the UseDirect API. The following providers are also supported:</p> <ul> <li><code>AlabamaStateParks</code>: Searches on ReserveAlaPark.com for Campsites</li> <li><code>ArizonaStateParks</code>: Searches on AZStateParks.com for Campsites</li> <li><code>FloridaStateParks</code>: Searches on FloridaStateParks.org for Campsites</li> <li><code>MinnesotaStateParks</code>: Searches on ReserveMN.usedirect.com for Campsites</li> <li><code>MissouriStateParks</code>: Searches on icampmo1.usedirect.com for Campsites</li> <li><code>OhioStateParks</code>: Searches on ReserveOhio.com for Campsites</li> <li><code>VirginiaStateParks</code>: Searches on ReserveVAParks.com for Campsites</li> <li><code>NorthernTerritory</code>: Searches the Australian Northern Territory for Campsites</li> <li><code>FairfaxCountyParks</code>: Searches on fairfax.usedirect.com for Campsites (Virginia)</li> <li><code>MaricopaCountyParks</code>: Searches on MaricopaCountyParks.org for Campsites (Arizona)</li> <li><code>OregonMetro</code>: Searches on OregonMetro.gov for Campsites (Portland Metro)</li> </ul>"},{"location":"python/","title":"Object-Oriented Usage (Python)","text":""},{"location":"python/#search-for-a-recreationgov-campsite","title":"Search for a Recreation.gov Campsite","text":"<pre><code>from datetime import datetime\nimport logging\nfrom typing import List\nfrom camply.containers import AvailableCampsite, SearchWindow\nfrom camply.search import SearchRecreationDotGov\nlogging.basicConfig(format=\"%(asctime)s [%(levelname)8s]: %(message)s\",\nlevel=logging.INFO)\nmonth_of_june = SearchWindow(start_date=datetime(year=2022, month=6, day=1),\nend_date=datetime(year=2022, month=6, day=30))\ncamping_finder = SearchRecreationDotGov(search_window=month_of_june,\nrecreation_area=2725,  # Glacier Ntl Park\nweekends_only=False,\nnights=1)\nmatches: List[AvailableCampsite] = camping_finder.get_matching_campsites(log=True, verbose=True,\ncontinuous=False)\n</code></pre> <p>The above script returns a list of any matching <code>AvailableCampsite</code> pydantic objects:</p> <pre><code>[\nAvailableCampsite(campsite_id=\"5391\",\nbooking_date=datetime.datetime(2022, 6, 13, 0, 0),\ncampsite_site_name=\"B37\",\ncampsite_loop_name=\"Loop B\",\ncampsite_type=\"STANDARD NONELECTRIC\",\ncampsite_occupancy=(0, 8),\ncampsite_use_type=\"Overnight\",\navailability_status=\"Available\",\nrecreation_area=\"Glacier National Park, MT\",\nrecreation_area_id=\"2725\",\nfacility_name=\"Fish Creek Campground\",\nfacility_id=\"232493\",\nbooking_url=\"https://www.recreation.gov/camping/campsites/5391\")\n]\n</code></pre>"},{"location":"python/#continuously-search-for-recreationgov-campsites","title":"Continuously Search for Recreation.gov Campsites","text":"<p>You'll notice that the <code>get_matching_campsites</code> function takes accepts parameter values very similar to the commandline arguments.</p> <pre><code>from datetime import datetime\nimport logging\nfrom camply.containers import SearchWindow\nfrom camply.search import SearchRecreationDotGov\nlogging.basicConfig(format=\"%(asctime)s [%(levelname)8s]: %(message)s\",\nlevel=logging.INFO)\nmonth_of_june = SearchWindow(start_date=datetime(year=2022, month=6, day=1),\nend_date=datetime(year=2022, month=6, day=30))\ncamping_finder = SearchRecreationDotGov(search_window=month_of_june,\nrecreation_area=[2991, 1074],  # Multiple Rec Areas\nweekends_only=False,\nnights=3)\ncamping_finder.get_matching_campsites(log=True, verbose=True,\ncontinuous=True,\npolling_interval=5,\nnotification_provider=\"pushover\",\nsearch_forever=True,\nnotify_first_try=False)\n</code></pre>"},{"location":"recreationdotgov/","title":"Finding Recreation Areas IDs and Campground IDs To Search Without Using the Command Line","text":"<p>You can uncover campground and recreation area IDs just by using the https://recreation.gov search functionality. Use the below example for a campground within Glacier National Park.</p> <p>First, perform your search on https://recreation.gov.</p> <p>The above search will take you to a URL like this: https://www.recreation.gov/search?q=Glacier%20National%20Park&amp;entity_id=2725&amp;entity_type=recarea. Taking a closer look at the URL components you can see that Glacier National Park has the Recreation Area ID #2725.</p> <p>Searching deeper into campgrounds inside of Glacier National Park you might find Fish Creek Campground at a URL like https://www.recreation.gov/camping/campgrounds/232493. Here, we can see that this campground has a Campground ID of #232493.</p>"},{"location":"reference/","title":"camply","text":"<p>camply init file</p>"},{"location":"reference/#camply.AvailableCampsite","title":"<code>AvailableCampsite</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>Campsite Storage</p> <p>This container should be universal regardless of API Provider</p> Source code in <code>camply/containers/data_containers.py</code> <pre><code>class AvailableCampsite(CamplyModel):\n\"\"\"\n    Campsite Storage\n    This container should be universal regardless of API Provider\n    \"\"\"\ncampsite_id: Union[int, str]\nbooking_date: datetime.datetime\nbooking_end_date: datetime.datetime\nbooking_nights: int\ncampsite_site_name: str\ncampsite_loop_name: Optional[str]\ncampsite_type: Optional[str]\ncampsite_occupancy: Tuple[int, int]\ncampsite_use_type: Optional[str]\navailability_status: str\nrecreation_area: str\nrecreation_area_id: Union[int, str]\nfacility_name: str\nfacility_id: Union[int, str]\nbooking_url: str\npermitted_equipment: Optional[List[RecDotGovEquipment]]\ncampsite_attributes: Optional[List[RecDotGovAttribute]]\n__unhashable__ = {\"permitted_equipment\", \"campsite_attributes\"}\n</code></pre>"},{"location":"reference/#camply.EquipmentOptions","title":"<code>EquipmentOptions</code>","text":"<p>         Bases: <code>str</code>, <code>Enum</code></p> <p>Enumeration of the Equipment Options</p> Source code in <code>camply/config/search_config.py</code> <pre><code>class EquipmentOptions(str, Enum):\n\"\"\"\n    Enumeration of the Equipment Options\n    \"\"\"\ntent = \"tent\"\nrv = \"rv\"\ntrailer = \"trailer\"\nvehicle = \"vehicle\"\nother = \"other\"\n__all_accepted_equipment__ = [tent, rv, trailer, vehicle]\n</code></pre>"},{"location":"reference/#camply.GoingToCamp","title":"<code>GoingToCamp</code>","text":"<p>         Bases: <code>BaseProvider</code></p> <p>Going To Camp API provider</p> Source code in <code>camply/providers/going_to_camp/going_to_camp_provider.py</code> <pre><code>class GoingToCamp(BaseProvider):\n\"\"\"\n    Going To Camp API provider\n    \"\"\"\n@classmethod\ndef find_recreation_areas(\ncls, search_string: Optional[str] = None, **kwargs\n) -&gt; List[RecreationArea]:\n\"\"\"\n        Find Matching Recreation Areas based on search string\n        Parameters\n        ----------\n        search_string: Optional[str]\n            Search Keyword(s)\n        Returns\n        -------\n        filtered_responses: List[RecreationArea]\n            Array of Matching Recreation Areas\n        \"\"\"\nif search_string is not None:\nlogger.info(f'Searching for Recreation Areas matching: \"{search_string}\"')\nif not search_string or search_string == \"\":\nrec_areas = RECREATION_AREAS.values()\nlog_sorted_response(rec_areas)\nreturn rec_areas\nrec_areas = []\nfor _, rec_area in RECREATION_AREAS.items():\nif (\nsearch_string.lower() in rec_area.recreation_area.lower()\nor search_string.lower() in rec_area.recreation_area_location.lower()\n):\nrec_areas.append(rec_area)\nlog_sorted_response(rec_areas)\nreturn rec_areas\ndef rec_area_lookup(self, rec_area_id: int) -&gt; Tuple[str, RecreationArea]:\n\"\"\"\n        Lookup a recreation area by ID\n        Parameters\n        ----------\n        rec_area_id: int\n            The recreation area ID to lookup\n        Returns\n        -------\n        domain_name, rec_ara: Tuple[str, RecreationArea]\n            The rec area's domain name and the recreation area object\n        \"\"\"\nfor domain_name, rec_area in RECREATION_AREAS.items():\nif str(rec_area.recreation_area_id) == str(rec_area_id):\nreturn domain_name, rec_area\ndef find_campgrounds(\nself,\nsearch_string: str = None,\nrec_area_id: Optional[List[int]] = None,\ncampground_id: Optional[List[int]] = None,\ncampsite_id: Optional[List[int]] = None,\n**kwargs,\n) -&gt; List[CampgroundFacility]:\n\"\"\"\n        Find Campgrounds Given a Set of Search Criteria\n        Parameters\n        ----------\n        search_string: str\n            Search Keyword(s)\n        rec_area_id: Optional[List[int]]\n            Recreation Area ID by which to filter\n        campground_id: Optional[List[int]]\n            ID of the Campground\n        Returns\n        -------\n        facilities: List[CampgroundFacility]\n            Array of Matching Campgrounds\n        \"\"\"\nif rec_area_id in (None, [], ()):\nlogger.error(\n\"This provider requires --rec-area to be specified when seaching for campsites\"\n)\nsys.exit(1)\nreturn self.find_facilities_per_recreation_area(\nrec_area_id=rec_area_id,\ncampground_id=campground_id,\nsearch_string=search_string,\n)\ndef _get_attr_val(self, attribute, attribute_detail) -&gt; any:\nfor attr_value in attribute.get(\"values\", []):\nfor attribute_enum_detail in attribute_detail.get(\"values\"):\nif attribute_enum_detail[\"enumValue\"] == attr_value:\nreturn _fetch_nested_key(\nattribute_enum_detail, \"localizedValues\", 0, \"displayName\"\n)\ndef get_site_details(self, rec_area_id: int, resource_id: int):\n\"\"\"\n        Get the details about a site in a recreation area\n        Parameters\n        ----------\n        rec_area_id: int\n            Recreation Area ID by which to filter\n        resource_id: int\n        Returns\n        -------\n        details: Dict[str, str]\n            The details about the site\n        \"\"\"\nif not hasattr(self, \"_attribute_details\"):\nself._attribute_details = self._api_request(\nrec_area_id, \"ATTRIBUTE_DETAILS\"\n)\nattribute_details = self._attribute_details\nsite_details = self._api_request(\nrec_area_id, \"SITE_DETAILS\", {\"resourceId\": resource_id}\n)\nsite_attributes = {}\nfor attribute in site_details[\"definedAttributes\"]:\nattribute_detail = attribute_details[\nf\"{attribute['attributeDefinitionId']}\"\n]\nattribute_name = _fetch_nested_key(\nattribute_detail, \"localizedValues\", 0, \"displayName\"\n)\nattribute_value = attribute.get(\"value\")\nattribute_values = []\n# Attribute a multi-value enum\nif not attribute_value:\nattr_value = self._get_attr_val(attribute, attribute_detail)\nif not attr_value:\ncontinue\nattribute_values.append(attr_value)\nelse:\nattribute_values.append(f\"{attribute_value}\")\nsite_attributes[attribute_name] = \",\".join(attribute_values)\nsite_details[\"site_attributes\"] = site_attributes\nreturn site_details\ndef get_reservation_link(\nself,\nrec_area_domain_name,\nresource_location_id,\nmap_id,\nequipment_id,\nsub_equipment_id,\nparty_size,\nstart_date,\nend_date,\n):\n\"\"\"\n        Generate a URL which a site can be booked\n        Returns\n        -------\n        url: str\n            The reservation link URL\n        \"\"\"\nif not sub_equipment_id:\nsub_equipment_id = \"\"\nreturn (\n\"https://%s/create-booking/results?mapId=%s\"\n\"&amp;bookingCategoryId=0\"\n\"&amp;startDate=%s\"\n\"&amp;endDate=%s\"\n\"&amp;isReserving=true\"\n\"&amp;equipmentId=%s\"\n\"&amp;subEquipmentId=%s\"\n\"&amp;partySize=%s\"\n\"&amp;resourceLocationId=%s\"\n% (\nrec_area_domain_name,\nmap_id,\nstart_date.isoformat(),\nend_date.isoformat(),\nequipment_id,\nsub_equipment_id,\nparty_size,\nresource_location_id,\n)\n)\ndef find_facilities_per_recreation_area(\nself,\nrec_area_id: Optional[Union[List[int], int]] = None,\ncampground_id: Optional[Union[List[int], int]] = None,\nsearch_string: Optional[str] = None,\n**kwargs,\n) -&gt; List[CampgroundFacility]:\n\"\"\"\n        Find Matching Campsites by Recreation Area\n        Parameters\n        ----------\n        rec_area_id: Optional[Union[List[int], int]]\n            Recreation Area ID\n        campground_id: Optional[Union[List[int], int]]\n            Campground IDs\n        search_string: Optional[str]\n            A string to search for in the facility name\n        Returns\n        -------\n        campgrounds: List[CampgroundFacility]\n            Array of Matching Campsites\n        \"\"\"\nrec_area_id = make_list(rec_area_id, coerce=int)[0]\nlogger.info(\nf\"Retrieving Facility Information for Recreation Area ID: `{rec_area_id}`.\"\n)\nrec_area = None\nfor _, ra in RECREATION_AREAS.items():\nif str(ra.recreation_area_id) == str(rec_area_id):\nrec_area = ra\nif not rec_area:\nlogger.error(f\"Recreation area '{rec_area_id}' does not exist.\")\nsys.exit(1)\nself.campground_details = {}\napi_response = self._api_request(rec_area_id, \"LIST_CAMPGROUNDS\")\nfiltered_facilities = self._filter_facilities_responses(\nrec_area_id, facilities=api_response\n)\ncampgrounds = []\n# Fetch campgrounds details for all facilities\nfor camp_details in self._api_request(rec_area_id, \"CAMP_DETAILS\"):\nself.campground_details[camp_details[\"resourceLocationId\"]] = camp_details\n# If a search string is provided, make sure every facility name contains\n# the search string\nif search_string and search_string not in [[], (), \"\"]:\nfiltered_facilities = [\nf\nfor f in filtered_facilities\nif search_string.lower() in f.resource_location_name.lower()\n]\nfor facility in filtered_facilities:\n_, campground_facility = self._process_facilities_responses(\nrec_area, facility=facility\n)\nif not campground_facility:\ncontinue\nif not campground_id:\ncampgrounds.append(campground_facility)\ncampground_strings = make_list(campground_id, coerce=str)\nif (\ncampground_id\nand str(campground_facility.facility_id) in campground_strings\n):\ncampgrounds.append(campground_facility)\nlogger.info(f\"{len(campgrounds)} Matching Campgrounds Found\")\nlog_sorted_response(response_array=campgrounds)\nreturn campgrounds\ndef _hostname_for(self, recreation_area_id: int) -&gt; str:\nfor hostname, recreation_area in RECREATION_AREAS.items():\nif str(recreation_area.recreation_area_id) == str(recreation_area_id):\nreturn hostname\nreturn None\ndef _api_request(\nself,\nrec_area_id: int,\nendpoint_name: str,\nparams: Optional[Dict[str, str]] = None,\n) -&gt; str:\nif params is None:\nparams = {}\nhostname = self._hostname_for(rec_area_id)\nendpoint = ENDPOINTS.get(endpoint_name)\nurl = None\nif endpoint:\nurl = endpoint.format(hostname)\nuser_agent = {\n\"User-Agent\": UserAgent(use_external_data=False, browsers=[\"chrome\"]).chrome\n}\nresponse = requests.get(url=url, headers=user_agent, params=params, timeout=30)\nif response.ok is False:\nerror_message = \"Receiving bad data from GoingToCamp API: status_code: \"\nf\"{response.status_code}: {response.text}\"\nlogger.error(error_message)\nraise ConnectionError(error_message)\nreturn json.loads(response.content)\ndef _filter_facilities_responses(\nself, rec_area_id: int, facilities=List[Dict[str, Any]]\n) -&gt; List[ResourceLocation]:\n\"\"\"\n        Filter Facilities to Actual Reservable Campsites\n        Parameters\n        ----------\n        rec_area_id: int\n            Recreation Area ID\n        facilities: List[Dict[str, Any]]\n            List of facilities\n        Returns\n        -------\n        List[ResourceLocation]\n        \"\"\"\nfiltered_facilities = []\nfor facil in facilities:\ntry:\nlocation_name = _fetch_nested_key(\nfacil, \"localizedValues\", 0, \"fullName\"\n)\npark_alerts = _fetch_nested_key(\nfacil, \"park_alerts\", \"en-US\", 0, \"messageTitle\"\n)\nif not park_alerts:\npark_alerts = _fetch_nested_key(\nfacil, \"park_alerts\", \"en-CA\", 0, \"messageTitle\"\n)\nregion_name = _fetch_nested_key(facil, \"region\")\nfacility = ResourceLocation(\nid=None,\nregion_name=region_name if region_name else \"\",\npark_alerts=park_alerts,\nrec_area_id=rec_area_id,\nresource_categories=facil.get(\"resourceCategoryIds\"),\nresource_location_id=facil.get(\"resourceLocationId\"),\nresource_location_name=location_name,\n)\nexcept ValidationError as ve:\nlogger.error(\"That doesn't look like a valid Campground Facility\")\nlogger.error(facil)\nraise ProviderSearchError(\n\"Invalid Campground Facility Returned\"\n) from ve\nif not facility.resource_categories:\ncontinue\n# Resource categories from: /api/resourcecategory\nif any(\n[\nCAMP_SITE in facility.resource_categories,\nGROUP_SITE in facility.resource_categories,\nOVERFLOW_SITE in facility.resource_categories,\n]\n):\nfiltered_facilities.append(facility)\nreturn filtered_facilities\ndef _process_facilities_responses(\nself, rec_area: RecreationArea, facility: ResourceLocation\n) -&gt; Tuple[dict, Optional[CampgroundFacility]]:\n\"\"\"\n        Process Facilities Responses to be More Usable\n        Parameters\n        ----------\n        facility: dict\n        Returns\n        -------\n        Tuple[dict, CampgroundFacility]\n        \"\"\"\nself.campground_details[facility.resource_location_id]\nfacility.id = _fetch_nested_key(\nself.campground_details, facility.resource_location_id, \"mapId\"\n)\nif facility.region_name:\nformatted_recreation_area = (\nf\"{rec_area.recreation_area}, {facility.region_name}\"\n)\nelse:\nformatted_recreation_area = f\"{rec_area.recreation_area}\"\ncampground_facility = CampgroundFacility(\nfacility_name=facility.resource_location_name,\nrecreation_area=formatted_recreation_area,\nfacility_id=facility.resource_location_id,\nrecreation_area_id=facility.rec_area_id,\nmap_id=facility.id,\n)\nreturn facility, campground_facility\ndef _find_matching_resources(self, rec_area_id: int, search_filter: Dict[str, any]):\nresults = self._api_request(rec_area_id, \"MAPDATA\", search_filter)\navailability_details = {\nsearch_filter[\"mapId\"]: results[\"resourceAvailabilities\"]\n}\nreturn availability_details, list(results[\"mapLinkAvailabilities\"].keys())\ndef list_equipment_types(self, rec_area_id: int) -&gt; Dict[str, int]:\n\"\"\"\n        List equipment types available for a recreation area\n        Params\n        ------\n        rec_area_id: int\n            The ID of the recreation area\n        Returns\n        -------\n        types: List[GoingToCampEquipment]\n            A list of equipment types available to this rec area\n        \"\"\"\nresults = self._api_request(rec_area_id, \"LIST_EQUIPMENT\")\nequipment_types = []\n# Only allow equipment from non-group equipment category (the 0th\n# element in results)\nfor sub_category in results[0][\"subEquipmentCategories\"]:\nequipment_name = _fetch_nested_key(\nsub_category, \"localizedValues\", 0, \"name\"\n)\nequipment_id = sub_category[\"subEquipmentCategoryId\"]\nequipment_types.append(\nGoingToCampEquipment(\nequipment_name=equipment_name, equipment_type_id=equipment_id\n)\n)\nlog_sorted_response(response_array=equipment_types)\nreturn equipment_types\ndef list_site_availability(\nself,\ncampground: CampgroundFacility,\nstart_date: datetime.date,\nend_date: datetime.date,\nequipment_type_id: Optional[str],\n) -&gt; List[AvailableResource]:\n\"\"\"\n        Retrieve the Availability for all Sites in a Camp Area\n        Sites are filtered on the provided date range and compatible\n        equipment.\n        Returns\n        -------\n        available_sites: List[AvailableResource]\n            The list of available sites\n        \"\"\"\nsearch_filter = {\n\"mapId\": campground.map_id,\n\"resourceLocationId\": campground.facility_id,\n\"bookingCategoryId\": 0,\n\"startDate\": start_date.isoformat(),\n\"endDate\": end_date.isoformat(),\n\"isReserving\": True,\n\"getDailyAvailability\": False,\n\"partySize\": 1,\n\"numEquipment\": 1,\n\"equipmentCategoryId\": NON_GROUP_EQUIPMENT,\n\"filterData\": [],\n}\nif equipment_type_id:\nsearch_filter[\"subEquipmentCategoryId\"] = equipment_type_id\nresources, additional_resources = self._find_matching_resources(\ncampground.recreation_area_id, search_filter\n)\n# Resources are often deeply nested; fetch nested resources\nfor map_id in additional_resources:\nsearch_filter[\"mapId\"] = map_id\navail, _ = self._find_matching_resources(\ncampground.recreation_area_id, search_filter\n)\nresources.update(avail)\navailabilities = []\nfor map_id, resource_details in resources.items():\nfor resource_id, availability_details in resource_details.items():\nif availability_details[0][\"availability\"] == 0:\nar = AvailableResource(resource_id=resource_id, map_id=map_id)\navailabilities.append(ar)\nreturn availabilities\n</code></pre>"},{"location":"reference/#camply.providers.going_to_camp.going_to_camp_provider.GoingToCamp.find_campgrounds","title":"<code>find_campgrounds(search_string=None, rec_area_id=None, campground_id=None, campsite_id=None, **kwargs)</code>","text":"<p>Find Campgrounds Given a Set of Search Criteria</p> <p>Parameters:</p> Name Type Description Default <code>search_string</code> <code>str</code> <p>Search Keyword(s)</p> <code>None</code> <code>rec_area_id</code> <code>Optional[List[int]]</code> <p>Recreation Area ID by which to filter</p> <code>None</code> <code>campground_id</code> <code>Optional[List[int]]</code> <p>ID of the Campground</p> <code>None</code> <p>Returns:</p> Name Type Description <code>facilities</code> <code>List[CampgroundFacility]</code> <p>Array of Matching Campgrounds</p> Source code in <code>camply/providers/going_to_camp/going_to_camp_provider.py</code> <pre><code>def find_campgrounds(\nself,\nsearch_string: str = None,\nrec_area_id: Optional[List[int]] = None,\ncampground_id: Optional[List[int]] = None,\ncampsite_id: Optional[List[int]] = None,\n**kwargs,\n) -&gt; List[CampgroundFacility]:\n\"\"\"\n    Find Campgrounds Given a Set of Search Criteria\n    Parameters\n    ----------\n    search_string: str\n        Search Keyword(s)\n    rec_area_id: Optional[List[int]]\n        Recreation Area ID by which to filter\n    campground_id: Optional[List[int]]\n        ID of the Campground\n    Returns\n    -------\n    facilities: List[CampgroundFacility]\n        Array of Matching Campgrounds\n    \"\"\"\nif rec_area_id in (None, [], ()):\nlogger.error(\n\"This provider requires --rec-area to be specified when seaching for campsites\"\n)\nsys.exit(1)\nreturn self.find_facilities_per_recreation_area(\nrec_area_id=rec_area_id,\ncampground_id=campground_id,\nsearch_string=search_string,\n)\n</code></pre>"},{"location":"reference/#camply.providers.going_to_camp.going_to_camp_provider.GoingToCamp.find_facilities_per_recreation_area","title":"<code>find_facilities_per_recreation_area(rec_area_id=None, campground_id=None, search_string=None, **kwargs)</code>","text":"<p>Find Matching Campsites by Recreation Area</p> <p>Parameters:</p> Name Type Description Default <code>rec_area_id</code> <code>Optional[Union[List[int], int]]</code> <p>Recreation Area ID</p> <code>None</code> <code>campground_id</code> <code>Optional[Union[List[int], int]]</code> <p>Campground IDs</p> <code>None</code> <code>search_string</code> <code>Optional[str]</code> <p>A string to search for in the facility name</p> <code>None</code> <p>Returns:</p> Name Type Description <code>campgrounds</code> <code>List[CampgroundFacility]</code> <p>Array of Matching Campsites</p> Source code in <code>camply/providers/going_to_camp/going_to_camp_provider.py</code> <pre><code>def find_facilities_per_recreation_area(\nself,\nrec_area_id: Optional[Union[List[int], int]] = None,\ncampground_id: Optional[Union[List[int], int]] = None,\nsearch_string: Optional[str] = None,\n**kwargs,\n) -&gt; List[CampgroundFacility]:\n\"\"\"\n    Find Matching Campsites by Recreation Area\n    Parameters\n    ----------\n    rec_area_id: Optional[Union[List[int], int]]\n        Recreation Area ID\n    campground_id: Optional[Union[List[int], int]]\n        Campground IDs\n    search_string: Optional[str]\n        A string to search for in the facility name\n    Returns\n    -------\n    campgrounds: List[CampgroundFacility]\n        Array of Matching Campsites\n    \"\"\"\nrec_area_id = make_list(rec_area_id, coerce=int)[0]\nlogger.info(\nf\"Retrieving Facility Information for Recreation Area ID: `{rec_area_id}`.\"\n)\nrec_area = None\nfor _, ra in RECREATION_AREAS.items():\nif str(ra.recreation_area_id) == str(rec_area_id):\nrec_area = ra\nif not rec_area:\nlogger.error(f\"Recreation area '{rec_area_id}' does not exist.\")\nsys.exit(1)\nself.campground_details = {}\napi_response = self._api_request(rec_area_id, \"LIST_CAMPGROUNDS\")\nfiltered_facilities = self._filter_facilities_responses(\nrec_area_id, facilities=api_response\n)\ncampgrounds = []\n# Fetch campgrounds details for all facilities\nfor camp_details in self._api_request(rec_area_id, \"CAMP_DETAILS\"):\nself.campground_details[camp_details[\"resourceLocationId\"]] = camp_details\n# If a search string is provided, make sure every facility name contains\n# the search string\nif search_string and search_string not in [[], (), \"\"]:\nfiltered_facilities = [\nf\nfor f in filtered_facilities\nif search_string.lower() in f.resource_location_name.lower()\n]\nfor facility in filtered_facilities:\n_, campground_facility = self._process_facilities_responses(\nrec_area, facility=facility\n)\nif not campground_facility:\ncontinue\nif not campground_id:\ncampgrounds.append(campground_facility)\ncampground_strings = make_list(campground_id, coerce=str)\nif (\ncampground_id\nand str(campground_facility.facility_id) in campground_strings\n):\ncampgrounds.append(campground_facility)\nlogger.info(f\"{len(campgrounds)} Matching Campgrounds Found\")\nlog_sorted_response(response_array=campgrounds)\nreturn campgrounds\n</code></pre>"},{"location":"reference/#camply.providers.going_to_camp.going_to_camp_provider.GoingToCamp.find_recreation_areas","title":"<code>find_recreation_areas(search_string=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Find Matching Recreation Areas based on search string</p> <p>Parameters:</p> Name Type Description Default <code>search_string</code> <code>Optional[str]</code> <p>Search Keyword(s)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>filtered_responses</code> <code>List[RecreationArea]</code> <p>Array of Matching Recreation Areas</p> Source code in <code>camply/providers/going_to_camp/going_to_camp_provider.py</code> <pre><code>@classmethod\ndef find_recreation_areas(\ncls, search_string: Optional[str] = None, **kwargs\n) -&gt; List[RecreationArea]:\n\"\"\"\n    Find Matching Recreation Areas based on search string\n    Parameters\n    ----------\n    search_string: Optional[str]\n        Search Keyword(s)\n    Returns\n    -------\n    filtered_responses: List[RecreationArea]\n        Array of Matching Recreation Areas\n    \"\"\"\nif search_string is not None:\nlogger.info(f'Searching for Recreation Areas matching: \"{search_string}\"')\nif not search_string or search_string == \"\":\nrec_areas = RECREATION_AREAS.values()\nlog_sorted_response(rec_areas)\nreturn rec_areas\nrec_areas = []\nfor _, rec_area in RECREATION_AREAS.items():\nif (\nsearch_string.lower() in rec_area.recreation_area.lower()\nor search_string.lower() in rec_area.recreation_area_location.lower()\n):\nrec_areas.append(rec_area)\nlog_sorted_response(rec_areas)\nreturn rec_areas\n</code></pre>"},{"location":"reference/#camply.providers.going_to_camp.going_to_camp_provider.GoingToCamp.get_reservation_link","title":"<code>get_reservation_link(rec_area_domain_name, resource_location_id, map_id, equipment_id, sub_equipment_id, party_size, start_date, end_date)</code>","text":"<p>Generate a URL which a site can be booked</p> <p>Returns:</p> Name Type Description <code>url</code> <code>str</code> <p>The reservation link URL</p> Source code in <code>camply/providers/going_to_camp/going_to_camp_provider.py</code> <pre><code>def get_reservation_link(\nself,\nrec_area_domain_name,\nresource_location_id,\nmap_id,\nequipment_id,\nsub_equipment_id,\nparty_size,\nstart_date,\nend_date,\n):\n\"\"\"\n    Generate a URL which a site can be booked\n    Returns\n    -------\n    url: str\n        The reservation link URL\n    \"\"\"\nif not sub_equipment_id:\nsub_equipment_id = \"\"\nreturn (\n\"https://%s/create-booking/results?mapId=%s\"\n\"&amp;bookingCategoryId=0\"\n\"&amp;startDate=%s\"\n\"&amp;endDate=%s\"\n\"&amp;isReserving=true\"\n\"&amp;equipmentId=%s\"\n\"&amp;subEquipmentId=%s\"\n\"&amp;partySize=%s\"\n\"&amp;resourceLocationId=%s\"\n% (\nrec_area_domain_name,\nmap_id,\nstart_date.isoformat(),\nend_date.isoformat(),\nequipment_id,\nsub_equipment_id,\nparty_size,\nresource_location_id,\n)\n)\n</code></pre>"},{"location":"reference/#camply.providers.going_to_camp.going_to_camp_provider.GoingToCamp.get_site_details","title":"<code>get_site_details(rec_area_id, resource_id)</code>","text":"<p>Get the details about a site in a recreation area</p> <p>Parameters:</p> Name Type Description Default <code>rec_area_id</code> <code>int</code> <p>Recreation Area ID by which to filter</p> required <code>resource_id</code> <code>int</code> required <p>Returns:</p> Name Type Description <code>details</code> <code>Dict[str, str]</code> <p>The details about the site</p> Source code in <code>camply/providers/going_to_camp/going_to_camp_provider.py</code> <pre><code>def get_site_details(self, rec_area_id: int, resource_id: int):\n\"\"\"\n    Get the details about a site in a recreation area\n    Parameters\n    ----------\n    rec_area_id: int\n        Recreation Area ID by which to filter\n    resource_id: int\n    Returns\n    -------\n    details: Dict[str, str]\n        The details about the site\n    \"\"\"\nif not hasattr(self, \"_attribute_details\"):\nself._attribute_details = self._api_request(\nrec_area_id, \"ATTRIBUTE_DETAILS\"\n)\nattribute_details = self._attribute_details\nsite_details = self._api_request(\nrec_area_id, \"SITE_DETAILS\", {\"resourceId\": resource_id}\n)\nsite_attributes = {}\nfor attribute in site_details[\"definedAttributes\"]:\nattribute_detail = attribute_details[\nf\"{attribute['attributeDefinitionId']}\"\n]\nattribute_name = _fetch_nested_key(\nattribute_detail, \"localizedValues\", 0, \"displayName\"\n)\nattribute_value = attribute.get(\"value\")\nattribute_values = []\n# Attribute a multi-value enum\nif not attribute_value:\nattr_value = self._get_attr_val(attribute, attribute_detail)\nif not attr_value:\ncontinue\nattribute_values.append(attr_value)\nelse:\nattribute_values.append(f\"{attribute_value}\")\nsite_attributes[attribute_name] = \",\".join(attribute_values)\nsite_details[\"site_attributes\"] = site_attributes\nreturn site_details\n</code></pre>"},{"location":"reference/#camply.providers.going_to_camp.going_to_camp_provider.GoingToCamp.list_equipment_types","title":"<code>list_equipment_types(rec_area_id)</code>","text":"<p>List equipment types available for a recreation area</p>"},{"location":"reference/#camply.providers.going_to_camp.going_to_camp_provider.GoingToCamp.list_equipment_types--params","title":"Params","text":"<p>rec_area_id: int     The ID of the recreation area</p> <p>Returns:</p> Name Type Description <code>types</code> <code>List[GoingToCampEquipment]</code> <p>A list of equipment types available to this rec area</p> Source code in <code>camply/providers/going_to_camp/going_to_camp_provider.py</code> <pre><code>def list_equipment_types(self, rec_area_id: int) -&gt; Dict[str, int]:\n\"\"\"\n    List equipment types available for a recreation area\n    Params\n    ------\n    rec_area_id: int\n        The ID of the recreation area\n    Returns\n    -------\n    types: List[GoingToCampEquipment]\n        A list of equipment types available to this rec area\n    \"\"\"\nresults = self._api_request(rec_area_id, \"LIST_EQUIPMENT\")\nequipment_types = []\n# Only allow equipment from non-group equipment category (the 0th\n# element in results)\nfor sub_category in results[0][\"subEquipmentCategories\"]:\nequipment_name = _fetch_nested_key(\nsub_category, \"localizedValues\", 0, \"name\"\n)\nequipment_id = sub_category[\"subEquipmentCategoryId\"]\nequipment_types.append(\nGoingToCampEquipment(\nequipment_name=equipment_name, equipment_type_id=equipment_id\n)\n)\nlog_sorted_response(response_array=equipment_types)\nreturn equipment_types\n</code></pre>"},{"location":"reference/#camply.providers.going_to_camp.going_to_camp_provider.GoingToCamp.list_site_availability","title":"<code>list_site_availability(campground, start_date, end_date, equipment_type_id)</code>","text":"<p>Retrieve the Availability for all Sites in a Camp Area</p> <p>Sites are filtered on the provided date range and compatible equipment.</p> <p>Returns:</p> Name Type Description <code>available_sites</code> <code>List[AvailableResource]</code> <p>The list of available sites</p> Source code in <code>camply/providers/going_to_camp/going_to_camp_provider.py</code> <pre><code>def list_site_availability(\nself,\ncampground: CampgroundFacility,\nstart_date: datetime.date,\nend_date: datetime.date,\nequipment_type_id: Optional[str],\n) -&gt; List[AvailableResource]:\n\"\"\"\n    Retrieve the Availability for all Sites in a Camp Area\n    Sites are filtered on the provided date range and compatible\n    equipment.\n    Returns\n    -------\n    available_sites: List[AvailableResource]\n        The list of available sites\n    \"\"\"\nsearch_filter = {\n\"mapId\": campground.map_id,\n\"resourceLocationId\": campground.facility_id,\n\"bookingCategoryId\": 0,\n\"startDate\": start_date.isoformat(),\n\"endDate\": end_date.isoformat(),\n\"isReserving\": True,\n\"getDailyAvailability\": False,\n\"partySize\": 1,\n\"numEquipment\": 1,\n\"equipmentCategoryId\": NON_GROUP_EQUIPMENT,\n\"filterData\": [],\n}\nif equipment_type_id:\nsearch_filter[\"subEquipmentCategoryId\"] = equipment_type_id\nresources, additional_resources = self._find_matching_resources(\ncampground.recreation_area_id, search_filter\n)\n# Resources are often deeply nested; fetch nested resources\nfor map_id in additional_resources:\nsearch_filter[\"mapId\"] = map_id\navail, _ = self._find_matching_resources(\ncampground.recreation_area_id, search_filter\n)\nresources.update(avail)\navailabilities = []\nfor map_id, resource_details in resources.items():\nfor resource_id, availability_details in resource_details.items():\nif availability_details[0][\"availability\"] == 0:\nar = AvailableResource(resource_id=resource_id, map_id=map_id)\navailabilities.append(ar)\nreturn availabilities\n</code></pre>"},{"location":"reference/#camply.providers.going_to_camp.going_to_camp_provider.GoingToCamp.rec_area_lookup","title":"<code>rec_area_lookup(rec_area_id)</code>","text":"<p>Lookup a recreation area by ID</p> <p>Parameters:</p> Name Type Description Default <code>rec_area_id</code> <code>int</code> <p>The recreation area ID to lookup</p> required <p>Returns:</p> Type Description <code>domain_name, rec_ara</code> <p>The rec area's domain name and the recreation area object</p> Source code in <code>camply/providers/going_to_camp/going_to_camp_provider.py</code> <pre><code>def rec_area_lookup(self, rec_area_id: int) -&gt; Tuple[str, RecreationArea]:\n\"\"\"\n    Lookup a recreation area by ID\n    Parameters\n    ----------\n    rec_area_id: int\n        The recreation area ID to lookup\n    Returns\n    -------\n    domain_name, rec_ara: Tuple[str, RecreationArea]\n        The rec area's domain name and the recreation area object\n    \"\"\"\nfor domain_name, rec_area in RECREATION_AREAS.items():\nif str(rec_area.recreation_area_id) == str(rec_area_id):\nreturn domain_name, rec_area\n</code></pre>"},{"location":"reference/#camply.RecreationDotGov","title":"<code>RecreationDotGov</code>","text":"<p>         Bases: <code>RecreationDotGovBase</code></p> <p>Recreation.gov: Campsite Searcher</p> Source code in <code>camply/providers/recreation_dot_gov/recdotgov_camps.py</code> <pre><code>class RecreationDotGov(RecreationDotGovBase):\n\"\"\"\n    Recreation.gov: Campsite Searcher\n    \"\"\"\nfacility_type = RIDBConfig.CAMPGROUND_FACILITY_FIELD_QUALIFIER\nresource_api_path = RIDBConfig.CAMPSITE_API_PATH\nactivity_name = \"CAMPING\"\napi_response_class = CampsiteResponse\napi_base_path = RecreationBookingConfig.API_BASE_PATH\napi_search_result_class = RecDotGovCampsite\napi_search_result_key = \"campsite_id\"\ndef paginate_recdotgov_campsites(\nself, facility_id: int, equipment: Optional[List[str]] = None\n) -&gt; List[RecDotGovCampsite]:\n\"\"\"\n        Paginate through the RecDotGov Campsite Metadata\n        \"\"\"\nresults = 0\ncontinue_paginate = True\nendpoint_url = api_utils.generate_url(\nscheme=RecreationBookingConfig.API_SCHEME,\nnetloc=RecreationBookingConfig.API_NET_LOC,\npath=\"api/search/campsites\",\n)\nfq_list = [f\"asset_id:{facility_id}\"]\nif isinstance(equipment, list) and len(equipment) &gt; 0:\nfor item in equipment:\nfq_list.append(f\"campsite_equipment_name:{item}\")\nparams = {\n\"start\": 0,\n\"size\": 1000,\n\"fq\": fq_list,\n\"include_non_site_specific_campsites\": True,\n}\ncampsites: List[RecDotGovCampsite] = []\nwhile continue_paginate is True:\nresponse = self.make_recdotgov_request_retry(\nmethod=\"GET\",\nurl=endpoint_url,\nparams=params,\n)\nreturned_data = json.loads(response.content)\ncampsite_response = RecDotGovCampsiteResponse(**returned_data)\ncampsites += campsite_response.campsites\nresults += campsite_response.size\nparams.update(start=results)\nif results == campsite_response.total:\ncontinue_paginate = False\nreturn campsites\ndef make_recdotgov_availability_request(\nself,\ncampground_id: int,\nmonth: datetime,\n) -&gt; requests.Response:\n\"\"\"\n        Make a request to the RecreationDotGov API\n        Parameters\n        ----------\n        campground_id\n        month\n        Returns\n        -------\n        requests.Response\n        \"\"\"\napi_endpoint = self._rec_availability_get_endpoint(\npath=f\"{campground_id}/{RecreationBookingConfig.API_MONTH_PATH}\"\n)\nformatted_month = month.strftime(\"%Y-%m-01T00:00:00.000Z\")\nquery_params = {\"start_date\": formatted_month}\nreturn self.make_recdotgov_request(\nmethod=\"GET\",\nurl=api_endpoint,\nparams=query_params,\n)\n@classmethod\ndef _items_to_unique_dicts(\ncls, item: Union[List[Dict[str, Any]], pd.Series]\n) -&gt; List[Dict[str, Any]]:\n\"\"\"\n        Ensure the proper items are parsed for equipment and attributes\n        \"\"\"\nif isinstance(item, pd.Series):\nlist_of_dicts = list(chain.from_iterable(item.tolist()))\nunique_list_of_dicts = [\ndict(s) for s in {frozenset(d.items()) for d in list_of_dicts}\n]\nreturn unique_list_of_dicts\nelse:\nreturn item\n@classmethod\ndef _get_equipment_and_attributes(\ncls,\ncampsite_id: int,\ncampsite_metadata: pd.DataFrame,\n) -&gt; Tuple[List[Dict[str, Any]], List[Dict[str, Any]]]:\n\"\"\"\n        Index a DataFrame in a Complicated Way\n        \"\"\"\ntry:\nequipment = campsite_metadata.at[campsite_id, \"permitted_equipment\"]\nexcept LookupError:\nequipment = None\ntry:\nattributes = campsite_metadata.at[campsite_id, \"attributes\"]\nexcept LookupError:\nattributes = None\nequipment = cls._items_to_unique_dicts(item=equipment)\nattributes = cls._items_to_unique_dicts(item=attributes)\nreturn equipment, attributes\n@classmethod\ndef process_campsite_availability(\ncls,\navailability: Dict[str, Any],\nrecreation_area: str,\nrecreation_area_id: int,\nfacility_name: str,\nfacility_id: int,\nmonth: datetime,\ncampsite_metadata: pd.DataFrame,\n) -&gt; List[Optional[AvailableCampsite]]:\n\"\"\"\n        Parse the JSON Response and return availabilities\n        Parameters\n        ----------\n        availability: Dict[str, Any]\n            API Response\n        recreation_area: str\n            Name of Recreation Area\n        recreation_area_id: int\n            ID of Recreation Area\n        facility_name: str\n            Campground Facility Name\n        facility_id: int\n            Campground Facility ID\n        month: datetime\n            Month to Process\n        campsite_metadata: pd.DataFrame\n            Metadata Fetched from the Recreation.gov API about the Campsites\n        Returns\n        -------\n        total_campsite_availability: List[Optional[AvailableCampsite]]\n            Any monthly availabilities\n        \"\"\"\ntotal_campsite_availability: List[Optional[AvailableCampsite]] = []\ncampsite_data = CampsiteAvailabilityResponse(**availability)\nfor campsite_id, site_related_data in campsite_data.campsites.items():\nfor (\nmatching_date,\navailability_status,\n) in site_related_data.availabilities.items():\nif (\navailability_status\nnot in RecreationBookingConfig.CAMPSITE_UNAVAILABLE_STRINGS\n):\nbooking_url = (\nf\"{RecreationBookingConfig.CAMPSITE_BOOKING_URL}/{campsite_id}\"\n)\nequipment, attributes = cls._get_equipment_and_attributes(\ncampsite_id=campsite_id, campsite_metadata=campsite_metadata\n)\navailable_campsite = AvailableCampsite(\ncampsite_id=campsite_id,\nbooking_date=matching_date,\nbooking_end_date=matching_date + timedelta(days=1),\nbooking_nights=1,\ncampsite_site_name=site_related_data.site,\ncampsite_loop_name=site_related_data.loop,\ncampsite_type=site_related_data.campsite_type,\ncampsite_occupancy=(\nsite_related_data.min_num_people,\nsite_related_data.max_num_people,\n),\ncampsite_use_type=site_related_data.type_of_use,\navailability_status=availability_status,\nrecreation_area=recreation_area,\nrecreation_area_id=recreation_area_id,\nfacility_name=facility_name,\nfacility_id=facility_id,\nbooking_url=booking_url,\npermitted_equipment=equipment,\ncampsite_attributes=attributes,\n)\ntotal_campsite_availability.append(available_campsite)\nreturn total_campsite_availability\n</code></pre>"},{"location":"reference/#camply.providers.recreation_dot_gov.recdotgov_camps.RecreationDotGov.make_recdotgov_availability_request","title":"<code>make_recdotgov_availability_request(campground_id, month)</code>","text":"<p>Make a request to the RecreationDotGov API</p> <p>Parameters:</p> Name Type Description Default <code>campground_id</code> <code>int</code> required <code>month</code> <code>datetime</code> required <p>Returns:</p> Type Description <code>requests.Response</code> Source code in <code>camply/providers/recreation_dot_gov/recdotgov_camps.py</code> <pre><code>def make_recdotgov_availability_request(\nself,\ncampground_id: int,\nmonth: datetime,\n) -&gt; requests.Response:\n\"\"\"\n    Make a request to the RecreationDotGov API\n    Parameters\n    ----------\n    campground_id\n    month\n    Returns\n    -------\n    requests.Response\n    \"\"\"\napi_endpoint = self._rec_availability_get_endpoint(\npath=f\"{campground_id}/{RecreationBookingConfig.API_MONTH_PATH}\"\n)\nformatted_month = month.strftime(\"%Y-%m-01T00:00:00.000Z\")\nquery_params = {\"start_date\": formatted_month}\nreturn self.make_recdotgov_request(\nmethod=\"GET\",\nurl=api_endpoint,\nparams=query_params,\n)\n</code></pre>"},{"location":"reference/#camply.providers.recreation_dot_gov.recdotgov_camps.RecreationDotGov.paginate_recdotgov_campsites","title":"<code>paginate_recdotgov_campsites(facility_id, equipment=None)</code>","text":"<p>Paginate through the RecDotGov Campsite Metadata</p> Source code in <code>camply/providers/recreation_dot_gov/recdotgov_camps.py</code> <pre><code>def paginate_recdotgov_campsites(\nself, facility_id: int, equipment: Optional[List[str]] = None\n) -&gt; List[RecDotGovCampsite]:\n\"\"\"\n    Paginate through the RecDotGov Campsite Metadata\n    \"\"\"\nresults = 0\ncontinue_paginate = True\nendpoint_url = api_utils.generate_url(\nscheme=RecreationBookingConfig.API_SCHEME,\nnetloc=RecreationBookingConfig.API_NET_LOC,\npath=\"api/search/campsites\",\n)\nfq_list = [f\"asset_id:{facility_id}\"]\nif isinstance(equipment, list) and len(equipment) &gt; 0:\nfor item in equipment:\nfq_list.append(f\"campsite_equipment_name:{item}\")\nparams = {\n\"start\": 0,\n\"size\": 1000,\n\"fq\": fq_list,\n\"include_non_site_specific_campsites\": True,\n}\ncampsites: List[RecDotGovCampsite] = []\nwhile continue_paginate is True:\nresponse = self.make_recdotgov_request_retry(\nmethod=\"GET\",\nurl=endpoint_url,\nparams=params,\n)\nreturned_data = json.loads(response.content)\ncampsite_response = RecDotGovCampsiteResponse(**returned_data)\ncampsites += campsite_response.campsites\nresults += campsite_response.size\nparams.update(start=results)\nif results == campsite_response.total:\ncontinue_paginate = False\nreturn campsites\n</code></pre>"},{"location":"reference/#camply.providers.recreation_dot_gov.recdotgov_camps.RecreationDotGov.process_campsite_availability","title":"<code>process_campsite_availability(availability, recreation_area, recreation_area_id, facility_name, facility_id, month, campsite_metadata)</code>  <code>classmethod</code>","text":"<p>Parse the JSON Response and return availabilities</p> <p>Parameters:</p> Name Type Description Default <code>availability</code> <code>Dict[str, Any]</code> <p>API Response</p> required <code>recreation_area</code> <code>str</code> <p>Name of Recreation Area</p> required <code>recreation_area_id</code> <code>int</code> <p>ID of Recreation Area</p> required <code>facility_name</code> <code>str</code> <p>Campground Facility Name</p> required <code>facility_id</code> <code>int</code> <p>Campground Facility ID</p> required <code>month</code> <code>datetime</code> <p>Month to Process</p> required <code>campsite_metadata</code> <code>pd.DataFrame</code> <p>Metadata Fetched from the Recreation.gov API about the Campsites</p> required <p>Returns:</p> Name Type Description <code>total_campsite_availability</code> <code>List[Optional[AvailableCampsite]]</code> <p>Any monthly availabilities</p> Source code in <code>camply/providers/recreation_dot_gov/recdotgov_camps.py</code> <pre><code>@classmethod\ndef process_campsite_availability(\ncls,\navailability: Dict[str, Any],\nrecreation_area: str,\nrecreation_area_id: int,\nfacility_name: str,\nfacility_id: int,\nmonth: datetime,\ncampsite_metadata: pd.DataFrame,\n) -&gt; List[Optional[AvailableCampsite]]:\n\"\"\"\n    Parse the JSON Response and return availabilities\n    Parameters\n    ----------\n    availability: Dict[str, Any]\n        API Response\n    recreation_area: str\n        Name of Recreation Area\n    recreation_area_id: int\n        ID of Recreation Area\n    facility_name: str\n        Campground Facility Name\n    facility_id: int\n        Campground Facility ID\n    month: datetime\n        Month to Process\n    campsite_metadata: pd.DataFrame\n        Metadata Fetched from the Recreation.gov API about the Campsites\n    Returns\n    -------\n    total_campsite_availability: List[Optional[AvailableCampsite]]\n        Any monthly availabilities\n    \"\"\"\ntotal_campsite_availability: List[Optional[AvailableCampsite]] = []\ncampsite_data = CampsiteAvailabilityResponse(**availability)\nfor campsite_id, site_related_data in campsite_data.campsites.items():\nfor (\nmatching_date,\navailability_status,\n) in site_related_data.availabilities.items():\nif (\navailability_status\nnot in RecreationBookingConfig.CAMPSITE_UNAVAILABLE_STRINGS\n):\nbooking_url = (\nf\"{RecreationBookingConfig.CAMPSITE_BOOKING_URL}/{campsite_id}\"\n)\nequipment, attributes = cls._get_equipment_and_attributes(\ncampsite_id=campsite_id, campsite_metadata=campsite_metadata\n)\navailable_campsite = AvailableCampsite(\ncampsite_id=campsite_id,\nbooking_date=matching_date,\nbooking_end_date=matching_date + timedelta(days=1),\nbooking_nights=1,\ncampsite_site_name=site_related_data.site,\ncampsite_loop_name=site_related_data.loop,\ncampsite_type=site_related_data.campsite_type,\ncampsite_occupancy=(\nsite_related_data.min_num_people,\nsite_related_data.max_num_people,\n),\ncampsite_use_type=site_related_data.type_of_use,\navailability_status=availability_status,\nrecreation_area=recreation_area,\nrecreation_area_id=recreation_area_id,\nfacility_name=facility_name,\nfacility_id=facility_id,\nbooking_url=booking_url,\npermitted_equipment=equipment,\ncampsite_attributes=attributes,\n)\ntotal_campsite_availability.append(available_campsite)\nreturn total_campsite_availability\n</code></pre>"},{"location":"reference/#camply.SearchRecreationDotGov","title":"<code>SearchRecreationDotGov</code>","text":"<p>         Bases: <code>SearchRecreationDotGovBase</code></p> <p>Searches on Recreation.gov for Campsites (default provider)</p> Source code in <code>camply/search/search_recreationdotgov.py</code> <pre><code>class SearchRecreationDotGov(SearchRecreationDotGovBase):\n\"\"\"\n    Searches on Recreation.gov for Campsites (default provider)\n    \"\"\"\nprovider_class = RecreationDotGov\n</code></pre>"},{"location":"reference/#camply.SearchWindow","title":"<code>SearchWindow</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>Search Window for Campsite Search</p> Source code in <code>camply/containers/data_containers.py</code> <pre><code>class SearchWindow(CamplyModel):\n\"\"\"\n    Search Window for Campsite Search\n    \"\"\"\n@validator(\"start_date\")\n@classmethod\ndef start_date_must_be_in_future(cls, v):\n\"\"\"\n        Validate that start_date is in the future.\n        Coerece start date to today's date when it is not in the future.\n        \"\"\"\ncurrent_date = datetime.datetime.now().date()\nif v &lt; current_date:\nreturn current_date\nreturn v\n@validator(\"end_date\")\n@classmethod\ndef end_date_must_be_in_future(cls, v):\n\"\"\"\n        Validate that end_date is in the future\n        \"\"\"\ncurrent_date = datetime.datetime.now().date()\nif v &lt; current_date:\nraise ValueError(\"must be in the future\")\nreturn v\nstart_date: datetime.date\nend_date: datetime.date\ndef get_date_range(self) -&gt; List[datetime.date]:\n\"\"\"\n        Generate a List of Dates Between two Dates\n        Returns\n        -------\n        List[datetime.date]\n        \"\"\"\nreturn [\nself.start_date + datetime.timedelta(days=x)\nfor x in range((self.end_date - self.start_date).days)\n]\ndef get_current_start_date(self) -&gt; datetime.date:\n\"\"\"\n        Return a start date with the current day in mind\n        \"\"\"\nreturn max((datetime.datetime.now().date(), self.start_date))\n</code></pre>"},{"location":"reference/#camply.containers.data_containers.SearchWindow.end_date_must_be_in_future","title":"<code>end_date_must_be_in_future(v)</code>  <code>classmethod</code>","text":"<p>Validate that end_date is in the future</p> Source code in <code>camply/containers/data_containers.py</code> <pre><code>@validator(\"end_date\")\n@classmethod\ndef end_date_must_be_in_future(cls, v):\n\"\"\"\n    Validate that end_date is in the future\n    \"\"\"\ncurrent_date = datetime.datetime.now().date()\nif v &lt; current_date:\nraise ValueError(\"must be in the future\")\nreturn v\n</code></pre>"},{"location":"reference/#camply.containers.data_containers.SearchWindow.get_current_start_date","title":"<code>get_current_start_date()</code>","text":"<p>Return a start date with the current day in mind</p> Source code in <code>camply/containers/data_containers.py</code> <pre><code>def get_current_start_date(self) -&gt; datetime.date:\n\"\"\"\n    Return a start date with the current day in mind\n    \"\"\"\nreturn max((datetime.datetime.now().date(), self.start_date))\n</code></pre>"},{"location":"reference/#camply.containers.data_containers.SearchWindow.get_date_range","title":"<code>get_date_range()</code>","text":"<p>Generate a List of Dates Between two Dates</p> <p>Returns:</p> Type Description <code>List[datetime.date]</code> Source code in <code>camply/containers/data_containers.py</code> <pre><code>def get_date_range(self) -&gt; List[datetime.date]:\n\"\"\"\n    Generate a List of Dates Between two Dates\n    Returns\n    -------\n    List[datetime.date]\n    \"\"\"\nreturn [\nself.start_date + datetime.timedelta(days=x)\nfor x in range((self.end_date - self.start_date).days)\n]\n</code></pre>"},{"location":"reference/#camply.containers.data_containers.SearchWindow.start_date_must_be_in_future","title":"<code>start_date_must_be_in_future(v)</code>  <code>classmethod</code>","text":"<p>Validate that start_date is in the future.</p> <p>Coerece start date to today's date when it is not in the future.</p> Source code in <code>camply/containers/data_containers.py</code> <pre><code>@validator(\"start_date\")\n@classmethod\ndef start_date_must_be_in_future(cls, v):\n\"\"\"\n    Validate that start_date is in the future.\n    Coerece start date to today's date when it is not in the future.\n    \"\"\"\ncurrent_date = datetime.datetime.now().date()\nif v &lt; current_date:\nreturn current_date\nreturn v\n</code></pre>"},{"location":"reference/#camply.SearchYellowstone","title":"<code>SearchYellowstone</code>","text":"<p>         Bases: <code>BaseCampingSearch</code></p> <p>Searches on YellowstoneNationalParkLodges.com for Campsites</p> Source code in <code>camply/search/search_yellowstone.py</code> <pre><code>class SearchYellowstone(BaseCampingSearch):\n\"\"\"\n    Searches on YellowstoneNationalParkLodges.com for Campsites\n    \"\"\"\nrecreation_area = Yellowstone.recreation_area\nprovider_class = Yellowstone\nlist_campsites_supported: bool = False\n# noinspection PyUnusedLocal\ndef __init__(\nself,\nsearch_window: Union[SearchWindow, List[SearchWindow]],\nweekends_only: bool = False,\ncampgrounds: Optional[Union[List[str], str]] = None,\nnights: int = 1,\noffline_search: bool = False,\noffline_search_path: Optional[str] = None,\n**kwargs,\n) -&gt; None:\n\"\"\"\n        Initialize with Search Parameters\n        Parameters\n        ----------\n        search_window: Union[SearchWindow, List[SearchWindow]]\n            Search Window tuple containing start date and End Date\n        weekends_only: bool\n            Whether to only search for Camping availabilities on the weekends (Friday /\n            Saturday nights)\n        campgrounds: Optional[Union[List[str], str]]\n            Campground ID or List of Campground IDs\n        nights: int\n            minimum number of consecutive nights to search per campsite,defaults to 1\n        offline_search: bool\n            When set to True, the campsite search will both save the results of the\n            campsites it's found, but also load those campsites before beginning a\n            search for other campsites.\n        offline_search_path: Optional[str]\n            When offline search is set to True, this is the name of the file to be saved/loaded.\n            When not specified, the filename will default to `camply_campsites.json`\n        \"\"\"\nsuper().__init__(\nsearch_window=search_window,\nweekends_only=weekends_only,\nnights=nights,\noffline_search=offline_search,\noffline_search_path=offline_search_path,\n**kwargs,\n)\nself.campgrounds = make_list(campgrounds)\ndef get_all_campsites(self) -&gt; List[AvailableCampsite]:\n\"\"\"\n        Search for all matching campsites in Yellowstone.\n        Returns\n        -------\n        List[AvailableCampsite]\n        \"\"\"\nall_campsites = []\nsearchable_campgrounds = self._get_searchable_campgrounds()\nthis_month = datetime.now().date().replace(day=1)\nfor month in self.search_months:\nif month &gt;= this_month:\nall_campsites += self.campsite_finder.get_monthly_campsites(\nmonth=month, nights=None if self.nights == 1 else self.nights\n)\nmatching_campsites = self._filter_campsites_to_campgrounds(\ncampsites=all_campsites, searchable_campgrounds=searchable_campgrounds\n)\ncampsite_df = self.campsites_to_df(campsites=matching_campsites)\ncampsite_df_validated = self._filter_date_overlap(campsites=campsite_df)\ntime_window_end = max(self.search_days) + timedelta(days=1)\ncompiled_campsite_df = campsite_df_validated[\ncampsite_df_validated.booking_end_date &lt;= pd.Timestamp(time_window_end)\n]\ncompiled_campsites = self.df_to_campsites(campsite_df=compiled_campsite_df)\nreturn compiled_campsites\ndef _get_searchable_campgrounds(self) -&gt; Optional[Set[str]]:\n\"\"\"\n        Return the Campgrounds for the Camping Search\n        Returns\n        -------\n        Optional[Set[str]]\n        \"\"\"\nif self.campgrounds in [None, []]:\nreturn None\nsupported_campsites = set(YellowstoneConfig.YELLOWSTONE_CAMPGROUNDS.keys())\nselected_campsites = set(self.campgrounds)\nsearchable_campgrounds = supported_campsites.intersection(selected_campsites)\nif len(searchable_campgrounds) == 0:\ncampground_ids = [\nf\"`{key}` ({value})\"\nfor key, value in YellowstoneConfig.YELLOWSTONE_CAMPGROUNDS.items()\n]\nerror_message = (\n\"You must supply a YellowstoneNationalParkLodges supported \"\n\"campground ID. Current supported Campground IDs: \"\nf\"{', '.join(campground_ids)}\"\n)\nlogger.error(error_message)\nraise SearchError(error_message)\nlogger.info(f\"{len(searchable_campgrounds)} Matching Campgrounds Found\")\nfor campground in searchable_campgrounds:\nlogger.info(\nf\"\u26f0  {YellowstoneConfig.YELLOWSTONE_RECREATION_AREA_FORMAL_NAME} \"\nf\"(#{YellowstoneConfig.YELLOWSTONE_RECREATION_AREA_ID}) - \ud83c\udfd5  \"\nf\"{YellowstoneConfig.YELLOWSTONE_CAMPGROUNDS[campground]} ({campground})\"\n)\nreturn searchable_campgrounds\ndef _filter_campsites_to_campgrounds(\nself, campsites: List[AvailableCampsite], searchable_campgrounds: Set[str]\n) -&gt; List[AvailableCampsite]:\n\"\"\"\n        Filter Campsites Down to Matching Campgrounds\n        Parameters\n        ----------\n        campsites: List[AvailableCampsite]\n        searchable_campgrounds: Set[str]\n        Returns\n        -------\n        List[AvailableCampsite]\n        \"\"\"\nif self.campgrounds in [None, []]:\nreturn campsites\nmatching_campsites = [\ncampsite\nfor campsite in campsites\nif campsite.facility_id in searchable_campgrounds\n]\nreturn matching_campsites\n@classmethod\ndef find_recreation_areas(cls, **kwargs) -&gt; List[RecreationArea]:\n\"\"\"\n        Return the Yellowstone Recreation Area Object\n        \"\"\"\nlog_sorted_response([cls.recreation_area])\nreturn [cls.recreation_area]\ndef list_campsite_units(self) -&gt; Any:\n\"\"\"\n        List Campsite Units\n        Returns\n        -------\n        Any\n        \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"reference/#camply.search.search_yellowstone.SearchYellowstone.__init__","title":"<code>__init__(search_window, weekends_only=False, campgrounds=None, nights=1, offline_search=False, offline_search_path=None, **kwargs)</code>","text":"<p>Initialize with Search Parameters</p> <p>Parameters:</p> Name Type Description Default <code>search_window</code> <code>Union[SearchWindow, List[SearchWindow]]</code> <p>Search Window tuple containing start date and End Date</p> required <code>weekends_only</code> <code>bool</code> <p>Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights)</p> <code>False</code> <code>campgrounds</code> <code>Optional[Union[List[str], str]]</code> <p>Campground ID or List of Campground IDs</p> <code>None</code> <code>nights</code> <code>int</code> <p>minimum number of consecutive nights to search per campsite,defaults to 1</p> <code>1</code> <code>offline_search</code> <code>bool</code> <p>When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites.</p> <code>False</code> <code>offline_search_path</code> <code>Optional[str]</code> <p>When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to <code>camply_campsites.json</code></p> <code>None</code> Source code in <code>camply/search/search_yellowstone.py</code> <pre><code>def __init__(\nself,\nsearch_window: Union[SearchWindow, List[SearchWindow]],\nweekends_only: bool = False,\ncampgrounds: Optional[Union[List[str], str]] = None,\nnights: int = 1,\noffline_search: bool = False,\noffline_search_path: Optional[str] = None,\n**kwargs,\n) -&gt; None:\n\"\"\"\n    Initialize with Search Parameters\n    Parameters\n    ----------\n    search_window: Union[SearchWindow, List[SearchWindow]]\n        Search Window tuple containing start date and End Date\n    weekends_only: bool\n        Whether to only search for Camping availabilities on the weekends (Friday /\n        Saturday nights)\n    campgrounds: Optional[Union[List[str], str]]\n        Campground ID or List of Campground IDs\n    nights: int\n        minimum number of consecutive nights to search per campsite,defaults to 1\n    offline_search: bool\n        When set to True, the campsite search will both save the results of the\n        campsites it's found, but also load those campsites before beginning a\n        search for other campsites.\n    offline_search_path: Optional[str]\n        When offline search is set to True, this is the name of the file to be saved/loaded.\n        When not specified, the filename will default to `camply_campsites.json`\n    \"\"\"\nsuper().__init__(\nsearch_window=search_window,\nweekends_only=weekends_only,\nnights=nights,\noffline_search=offline_search,\noffline_search_path=offline_search_path,\n**kwargs,\n)\nself.campgrounds = make_list(campgrounds)\n</code></pre>"},{"location":"reference/#camply.search.search_yellowstone.SearchYellowstone.find_recreation_areas","title":"<code>find_recreation_areas(**kwargs)</code>  <code>classmethod</code>","text":"<p>Return the Yellowstone Recreation Area Object</p> Source code in <code>camply/search/search_yellowstone.py</code> <pre><code>@classmethod\ndef find_recreation_areas(cls, **kwargs) -&gt; List[RecreationArea]:\n\"\"\"\n    Return the Yellowstone Recreation Area Object\n    \"\"\"\nlog_sorted_response([cls.recreation_area])\nreturn [cls.recreation_area]\n</code></pre>"},{"location":"reference/#camply.search.search_yellowstone.SearchYellowstone.get_all_campsites","title":"<code>get_all_campsites()</code>","text":"<p>Search for all matching campsites in Yellowstone.</p> <p>Returns:</p> Type Description <code>List[AvailableCampsite]</code> Source code in <code>camply/search/search_yellowstone.py</code> <pre><code>def get_all_campsites(self) -&gt; List[AvailableCampsite]:\n\"\"\"\n    Search for all matching campsites in Yellowstone.\n    Returns\n    -------\n    List[AvailableCampsite]\n    \"\"\"\nall_campsites = []\nsearchable_campgrounds = self._get_searchable_campgrounds()\nthis_month = datetime.now().date().replace(day=1)\nfor month in self.search_months:\nif month &gt;= this_month:\nall_campsites += self.campsite_finder.get_monthly_campsites(\nmonth=month, nights=None if self.nights == 1 else self.nights\n)\nmatching_campsites = self._filter_campsites_to_campgrounds(\ncampsites=all_campsites, searchable_campgrounds=searchable_campgrounds\n)\ncampsite_df = self.campsites_to_df(campsites=matching_campsites)\ncampsite_df_validated = self._filter_date_overlap(campsites=campsite_df)\ntime_window_end = max(self.search_days) + timedelta(days=1)\ncompiled_campsite_df = campsite_df_validated[\ncampsite_df_validated.booking_end_date &lt;= pd.Timestamp(time_window_end)\n]\ncompiled_campsites = self.df_to_campsites(campsite_df=compiled_campsite_df)\nreturn compiled_campsites\n</code></pre>"},{"location":"reference/#camply.search.search_yellowstone.SearchYellowstone.list_campsite_units","title":"<code>list_campsite_units()</code>","text":"<p>List Campsite Units</p> <p>Returns:</p> Type Description <code>Any</code> Source code in <code>camply/search/search_yellowstone.py</code> <pre><code>def list_campsite_units(self) -&gt; Any:\n\"\"\"\n    List Campsite Units\n    Returns\n    -------\n    Any\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"reference/#camply.Yellowstone","title":"<code>Yellowstone</code>","text":"<p>         Bases: <code>BaseProvider</code></p> <p>Scanner for Lodging in Yellowstone</p> Source code in <code>camply/providers/xanterra/yellowstone_lodging.py</code> <pre><code>class Yellowstone(BaseProvider):\n\"\"\"\n    Scanner for Lodging in Yellowstone\n    \"\"\"\nrecreation_area = RecreationArea(\nrecreation_area=YellowstoneConfig.YELLOWSTONE_RECREATION_AREA_FULL_NAME,\nrecreation_area_id=YellowstoneConfig.YELLOWSTONE_RECREATION_AREA_ID,\nrecreation_area_location=\"USA\",\n)\ndef _get_monthly_availability(self, month: datetime, nights: int = None) -&gt; dict:\n\"\"\"\n        Check All Lodging in Yellowstone for Campground Data\n        Returns\n        -------\n        data_availability: dict\n            Data Availability Dictionary\n        \"\"\"\nquery_dict = {\n\"date\": self._ensure_current_month(month=month),\n\"limit\": 31,\n\"rate_code\": YellowstoneConfig.RATE_CODE,\n}\nif nights is not None:\nquery_dict.update({\"nights\": nights})\napi_endpoint = self._get_api_endpoint(\nurl_path=YellowstoneConfig.YELLOWSTONE_LODGING_PATH, query=None\n)\nlogger.info(\nf\"Searching for Yellowstone Lodging Availability: {month.strftime('%B, %Y')}\"\n)\nall_resort_availability_data = self.make_yellowstone_request(\nendpoint=api_endpoint, params=query_dict\n)\nreturn all_resort_availability_data\n@staticmethod\n@tenacity.retry(\nwait=tenacity.wait_random_exponential(multiplier=3, max=1800),\nstop=tenacity.stop.stop_after_delay(6000),\n)\ndef _try_retry_get_data(endpoint: str, params: Optional[dict] = None) -&gt; dict:\n\"\"\"\n        Try and Retry Fetching Data from the Yellowstone API.\n        Unfortunately this is a required method to request the data since the\n        Yellowstone API doesn't always return data.\n        Parameters\n        ----------\n        endpoint: str\n            API Endpoint\n        params\n        Returns\n        -------\n        dict\n        \"\"\"\nyellowstone_headers = {}\nuser_agent = {\n\"User-Agent\": UserAgent(use_external_data=False, browsers=[\"chrome\"]).chrome\n}\nyellowstone_headers.update(user_agent)\nyellowstone_headers.update(STANDARD_HEADERS)\nyellowstone_headers.update(YellowstoneConfig.API_REFERRERS)\nresponse = requests.get(\nurl=endpoint, headers=yellowstone_headers, params=params, timeout=30\n)\nif response.ok is True and response.text.strip() != \"\":\nreturn loads(response.content)\nelse:\nerror_message = (\n\"Something went wrong with checking the \"\n\"Yellowstone Booking API. Will continue retrying.\"\n)\nlogger.warning(error_message)\nraise RuntimeError(error_message)\n@staticmethod\ndef make_yellowstone_request(endpoint: str, params: Optional[dict] = None) -&gt; dict:\n\"\"\"\n        Try and Retry Fetching Data from the Yellowstone API.\n        Unfortunately this is a required method to request the data since the\n        Yellowstone API doesn't always return data.\n        Parameters\n        ----------\n        endpoint: str\n            API Endpoint\n        params\n        Returns\n        -------\n        dict\n        \"\"\"\ntry:\ncontent = Yellowstone._try_retry_get_data(endpoint=endpoint, params=params)\nexcept RuntimeError as re:\nraise RuntimeError(f\"error_message: {re}\") from re\nreturn content\n@classmethod\ndef _get_api_endpoint(cls, url_path: str, query: Optional[dict] = None) -&gt; str:\n\"\"\"\n        Build the API Endpoint for All Yellowstone Lodging\n        \"\"\"\nif query is not None:\nquery_string = parse.urlencode(query=query)\nelse:\nquery_string = \"\"\nurl_components = {\n\"scheme\": YellowstoneConfig.API_SCHEME,\n\"netloc\": YellowstoneConfig.API_BASE_ENDPOINT,\n\"url\": url_path,\n\"params\": \"\",\n\"query\": query_string,\n\"fragment\": \"\",\n}\napi_endpoint = parse.urlunparse(tuple(url_components.values()))\nreturn api_endpoint\n@classmethod\ndef _return_lodging_url(\ncls, lodging_code: str, month: datetime, params: Optional[dict] = \"\"\n) -&gt; str:\n\"\"\"\n        Return a Browser Loadable URL to book from\n        Parameters\n        ----------\n        lodging_code: str\n            Lodging Code from API\n        month: datetime\n            Month to return bookings filtered to\n        params: Optional[dict]\n            Optional URL Parameters\n        Returns\n        -------\n        str\n            URL String\n        \"\"\"\nquery = {\n\"dateFrom\": month.strftime(\"%m-%d-%Y\"),\n\"adults\": 1,\n\"destination\": lodging_code,\n\"children\": 0,\n}\nif params is not None:\nquery.update(params)\nquery_string = parse.urlencode(query=query)\nurl_components = {\n\"scheme\": YellowstoneConfig.API_SCHEME,\n\"netloc\": YellowstoneConfig.WEBUI_BASE_ENDPOINT,\n\"url\": YellowstoneConfig.WEBUI_BOOKING_PATH,\n\"params\": \"\",\n\"query\": query_string,\n\"fragment\": \"\",\n}\nwebui_endpoint = parse.urlunparse(tuple(url_components.values()))\nreturn webui_endpoint\n@classmethod\ndef _compile_campground_availabilities(\ncls, availability: XantResortData\n) -&gt; List[dict]:\n\"\"\"\n        Gather Data about campground availabilities within a JSON Availability Objet\n        Parameters\n        ----------\n        availability: ResortData\n            JSON Availability Object\n        Returns\n        -------\n        available_campsites:  List[dict]\n            List of Availabilities as JSON\n        \"\"\"\navailable_campsites = []\nfor booking_date, daily_data in availability.availability.items():\ncamping_keys = [\nkey\nfor key in daily_data.keys()\nif YellowstoneConfig.LODGING_CAMPGROUND_QUALIFIER in key\n]\nfor hotel_code in camping_keys:\nhotel_data = daily_data[hotel_code]\ntry:\nhotel_title = hotel_data.rates[YellowstoneConfig.RATE_CODE].title\nhotel_rate_mins = hotel_data.rates[YellowstoneConfig.RATE_CODE].mins\nif hotel_rate_mins != {1: 0}:\nmin_capacity = min(hotel_rate_mins.keys())\nmax_capacity = max(hotel_rate_mins.keys())\ncapacity = (min_capacity, max_capacity)\ncampsite = {\n\"campsite_id\": None,\n\"booking_date\": booking_date,\n\"campsite_occupancy\": capacity,\n\"recreation_area\": YellowstoneConfig.YELLOWSTONE_RECREATION_AREA_NAME,\n\"recreation_area_id\": YellowstoneConfig.YELLOWSTONE_RECREATION_AREA_ID,\n\"facility_name\": hotel_title.replace(\n*YellowstoneConfig.YELLOWSTONE_CAMPGROUND_NAME_REPLACE\n),\n\"facility_id\": hotel_code,\n}\navailable_campsites.append(campsite)\nexcept KeyError:\npass\nlogger.info(\nf\"\\t{logging_utils.get_emoji(available_campsites)}\\t\"\nf\"{len(available_campsites)} sites found.\"\n)\nreturn available_campsites\ndef _gather_campsite_specific_availability(\nself,\navailable_campsites: List[dict],\nmonth: datetime,\nnights: Optional[int] = None,\n) -&gt; List[dict]:\n\"\"\"\n        Get campsite extra information\n        Given a DataFrame of campsite availability, return updated Data with details\n        about the actual campsites that are available (i.e Tent Size, RV Length, Etc)\n        Parameters\n        ----------\n        available_campsites: List[dict]\n            List of Available Campsites as JSON objects\n        month: datetime\n            Month object\n        Returns\n        -------\n        List[dict]\n        \"\"\"\navailable_room_array = []\navailability_df = DataFrame(data=available_campsites)\nif availability_df.empty is True:\nreturn available_room_array\nfor facility_id, _facility_df in availability_df.groupby(\nYellowstoneConfig.FACILITY_ID\n):\napi_endpoint = self._get_api_endpoint(\nurl_path=YellowstoneConfig.YELLOWSTONE_CAMPSITE_AVAILABILITY, query=None\n)\nparams = {\"date\": self._ensure_current_month(month=month), \"limit\": 31}\nif nights is not None:\nparams.update({\"nights\": nights})\ncampsite_data = self.make_yellowstone_request(\nendpoint=f\"{api_endpoint}/{facility_id}\", params=params\n)\ncampsite_availability = campsite_data[\nYellowstoneConfig.BOOKING_AVAILABILITY\n]\nbooking_dates = campsite_availability.keys()\navailabilities = self._process_daily_availability(\nbooking_dates=booking_dates,\ncampsite_availability=campsite_availability,\nfacility_id=facility_id,\n)\navailable_room_array += availabilities\nreturn available_room_array\n@classmethod\ndef _process_daily_availability(\ncls, booking_dates: List[str], campsite_availability: dict, facility_id: str\n) -&gt; List[dict]:\n\"\"\"\n        Process Monthly Availability\n        Parameters\n        ----------\n        booking_dates: List[str]\n            List of booking dates to process\n        campsite_availability: dict\n            Campsite availability dict\n        facility_id: str\n            Identification of the Facility\n        Returns\n        -------\n        List[dict]\n        \"\"\"\ndaily_availabilities = []\nfor booking_date_str in booking_dates:\ndaily_availability = campsite_availability[booking_date_str]\nif (\ndaily_availability[YellowstoneConfig.FACILITY_STATUS]\n== YellowstoneConfig.FACILITY_STATUS_QUALIFIER\n):\navailable_rooms = daily_availability[YellowstoneConfig.FACILITY_ROOMS]\nfor room in available_rooms:\nif room[YellowstoneConfig.FACILITY_AVAILABLE_QUALIFIER] &gt; 0:\ndaily_availabilities.append(\n{\n\"booking_date\": booking_date_str,\n\"facility_id\": facility_id,\n\"campsite_code\": room[\nYellowstoneConfig.FACILITY_ROOM_CODE\n],\n\"available\": room[\nYellowstoneConfig.FACILITY_AVAILABLE_QUALIFIER\n],\n\"price\": room[YellowstoneConfig.FACILITY_PRICE],\n}\n)\nreturn daily_availabilities\ndef _get_property_information(self, available_rooms: List[dict]) -&gt; List[dict]:\n\"\"\"\n        Gather Information About All Campgrounds / Hotels within Yellowstone\n        Parameters\n        ----------\n        available_rooms: List[dict]\n        Returns\n        -------\n        List[dict]\n        \"\"\"\nproperty_info_array = []\navailability_df = DataFrame(data=available_rooms)\nif availability_df.empty is True:\nreturn property_info_array\nfacility_identifiers = availability_df[YellowstoneConfig.FACILITY_ID].unique()\nfor facility_id in facility_identifiers:\napi_endpoint = self._get_api_endpoint(\nurl_path=YellowstoneConfig.YELLOWSTONE_PROPERTY_INFO, query=None\n)\ncampsite_info = self.make_yellowstone_request(\nendpoint=f\"{api_endpoint}/{facility_id}\"\n)\ncampsite_codes = campsite_info.keys()\nfor campsite_code in campsite_codes:\ncampsite_data = campsite_info[campsite_code]\nproperty_info_array.append(\n{\n\"facility_id\": facility_id,\n\"campsite_code\": campsite_code,\n\"campsite_title\": campsite_data[\nYellowstoneConfig.LODGING_TITLE\n],\n\"campsite_type\": campsite_data[\nYellowstoneConfig.FACILITY_TYPE\n].upper(),\n\"capacity\": (\ncampsite_data[YellowstoneConfig.LODGING_OCCUPANCY_BASE],\ncampsite_data[YellowstoneConfig.LODGING_OCCUPANCY_MAX],\n),\n}\n)\nreturn property_info_array\ndef get_monthly_campsites(\nself, month: datetime, nights: Optional[int] = None\n) -&gt; List[AvailableCampsite]:\n\"\"\"\n        Return All Campsites Available in a Given Month\n        Parameters\n        ----------\n        month: datetime\n            Month to Search\n        nights: Optional[int]\n            Search for consecutive nights\n        Returns\n        -------\n        List[AvailableCampsite]\n        \"\"\"\nnow = datetime.now().date()\nsearch_date = month.replace(day=1)\nif month &lt;= now:\nlogger.info(\n\"Cannot input search dates before today, adjusting search parameters.\"\n)\nsearch_date = search_date.replace(\nyear=now.year, month=now.month, day=now.day\n)\navailability_found = self._get_monthly_availability(\nmonth=search_date, nights=nights\n)\navailability = XantResortData(**availability_found)\nmonthly_campsites = self._compile_campground_availabilities(\navailability=availability\n)\ncampsite_data = DataFrame(\nmonthly_campsites, columns=YellowstoneConfig.CAMPSITE_DATA_COLUMNS\n).drop_duplicates()\nif campsite_data.empty is True:\nreturn []\navailable_room_array = self._gather_campsite_specific_availability(\navailable_campsites=monthly_campsites, month=month, nights=nights\n)\navailable_rooms = DataFrame(available_room_array)\nproperty_info = self._get_property_information(\navailable_rooms=available_room_array\n)\nproperties = DataFrame(property_info)\nmerged_campsites = available_rooms.merge(\nproperties,\non=[\nYellowstoneConfig.FACILITY_ID_COLUMN,\nYellowstoneConfig.CAMPSITE_ID_COLUMN,\n],\n)\nmerged_campsites[YellowstoneConfig.BOOKING_DATE_COLUMN] = to_datetime(\nmerged_campsites[YellowstoneConfig.BOOKING_DATE_COLUMN]\n)\nif nights is not None:\nnights_param = {\"nights\": nights}\nelse:\nnights_param = {\"nights\": 1}\nbooking_nights = nights_param.get(\"nights\")\nmerged_campsites[YellowstoneConfig.BOOKING_END_DATE_COLUMN] = merged_campsites[\nYellowstoneConfig.BOOKING_DATE_COLUMN\n] + timedelta(days=booking_nights)\nmerged_campsites[YellowstoneConfig.BOOKING_NIGHTS_COLUMN] = booking_nights\nfinal_campsites = merged_campsites.merge(\ncampsite_data, on=YellowstoneConfig.FACILITY_ID_COLUMN\n).sort_values(by=YellowstoneConfig.BOOKING_DATE_COLUMN)\nfinal_campsites[YellowstoneConfig.BOOKING_URL_COLUMN] = final_campsites.apply(\nlambda x: self._return_lodging_url(\nlodging_code=x.facility_id, month=x.booking_date, params=nights_param\n),\naxis=1,\n)\nall_monthly_campsite_array = self._df_to_campsites(campsite_df=final_campsites)\nreturn all_monthly_campsite_array\n@classmethod\ndef _df_to_campsites(cls, campsite_df: DataFrame) -&gt; List[AvailableCampsite]:\n\"\"\"\n        Transform a DataFrame into an array of AvailableCampsites\n        Parameters\n        ----------\n        campsite_df: DataFrame\n        Returns\n        -------\n        List[AvailableCampsite]\n        \"\"\"\nall_monthly_campsite_array = []\nfor _, row in campsite_df.iterrows():\ncampsite = AvailableCampsite(\ncampsite_id=row[YellowstoneConfig.CAMPSITE_ID_COLUMN],\nbooking_date=row[YellowstoneConfig.BOOKING_DATE_COLUMN],\nbooking_end_date=row[YellowstoneConfig.BOOKING_END_DATE_COLUMN],\nbooking_nights=row[YellowstoneConfig.BOOKING_NIGHTS_COLUMN],\ncampsite_site_name=row[YellowstoneConfig.CAMPSITE_SITE_NAME_COLUMN],\ncampsite_loop_name=YellowstoneConfig.YELLOWSTONE_LOOP_NAME,\ncampsite_type=row[YellowstoneConfig.CAMPSITE_TYPE_COLUMN],\ncampsite_occupancy=row[YellowstoneConfig.CAMPSITE_OCCUPANCY_COLUMN],\ncampsite_use_type=row[YellowstoneConfig.CAMPSITE_USE_TYPE_COLUMN],\navailability_status=YellowstoneConfig.CAMPSITE_AVAILABILITY_STATUS,\nrecreation_area=YellowstoneConfig.YELLOWSTONE_RECREATION_AREA_NAME,\nrecreation_area_id=YellowstoneConfig.YELLOWSTONE_RECREATION_AREA_ID,\nfacility_name=row[YellowstoneConfig.FACILITY_NAME_COLUMN],\nfacility_id=row[YellowstoneConfig.FACILITY_ID_COLUMN],\nbooking_url=row[YellowstoneConfig.BOOKING_URL_COLUMN],\n)\nall_monthly_campsite_array.append(campsite)\nreturn all_monthly_campsite_array\n@classmethod\ndef _ensure_current_month(cls, month: datetime) -&gt; datetime:\n\"\"\"\n        Ensure That We Never Give the Yellowstone API Dates in the past.\n        Parameters\n        ----------\n        month: datetime\n        Returns\n        -------\n        datetime\n        \"\"\"\nyellowstone_timezone = timezone(YellowstoneConfig.YELLOWSTONE_TIMEZONE)\nyellowstone_current_time = datetime.now(yellowstone_timezone).date()\ntoday = datetime(\nyear=yellowstone_current_time.year,\nmonth=yellowstone_current_time.month,\nday=yellowstone_current_time.day,\n).date()\nif today &gt; month:\nmonth = today\nreturn month\ndef find_campgrounds(self, **kwargs) -&gt; List[CampgroundFacility]:\n\"\"\"\n        Print the Campgrounds inside of Yellowstone\n        \"\"\"\nlog_sorted_response(YellowstoneConfig.YELLOWSTONE_CAMPGROUND_OBJECTS)\nreturn YellowstoneConfig.YELLOWSTONE_CAMPGROUND_OBJECTS\n</code></pre>"},{"location":"reference/#camply.providers.xanterra.yellowstone_lodging.Yellowstone.find_campgrounds","title":"<code>find_campgrounds(**kwargs)</code>","text":"<p>Print the Campgrounds inside of Yellowstone</p> Source code in <code>camply/providers/xanterra/yellowstone_lodging.py</code> <pre><code>def find_campgrounds(self, **kwargs) -&gt; List[CampgroundFacility]:\n\"\"\"\n    Print the Campgrounds inside of Yellowstone\n    \"\"\"\nlog_sorted_response(YellowstoneConfig.YELLOWSTONE_CAMPGROUND_OBJECTS)\nreturn YellowstoneConfig.YELLOWSTONE_CAMPGROUND_OBJECTS\n</code></pre>"},{"location":"reference/#camply.providers.xanterra.yellowstone_lodging.Yellowstone.get_monthly_campsites","title":"<code>get_monthly_campsites(month, nights=None)</code>","text":"<p>Return All Campsites Available in a Given Month</p> <p>Parameters:</p> Name Type Description Default <code>month</code> <code>datetime</code> <p>Month to Search</p> required <code>nights</code> <code>Optional[int]</code> <p>Search for consecutive nights</p> <code>None</code> <p>Returns:</p> Type Description <code>List[AvailableCampsite]</code> Source code in <code>camply/providers/xanterra/yellowstone_lodging.py</code> <pre><code>def get_monthly_campsites(\nself, month: datetime, nights: Optional[int] = None\n) -&gt; List[AvailableCampsite]:\n\"\"\"\n    Return All Campsites Available in a Given Month\n    Parameters\n    ----------\n    month: datetime\n        Month to Search\n    nights: Optional[int]\n        Search for consecutive nights\n    Returns\n    -------\n    List[AvailableCampsite]\n    \"\"\"\nnow = datetime.now().date()\nsearch_date = month.replace(day=1)\nif month &lt;= now:\nlogger.info(\n\"Cannot input search dates before today, adjusting search parameters.\"\n)\nsearch_date = search_date.replace(\nyear=now.year, month=now.month, day=now.day\n)\navailability_found = self._get_monthly_availability(\nmonth=search_date, nights=nights\n)\navailability = XantResortData(**availability_found)\nmonthly_campsites = self._compile_campground_availabilities(\navailability=availability\n)\ncampsite_data = DataFrame(\nmonthly_campsites, columns=YellowstoneConfig.CAMPSITE_DATA_COLUMNS\n).drop_duplicates()\nif campsite_data.empty is True:\nreturn []\navailable_room_array = self._gather_campsite_specific_availability(\navailable_campsites=monthly_campsites, month=month, nights=nights\n)\navailable_rooms = DataFrame(available_room_array)\nproperty_info = self._get_property_information(\navailable_rooms=available_room_array\n)\nproperties = DataFrame(property_info)\nmerged_campsites = available_rooms.merge(\nproperties,\non=[\nYellowstoneConfig.FACILITY_ID_COLUMN,\nYellowstoneConfig.CAMPSITE_ID_COLUMN,\n],\n)\nmerged_campsites[YellowstoneConfig.BOOKING_DATE_COLUMN] = to_datetime(\nmerged_campsites[YellowstoneConfig.BOOKING_DATE_COLUMN]\n)\nif nights is not None:\nnights_param = {\"nights\": nights}\nelse:\nnights_param = {\"nights\": 1}\nbooking_nights = nights_param.get(\"nights\")\nmerged_campsites[YellowstoneConfig.BOOKING_END_DATE_COLUMN] = merged_campsites[\nYellowstoneConfig.BOOKING_DATE_COLUMN\n] + timedelta(days=booking_nights)\nmerged_campsites[YellowstoneConfig.BOOKING_NIGHTS_COLUMN] = booking_nights\nfinal_campsites = merged_campsites.merge(\ncampsite_data, on=YellowstoneConfig.FACILITY_ID_COLUMN\n).sort_values(by=YellowstoneConfig.BOOKING_DATE_COLUMN)\nfinal_campsites[YellowstoneConfig.BOOKING_URL_COLUMN] = final_campsites.apply(\nlambda x: self._return_lodging_url(\nlodging_code=x.facility_id, month=x.booking_date, params=nights_param\n),\naxis=1,\n)\nall_monthly_campsite_array = self._df_to_campsites(campsite_df=final_campsites)\nreturn all_monthly_campsite_array\n</code></pre>"},{"location":"reference/#camply.providers.xanterra.yellowstone_lodging.Yellowstone.make_yellowstone_request","title":"<code>make_yellowstone_request(endpoint, params=None)</code>  <code>staticmethod</code>","text":"<p>Try and Retry Fetching Data from the Yellowstone API.</p> <p>Unfortunately this is a required method to request the data since the Yellowstone API doesn't always return data.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>API Endpoint</p> required <code>params</code> <code>Optional[dict]</code> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> Source code in <code>camply/providers/xanterra/yellowstone_lodging.py</code> <pre><code>@staticmethod\ndef make_yellowstone_request(endpoint: str, params: Optional[dict] = None) -&gt; dict:\n\"\"\"\n    Try and Retry Fetching Data from the Yellowstone API.\n    Unfortunately this is a required method to request the data since the\n    Yellowstone API doesn't always return data.\n    Parameters\n    ----------\n    endpoint: str\n        API Endpoint\n    params\n    Returns\n    -------\n    dict\n    \"\"\"\ntry:\ncontent = Yellowstone._try_retry_get_data(endpoint=endpoint, params=params)\nexcept RuntimeError as re:\nraise RuntimeError(f\"error_message: {re}\") from re\nreturn content\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>camply<ul> <li>_version</li> <li>cli</li> <li>config<ul> <li>api_config</li> <li>data_columns</li> <li>file_config</li> <li>logging_config</li> <li>notification_config</li> <li>search_config</li> <li>yellowstone_config</li> </ul> </li> <li>containers<ul> <li>api_responses</li> <li>base_container</li> <li>data_containers</li> <li>examples</li> <li>gtc_api_responses</li> <li>search_model</li> <li>usedirect</li> </ul> </li> <li>exceptions</li> <li>notifications<ul> <li>apprise</li> <li>base_notifications</li> <li>email_notifications</li> <li>multi_provider_notifications</li> <li>ntfy</li> <li>pushbullet</li> <li>pushover</li> <li>silent_notifications</li> <li>slack</li> <li>telegram</li> <li>twilio</li> </ul> </li> <li>providers<ul> <li>base_provider</li> <li>going_to_camp<ul> <li>going_to_camp_provider</li> </ul> </li> <li>recreation_dot_gov<ul> <li>recdotgov_camps</li> <li>recdotgov_provider</li> <li>recdotgov_tours</li> </ul> </li> <li>usedirect<ul> <li>usedirect</li> <li>variations</li> </ul> </li> <li>xanterra<ul> <li>yellowstone_lodging</li> </ul> </li> </ul> </li> <li>search<ul> <li>base_search</li> <li>search_going_to_camp</li> <li>search_recreationdotgov</li> <li>search_usedirect</li> <li>search_yellowstone</li> </ul> </li> <li>utils<ul> <li>api_utils</li> <li>configure_camply</li> <li>general_utils</li> <li>logging_utils</li> <li>yaml_utils</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/_version/","title":"_version","text":"<p>camply Version file</p>"},{"location":"reference/cli/","title":"cli","text":"<p>Camply Command Line Interface</p>"},{"location":"reference/cli/#camply.cli.CamplyContext","title":"<code>CamplyContext</code>  <code>dataclass</code>","text":"<p>Context Object Passed Around Application</p> Source code in <code>camply/cli.py</code> <pre><code>@dataclass\nclass CamplyContext:\n\"\"\"\n    Context Object Passed Around Application\n    \"\"\"\ndebug: Optional[bool] = None\nprovider: Optional[str] = None\n</code></pre>"},{"location":"reference/cli/#camply.cli.campgrounds","title":"<code>campgrounds(context, debug, search=None, state=None, rec_area=None, campground=None, campsite=None, provider=DEFAULT_CAMPLY_PROVIDER)</code>","text":"<p>Search for Campgrounds (inside of Recreation Areas) and list them</p> <p>Search for Campgrounds and their IDs. Campgrounds are facilities inside of Recreation Areas that contain campsites. Most 'campgrounds' are areas made up of multiple campsites, others are facilities like fire towers or cabins that might only contain a single 'campsite' to book.</p> Source code in <code>camply/cli.py</code> <pre><code>@camply_command_line.command(cls=RichCommand)\n@search_argument\n@state_argument\n@rec_area_argument\n@campground_argument\n@campsite_id_argument\n@provider_argument\n@debug_option\n@click.pass_obj\ndef campgrounds(\ncontext: CamplyContext,\ndebug: bool,\nsearch: Optional[str] = None,\nstate: Optional[str] = None,\nrec_area: Optional[int] = None,\ncampground: Optional[int] = None,\ncampsite: Optional[int] = None,\nprovider: Optional[str] = DEFAULT_CAMPLY_PROVIDER,\n) -&gt; None:\n\"\"\"\n    Search for Campgrounds (inside of Recreation Areas) and list them\n    Search for Campgrounds and their IDs. Campgrounds are facilities inside of\n    Recreation Areas that contain campsites. Most 'campgrounds' are areas made up of\n    multiple campsites, others are facilities like fire towers or cabins that might only\n    contain a single 'campsite' to book.\n    \"\"\"\nprovider = _preferred_provider(context, provider)\nif context.debug is None:\ncontext.debug = debug\n_set_up_debug(debug=context.debug)\nif all(\n[\nsearch is None,\nstate is None,\nlen(rec_area) == 0,\nlen(campground) == 0,\nlen(campsite) == 0,\nprovider not in [Yellowstone.__name__, GoingToCamp.__name__],\n]\n):\nlogger.error(\n\"You must add a --search, --state, --campground, --campsite, \"\n\"or --rec-area parameter to search for Campgrounds.\"\n)\nsys.exit(1)\nsearch_provider_class = CAMPSITE_SEARCH_PROVIDER[provider]\ncamp_finder = search_provider_class.provider_class()\nparams = {}\nif state is not None:\nparams.update({\"state\": state})\ncamp_finder.find_campgrounds(\nsearch_string=search,\nrec_area_id=make_list(rec_area, coerce=int),\ncampground_id=make_list(campground, coerce=int),\ncampsite_id=make_list(campsite, coerce=int),\n**params,\n)\n</code></pre>"},{"location":"reference/cli/#camply.cli.camply_command_line","title":"<code>camply_command_line(ctx, debug, provider)</code>","text":"<p>Welcome to camply, the campsite finder.</p> <p>Finding reservations at sold out campgrounds can be tough. That's where camply comes in. It searches the APIs of booking services like https://recreation.gov (which indexes thousands of campgrounds across the USA) to continuously check for cancellations and availabilities to pop up. Once a campsite becomes available, camply sends you a notification to book your spot!</p> <p>\b</p> <p>visit the camply documentation at https://juftin.com/camply</p> Source code in <code>camply/cli.py</code> <pre><code>@tui()\n@click.group(cls=RichGroup)\n@debug_option\n@provider_argument\n@click.version_option(version=__version__, prog_name=__application__)\n@click.pass_context\ndef camply_command_line(\nctx: click.core.Context, debug: bool, provider: Optional[str]\n) -&gt; None:\n\"\"\"\n    Welcome to camply, the campsite finder.\n    Finding reservations at sold out campgrounds can be\n    tough. That's where camply comes in. It searches the APIs of booking services like\n    https://recreation.gov (which indexes thousands of campgrounds across the USA) to continuously\n    check for cancellations and availabilities to pop up. Once a campsite becomes available,\n    camply sends you a notification to book your spot!\n    \\b\n    visit the camply documentation at https://juftin.com/camply\n    \"\"\"\nset_up_logging(log_level=None if debug is False else logging.INFO)\nlogger.camply(\"camply, the campsite finder \u26fa\ufe0f\")\nctx.obj = CamplyContext(debug=debug, provider=provider)\n_set_up_debug(debug=debug)\n</code></pre>"},{"location":"reference/cli/#camply.cli.campsites","title":"<code>campsites(context, debug, rec_area, campground, campsite, start_date, end_date, weekends, nights, provider, continuous, polling_interval, notifications, notify_first_try, search_forever, search_once, yaml_config, offline_search, offline_search_path, equipment, equipment_id, day)</code>","text":"<p>Find Available Campsites with Custom Search Criteria</p> <p>Search for a campsite within camply. Campsites are returned based on the search criteria provided. Campsites contain properties like booking date, site type (tent, RV, cabin, etc), capacity, price, and a link to make the booking. Required parameters include <code>--start-date</code>, <code>--end-date</code>, <code>--rec-area</code> / <code>--campground</code>. Constant searching functionality can be enabled with  <code>--continuous</code> and notifications can be enabled using <code>--notifications</code>.</p> Source code in <code>camply/cli.py</code> <pre><code>@camply_command_line.command(cls=RichCommand)\n@rec_area_argument\n@campground_argument\n@campsite_id_argument\n@start_date_argument\n@end_date_argument\n@nights_argument\n@weekends_argument\n@day_of_the_week_argument\n@notifications_argument\n@continuous_argument\n@search_forever_argument\n@yaml_config_argument\n@offline_search_argument\n@offline_search_path_argument\n@search_once_argument\n@polling_interval_argument\n@notify_first_try_argument\n@equipment_argument\n@equipment_id_argument\n@provider_argument\n@debug_option\n@click.pass_obj\ndef campsites(\ncontext: CamplyContext,\ndebug: bool,\nrec_area: Tuple[Union[str, int]],\ncampground: Tuple[Union[str, int]],\ncampsite: Tuple[Union[str, int]],\nstart_date: str,\nend_date: str,\nweekends: bool,\nnights: int,\nprovider: Optional[str],\ncontinuous: bool,\npolling_interval: Optional[str],\nnotifications: Tuple[str],\nnotify_first_try: Optional[str],\nsearch_forever: Optional[str],\nsearch_once: bool,\nyaml_config: Optional[str],\noffline_search: bool,\noffline_search_path: Optional[str],\nequipment: Tuple[Union[str, int]],\nequipment_id: Tuple[Union[str, int]],\nday: Optional[Tuple[str]],\n) -&gt; None:\n\"\"\"\n    Find Available Campsites with Custom Search Criteria\n    Search for a campsite within camply. Campsites are returned based on the search criteria\n    provided. Campsites contain properties like booking date, site type (tent, RV, cabin, etc),\n    capacity, price, and a link to make the booking. Required parameters include\n    `--start-date`, `--end-date`, `--rec-area` / `--campground`. Constant searching\n    functionality can be enabled with  `--continuous` and notifications can be enabled using\n    `--notifications`.\n    \"\"\"\nif context.debug is None:\ncontext.debug = debug\n_set_up_debug(debug=context.debug)\nif yaml_config is not None:\nprovider, provider_kwargs, search_kwargs = yaml_utils.yaml_file_to_arguments(\nfile_path=yaml_config\n)\nprovider = _preferred_provider(context, provider)\nelse:\nprovider = _preferred_provider(context, provider)\nprovider_kwargs, search_kwargs = _get_provider_kwargs_from_cli(\nrec_area=rec_area,\ncampground=campground,\ncampsite=campsite,\nstart_date=start_date,\nend_date=end_date,\nweekends=weekends,\nnights=nights,\nprovider=provider,\ncontinuous=continuous,\npolling_interval=polling_interval,\nnotifications=notifications,\nnotify_first_try=notify_first_try,\nsearch_forever=search_forever,\nsearch_once=search_once,\noffline_search=offline_search,\noffline_search_path=offline_search_path,\nequipment=equipment,\nequipment_id=equipment_id,\nday=day,\nyaml_config=yaml_config,\n)\nprovider_class: Type[BaseCampingSearch] = CAMPSITE_SEARCH_PROVIDER[provider]\ncamping_finder: BaseCampingSearch = provider_class(**provider_kwargs)\ncamping_finder.get_matching_campsites(**search_kwargs)\n</code></pre>"},{"location":"reference/cli/#camply.cli.cli","title":"<code>cli()</code>","text":"<p>Camply Command Line Utility Wrapper</p> Source code in <code>camply/cli.py</code> <pre><code>def cli():\n\"\"\"\n    Camply Command Line Utility Wrapper\n    \"\"\"\ntry:\ncamply_command_line()\nexcept KeyboardInterrupt:\nlogger.debug(\"Handling Exit Request\")\nfinally:\nlogger.camply(\"Exiting camply \ud83d\udc4b\")\n</code></pre>"},{"location":"reference/cli/#camply.cli.configure","title":"<code>configure(context, debug)</code>","text":"<p>Set up camply configuration file with an interactive console</p> <p>In order to send notifications through camply you must set up some authorization values. Whether you need to set up pushover notifications (push notifications on your phone, your pushover account can be set up at https://pushover.net) or Email messages, everything can be done through the configure command. The end result is a file called .camply in your home folder.</p> Source code in <code>camply/cli.py</code> <pre><code>@camply_command_line.command(cls=RichCommand)\n@debug_option\n@click.pass_obj\ndef configure(context: CamplyContext, debug: bool) -&gt; None:\n\"\"\"\n    Set up camply configuration file with an interactive console\n    In order to send notifications through camply you must set up some authorization values.\n    Whether you need to set up pushover notifications (push notifications on your phone,\n    your pushover account can be set up at https://pushover.net) or Email messages, everything\n    can be done through the configure command. The end result is a file called .camply in your\n    home folder.\n    \"\"\"\nif context.debug is None:\ncontext.debug = debug\n_set_up_debug(debug=context.debug)\nconfigure_camply.generate_dot_camply_file()\n</code></pre>"},{"location":"reference/cli/#camply.cli.equipment_types","title":"<code>equipment_types(context, rec_area=None, provider=DEFAULT_CAMPLY_PROVIDER)</code>","text":"<p>Get a list of supported equipment</p> <p>This command returns supported equipment for the current provider/recreation area. Equipment are camping equipment that can be used at a campsite. Different providers and recreation areas have different types of equipment for which reservations can be made.</p> Source code in <code>camply/cli.py</code> <pre><code>@camply_command_line.command(cls=RichCommand)\n@rec_area_argument\n@provider_argument\n@click.pass_obj\ndef equipment_types(\ncontext: CamplyContext,\nrec_area: Optional[int] = None,\nprovider: str = DEFAULT_CAMPLY_PROVIDER,\n) -&gt; None:\n\"\"\"\n    Get a list of supported equipment\n    This command returns supported equipment for the current provider/recreation area.\n    Equipment are camping equipment that can be used at a campsite. Different providers\n    and recreation areas have different types of equipment for which reservations can be made.\n    \"\"\"\nprovider = _preferred_provider(context, provider)\nif not rec_area and provider == GoingToCamp.__name__:\nlogger.error(\n\"This provider requires --rec-area to be specified when listing equipment types\"\n)\nsys.exit(1)\nif provider == GoingToCamp.__name__:\nGoingToCamp().list_equipment_types(rec_area[0])\nelif provider.startswith(RecreationDotGov.__name__):\nlog_sorted_response(response_array=EquipmentOptions.__all_accepted_equipment__)\nelse:\nlogger.warning(\"That Provider doesn't support equipment based searching, yet \ud83d\ude42\")\nsys.exit(0)\n</code></pre>"},{"location":"reference/cli/#camply.cli.list_campsites","title":"<code>list_campsites(context, debug, campground, rec_area, provider)</code>","text":"<p>List campsite IDs for a given campground or recreation area</p> Source code in <code>camply/cli.py</code> <pre><code>@camply_command_line.command(cls=RichCommand)\n@rec_area_argument\n@campground_argument\n@provider_argument\n@debug_option\n@click.pass_obj\ndef list_campsites(\ncontext: CamplyContext,\ndebug: bool,\ncampground: Sequence[int],\nrec_area: Sequence[int],\nprovider: str,\n) -&gt; None:\n\"\"\"\n    List campsite IDs for a given campground or recreation area\n    \"\"\"\nprovider = _preferred_provider(context, provider)\nif context.debug is None:\ncontext.debug = debug\n_set_up_debug(debug=context.debug)\nif all(\n[\nlen(rec_area) == 0,\nlen(campground) == 0,\n]\n):\nlogger.error(\n\"You must provide a `--campground` or `--rec-area` to list campsites\"\n)\nsys.exit(1)\nsearch_provider_class = CAMPSITE_SEARCH_PROVIDER[provider]\nif search_provider_class.list_campsites_supported is False:\nlogger.error(\"That provider does not support listing campsites\")\nsys.exit(1)\ncamp_search = search_provider_class(\nsearch_window=SearchWindow(\nstart_date=date.today() + timedelta(days=1),\nend_date=date.today() + timedelta(days=2),\n),\nrecreation_area=rec_area,\ncampgrounds=campground,\nverbose=False,\n)\nlogger.info(\"Searching for campsites to list\")\ncamp_search.list_campsite_units()\n</code></pre>"},{"location":"reference/cli/#camply.cli.providers","title":"<code>providers(context, debug)</code>","text":"<p>List the different camply providers</p> Source code in <code>camply/cli.py</code> <pre><code>@camply_command_line.command(cls=RichCommand)\n@debug_option\n@click.pass_obj\ndef providers(\ncontext: CamplyContext,\ndebug: bool,\n) -&gt; None:\n\"\"\"\n    List the different camply providers\n    \"\"\"\nif context.debug is None:\ncontext.debug = debug\n_set_up_debug(debug=context.debug)\nlogger.info(\n\"camply currently supports %s providers:\", len(CAMPSITE_SEARCH_PROVIDER.keys())\n)\nfor provider_name, search_class in CAMPSITE_SEARCH_PROVIDER.items():\nlogger.info(\n'    \"%s\":    %s',\nprovider_name,\nsearch_class.__doc__.strip().splitlines()[0],\n)\n</code></pre>"},{"location":"reference/cli/#camply.cli.recreation_areas","title":"<code>recreation_areas(context, search, state, debug, provider=DEFAULT_CAMPLY_PROVIDER)</code>","text":"<p>Search for Recreation Areas and list them</p> <p>Search for Recreation Areas and their IDs. Recreation Areas are places like National Parks and National Forests that can contain one or many campgrounds.</p> Source code in <code>camply/cli.py</code> <pre><code>@camply_command_line.command(cls=RichCommand)\n@search_argument\n@state_argument\n@debug_option\n@provider_argument\n@click.pass_obj\ndef recreation_areas(\ncontext: CamplyContext,\nsearch: Optional[str],\nstate: Optional[str],\ndebug: bool,\nprovider: str = DEFAULT_CAMPLY_PROVIDER,\n) -&gt; None:\n\"\"\"\n    Search for Recreation Areas and list them\n    Search for Recreation Areas and their IDs. Recreation Areas are places like\n    National Parks and National Forests that can contain one or many campgrounds.\n    \"\"\"\nprovider = _preferred_provider(context, provider)\nif context.debug is None:\ncontext.debug = debug\n_set_up_debug(debug=context.debug)\nif all(\n[\nsearch is None,\nstate is not None,\nprovider in [Yellowstone.__name__, GoingToCamp.__name__],\n]\n):\n# State Filtering Not Supported\nlogger.error(\nf\"{provider} does not support filtering recreation areas by state. Leave --state blank.\"\n)\nsys.exit(1)\nif provider == GoingToCamp.__name__:\nrec_area_finder = GoingToCamp()\nelif provider.startswith(RecreationDotGov.__name__):\nrec_area_finder = RecreationDotGov()\nelse:\nrec_area_finder = CAMPSITE_SEARCH_PROVIDER[provider]\nparams = {}\nif state is not None:\nparams.update({\"state\": state})\nrec_area_finder.find_recreation_areas(search_string=search, **params)\n</code></pre>"},{"location":"reference/cli/#camply.cli.test_notifications","title":"<code>test_notifications(context, debug, notifications)</code>","text":"<p>Test your notification provider setup</p> Source code in <code>camply/cli.py</code> <pre><code>@camply_command_line.command(cls=RichCommand)\n@click.option(\"--notifications\", **test_notifications_kwargs)\n@debug_option\n@click.pass_obj\ndef test_notifications(\ncontext: CamplyContext, debug: bool, notifications: Container[str]\n) -&gt; None:\n\"\"\"\n    Test your notification provider setup\n    \"\"\"\nif context.debug is None:\ncontext.debug = debug\n_set_up_debug(debug=context.debug)\nnotification_providers = make_list(notifications)\nprovider = MultiNotifierProvider(provider=notification_providers)\nlogger.info(\"Testing your notification providers:\")\nfor sub_provider in provider.providers:\nlogger.info('\\t\"%s\"', sub_provider)\nprovider.send_campsites(campsites=[example_campsite])\n</code></pre>"},{"location":"reference/cli/#camply.cli.tui","title":"<code>tui(*args, **kwargs)</code>","text":"<p>TUI Placeholder - trogon not installed</p> Source code in <code>camply/cli.py</code> <pre><code>def tui(*args, **kwargs):\n\"\"\"\n    TUI Placeholder - trogon not installed\n    \"\"\"\ndef placeholder(app: click.Group):\n\"\"\"\n        Return the group in place\n        \"\"\"\nreturn app\nreturn placeholder\n</code></pre>"},{"location":"reference/exceptions/","title":"exceptions","text":"<p>Camply: Common Exceptions</p>"},{"location":"reference/exceptions/#camply.exceptions.CamplyError","title":"<code>CamplyError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Base Camply Error</p> Source code in <code>camply/exceptions.py</code> <pre><code>class CamplyError(Exception):\n\"\"\"\n    Base Camply Error\n    \"\"\"\n</code></pre>"},{"location":"reference/exceptions/#camply.exceptions.CampsiteNotFoundError","title":"<code>CampsiteNotFoundError</code>","text":"<p>         Bases: <code>SearchError</code></p> <p>Campsite not found Error</p> Source code in <code>camply/exceptions.py</code> <pre><code>class CampsiteNotFoundError(SearchError):\n\"\"\"\n    Campsite not found Error\n    \"\"\"\n</code></pre>"},{"location":"reference/exceptions/#camply.exceptions.SearchError","title":"<code>SearchError</code>","text":"<p>         Bases: <code>CamplyError</code></p> <p>Generic Search Error</p> Source code in <code>camply/exceptions.py</code> <pre><code>class SearchError(CamplyError):\n\"\"\"\n    Generic Search Error\n    \"\"\"\n</code></pre>"},{"location":"reference/config/","title":"config","text":"<p>Config init file</p>"},{"location":"reference/config/#camply.config.AppriseConfig","title":"<code>AppriseConfig</code>","text":"<p>Apprise Notification Config Class</p> Source code in <code>camply/config/notification_config.py</code> <pre><code>class AppriseConfig:\n\"\"\"\n    Apprise Notification Config Class\n    \"\"\"\nAPPRISE_URL: str = getenv(\"APPRISE_URL\", None)\n</code></pre>"},{"location":"reference/config/#camply.config.CampsiteContainerFields","title":"<code>CampsiteContainerFields</code>","text":"<p>String Variable Storage Class</p> Source code in <code>camply/config/data_columns.py</code> <pre><code>class CampsiteContainerFields:\n\"\"\"\n    String Variable Storage Class\n    \"\"\"\nCAMPSITE_ID: str = \"campsite_id\"\nCAMPGROUND_ID: str = \"facility_id\"\nBOOKING_DATE: str = \"booking_date\"\nCAMPSITE_GROUP: str = \"campsite_group\"\nBOOKING_END_DATE: str = \"booking_end_date\"\nBOOKING_URL: str = \"booking_url\"\nPERMITTED_EQUIPMENT: str = \"permitted_equipment\"\nCAMPSITE_ATTRIBUTES: str = \"campsite_attributes\"\n</code></pre>"},{"location":"reference/config/#camply.config.DataColumns","title":"<code>DataColumns</code>","text":"<p>Variable Storage Class</p> Source code in <code>camply/config/data_columns.py</code> <pre><code>class DataColumns:\n\"\"\"\n    Variable Storage Class\n    \"\"\"\nCAMPSITE_ID_COLUMN: str = \"campsite_code\"\nBOOKING_DATE_COLUMN: str = \"booking_date\"\nBOOKING_END_DATE_COLUMN: str = \"booking_end_date\"\nBOOKING_NIGHTS_COLUMN: str = \"booking_nights\"\nCAMPSITE_SITE_NAME_COLUMN: str = \"campsite_title\"\nCAMPSITE_TYPE_COLUMN: str = \"campsite_type\"\nCAMPSITE_OCCUPANCY_COLUMN: str = \"capacity\"\nCAMPSITE_USE_TYPE_COLUMN: str = \"campsite_type\"\nAVAILABILITY_STATUS_COLUMN: str = \"Available\"\nRECREATION_AREA_COLUMN: str = \"recreation_area\"\nFACILITY_NAME_COLUMN: str = \"facility_name\"\nFACILITY_ID_COLUMN: str = \"facility_id\"\nBOOKING_URL_COLUMN: str = \"booking_url\"\n</code></pre>"},{"location":"reference/config/#camply.config.EmailConfig","title":"<code>EmailConfig</code>","text":"<p>Email Notification Config Class</p> Source code in <code>camply/config/notification_config.py</code> <pre><code>class EmailConfig:\n\"\"\"\n    Email Notification Config Class\n    \"\"\"\nEMAIL_TO_ADDRESS: Optional[str] = getenv(\"EMAIL_TO_ADDRESS\", None)\nDEFAULT_FROM_ADDRESS: str = \"camply@juftin.com\"\nEMAIL_FROM_ADDRESS: str = getenv(\"EMAIL_FROM_ADDRESS\", DEFAULT_FROM_ADDRESS)\nDEFAULT_SUBJECT_LINE: str = \"Camply Notification\"\nEMAIL_SUBJECT_LINE: str = getenv(\"EMAIL_SUBJECT_LINE\", DEFAULT_SUBJECT_LINE)\nDEFAULT_SMTP_SERVER: str = \"smtp.gmail.com\"\nEMAIL_SMTP_SERVER: str = getenv(\"EMAIL_SMTP_SERVER\", DEFAULT_SMTP_SERVER)\nEMAIL_USERNAME: Optional[str] = getenv(\"EMAIL_USERNAME\", None)\nEMAIL_PASSWORD: Optional[str] = getenv(\"EMAIL_PASSWORD\", None)\nDEFAULT_SMTP_PORT: int = 465\nEMAIL_SMTP_PORT: int = int(getenv(\"EMAIL_SMTP_PORT\", DEFAULT_SMTP_PORT))\nENVIRONMENT_VARIABLE_NAMES: List[str] = [\n\"EMAIL_TO_ADDRESS\",\n\"EMAIL_USERNAME\",\n\"EMAIL_PASSWORD\",\n]\nOPTIONAL_ENVIRONMENT_VARIABLE: List[str] = [\nf\"EMAIL_SMTP_SERVER (default: {DEFAULT_SMTP_SERVER})\",\nf\"EMAIL_FROM_ADDRESS (default: {DEFAULT_FROM_ADDRESS})\",\nf'EMAIL_SUBJECT_LINE (default: \"{DEFAULT_SUBJECT_LINE}\")',\nf\"EMAIL_SMTP_PORT (default: {DEFAULT_SMTP_PORT})\",\n]\n</code></pre>"},{"location":"reference/config/#camply.config.EquipmentOptions","title":"<code>EquipmentOptions</code>","text":"<p>         Bases: <code>str</code>, <code>Enum</code></p> <p>Enumeration of the Equipment Options</p> Source code in <code>camply/config/search_config.py</code> <pre><code>class EquipmentOptions(str, Enum):\n\"\"\"\n    Enumeration of the Equipment Options\n    \"\"\"\ntent = \"tent\"\nrv = \"rv\"\ntrailer = \"trailer\"\nvehicle = \"vehicle\"\nother = \"other\"\n__all_accepted_equipment__ = [tent, rv, trailer, vehicle]\n</code></pre>"},{"location":"reference/config/#camply.config.FileConfig","title":"<code>FileConfig</code>","text":"<p>File Path Storage Class</p> Source code in <code>camply/config/file_config.py</code> <pre><code>class FileConfig:\n\"\"\"\n    File Path Storage Class\n    \"\"\"\nHOME_PATH = abspath(Path.home())\nDOT_CAMPLY_FILE = join(HOME_PATH, \".camply\")\n_file_config_file = Path(abspath(__file__))\n_config_dir = _file_config_file.parent\nCAMPLY_DIRECTORY = _config_dir.parent\nROOT_DIRECTORY = CAMPLY_DIRECTORY.parent\nDOT_CAMPLY_FIELDS = OrderedDict(\nPUSHOVER_PUSH_USER={\"default\": \"\", \"notes\": \"Enables Pushover Notifications\"},\nPUSHBULLET_API_TOKEN={\n\"default\": \"\",\n\"notes\": \"Enables Pushbullet Notifications\",\n},\nSLACK_WEBHOOK={\"default\": \"\", \"notes\": \"Enables Slack Notifications\"},\nTELEGRAM_BOT_TOKEN={\"default\": \"\", \"notes\": \"Enables Telegram Notifications\"},\nTELEGRAM_CHAT_ID={\n\"default\": \"\",\n\"notes\": \"Telegram Notification will be sent here\",\n},\nTWILIO_ACCOUNT_SID={\"default\": \"\", \"notes\": \"Twilio Account SID\"},\nTWILIO_AUTH_TOKEN={\"default\": \"\", \"notes\": \"Twilio Auth Token\"},\nTWILIO_SOURCE_NUMBER={\n\"default\": \"\",\n\"notes\": \"Twilio Source number. E.164 format\",\n},\nTWILIO_DEST_NUMBERS={\n\"default\": \"\",\n\"notes\": \"Comma-separated list of phone numbers.\",\n},\nEMAIL_TO_ADDRESS={\n\"default\": \"\",\n\"notes\": \"Email Notifications will be sent here\",\n},\nEMAIL_USERNAME={\"default\": \"\", \"notes\": \"Email Authorization Login Username\"},\nEMAIL_PASSWORD={\"default\": \"\", \"notes\": \"Email Authorization Login Password\"},\nEMAIL_SMTP_SERVER={\n\"default\": \"smtp.gmail.com\",\n\"notes\": \"Email Authorization SMTP Server Address\",\n},\nEMAIL_SMTP_PORT={\n\"default\": 465,\n\"notes\": \"Email Authorization SMTP Server Port\",\n},\nEMAIL_FROM_ADDRESS={\n\"default\": \"camply@juftin.com\",\n\"notes\": \"Email Notifications Will Come From this Email\",\n},\nEMAIL_SUBJECT_LINE={\n\"default\": \"Camply Notification\",\n\"notes\": \"Email Notifications Will Have This Subject Line\",\n},\nPUSHOVER_PUSH_TOKEN={\n\"default\": \"\",\n\"notes\": \"Pushover Notifications From Your Custom App \" \"(not required)\",\n},\nNTFY_TOPIC={\n\"default\": \"\",\n\"notes\": \"NTFY Notification Topic\",\n},\nAPPRISE_URL={\"default\": \"\", \"notes\": \"Apprise notification URL\"},\nRIDB_API_KEY={\n\"default\": \"\",\n\"notes\": \"Personal Recreation.gov API Key (not required)\",\n},\n)\nPROVIDERS_DIRECTORY = CAMPLY_DIRECTORY.joinpath(\"providers\")\nRESERVE_CALIFORNIA_PROVIDER = PROVIDERS_DIRECTORY.joinpath(\"reserve_california\")\nUSEDIRECT_PROVIDER = PROVIDERS_DIRECTORY.joinpath(\"usedirect\")\n</code></pre>"},{"location":"reference/config/#camply.config.NtfyConfig","title":"<code>NtfyConfig</code>","text":"<p>Ntfy Notification Config Class</p> Source code in <code>camply/config/notification_config.py</code> <pre><code>class NtfyConfig:\n\"\"\"\n    Ntfy Notification Config Class\n    \"\"\"\nNTFY_API_ENDPOINT: str = \"https://ntfy.sh/\"\nNTFY_TOPIC = getenv(\"NTFY_TOPIC\", None)\n</code></pre>"},{"location":"reference/config/#camply.config.PushbulletConfig","title":"<code>PushbulletConfig</code>","text":"<p>Pushbullet Notification Config Class</p> Source code in <code>camply/config/notification_config.py</code> <pre><code>class PushbulletConfig:\n\"\"\"\n    Pushbullet Notification Config Class\n    \"\"\"\nPUSHBULLET_API_ENDPOINT: str = \"https://api.pushbullet.com/v2/pushes\"\nAPI_HEADERS: dict = {\"Content-Type\": \"application/json\"}\nAPI_TOKEN = getenv(\"PUSHBULLET_API_TOKEN\", None)\n</code></pre>"},{"location":"reference/config/#camply.config.PushoverConfig","title":"<code>PushoverConfig</code>","text":"<p>Pushover Notification Config Class</p> Source code in <code>camply/config/notification_config.py</code> <pre><code>class PushoverConfig:\n\"\"\"\n    Pushover Notification Config Class\n    \"\"\"\nPUSHOVER_API_ENDPOINT: str = \"https://api.pushover.net/1/messages.json\"\nPUSHOVER_DEFAULT_API_TOKEN: bytes = b\"YWpjN3M1a2hhYTRlOG1zYWhncnFnaHduZGdtbmI3\"\nAPI_HEADERS: dict = {\"Content-Type\": \"application/json\"}\nPUSH_TOKEN: str = getenv(\"PUSHOVER_PUSH_TOKEN\", None)\nPUSH_USER: str = getenv(\"PUSHOVER_PUSH_USER\", None)\n</code></pre>"},{"location":"reference/config/#camply.config.RIDBConfig","title":"<code>RIDBConfig</code>","text":"<p>RIDB API Configuration</p> <p>https://ridb.recreation.gov/docs</p> Source code in <code>camply/config/api_config.py</code> <pre><code>class RIDBConfig:\n\"\"\"\n    RIDB API Configuration\n    https://ridb.recreation.gov/docs\n    \"\"\"\n_camply_ridb_service_account_api_token: bytes = (\nb\"YTc0MTY0NzEtMWI1ZC00YTY0LWFkM2QtYTIzM2U3Y2I1YzQ0\"\n)\n_api_key: Union[str, bytes] = getenv(\n\"RIDB_API_KEY\", _camply_ridb_service_account_api_token\n)\nAPI_KEY = _camply_ridb_service_account_api_token if _api_key == \"\" else _api_key\nRIDB_SCHEME: str = \"https\"\nRIDB_NET_LOC: str = \"ridb.recreation.gov\"\nRIDB_BASE_PATH: str = \"api/v1/\"\n# FACILITIES_API_PATH FIELDS\nFACILITIES_API_PATH: str = \"facilities\"\nCAMPGROUND_FACILITY_FIELD_QUALIFIER: str = \"Campground\"\nTICKET_FACILITY_FIELD_QUALIFIER: str = \"Ticket Facility\"\nTIMED_ENTRY_FACILITY_FIELD_QUALIFIER: str = \"Timed Entry\"\n# RECREATION AREA FIELDS\nREC_AREA_API_PATH: str = \"recareas\"\n# CAMPSITE DETAILS\nCAMPSITE_API_PATH: str = \"campsites\"\n# TOUR DETAILS\nTOUR_API_PATH: str = \"tours\"\n</code></pre>"},{"location":"reference/config/#camply.config.RecreationBookingConfig","title":"<code>RecreationBookingConfig</code>","text":"<p>Variable Storage Class for Recreation.gov Booking API</p> Source code in <code>camply/config/api_config.py</code> <pre><code>class RecreationBookingConfig:\n\"\"\"\n    Variable Storage Class for Recreation.gov Booking API\n    \"\"\"\nAPI_SCHEME: str = \"https\"\nAPI_NET_LOC = \"www.recreation.gov\"\nAPI_BASE_PATH: str = \"api/camps/availability/campground/\"\nAPI_MONTH_PATH: str = \"month\"\nAPI_REFERRERS: Dict[str, Any] = {\"Referer\": \"https://www.recreation.gov/\"}\nCAMPSITE_UNAVAILABLE_STRINGS: list = [\n\"Reserved\",\n\"Not Available\",\n\"Not Reservable\",\n\"Not Reservable Management\",\n\"Not Available Cutoff\",\n\"Lottery\",\n\"Open\",\n\"NYR\",\n\"Closed\",\n]\nCAMPSITE_LOCATION_LOOP_DEFAULT: str = \"Default Loop\"\nCAMPSITE_LOCATION_SITE_DEFAULT: str = \"Default Site\"\nCAMPSITE_BOOKING_URL: str = \"https://www.recreation.gov/camping/campsites\"\nRATE_LIMITING = (1.01, 1.51)\n</code></pre>"},{"location":"reference/config/#camply.config.SearchConfig","title":"<code>SearchConfig</code>","text":"<p>File Path Storage Class</p> Source code in <code>camply/config/search_config.py</code> <pre><code>class SearchConfig:\n\"\"\"\n    File Path Storage Class\n    \"\"\"\nPOLLING_INTERVAL_MINIMUM: int = 5  # 5 MINUTES\nRECOMMENDED_POLLING_INTERVAL: int = 10  # 10 MINUTES\nERROR_MESSAGE: str = \"No search days configured. Exiting\"\nMINIMUM_CAMPSITES_FIRST_NOTIFY: int = 5\nMAXIMUM_NOTIFICATION_BATCH_SIZE: int = 20\n</code></pre>"},{"location":"reference/config/#camply.config.SlackConfig","title":"<code>SlackConfig</code>","text":"<p>Slack Notification Config Class</p> Source code in <code>camply/config/notification_config.py</code> <pre><code>class SlackConfig:\n\"\"\"\n    Slack Notification Config Class\n    \"\"\"\nSLACK_WEBHOOK: Optional[str] = getenv(\"SLACK_WEBHOOK\", None)\n</code></pre>"},{"location":"reference/config/#camply.config.TelegramConfig","title":"<code>TelegramConfig</code>","text":"<p>Telegram Notification Config Class</p> Source code in <code>camply/config/notification_config.py</code> <pre><code>class TelegramConfig:\n\"\"\"\n    Telegram Notification Config Class\n    \"\"\"\nBOT_TOKEN = getenv(\"TELEGRAM_BOT_TOKEN\", None)\nCHAT_ID = getenv(\"TELEGRAM_CHAT_ID\", None)\nAPI_ENDPOINT: str = f\"https://api.telegram.org/bot{BOT_TOKEN}/sendMessage\"\nAPI_HEADERS: dict = {\"Content-Type\": \"application/json\"}\nAPI_CONTENT: dict = {\n\"chat_id\": CHAT_ID,\n\"parse_mode\": \"MarkdownV2\",\n\"disable_web_page_preview\": \"true\",\n}\n</code></pre>"},{"location":"reference/config/#camply.config.TwilioConfig","title":"<code>TwilioConfig</code>","text":"<p>Twilio Notification Config Class</p> Source code in <code>camply/config/notification_config.py</code> <pre><code>class TwilioConfig:\n\"\"\"\n    Twilio Notification Config Class\n    \"\"\"\nACCOUNT_SID = getenv(\"TWILIO_ACCOUNT_SID\", None)\nAUTH_TOKEN = getenv(\"TWILIO_AUTH_TOKEN\", None)\nSOURCE_NUMBER = getenv(\"TWILIO_SOURCE_NUMBER\", None)\n# comma separated set of phone numbers\nDEST_NUMBERS = getenv(\"TWILIO_DEST_NUMBERS\", None)\n</code></pre>"},{"location":"reference/config/#camply.config.YellowstoneConfig","title":"<code>YellowstoneConfig</code>","text":"<p>         Bases: <code>DataColumns</code></p> <p>Variable Storage Class</p> Source code in <code>camply/config/yellowstone_config.py</code> <pre><code>class YellowstoneConfig(DataColumns):\n\"\"\"\n    Variable Storage Class\n    \"\"\"\nAPI_SCHEME: str = \"https\"\nAPI_BASE_ENDPOINT: str = \"webapi.xanterra.net\"\nAPI_BASE_PATH: str = \"v1/api\"\nLODGING_PATH: str = f\"/{API_BASE_PATH}/availability/hotels\"\nYELLOWSTONE_PARK_PATH: str = \"yellowstonenationalparklodges\"\nYELLOWSTONE_LODGING_PATH: str = f\"{LODGING_PATH}/{YELLOWSTONE_PARK_PATH}\"\nCAMPSITE_AVAILABILITY: str = f\"{API_BASE_PATH}/availability/rooms\"\nYELLOWSTONE_CAMPSITE_AVAILABILITY: str = (\nf\"{CAMPSITE_AVAILABILITY}/{YELLOWSTONE_PARK_PATH}\"\n)\nYELLOWSTONE_PROPERTY_INFO: str = (\nf\"{API_BASE_PATH}/property/rooms/{YELLOWSTONE_PARK_PATH}\"\n)\nAPI_REFERRERS: dict = {\n\"Host\": \"webapi.xanterra.net\",\n\"Origin\": \"https://secure.yellowstonenationalparklodges.com\",\n\"Referer\": \"https://secure.yellowstonenationalparklodges.com/\",\n}\nLODGING_CAMPGROUND_QUALIFIER: str = \":RV\"\n# JSON FILTERING\nBOOKING_AVAILABILITY: str = \"availability\"\n# DATAFRAME FILTERING\nFACILITY_ID: str = \"facility_id\"\nFACILITY_STATUS: str = \"status\"\nFACILITY_STATUS_QUALIFIER: str = \"OPEN\"\nFACILITY_ROOMS: str = \"rooms\"\nFACILITY_AVAILABLE_QUALIFIER: str = \"available\"\nFACILITY_HOTEL_CODE: str = \"hotelCode\"\nFACILITY_ROOM_CODE: str = \"roomCode\"\nFACILITY_PRICE: str = \"price\"\nFACILITY_TYPE: str = \"type\"\nCAMPSITE_DATA_COLUMNS: List[str] = [\"facility_id\", \"facility_name\", \"booking_url\"]\nRATE_CODE: str = \"INTERNET\"\nLODGING_RATES: str = \"rates\"\nLODGING_TITLE: str = \"title\"\nLODGING_BASE_PRICES: str = \"mins\"\nLODGING_OCCUPANCY_BASE: str = \"occupancyBase\"\nLODGING_OCCUPANCY_MAX: str = \"occupancyMax\"\nLODGING_ERROR_MESSAGE: str = \"message\"\nMINIMUM_POLLING_INTERVAL: int = 45\nWEBUI_ALIAS_ENDPOINT: str = \"yellowstonenationalparklodges.com\"\nWEBUI_BASE_ENDPOINT: str = \"secure.yellowstonenationalparklodges.com\"\nWEBUI_BOOKING_PATH: str = \"booking/lodging-select\"\nYELLOWSTONE_RECREATION_AREA_ID: int = 1\nYELLOWSTONE_RECREATION_AREA_NAME: str = \"Yellowstone\"\nYELLOWSTONE_RECREATION_AREA_FULL_NAME: str = \"Yellowstone National Park\"\nYELLOWSTONE_RECREATION_AREA_FORMAL_NAME: str = \"Yellowstone National Park, USA\"\nYELLOWSTONE_LOOP_NAME: str = \"N/A\"\nCAMPSITE_AVAILABILITY_STATUS: str = \"Available\"\nYELLOWSTONE_CAMPGROUND_NAME_REPLACE: Tuple[str, str] = (\n\"CG Internet Rate\",\n\"Campground\",\n)\nYELLOWSTONE_TIMEZONE: str = \"America/Denver\"\n# LODGES:  https://webapi.xanterra.net/v1/api/property/hotels/yellowstonenationalparklodges\nYELLOWSTONE_CAMPGROUNDS: Dict[str, str] = {\n\"YLYC:RV\": \"Canyon Campground\",\n\"YLYB:RV\": \"Bridge Bay Campground\",\n\"YLYG:RV\": \"Grant Campground\",\n\"YLYM:RV\": \"Madison Campground\",\n\"YLYF:RV\": \"Fishing Bridge RV Park\",\n}\nYELLOWSTONE_CAMPGROUND_OBJECTS: List[CampgroundFacility] = []\nfor key, value in YELLOWSTONE_CAMPGROUNDS.items():\nYELLOWSTONE_CAMPGROUND_OBJECTS.append(\nCampgroundFacility(\nrecreation_area_id=YELLOWSTONE_RECREATION_AREA_ID,\nrecreation_area=YELLOWSTONE_RECREATION_AREA_FORMAL_NAME,\nfacility_name=value,\nfacility_id=str(key),\n)\n)\n</code></pre>"},{"location":"reference/config/api_config/","title":"api_config","text":"<p>API Searching Configuration</p>"},{"location":"reference/config/api_config/#camply.config.api_config.RIDBConfig","title":"<code>RIDBConfig</code>","text":"<p>RIDB API Configuration</p> <p>https://ridb.recreation.gov/docs</p> Source code in <code>camply/config/api_config.py</code> <pre><code>class RIDBConfig:\n\"\"\"\n    RIDB API Configuration\n    https://ridb.recreation.gov/docs\n    \"\"\"\n_camply_ridb_service_account_api_token: bytes = (\nb\"YTc0MTY0NzEtMWI1ZC00YTY0LWFkM2QtYTIzM2U3Y2I1YzQ0\"\n)\n_api_key: Union[str, bytes] = getenv(\n\"RIDB_API_KEY\", _camply_ridb_service_account_api_token\n)\nAPI_KEY = _camply_ridb_service_account_api_token if _api_key == \"\" else _api_key\nRIDB_SCHEME: str = \"https\"\nRIDB_NET_LOC: str = \"ridb.recreation.gov\"\nRIDB_BASE_PATH: str = \"api/v1/\"\n# FACILITIES_API_PATH FIELDS\nFACILITIES_API_PATH: str = \"facilities\"\nCAMPGROUND_FACILITY_FIELD_QUALIFIER: str = \"Campground\"\nTICKET_FACILITY_FIELD_QUALIFIER: str = \"Ticket Facility\"\nTIMED_ENTRY_FACILITY_FIELD_QUALIFIER: str = \"Timed Entry\"\n# RECREATION AREA FIELDS\nREC_AREA_API_PATH: str = \"recareas\"\n# CAMPSITE DETAILS\nCAMPSITE_API_PATH: str = \"campsites\"\n# TOUR DETAILS\nTOUR_API_PATH: str = \"tours\"\n</code></pre>"},{"location":"reference/config/api_config/#camply.config.api_config.RecreationBookingConfig","title":"<code>RecreationBookingConfig</code>","text":"<p>Variable Storage Class for Recreation.gov Booking API</p> Source code in <code>camply/config/api_config.py</code> <pre><code>class RecreationBookingConfig:\n\"\"\"\n    Variable Storage Class for Recreation.gov Booking API\n    \"\"\"\nAPI_SCHEME: str = \"https\"\nAPI_NET_LOC = \"www.recreation.gov\"\nAPI_BASE_PATH: str = \"api/camps/availability/campground/\"\nAPI_MONTH_PATH: str = \"month\"\nAPI_REFERRERS: Dict[str, Any] = {\"Referer\": \"https://www.recreation.gov/\"}\nCAMPSITE_UNAVAILABLE_STRINGS: list = [\n\"Reserved\",\n\"Not Available\",\n\"Not Reservable\",\n\"Not Reservable Management\",\n\"Not Available Cutoff\",\n\"Lottery\",\n\"Open\",\n\"NYR\",\n\"Closed\",\n]\nCAMPSITE_LOCATION_LOOP_DEFAULT: str = \"Default Loop\"\nCAMPSITE_LOCATION_SITE_DEFAULT: str = \"Default Site\"\nCAMPSITE_BOOKING_URL: str = \"https://www.recreation.gov/camping/campsites\"\nRATE_LIMITING = (1.01, 1.51)\n</code></pre>"},{"location":"reference/config/api_config/#camply.config.api_config.UseDirectConfig","title":"<code>UseDirectConfig</code>","text":"<p>Reserve California API Configuration</p> Source code in <code>camply/config/api_config.py</code> <pre><code>class UseDirectConfig:\n\"\"\"\n    Reserve California API Configuration\n    \"\"\"\nRDR_PREFIX = \"rdr\"\nSEARCH_PREFIX = \"search\"\nCITYPARK_ENDPOINT = f\"{RDR_PREFIX}/fd/citypark\"\nLIST_PLACES_ENDPOINT = f\"{RDR_PREFIX}/fd/places\"\nLIST_FACILITIES_ENDPOINT = f\"{RDR_PREFIX}/fd/facilities\"\nSEARCH_ENDPOINT = f\"{CITYPARK_ENDPOINT}/namecontains\"\nMETADATA_PREFIX = f\"{RDR_PREFIX}/{SEARCH_PREFIX}/filters\"\nPLACE_ENDPOINT = f\"{RDR_PREFIX}/{SEARCH_PREFIX}/place\"\nAVAILABILITY_ENDPOINT = f\"{RDR_PREFIX}/{SEARCH_PREFIX}/grid\"\nDATE_FORMAT = \"%m-%d-%Y\"\n</code></pre>"},{"location":"reference/config/data_columns/","title":"data_columns","text":"<p>Project Configuration for Data Variable Labels</p>"},{"location":"reference/config/data_columns/#camply.config.data_columns.CampsiteContainerFields","title":"<code>CampsiteContainerFields</code>","text":"<p>String Variable Storage Class</p> Source code in <code>camply/config/data_columns.py</code> <pre><code>class CampsiteContainerFields:\n\"\"\"\n    String Variable Storage Class\n    \"\"\"\nCAMPSITE_ID: str = \"campsite_id\"\nCAMPGROUND_ID: str = \"facility_id\"\nBOOKING_DATE: str = \"booking_date\"\nCAMPSITE_GROUP: str = \"campsite_group\"\nBOOKING_END_DATE: str = \"booking_end_date\"\nBOOKING_URL: str = \"booking_url\"\nPERMITTED_EQUIPMENT: str = \"permitted_equipment\"\nCAMPSITE_ATTRIBUTES: str = \"campsite_attributes\"\n</code></pre>"},{"location":"reference/config/data_columns/#camply.config.data_columns.DataColumns","title":"<code>DataColumns</code>","text":"<p>Variable Storage Class</p> Source code in <code>camply/config/data_columns.py</code> <pre><code>class DataColumns:\n\"\"\"\n    Variable Storage Class\n    \"\"\"\nCAMPSITE_ID_COLUMN: str = \"campsite_code\"\nBOOKING_DATE_COLUMN: str = \"booking_date\"\nBOOKING_END_DATE_COLUMN: str = \"booking_end_date\"\nBOOKING_NIGHTS_COLUMN: str = \"booking_nights\"\nCAMPSITE_SITE_NAME_COLUMN: str = \"campsite_title\"\nCAMPSITE_TYPE_COLUMN: str = \"campsite_type\"\nCAMPSITE_OCCUPANCY_COLUMN: str = \"capacity\"\nCAMPSITE_USE_TYPE_COLUMN: str = \"campsite_type\"\nAVAILABILITY_STATUS_COLUMN: str = \"Available\"\nRECREATION_AREA_COLUMN: str = \"recreation_area\"\nFACILITY_NAME_COLUMN: str = \"facility_name\"\nFACILITY_ID_COLUMN: str = \"facility_id\"\nBOOKING_URL_COLUMN: str = \"booking_url\"\n</code></pre>"},{"location":"reference/config/file_config/","title":"file_config","text":"<p>Project Configuration for Yellowstone Variables</p>"},{"location":"reference/config/file_config/#camply.config.file_config.FileConfig","title":"<code>FileConfig</code>","text":"<p>File Path Storage Class</p> Source code in <code>camply/config/file_config.py</code> <pre><code>class FileConfig:\n\"\"\"\n    File Path Storage Class\n    \"\"\"\nHOME_PATH = abspath(Path.home())\nDOT_CAMPLY_FILE = join(HOME_PATH, \".camply\")\n_file_config_file = Path(abspath(__file__))\n_config_dir = _file_config_file.parent\nCAMPLY_DIRECTORY = _config_dir.parent\nROOT_DIRECTORY = CAMPLY_DIRECTORY.parent\nDOT_CAMPLY_FIELDS = OrderedDict(\nPUSHOVER_PUSH_USER={\"default\": \"\", \"notes\": \"Enables Pushover Notifications\"},\nPUSHBULLET_API_TOKEN={\n\"default\": \"\",\n\"notes\": \"Enables Pushbullet Notifications\",\n},\nSLACK_WEBHOOK={\"default\": \"\", \"notes\": \"Enables Slack Notifications\"},\nTELEGRAM_BOT_TOKEN={\"default\": \"\", \"notes\": \"Enables Telegram Notifications\"},\nTELEGRAM_CHAT_ID={\n\"default\": \"\",\n\"notes\": \"Telegram Notification will be sent here\",\n},\nTWILIO_ACCOUNT_SID={\"default\": \"\", \"notes\": \"Twilio Account SID\"},\nTWILIO_AUTH_TOKEN={\"default\": \"\", \"notes\": \"Twilio Auth Token\"},\nTWILIO_SOURCE_NUMBER={\n\"default\": \"\",\n\"notes\": \"Twilio Source number. E.164 format\",\n},\nTWILIO_DEST_NUMBERS={\n\"default\": \"\",\n\"notes\": \"Comma-separated list of phone numbers.\",\n},\nEMAIL_TO_ADDRESS={\n\"default\": \"\",\n\"notes\": \"Email Notifications will be sent here\",\n},\nEMAIL_USERNAME={\"default\": \"\", \"notes\": \"Email Authorization Login Username\"},\nEMAIL_PASSWORD={\"default\": \"\", \"notes\": \"Email Authorization Login Password\"},\nEMAIL_SMTP_SERVER={\n\"default\": \"smtp.gmail.com\",\n\"notes\": \"Email Authorization SMTP Server Address\",\n},\nEMAIL_SMTP_PORT={\n\"default\": 465,\n\"notes\": \"Email Authorization SMTP Server Port\",\n},\nEMAIL_FROM_ADDRESS={\n\"default\": \"camply@juftin.com\",\n\"notes\": \"Email Notifications Will Come From this Email\",\n},\nEMAIL_SUBJECT_LINE={\n\"default\": \"Camply Notification\",\n\"notes\": \"Email Notifications Will Have This Subject Line\",\n},\nPUSHOVER_PUSH_TOKEN={\n\"default\": \"\",\n\"notes\": \"Pushover Notifications From Your Custom App \" \"(not required)\",\n},\nNTFY_TOPIC={\n\"default\": \"\",\n\"notes\": \"NTFY Notification Topic\",\n},\nAPPRISE_URL={\"default\": \"\", \"notes\": \"Apprise notification URL\"},\nRIDB_API_KEY={\n\"default\": \"\",\n\"notes\": \"Personal Recreation.gov API Key (not required)\",\n},\n)\nPROVIDERS_DIRECTORY = CAMPLY_DIRECTORY.joinpath(\"providers\")\nRESERVE_CALIFORNIA_PROVIDER = PROVIDERS_DIRECTORY.joinpath(\"reserve_california\")\nUSEDIRECT_PROVIDER = PROVIDERS_DIRECTORY.joinpath(\"usedirect\")\n</code></pre>"},{"location":"reference/config/logging_config/","title":"logging_config","text":"<p>Dynamic Logging Configuration</p>"},{"location":"reference/config/logging_config/#camply.config.logging_config.get_log_handler","title":"<code>get_log_handler(log_level=None)</code>","text":"<p>Determine which logging handler should be used</p> <p>Parameters:</p> Name Type Description Default <code>log_level</code> <code>Optional[int]</code> <p>Which logging level should be used. If none is provided the LOG_LEVEL environment variable will be used, defaulting to \"INFO\".</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[logging.Handler, Union[int, str]]</code> Source code in <code>camply/config/logging_config.py</code> <pre><code>def get_log_handler(\nlog_level: Optional[int] = None,\n) -&gt; Tuple[logging.Handler, Union[int, str]]:\n\"\"\"\n    Determine which logging handler should be used\n    Parameters\n    ----------\n    log_level: Optional[int]\n        Which logging level should be used. If none is provided the LOG_LEVEL environment\n        variable will be used, defaulting to \"INFO\".\n    Returns\n    -------\n    Tuple[logging.Handler, Union[int, str]]\n    \"\"\"\nif log_level is None:\nlog_level = logging.getLevelName(getenv(\"LOG_LEVEL\", \"INFO\").upper())\nrich_handler = RichHandler(\nlevel=log_level,\nrich_tracebacks=True,\nomit_repeated_times=False,\nshow_path=False,\n)\npython_handler = logging.StreamHandler()\npython_formatter = logging.Formatter(\"%(asctime)s [%(levelname)8s]: %(message)s\")\npython_handler.setFormatter(python_formatter)\npython_handler.setLevel(log_level)\n_log_dict = {\n\"rich\": rich_handler,\n\"python\": python_handler,\n}\nif getenv(\"PYTEST_CURRENT_TEST\", None) is not None:\nhandler = \"python\"\nelse:\nhandler = LOG_HANDLER\nlog_handler: logging.Handler = _log_dict.get(handler, rich_handler)\nreturn log_handler, log_level\n</code></pre>"},{"location":"reference/config/logging_config/#camply.config.logging_config.set_up_logging","title":"<code>set_up_logging(log_level=None)</code>","text":"<p>Set Up a Root Logger</p> <p>Parameters:</p> Name Type Description Default <code>log_level</code> <code>Optional[int]</code> <p>Which logging level should be used. If none is provided the LOG_LEVEL environment variable will be used, defaulting to \"INFO\".</p> <code>None</code> Source code in <code>camply/config/logging_config.py</code> <pre><code>def set_up_logging(log_level: Optional[int] = None) -&gt; None:\n\"\"\"\n    Set Up a Root Logger\n    Parameters\n    ----------\n    log_level: Optional[int]\n        Which logging level should be used. If none is provided the LOG_LEVEL environment\n        variable will be used, defaulting to \"INFO\".\n    \"\"\"\nlog_handler, level_to_log = get_log_handler(log_level=log_level)\nlogging.root.handlers = [log_handler]\nif isinstance(log_handler, RichHandler):\nrich_formatter = logging.Formatter(\ndatefmt=\"[%Y-%m-%d %H:%M:%S]\", fmt=\"%(message)s\"\n)\nlogging.root.handlers[0].setFormatter(rich_formatter)\nlevel_to_log = logging.NOTSET\nlogging.root.setLevel(level_to_log)\n</code></pre>"},{"location":"reference/config/notification_config/","title":"notification_config","text":"<p>Project Configuration for Pushover Variables</p>"},{"location":"reference/config/notification_config/#camply.config.notification_config.AppriseConfig","title":"<code>AppriseConfig</code>","text":"<p>Apprise Notification Config Class</p> Source code in <code>camply/config/notification_config.py</code> <pre><code>class AppriseConfig:\n\"\"\"\n    Apprise Notification Config Class\n    \"\"\"\nAPPRISE_URL: str = getenv(\"APPRISE_URL\", None)\n</code></pre>"},{"location":"reference/config/notification_config/#camply.config.notification_config.EmailConfig","title":"<code>EmailConfig</code>","text":"<p>Email Notification Config Class</p> Source code in <code>camply/config/notification_config.py</code> <pre><code>class EmailConfig:\n\"\"\"\n    Email Notification Config Class\n    \"\"\"\nEMAIL_TO_ADDRESS: Optional[str] = getenv(\"EMAIL_TO_ADDRESS\", None)\nDEFAULT_FROM_ADDRESS: str = \"camply@juftin.com\"\nEMAIL_FROM_ADDRESS: str = getenv(\"EMAIL_FROM_ADDRESS\", DEFAULT_FROM_ADDRESS)\nDEFAULT_SUBJECT_LINE: str = \"Camply Notification\"\nEMAIL_SUBJECT_LINE: str = getenv(\"EMAIL_SUBJECT_LINE\", DEFAULT_SUBJECT_LINE)\nDEFAULT_SMTP_SERVER: str = \"smtp.gmail.com\"\nEMAIL_SMTP_SERVER: str = getenv(\"EMAIL_SMTP_SERVER\", DEFAULT_SMTP_SERVER)\nEMAIL_USERNAME: Optional[str] = getenv(\"EMAIL_USERNAME\", None)\nEMAIL_PASSWORD: Optional[str] = getenv(\"EMAIL_PASSWORD\", None)\nDEFAULT_SMTP_PORT: int = 465\nEMAIL_SMTP_PORT: int = int(getenv(\"EMAIL_SMTP_PORT\", DEFAULT_SMTP_PORT))\nENVIRONMENT_VARIABLE_NAMES: List[str] = [\n\"EMAIL_TO_ADDRESS\",\n\"EMAIL_USERNAME\",\n\"EMAIL_PASSWORD\",\n]\nOPTIONAL_ENVIRONMENT_VARIABLE: List[str] = [\nf\"EMAIL_SMTP_SERVER (default: {DEFAULT_SMTP_SERVER})\",\nf\"EMAIL_FROM_ADDRESS (default: {DEFAULT_FROM_ADDRESS})\",\nf'EMAIL_SUBJECT_LINE (default: \"{DEFAULT_SUBJECT_LINE}\")',\nf\"EMAIL_SMTP_PORT (default: {DEFAULT_SMTP_PORT})\",\n]\n</code></pre>"},{"location":"reference/config/notification_config/#camply.config.notification_config.NtfyConfig","title":"<code>NtfyConfig</code>","text":"<p>Ntfy Notification Config Class</p> Source code in <code>camply/config/notification_config.py</code> <pre><code>class NtfyConfig:\n\"\"\"\n    Ntfy Notification Config Class\n    \"\"\"\nNTFY_API_ENDPOINT: str = \"https://ntfy.sh/\"\nNTFY_TOPIC = getenv(\"NTFY_TOPIC\", None)\n</code></pre>"},{"location":"reference/config/notification_config/#camply.config.notification_config.PushbulletConfig","title":"<code>PushbulletConfig</code>","text":"<p>Pushbullet Notification Config Class</p> Source code in <code>camply/config/notification_config.py</code> <pre><code>class PushbulletConfig:\n\"\"\"\n    Pushbullet Notification Config Class\n    \"\"\"\nPUSHBULLET_API_ENDPOINT: str = \"https://api.pushbullet.com/v2/pushes\"\nAPI_HEADERS: dict = {\"Content-Type\": \"application/json\"}\nAPI_TOKEN = getenv(\"PUSHBULLET_API_TOKEN\", None)\n</code></pre>"},{"location":"reference/config/notification_config/#camply.config.notification_config.PushoverConfig","title":"<code>PushoverConfig</code>","text":"<p>Pushover Notification Config Class</p> Source code in <code>camply/config/notification_config.py</code> <pre><code>class PushoverConfig:\n\"\"\"\n    Pushover Notification Config Class\n    \"\"\"\nPUSHOVER_API_ENDPOINT: str = \"https://api.pushover.net/1/messages.json\"\nPUSHOVER_DEFAULT_API_TOKEN: bytes = b\"YWpjN3M1a2hhYTRlOG1zYWhncnFnaHduZGdtbmI3\"\nAPI_HEADERS: dict = {\"Content-Type\": \"application/json\"}\nPUSH_TOKEN: str = getenv(\"PUSHOVER_PUSH_TOKEN\", None)\nPUSH_USER: str = getenv(\"PUSHOVER_PUSH_USER\", None)\n</code></pre>"},{"location":"reference/config/notification_config/#camply.config.notification_config.SlackConfig","title":"<code>SlackConfig</code>","text":"<p>Slack Notification Config Class</p> Source code in <code>camply/config/notification_config.py</code> <pre><code>class SlackConfig:\n\"\"\"\n    Slack Notification Config Class\n    \"\"\"\nSLACK_WEBHOOK: Optional[str] = getenv(\"SLACK_WEBHOOK\", None)\n</code></pre>"},{"location":"reference/config/notification_config/#camply.config.notification_config.TelegramConfig","title":"<code>TelegramConfig</code>","text":"<p>Telegram Notification Config Class</p> Source code in <code>camply/config/notification_config.py</code> <pre><code>class TelegramConfig:\n\"\"\"\n    Telegram Notification Config Class\n    \"\"\"\nBOT_TOKEN = getenv(\"TELEGRAM_BOT_TOKEN\", None)\nCHAT_ID = getenv(\"TELEGRAM_CHAT_ID\", None)\nAPI_ENDPOINT: str = f\"https://api.telegram.org/bot{BOT_TOKEN}/sendMessage\"\nAPI_HEADERS: dict = {\"Content-Type\": \"application/json\"}\nAPI_CONTENT: dict = {\n\"chat_id\": CHAT_ID,\n\"parse_mode\": \"MarkdownV2\",\n\"disable_web_page_preview\": \"true\",\n}\n</code></pre>"},{"location":"reference/config/notification_config/#camply.config.notification_config.TwilioConfig","title":"<code>TwilioConfig</code>","text":"<p>Twilio Notification Config Class</p> Source code in <code>camply/config/notification_config.py</code> <pre><code>class TwilioConfig:\n\"\"\"\n    Twilio Notification Config Class\n    \"\"\"\nACCOUNT_SID = getenv(\"TWILIO_ACCOUNT_SID\", None)\nAUTH_TOKEN = getenv(\"TWILIO_AUTH_TOKEN\", None)\nSOURCE_NUMBER = getenv(\"TWILIO_SOURCE_NUMBER\", None)\n# comma separated set of phone numbers\nDEST_NUMBERS = getenv(\"TWILIO_DEST_NUMBERS\", None)\n</code></pre>"},{"location":"reference/config/search_config/","title":"search_config","text":"<p>Project Configuration for Yellowstone Variables</p>"},{"location":"reference/config/search_config/#camply.config.search_config.EquipmentConfig","title":"<code>EquipmentConfig</code>","text":"<p>Campsite Equipment Configuration</p> Source code in <code>camply/config/search_config.py</code> <pre><code>class EquipmentConfig:\n\"\"\"\n    Campsite Equipment Configuration\n    \"\"\"\nEQUIPMENT_MAPPING = OrderedDict()\nEQUIPMENT_MAPPING[EquipmentOptions.tent] = [\n\"Tent\",\n\"Large Tent Over 9X12\",\nr\"Large Tent Over 9X12`\",\n\"Small Tent\",\n]\nEQUIPMENT_MAPPING[EquipmentOptions.rv] = [\n\"RV\",\n\"Pop up\",\n\"Caravan/Camper Van\",\n\"RV/Motorhome\",\n\"Fifth Wheel\",\n]\nEQUIPMENT_MAPPING[EquipmentOptions.trailer] = [\"Trailer\"]\nEQUIPMENT_MAPPING[EquipmentOptions.vehicle] = [\n\"Pickup Camper\",\n\"Vehicle\",\n\"Car\",\n]\nEQUIPMENT_MAPPING[EquipmentOptions.other] = [\"Hammock\", \"Horse\", \"Boat\", \"\"]\nEQUIPMENT_REVERSE_MAPPING: Dict[str, str] = {}\nfor key, list_of_values in EQUIPMENT_MAPPING.items():\nfor value in list_of_values:\nEQUIPMENT_REVERSE_MAPPING[value] = key\nTIMESTAMP_EQUIPMENT = []\nfor hour in range(0, 24):\nhour_str = str(hour).zfill(2)\nfor minute in range(0, 60):\nminute_str = str(minute).zfill(2)\nTIMESTAMP_EQUIPMENT.append(hour_str + minute_str)\n</code></pre>"},{"location":"reference/config/search_config/#camply.config.search_config.EquipmentOptions","title":"<code>EquipmentOptions</code>","text":"<p>         Bases: <code>str</code>, <code>Enum</code></p> <p>Enumeration of the Equipment Options</p> Source code in <code>camply/config/search_config.py</code> <pre><code>class EquipmentOptions(str, Enum):\n\"\"\"\n    Enumeration of the Equipment Options\n    \"\"\"\ntent = \"tent\"\nrv = \"rv\"\ntrailer = \"trailer\"\nvehicle = \"vehicle\"\nother = \"other\"\n__all_accepted_equipment__ = [tent, rv, trailer, vehicle]\n</code></pre>"},{"location":"reference/config/search_config/#camply.config.search_config.SearchConfig","title":"<code>SearchConfig</code>","text":"<p>File Path Storage Class</p> Source code in <code>camply/config/search_config.py</code> <pre><code>class SearchConfig:\n\"\"\"\n    File Path Storage Class\n    \"\"\"\nPOLLING_INTERVAL_MINIMUM: int = 5  # 5 MINUTES\nRECOMMENDED_POLLING_INTERVAL: int = 10  # 10 MINUTES\nERROR_MESSAGE: str = \"No search days configured. Exiting\"\nMINIMUM_CAMPSITES_FIRST_NOTIFY: int = 5\nMAXIMUM_NOTIFICATION_BATCH_SIZE: int = 20\n</code></pre>"},{"location":"reference/config/yellowstone_config/","title":"yellowstone_config","text":"<p>Project Configuration for Yellowstone Variables</p>"},{"location":"reference/config/yellowstone_config/#camply.config.yellowstone_config.YellowstoneConfig","title":"<code>YellowstoneConfig</code>","text":"<p>         Bases: <code>DataColumns</code></p> <p>Variable Storage Class</p> Source code in <code>camply/config/yellowstone_config.py</code> <pre><code>class YellowstoneConfig(DataColumns):\n\"\"\"\n    Variable Storage Class\n    \"\"\"\nAPI_SCHEME: str = \"https\"\nAPI_BASE_ENDPOINT: str = \"webapi.xanterra.net\"\nAPI_BASE_PATH: str = \"v1/api\"\nLODGING_PATH: str = f\"/{API_BASE_PATH}/availability/hotels\"\nYELLOWSTONE_PARK_PATH: str = \"yellowstonenationalparklodges\"\nYELLOWSTONE_LODGING_PATH: str = f\"{LODGING_PATH}/{YELLOWSTONE_PARK_PATH}\"\nCAMPSITE_AVAILABILITY: str = f\"{API_BASE_PATH}/availability/rooms\"\nYELLOWSTONE_CAMPSITE_AVAILABILITY: str = (\nf\"{CAMPSITE_AVAILABILITY}/{YELLOWSTONE_PARK_PATH}\"\n)\nYELLOWSTONE_PROPERTY_INFO: str = (\nf\"{API_BASE_PATH}/property/rooms/{YELLOWSTONE_PARK_PATH}\"\n)\nAPI_REFERRERS: dict = {\n\"Host\": \"webapi.xanterra.net\",\n\"Origin\": \"https://secure.yellowstonenationalparklodges.com\",\n\"Referer\": \"https://secure.yellowstonenationalparklodges.com/\",\n}\nLODGING_CAMPGROUND_QUALIFIER: str = \":RV\"\n# JSON FILTERING\nBOOKING_AVAILABILITY: str = \"availability\"\n# DATAFRAME FILTERING\nFACILITY_ID: str = \"facility_id\"\nFACILITY_STATUS: str = \"status\"\nFACILITY_STATUS_QUALIFIER: str = \"OPEN\"\nFACILITY_ROOMS: str = \"rooms\"\nFACILITY_AVAILABLE_QUALIFIER: str = \"available\"\nFACILITY_HOTEL_CODE: str = \"hotelCode\"\nFACILITY_ROOM_CODE: str = \"roomCode\"\nFACILITY_PRICE: str = \"price\"\nFACILITY_TYPE: str = \"type\"\nCAMPSITE_DATA_COLUMNS: List[str] = [\"facility_id\", \"facility_name\", \"booking_url\"]\nRATE_CODE: str = \"INTERNET\"\nLODGING_RATES: str = \"rates\"\nLODGING_TITLE: str = \"title\"\nLODGING_BASE_PRICES: str = \"mins\"\nLODGING_OCCUPANCY_BASE: str = \"occupancyBase\"\nLODGING_OCCUPANCY_MAX: str = \"occupancyMax\"\nLODGING_ERROR_MESSAGE: str = \"message\"\nMINIMUM_POLLING_INTERVAL: int = 45\nWEBUI_ALIAS_ENDPOINT: str = \"yellowstonenationalparklodges.com\"\nWEBUI_BASE_ENDPOINT: str = \"secure.yellowstonenationalparklodges.com\"\nWEBUI_BOOKING_PATH: str = \"booking/lodging-select\"\nYELLOWSTONE_RECREATION_AREA_ID: int = 1\nYELLOWSTONE_RECREATION_AREA_NAME: str = \"Yellowstone\"\nYELLOWSTONE_RECREATION_AREA_FULL_NAME: str = \"Yellowstone National Park\"\nYELLOWSTONE_RECREATION_AREA_FORMAL_NAME: str = \"Yellowstone National Park, USA\"\nYELLOWSTONE_LOOP_NAME: str = \"N/A\"\nCAMPSITE_AVAILABILITY_STATUS: str = \"Available\"\nYELLOWSTONE_CAMPGROUND_NAME_REPLACE: Tuple[str, str] = (\n\"CG Internet Rate\",\n\"Campground\",\n)\nYELLOWSTONE_TIMEZONE: str = \"America/Denver\"\n# LODGES:  https://webapi.xanterra.net/v1/api/property/hotels/yellowstonenationalparklodges\nYELLOWSTONE_CAMPGROUNDS: Dict[str, str] = {\n\"YLYC:RV\": \"Canyon Campground\",\n\"YLYB:RV\": \"Bridge Bay Campground\",\n\"YLYG:RV\": \"Grant Campground\",\n\"YLYM:RV\": \"Madison Campground\",\n\"YLYF:RV\": \"Fishing Bridge RV Park\",\n}\nYELLOWSTONE_CAMPGROUND_OBJECTS: List[CampgroundFacility] = []\nfor key, value in YELLOWSTONE_CAMPGROUNDS.items():\nYELLOWSTONE_CAMPGROUND_OBJECTS.append(\nCampgroundFacility(\nrecreation_area_id=YELLOWSTONE_RECREATION_AREA_ID,\nrecreation_area=YELLOWSTONE_RECREATION_AREA_FORMAL_NAME,\nfacility_name=value,\nfacility_id=str(key),\n)\n)\n</code></pre>"},{"location":"reference/containers/","title":"containers","text":"<p>camply Data Storage Objects</p>"},{"location":"reference/containers/#camply.containers.AvailableCampsite","title":"<code>AvailableCampsite</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>Campsite Storage</p> <p>This container should be universal regardless of API Provider</p> Source code in <code>camply/containers/data_containers.py</code> <pre><code>class AvailableCampsite(CamplyModel):\n\"\"\"\n    Campsite Storage\n    This container should be universal regardless of API Provider\n    \"\"\"\ncampsite_id: Union[int, str]\nbooking_date: datetime.datetime\nbooking_end_date: datetime.datetime\nbooking_nights: int\ncampsite_site_name: str\ncampsite_loop_name: Optional[str]\ncampsite_type: Optional[str]\ncampsite_occupancy: Tuple[int, int]\ncampsite_use_type: Optional[str]\navailability_status: str\nrecreation_area: str\nrecreation_area_id: Union[int, str]\nfacility_name: str\nfacility_id: Union[int, str]\nbooking_url: str\npermitted_equipment: Optional[List[RecDotGovEquipment]]\ncampsite_attributes: Optional[List[RecDotGovAttribute]]\n__unhashable__ = {\"permitted_equipment\", \"campsite_attributes\"}\n</code></pre>"},{"location":"reference/containers/#camply.containers.AvailableResource","title":"<code>AvailableResource</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>A resource that is available for booking</p> Source code in <code>camply/containers/data_containers.py</code> <pre><code>class AvailableResource(CamplyModel):\n\"\"\"\n    A resource that is available for booking\n    \"\"\"\nresource_id: int\nmap_id: int\n</code></pre>"},{"location":"reference/containers/#camply.containers.CampgroundFacility","title":"<code>CampgroundFacility</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>Campground Facility Data Storage</p> Source code in <code>camply/containers/data_containers.py</code> <pre><code>class CampgroundFacility(CamplyModel):\n\"\"\"\n    Campground Facility Data Storage\n    \"\"\"\nfacility_name: str\nrecreation_area: str\nfacility_id: Union[int, str]\nrecreation_area_id: Union[int, str]\nmap_id: Optional[int]\ncoordinates: Optional[Tuple[float, float]]\n</code></pre>"},{"location":"reference/containers/#camply.containers.CamplyModel","title":"<code>CamplyModel</code>","text":"<p>         Bases: <code>BaseModel</code></p> <p>Hashable Pydantic Model</p> Source code in <code>camply/containers/base_container.py</code> <pre><code>class CamplyModel(BaseModel):\n\"\"\"\n    Hashable Pydantic Model\n    \"\"\"\n__unhashable__: Set[str] = set()\ndef __hash__(self):\n\"\"\"\n        Hash Method for Pydantic BaseModels\n        \"\"\"\nreturn hash(self.__class__) + hash(\ntuple(\nvalue\nfor key, value in self.__dict__.items()\nif key not in self.__unhashable__\n)\n)\ndef __eq__(self, other: Any) -&gt; bool:\n\"\"\"\n        Exclude Unhashable Fields When Evaluating Equality\n        \"\"\"\nif isinstance(other, CamplyModel):\nreturn self.dict(exclude=self.__unhashable__) == other.dict(\nexclude=other.__unhashable__\n)\nelse:\nreturn self.dict(exclude=self.__unhashable__) == other\nclass Config:\n\"\"\"\n        Camply Wide Configuration\n        \"\"\"\nanystr_strip_whitespace = True\n</code></pre>"},{"location":"reference/containers/#camply.containers.base_container.CamplyModel.Config","title":"<code>Config</code>","text":"<p>Camply Wide Configuration</p> Source code in <code>camply/containers/base_container.py</code> <pre><code>class Config:\n\"\"\"\n    Camply Wide Configuration\n    \"\"\"\nanystr_strip_whitespace = True\n</code></pre>"},{"location":"reference/containers/#camply.containers.base_container.CamplyModel.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Exclude Unhashable Fields When Evaluating Equality</p> Source code in <code>camply/containers/base_container.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n\"\"\"\n    Exclude Unhashable Fields When Evaluating Equality\n    \"\"\"\nif isinstance(other, CamplyModel):\nreturn self.dict(exclude=self.__unhashable__) == other.dict(\nexclude=other.__unhashable__\n)\nelse:\nreturn self.dict(exclude=self.__unhashable__) == other\n</code></pre>"},{"location":"reference/containers/#camply.containers.base_container.CamplyModel.__hash__","title":"<code>__hash__()</code>","text":"<p>Hash Method for Pydantic BaseModels</p> Source code in <code>camply/containers/base_container.py</code> <pre><code>def __hash__(self):\n\"\"\"\n    Hash Method for Pydantic BaseModels\n    \"\"\"\nreturn hash(self.__class__) + hash(\ntuple(\nvalue\nfor key, value in self.__dict__.items()\nif key not in self.__unhashable__\n)\n)\n</code></pre>"},{"location":"reference/containers/#camply.containers.RecreationArea","title":"<code>RecreationArea</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>Recreation Area Data Storage</p> Source code in <code>camply/containers/data_containers.py</code> <pre><code>class RecreationArea(CamplyModel):\n\"\"\"\n    Recreation Area Data Storage\n    \"\"\"\nrecreation_area: str\nrecreation_area_id: Union[int, str]\nrecreation_area_location: str\ncoordinates: Optional[Tuple[float, float]]\ndescription: Optional[str]\n</code></pre>"},{"location":"reference/containers/#camply.containers.SearchWindow","title":"<code>SearchWindow</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>Search Window for Campsite Search</p> Source code in <code>camply/containers/data_containers.py</code> <pre><code>class SearchWindow(CamplyModel):\n\"\"\"\n    Search Window for Campsite Search\n    \"\"\"\n@validator(\"start_date\")\n@classmethod\ndef start_date_must_be_in_future(cls, v):\n\"\"\"\n        Validate that start_date is in the future.\n        Coerece start date to today's date when it is not in the future.\n        \"\"\"\ncurrent_date = datetime.datetime.now().date()\nif v &lt; current_date:\nreturn current_date\nreturn v\n@validator(\"end_date\")\n@classmethod\ndef end_date_must_be_in_future(cls, v):\n\"\"\"\n        Validate that end_date is in the future\n        \"\"\"\ncurrent_date = datetime.datetime.now().date()\nif v &lt; current_date:\nraise ValueError(\"must be in the future\")\nreturn v\nstart_date: datetime.date\nend_date: datetime.date\ndef get_date_range(self) -&gt; List[datetime.date]:\n\"\"\"\n        Generate a List of Dates Between two Dates\n        Returns\n        -------\n        List[datetime.date]\n        \"\"\"\nreturn [\nself.start_date + datetime.timedelta(days=x)\nfor x in range((self.end_date - self.start_date).days)\n]\ndef get_current_start_date(self) -&gt; datetime.date:\n\"\"\"\n        Return a start date with the current day in mind\n        \"\"\"\nreturn max((datetime.datetime.now().date(), self.start_date))\n</code></pre>"},{"location":"reference/containers/#camply.containers.data_containers.SearchWindow.end_date_must_be_in_future","title":"<code>end_date_must_be_in_future(v)</code>  <code>classmethod</code>","text":"<p>Validate that end_date is in the future</p> Source code in <code>camply/containers/data_containers.py</code> <pre><code>@validator(\"end_date\")\n@classmethod\ndef end_date_must_be_in_future(cls, v):\n\"\"\"\n    Validate that end_date is in the future\n    \"\"\"\ncurrent_date = datetime.datetime.now().date()\nif v &lt; current_date:\nraise ValueError(\"must be in the future\")\nreturn v\n</code></pre>"},{"location":"reference/containers/#camply.containers.data_containers.SearchWindow.get_current_start_date","title":"<code>get_current_start_date()</code>","text":"<p>Return a start date with the current day in mind</p> Source code in <code>camply/containers/data_containers.py</code> <pre><code>def get_current_start_date(self) -&gt; datetime.date:\n\"\"\"\n    Return a start date with the current day in mind\n    \"\"\"\nreturn max((datetime.datetime.now().date(), self.start_date))\n</code></pre>"},{"location":"reference/containers/#camply.containers.data_containers.SearchWindow.get_date_range","title":"<code>get_date_range()</code>","text":"<p>Generate a List of Dates Between two Dates</p> <p>Returns:</p> Type Description <code>List[datetime.date]</code> Source code in <code>camply/containers/data_containers.py</code> <pre><code>def get_date_range(self) -&gt; List[datetime.date]:\n\"\"\"\n    Generate a List of Dates Between two Dates\n    Returns\n    -------\n    List[datetime.date]\n    \"\"\"\nreturn [\nself.start_date + datetime.timedelta(days=x)\nfor x in range((self.end_date - self.start_date).days)\n]\n</code></pre>"},{"location":"reference/containers/#camply.containers.data_containers.SearchWindow.start_date_must_be_in_future","title":"<code>start_date_must_be_in_future(v)</code>  <code>classmethod</code>","text":"<p>Validate that start_date is in the future.</p> <p>Coerece start date to today's date when it is not in the future.</p> Source code in <code>camply/containers/data_containers.py</code> <pre><code>@validator(\"start_date\")\n@classmethod\ndef start_date_must_be_in_future(cls, v):\n\"\"\"\n    Validate that start_date is in the future.\n    Coerece start date to today's date when it is not in the future.\n    \"\"\"\ncurrent_date = datetime.datetime.now().date()\nif v &lt; current_date:\nreturn current_date\nreturn v\n</code></pre>"},{"location":"reference/containers/api_responses/","title":"api_responses","text":"<p>API Response Objects</p> <p>These are JSON Responses from APIs</p>"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.AwareDatetime","title":"<code>AwareDatetime</code>","text":"<p>         Bases: <code>datetime.datetime</code></p> <p>Datetime Aware Timestamp Parsing</p> Source code in <code>camply/containers/api_responses.py</code> <pre><code>class AwareDatetime(datetime.datetime):\n\"\"\"\n    Datetime Aware Timestamp Parsing\n    \"\"\"\n@classmethod\ndef __get_validators__(cls) -&gt; Iterator:\n\"\"\"\n        Generate Validators\n        \"\"\"\nyield cls.validate\n@classmethod\ndef validate(cls, v: Union[str, datetime.datetime]) -&gt; datetime.datetime:\n\"\"\"\n        Validate Date Strings Into\n        Parameters\n        ----------\n        v: Union[str, datetime.datetime]\n        Returns\n        -------\n        datetime.datetime\n        \"\"\"\nif isinstance(v, str):\nreturn datetime.datetime.strptime(v, \"%Y-%m-%dT%H:%M:%S%z\")\nelif isinstance(v, datetime.datetime):\nif v.tzinfo is None:\nraise ValueError(\n\"You Must Provide a Parsable Datetime Object with tzinfo\"\n)\nreturn v\nelse:\nraise ValueError(\"You Must Provide a Parsable Datetime String or Object\")\n</code></pre>"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.AwareDatetime.__get_validators__","title":"<code>__get_validators__()</code>  <code>classmethod</code>","text":"<p>Generate Validators</p> Source code in <code>camply/containers/api_responses.py</code> <pre><code>@classmethod\ndef __get_validators__(cls) -&gt; Iterator:\n\"\"\"\n    Generate Validators\n    \"\"\"\nyield cls.validate\n</code></pre>"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.AwareDatetime.validate","title":"<code>validate(v)</code>  <code>classmethod</code>","text":"<p>Validate Date Strings Into</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>Union[str, datetime.datetime]</code> required <p>Returns:</p> Type Description <code>datetime.datetime</code> Source code in <code>camply/containers/api_responses.py</code> <pre><code>@classmethod\ndef validate(cls, v: Union[str, datetime.datetime]) -&gt; datetime.datetime:\n\"\"\"\n    Validate Date Strings Into\n    Parameters\n    ----------\n    v: Union[str, datetime.datetime]\n    Returns\n    -------\n    datetime.datetime\n    \"\"\"\nif isinstance(v, str):\nreturn datetime.datetime.strptime(v, \"%Y-%m-%dT%H:%M:%S%z\")\nelif isinstance(v, datetime.datetime):\nif v.tzinfo is None:\nraise ValueError(\n\"You Must Provide a Parsable Datetime Object with tzinfo\"\n)\nreturn v\nelse:\nraise ValueError(\"You Must Provide a Parsable Datetime String or Object\")\n</code></pre>"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.CampsiteAvailabilityResponse","title":"<code>CampsiteAvailabilityResponse</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>https://ridb.recreation.gov/api/v1/campsites/ Source code in <code>camply/containers/api_responses.py</code> <pre><code>class CampsiteAvailabilityResponse(CamplyModel):\n\"\"\"\n    https://ridb.recreation.gov/api/v1/campsites/&lt;CAMPSITE ID&gt;\n    \"\"\"\ncampsites: Dict[int, _CampsiteAvailabilityCampsiteResponse]\n</code></pre>"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.CampsiteResponse","title":"<code>CampsiteResponse</code>","text":"<p>         Bases: <code>CoreRecDotGovResponse</code></p> <p>https://ridb.recreation.gov/api/v1/campsites/ Source code in <code>camply/containers/api_responses.py</code> <pre><code>class CampsiteResponse(CoreRecDotGovResponse):\n\"\"\"\n    https://ridb.recreation.gov/api/v1/campsites/&lt;CAMPSITE ID&gt;\n    \"\"\"\nCampsiteID: int\nFacilityID: int\nCampsiteName: str\nCampsiteType: str\nTypeOfUse: str\nLoop: str\nCampsiteAccessible: bool\nCampsiteReservable: bool\nCampsiteLongitude: float\nCampsiteLatitude: float\nCreatedDate: datetime.date\nLastUpdatedDate: datetime.date\nPERMITTEDEQUIPMENT: List[_CampsiteEquipment]\nATTRIBUTES: List[_CampsiteAttribute]\ndef __str__(self) -&gt; str:\n\"\"\"\n        String Representation\n        \"\"\"\nreturn f\"{self.CampsiteName} (#{self.CampsiteID})\"\n</code></pre>"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.CampsiteResponse.__str__","title":"<code>__str__()</code>","text":"<p>String Representation</p> Source code in <code>camply/containers/api_responses.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"\n    String Representation\n    \"\"\"\nreturn f\"{self.CampsiteName} (#{self.CampsiteID})\"\n</code></pre>"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.CoreRecDotGovResponse","title":"<code>CoreRecDotGovResponse</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>Core Response from Recreation.gov</p> Source code in <code>camply/containers/api_responses.py</code> <pre><code>class CoreRecDotGovResponse(CamplyModel):\n\"\"\"\n    Core Response from Recreation.gov\n    \"\"\"\n</code></pre>"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.Date","title":"<code>Date</code>","text":"<p>         Bases: <code>datetime.date</code></p> <p>Date Parsing</p> Source code in <code>camply/containers/api_responses.py</code> <pre><code>class Date(datetime.date):\n\"\"\"\n    Date Parsing\n    \"\"\"\n@classmethod\ndef __get_validators__(cls) -&gt; Iterator:\n\"\"\"\n        Generate Validators\n        \"\"\"\nyield cls.validate\n@classmethod\ndef validate(cls, v: Union[str, datetime.date]) -&gt; datetime.date:\n\"\"\"\n        Validate Date Strings Into\n        Parameters\n        ----------\n        v: Union[str, datetime.date]\n        Returns\n        -------\n        datetime.date\n        \"\"\"\nif isinstance(v, str):\nreturn datetime.datetime.strptime(v, \"%Y-%m-%d\").date()\nelif isinstance(v, datetime.date):\nreturn v\nelse:\nraise ValueError(\"You Must Provide a Parsable Date String or Object\")\n</code></pre>"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.Date.__get_validators__","title":"<code>__get_validators__()</code>  <code>classmethod</code>","text":"<p>Generate Validators</p> Source code in <code>camply/containers/api_responses.py</code> <pre><code>@classmethod\ndef __get_validators__(cls) -&gt; Iterator:\n\"\"\"\n    Generate Validators\n    \"\"\"\nyield cls.validate\n</code></pre>"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.Date.validate","title":"<code>validate(v)</code>  <code>classmethod</code>","text":"<p>Validate Date Strings Into</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>Union[str, datetime.date]</code> required <p>Returns:</p> Type Description <code>datetime.date</code> Source code in <code>camply/containers/api_responses.py</code> <pre><code>@classmethod\ndef validate(cls, v: Union[str, datetime.date]) -&gt; datetime.date:\n\"\"\"\n    Validate Date Strings Into\n    Parameters\n    ----------\n    v: Union[str, datetime.date]\n    Returns\n    -------\n    datetime.date\n    \"\"\"\nif isinstance(v, str):\nreturn datetime.datetime.strptime(v, \"%Y-%m-%d\").date()\nelif isinstance(v, datetime.date):\nreturn v\nelse:\nraise ValueError(\"You Must Provide a Parsable Date String or Object\")\n</code></pre>"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.FacilityResponse","title":"<code>FacilityResponse</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>/api/v1/facilities/ Source code in <code>camply/containers/api_responses.py</code> <pre><code>class FacilityResponse(CamplyModel):\n\"\"\"\n    /api/v1/facilities/&lt;Facility ID&gt;\n    \"\"\"\nFacilityID: Union[int, str]\nFacilityName: str\nFacilityTypeDescription: str\nEnabled: bool\nReservable: bool\nFACILITYADDRESS: Optional[List[_FacilityAddress]]\nRECAREA: Optional[List[_FacilityRecArea]]\nORGANIZATION: Optional[List[_FacilityOrganization]]\nParentRecAreaID: Optional[Union[int, str]]\n@validator(\"ParentRecAreaID\", pre=True, always=False)\ndef validate_parentrecid(cls, val: Any) -&gt; Optional[int]:\n\"\"\"\n        Validate Empty Strings as Null\n        \"\"\"\nif val == \"\":\nreturn None\nreturn val\n</code></pre>"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.FacilityResponse.validate_parentrecid","title":"<code>validate_parentrecid(val)</code>","text":"<p>Validate Empty Strings as Null</p> Source code in <code>camply/containers/api_responses.py</code> <pre><code>@validator(\"ParentRecAreaID\", pre=True, always=False)\ndef validate_parentrecid(cls, val: Any) -&gt; Optional[int]:\n\"\"\"\n    Validate Empty Strings as Null\n    \"\"\"\nif val == \"\":\nreturn None\nreturn val\n</code></pre>"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.GenericResponse","title":"<code>GenericResponse</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>Generic Response to Be Paginated</p> Source code in <code>camply/containers/api_responses.py</code> <pre><code>class GenericResponse(CamplyModel):\n\"\"\"\n    Generic Response to Be Paginated\n    \"\"\"\nRECDATA: Any\nMETADATA: _PaginationMetadataResponse\n</code></pre>"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.RecDotGovCampsite","title":"<code>RecDotGovCampsite</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>Recreation.gov Campsite Object</p> Source code in <code>camply/containers/api_responses.py</code> <pre><code>class RecDotGovCampsite(CamplyModel):\n\"\"\"\n    Recreation.gov Campsite Object\n    \"\"\"\naccessible: bool\nasset_id: int\nasset_type = str\nattributes: List[RecDotGovAttribute]\naverage_rating: Optional[int]\ncampsite_id: int\ncampsite_reserve_type: str\ncity: Optional[str]\ncountry_code: Optional[str]\nfee_templates: Dict[str, Any]\nlatitude: Optional[float]\nlongitude: Optional[float]\nloop: str\nname: str\nnumber_of_ratings = int\norg_id: int\norg_name: str\nparent_asset_id: int\nparent_asset_name: str\nparent_asset_type: str\npermitted_equipment: List[RecDotGovEquipment]\npreview_image_url: Optional[str]\nreservable: bool\nstate_code: Optional[str]\ntype: str\ntype_of_use: str\n</code></pre>"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.RecDotGovCampsiteResponse","title":"<code>RecDotGovCampsiteResponse</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>Parent Response from Campsite Metadata</p> Source code in <code>camply/containers/api_responses.py</code> <pre><code>class RecDotGovCampsiteResponse(CamplyModel):\n\"\"\"\n    Parent Response from Campsite Metadata\n    \"\"\"\ncampsites: List[RecDotGovCampsite]\nsize: int\nspelling_autocorrected: Any\nstart: int\ntotal: int\n</code></pre>"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.RecDotGovSearchResponse","title":"<code>RecDotGovSearchResponse</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>Parent Response from Search Results</p> Source code in <code>camply/containers/api_responses.py</code> <pre><code>class RecDotGovSearchResponse(CamplyModel):\n\"\"\"\n    Parent Response from Search Results\n    \"\"\"\nresults: List[RecDotGovSearchResult]\nsize: int\nspelling_autocorrected: Any\nstart: int\ntotal: int\n</code></pre>"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.RecDotGovSearchResult","title":"<code>RecDotGovSearchResult</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>Recreation.gov Search Result Object</p> Source code in <code>camply/containers/api_responses.py</code> <pre><code>class RecDotGovSearchResult(CamplyModel):\n\"\"\"\n    Recreation.gov Search Result Object\n    \"\"\"\naverage_rating: Optional[int]\ndescription: str\nentity_id: int\nentity_type: str\nlatitude: Optional[float]\nlongitude: Optional[float]\nname: str\nnumber_of_ratings = int\norg_id: int\nparent_id: int\nparent_name: str\nparent_type: str\npreview_image_url: Optional[str]\nreservable: bool\ntime_zone: str\ntype: str\n</code></pre>"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.RecreationAreaResponse","title":"<code>RecreationAreaResponse</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>https://ridb.recreation.gov/api/v1/campsites/ Source code in <code>camply/containers/api_responses.py</code> <pre><code>class RecreationAreaResponse(CamplyModel):\n\"\"\"\n    https://ridb.recreation.gov/api/v1/campsites/&lt;CAMPSITE ID&gt;\n    \"\"\"\nRecAreaID: Union[int, str]\nRecAreaName: str\nRECAREAADDRESS: List[_RecAreaAddress]\n</code></pre>"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.TourDailyAvailabilityBookingWindow","title":"<code>TourDailyAvailabilityBookingWindow</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>https://ridb.recreation.gov/api/v1/tours/ Source code in <code>camply/containers/api_responses.py</code> <pre><code>class TourDailyAvailabilityBookingWindow(CamplyModel):\n\"\"\"\n    https://ridb.recreation.gov/api/v1/tours/&lt;CAMPSITE ID&gt;\n    \"\"\"\nopen_timestamp: AwareDatetime\nclose_timestamp: AwareDatetime\n</code></pre>"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.TourDailyAvailabilityBookingWindows","title":"<code>TourDailyAvailabilityBookingWindows</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>https://ridb.recreation.gov/api/v1/tours/ Source code in <code>camply/containers/api_responses.py</code> <pre><code>class TourDailyAvailabilityBookingWindows(CamplyModel):\n\"\"\"\n    https://ridb.recreation.gov/api/v1/tours/&lt;CAMPSITE ID&gt;\n    \"\"\"\nPRIMARY: Optional[TourDailyAvailabilityBookingWindow]\nSECONDARY: Optional[TourDailyAvailabilityBookingWindow]\n</code></pre>"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.TourDailyAvailabilityResponse","title":"<code>TourDailyAvailabilityResponse</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>https://ridb.recreation.gov/api/v1/tours/ Source code in <code>camply/containers/api_responses.py</code> <pre><code>class TourDailyAvailabilityResponse(CamplyModel):\n\"\"\"\n    https://ridb.recreation.gov/api/v1/tours/&lt;CAMPSITE ID&gt;\n    \"\"\"\nfacility_id: int\nbooking_windows: TourDailyAvailabilityBookingWindows\ninventory_count: Dict[str, int]\nreservation_count: Dict[str, int]\nstatus: str\ntour_date: Date\ntour_id: int\ntour_time: str\n</code></pre>"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.TourMonthlyAvailabilityResponse","title":"<code>TourMonthlyAvailabilityResponse</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>https://ridb.recreation.gov/api/v1/tours/ Source code in <code>camply/containers/api_responses.py</code> <pre><code>class TourMonthlyAvailabilityResponse(CamplyModel):\n\"\"\"\n    https://ridb.recreation.gov/api/v1/tours/&lt;CAMPSITE ID&gt;\n    \"\"\"\nfacility_availability_summary_view_by_local_date: Dict[\nDate, _TourMonthlyAvailabilityDateResponse\n]\n</code></pre>"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.TourResponse","title":"<code>TourResponse</code>","text":"<p>         Bases: <code>CoreRecDotGovResponse</code></p> <p>https://ridb.recreation.gov/api/v1/tours/ Source code in <code>camply/containers/api_responses.py</code> <pre><code>class TourResponse(CoreRecDotGovResponse):\n\"\"\"\n    https://ridb.recreation.gov/api/v1/tours/&lt;TOUR ID&gt;\n    \"\"\"\nTourID: int\nFacilityID: int\nTourName: str\nTourType: str\nTourDuration: int\nTourDescription: str\nTourAccessible: bool\nCreatedDate: datetime.date\nLastUpdatedDate: datetime.date\nATTRIBUTES: List[_CampsiteAttribute]\ndef __str__(self) -&gt; str:\n\"\"\"\n        String Representation\n        \"\"\"\nreturn f\"{self.TourName} (#{self.TourID})\"\n</code></pre>"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.TourResponse.__str__","title":"<code>__str__()</code>","text":"<p>String Representation</p> Source code in <code>camply/containers/api_responses.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"\n    String Representation\n    \"\"\"\nreturn f\"{self.TourName} (#{self.TourID})\"\n</code></pre>"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.UnawareDatetime","title":"<code>UnawareDatetime</code>","text":"<p>         Bases: <code>datetime.datetime</code></p> <p>Datetime Unaware Timestamp Parsing</p> Source code in <code>camply/containers/api_responses.py</code> <pre><code>class UnawareDatetime(datetime.datetime):\n\"\"\"\n    Datetime Unaware Timestamp Parsing\n    \"\"\"\n@classmethod\ndef __get_validators__(cls) -&gt; Iterator:\n\"\"\"\n        Generate Validators\n        \"\"\"\nyield cls.validate\n@classmethod\ndef validate(cls, v: Union[str, datetime.datetime]) -&gt; datetime.datetime:\n\"\"\"\n        Validate Date Strings Into\n        Parameters\n        ----------\n        v: Union[str, datetime.datetime]\n        Returns\n        -------\n        datetime.datetime\n        \"\"\"\nif isinstance(v, str):\nreturn datetime.datetime.strptime(v, \"%Y-%m-%dT%H:%M:%SZ\")\nelif isinstance(v, datetime.datetime):\nreturn v.replace(tzinfo=None)\nelse:\nraise ValueError(\"You Must Provide a Parsable Datetime String or Object\")\n</code></pre>"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.UnawareDatetime.__get_validators__","title":"<code>__get_validators__()</code>  <code>classmethod</code>","text":"<p>Generate Validators</p> Source code in <code>camply/containers/api_responses.py</code> <pre><code>@classmethod\ndef __get_validators__(cls) -&gt; Iterator:\n\"\"\"\n    Generate Validators\n    \"\"\"\nyield cls.validate\n</code></pre>"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.UnawareDatetime.validate","title":"<code>validate(v)</code>  <code>classmethod</code>","text":"<p>Validate Date Strings Into</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>Union[str, datetime.datetime]</code> required <p>Returns:</p> Type Description <code>datetime.datetime</code> Source code in <code>camply/containers/api_responses.py</code> <pre><code>@classmethod\ndef validate(cls, v: Union[str, datetime.datetime]) -&gt; datetime.datetime:\n\"\"\"\n    Validate Date Strings Into\n    Parameters\n    ----------\n    v: Union[str, datetime.datetime]\n    Returns\n    -------\n    datetime.datetime\n    \"\"\"\nif isinstance(v, str):\nreturn datetime.datetime.strptime(v, \"%Y-%m-%dT%H:%M:%SZ\")\nelif isinstance(v, datetime.datetime):\nreturn v.replace(tzinfo=None)\nelse:\nraise ValueError(\"You Must Provide a Parsable Datetime String or Object\")\n</code></pre>"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.XantCampgroundDetails","title":"<code>XantCampgroundDetails</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>Yellowstone Campground Details OBject</p> Source code in <code>camply/containers/api_responses.py</code> <pre><code>class XantCampgroundDetails(CamplyModel):\n\"\"\"\n    Yellowstone Campground Details OBject\n    \"\"\"\nhotelCode: str\nstatus: str\nmessage: str\nmin: str\nmax: str\nperGuests: Dict[int, XantPerGuest]\nrates: Dict[str, XantRates]\nrates2: Optional[Dict[str, XantRates]]\n</code></pre>"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.XantPerGuest","title":"<code>XantPerGuest</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>PerGuest Objects</p> Source code in <code>camply/containers/api_responses.py</code> <pre><code>class XantPerGuest(CamplyModel):\n\"\"\"\n    PerGuest Objects\n    \"\"\"\na2: Optional[Union[int, str]]\nb: Optional[Union[int, str]]\nb2: Optional[Union[int, str]]\nm: Optional[Union[int, str]]\nm2: Optional[Union[int, str]]\nr: Optional[Union[int, str]]\nr2: Optional[Union[int, str]]\ns: Optional[Union[int, str]]\n</code></pre>"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.XantRates","title":"<code>XantRates</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>Yellowstone Rates Object</p> Source code in <code>camply/containers/api_responses.py</code> <pre><code>class XantRates(CamplyModel):\n\"\"\"\n    Yellowstone Rates Object\n    \"\"\"\ncode: str\ntitle: str\ndescription: str\ncategory: str\nminstay: int\nstart: datetime.date\navailable: Dict[int, int]\nmins: Dict[int, int]\nmin: int\n@validator(\"start\", pre=True)\ndef parse_datetime(cls, value):\n\"\"\"\n        Parse Poorly Formatted Date Strings\n        \"\"\"\nreturn datetime.datetime.strptime(value, \"%m/%d/%Y\").date()\n</code></pre>"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.XantRates.parse_datetime","title":"<code>parse_datetime(value)</code>","text":"<p>Parse Poorly Formatted Date Strings</p> Source code in <code>camply/containers/api_responses.py</code> <pre><code>@validator(\"start\", pre=True)\ndef parse_datetime(cls, value):\n\"\"\"\n    Parse Poorly Formatted Date Strings\n    \"\"\"\nreturn datetime.datetime.strptime(value, \"%m/%d/%Y\").date()\n</code></pre>"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.XantResortData","title":"<code>XantResortData</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>Main Yellowstone API Response Wrapper</p> Source code in <code>camply/containers/api_responses.py</code> <pre><code>class XantResortData(CamplyModel):\n\"\"\"\n    Main Yellowstone API Response Wrapper\n    \"\"\"\navailability: Dict[datetime.date, Dict[str, XantCampgroundDetails]]\n@validator(\"availability\", pre=True)\ndef parse_datetime(cls, value):\n\"\"\"\n        Parse Poorly Formatted Date Strings\n        \"\"\"\nreturn {\ndatetime.datetime.strptime(x, \"%m/%d/%Y\").date(): y\nfor x, y in value.items()\n}\n</code></pre>"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.XantResortData.parse_datetime","title":"<code>parse_datetime(value)</code>","text":"<p>Parse Poorly Formatted Date Strings</p> Source code in <code>camply/containers/api_responses.py</code> <pre><code>@validator(\"availability\", pre=True)\ndef parse_datetime(cls, value):\n\"\"\"\n    Parse Poorly Formatted Date Strings\n    \"\"\"\nreturn {\ndatetime.datetime.strptime(x, \"%m/%d/%Y\").date(): y\nfor x, y in value.items()\n}\n</code></pre>"},{"location":"reference/containers/base_container/","title":"base_container","text":"<p>Base Pydantic Object for Containers</p>"},{"location":"reference/containers/base_container/#camply.containers.base_container.CamplyModel","title":"<code>CamplyModel</code>","text":"<p>         Bases: <code>BaseModel</code></p> <p>Hashable Pydantic Model</p> Source code in <code>camply/containers/base_container.py</code> <pre><code>class CamplyModel(BaseModel):\n\"\"\"\n    Hashable Pydantic Model\n    \"\"\"\n__unhashable__: Set[str] = set()\ndef __hash__(self):\n\"\"\"\n        Hash Method for Pydantic BaseModels\n        \"\"\"\nreturn hash(self.__class__) + hash(\ntuple(\nvalue\nfor key, value in self.__dict__.items()\nif key not in self.__unhashable__\n)\n)\ndef __eq__(self, other: Any) -&gt; bool:\n\"\"\"\n        Exclude Unhashable Fields When Evaluating Equality\n        \"\"\"\nif isinstance(other, CamplyModel):\nreturn self.dict(exclude=self.__unhashable__) == other.dict(\nexclude=other.__unhashable__\n)\nelse:\nreturn self.dict(exclude=self.__unhashable__) == other\nclass Config:\n\"\"\"\n        Camply Wide Configuration\n        \"\"\"\nanystr_strip_whitespace = True\n</code></pre>"},{"location":"reference/containers/base_container/#camply.containers.base_container.CamplyModel.Config","title":"<code>Config</code>","text":"<p>Camply Wide Configuration</p> Source code in <code>camply/containers/base_container.py</code> <pre><code>class Config:\n\"\"\"\n    Camply Wide Configuration\n    \"\"\"\nanystr_strip_whitespace = True\n</code></pre>"},{"location":"reference/containers/base_container/#camply.containers.base_container.CamplyModel.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Exclude Unhashable Fields When Evaluating Equality</p> Source code in <code>camply/containers/base_container.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n\"\"\"\n    Exclude Unhashable Fields When Evaluating Equality\n    \"\"\"\nif isinstance(other, CamplyModel):\nreturn self.dict(exclude=self.__unhashable__) == other.dict(\nexclude=other.__unhashable__\n)\nelse:\nreturn self.dict(exclude=self.__unhashable__) == other\n</code></pre>"},{"location":"reference/containers/base_container/#camply.containers.base_container.CamplyModel.__hash__","title":"<code>__hash__()</code>","text":"<p>Hash Method for Pydantic BaseModels</p> Source code in <code>camply/containers/base_container.py</code> <pre><code>def __hash__(self):\n\"\"\"\n    Hash Method for Pydantic BaseModels\n    \"\"\"\nreturn hash(self.__class__) + hash(\ntuple(\nvalue\nfor key, value in self.__dict__.items()\nif key not in self.__unhashable__\n)\n)\n</code></pre>"},{"location":"reference/containers/base_container/#camply.containers.base_container.GoingToCampEquipment","title":"<code>GoingToCampEquipment</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>Model of GoingToCamp provider equipment</p> Source code in <code>camply/containers/base_container.py</code> <pre><code>class GoingToCampEquipment(CamplyModel):\n\"\"\"\n    Model of GoingToCamp provider equipment\n    \"\"\"\nequipment_name: str\nequipment_type_id: int\n</code></pre>"},{"location":"reference/containers/base_container/#camply.containers.base_container.RecDotGovAttribute","title":"<code>RecDotGovAttribute</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>Attribute Object on the Recreation.gov Campsite</p> Source code in <code>camply/containers/base_container.py</code> <pre><code>class RecDotGovAttribute(CamplyModel):\n\"\"\"\n    Attribute Object on the Recreation.gov Campsite\n    \"\"\"\nattribute_category: str\nattribute_id: int\nattribute_name: str\nattribute_value: Any\n</code></pre>"},{"location":"reference/containers/base_container/#camply.containers.base_container.RecDotGovEquipment","title":"<code>RecDotGovEquipment</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>Equipment Object on the Recreation.gov Campsite</p> Source code in <code>camply/containers/base_container.py</code> <pre><code>class RecDotGovEquipment(CamplyModel):\n\"\"\"\n    Equipment Object on the Recreation.gov Campsite\n    \"\"\"\nequipment_name: str\nmax_length: float\n</code></pre>"},{"location":"reference/containers/data_containers/","title":"data_containers","text":"<p>Storage Containers for the Application</p>"},{"location":"reference/containers/data_containers/#camply.containers.data_containers.AvailableCampsite","title":"<code>AvailableCampsite</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>Campsite Storage</p> <p>This container should be universal regardless of API Provider</p> Source code in <code>camply/containers/data_containers.py</code> <pre><code>class AvailableCampsite(CamplyModel):\n\"\"\"\n    Campsite Storage\n    This container should be universal regardless of API Provider\n    \"\"\"\ncampsite_id: Union[int, str]\nbooking_date: datetime.datetime\nbooking_end_date: datetime.datetime\nbooking_nights: int\ncampsite_site_name: str\ncampsite_loop_name: Optional[str]\ncampsite_type: Optional[str]\ncampsite_occupancy: Tuple[int, int]\ncampsite_use_type: Optional[str]\navailability_status: str\nrecreation_area: str\nrecreation_area_id: Union[int, str]\nfacility_name: str\nfacility_id: Union[int, str]\nbooking_url: str\npermitted_equipment: Optional[List[RecDotGovEquipment]]\ncampsite_attributes: Optional[List[RecDotGovAttribute]]\n__unhashable__ = {\"permitted_equipment\", \"campsite_attributes\"}\n</code></pre>"},{"location":"reference/containers/data_containers/#camply.containers.data_containers.AvailableResource","title":"<code>AvailableResource</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>A resource that is available for booking</p> Source code in <code>camply/containers/data_containers.py</code> <pre><code>class AvailableResource(CamplyModel):\n\"\"\"\n    A resource that is available for booking\n    \"\"\"\nresource_id: int\nmap_id: int\n</code></pre>"},{"location":"reference/containers/data_containers/#camply.containers.data_containers.CampgroundFacility","title":"<code>CampgroundFacility</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>Campground Facility Data Storage</p> Source code in <code>camply/containers/data_containers.py</code> <pre><code>class CampgroundFacility(CamplyModel):\n\"\"\"\n    Campground Facility Data Storage\n    \"\"\"\nfacility_name: str\nrecreation_area: str\nfacility_id: Union[int, str]\nrecreation_area_id: Union[int, str]\nmap_id: Optional[int]\ncoordinates: Optional[Tuple[float, float]]\n</code></pre>"},{"location":"reference/containers/data_containers/#camply.containers.data_containers.ListedCampsite","title":"<code>ListedCampsite</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>A Campsite Meant to Be Listed</p> Source code in <code>camply/containers/data_containers.py</code> <pre><code>class ListedCampsite(CamplyModel):\n\"\"\"\n    A Campsite Meant to Be Listed\n    \"\"\"\nname: str\nid: int\nfacility_id: int\n</code></pre>"},{"location":"reference/containers/data_containers/#camply.containers.data_containers.RecreationArea","title":"<code>RecreationArea</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>Recreation Area Data Storage</p> Source code in <code>camply/containers/data_containers.py</code> <pre><code>class RecreationArea(CamplyModel):\n\"\"\"\n    Recreation Area Data Storage\n    \"\"\"\nrecreation_area: str\nrecreation_area_id: Union[int, str]\nrecreation_area_location: str\ncoordinates: Optional[Tuple[float, float]]\ndescription: Optional[str]\n</code></pre>"},{"location":"reference/containers/data_containers/#camply.containers.data_containers.SearchWindow","title":"<code>SearchWindow</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>Search Window for Campsite Search</p> Source code in <code>camply/containers/data_containers.py</code> <pre><code>class SearchWindow(CamplyModel):\n\"\"\"\n    Search Window for Campsite Search\n    \"\"\"\n@validator(\"start_date\")\n@classmethod\ndef start_date_must_be_in_future(cls, v):\n\"\"\"\n        Validate that start_date is in the future.\n        Coerece start date to today's date when it is not in the future.\n        \"\"\"\ncurrent_date = datetime.datetime.now().date()\nif v &lt; current_date:\nreturn current_date\nreturn v\n@validator(\"end_date\")\n@classmethod\ndef end_date_must_be_in_future(cls, v):\n\"\"\"\n        Validate that end_date is in the future\n        \"\"\"\ncurrent_date = datetime.datetime.now().date()\nif v &lt; current_date:\nraise ValueError(\"must be in the future\")\nreturn v\nstart_date: datetime.date\nend_date: datetime.date\ndef get_date_range(self) -&gt; List[datetime.date]:\n\"\"\"\n        Generate a List of Dates Between two Dates\n        Returns\n        -------\n        List[datetime.date]\n        \"\"\"\nreturn [\nself.start_date + datetime.timedelta(days=x)\nfor x in range((self.end_date - self.start_date).days)\n]\ndef get_current_start_date(self) -&gt; datetime.date:\n\"\"\"\n        Return a start date with the current day in mind\n        \"\"\"\nreturn max((datetime.datetime.now().date(), self.start_date))\n</code></pre>"},{"location":"reference/containers/data_containers/#camply.containers.data_containers.SearchWindow.end_date_must_be_in_future","title":"<code>end_date_must_be_in_future(v)</code>  <code>classmethod</code>","text":"<p>Validate that end_date is in the future</p> Source code in <code>camply/containers/data_containers.py</code> <pre><code>@validator(\"end_date\")\n@classmethod\ndef end_date_must_be_in_future(cls, v):\n\"\"\"\n    Validate that end_date is in the future\n    \"\"\"\ncurrent_date = datetime.datetime.now().date()\nif v &lt; current_date:\nraise ValueError(\"must be in the future\")\nreturn v\n</code></pre>"},{"location":"reference/containers/data_containers/#camply.containers.data_containers.SearchWindow.get_current_start_date","title":"<code>get_current_start_date()</code>","text":"<p>Return a start date with the current day in mind</p> Source code in <code>camply/containers/data_containers.py</code> <pre><code>def get_current_start_date(self) -&gt; datetime.date:\n\"\"\"\n    Return a start date with the current day in mind\n    \"\"\"\nreturn max((datetime.datetime.now().date(), self.start_date))\n</code></pre>"},{"location":"reference/containers/data_containers/#camply.containers.data_containers.SearchWindow.get_date_range","title":"<code>get_date_range()</code>","text":"<p>Generate a List of Dates Between two Dates</p> <p>Returns:</p> Type Description <code>List[datetime.date]</code> Source code in <code>camply/containers/data_containers.py</code> <pre><code>def get_date_range(self) -&gt; List[datetime.date]:\n\"\"\"\n    Generate a List of Dates Between two Dates\n    Returns\n    -------\n    List[datetime.date]\n    \"\"\"\nreturn [\nself.start_date + datetime.timedelta(days=x)\nfor x in range((self.end_date - self.start_date).days)\n]\n</code></pre>"},{"location":"reference/containers/data_containers/#camply.containers.data_containers.SearchWindow.start_date_must_be_in_future","title":"<code>start_date_must_be_in_future(v)</code>  <code>classmethod</code>","text":"<p>Validate that start_date is in the future.</p> <p>Coerece start date to today's date when it is not in the future.</p> Source code in <code>camply/containers/data_containers.py</code> <pre><code>@validator(\"start_date\")\n@classmethod\ndef start_date_must_be_in_future(cls, v):\n\"\"\"\n    Validate that start_date is in the future.\n    Coerece start date to today's date when it is not in the future.\n    \"\"\"\ncurrent_date = datetime.datetime.now().date()\nif v &lt; current_date:\nreturn current_date\nreturn v\n</code></pre>"},{"location":"reference/containers/examples/","title":"examples","text":"<p>Example Containers</p>"},{"location":"reference/containers/gtc_api_responses/","title":"gtc_api_responses","text":"<p>GoingToCamp provider containers</p>"},{"location":"reference/containers/gtc_api_responses/#camply.containers.gtc_api_responses.ResourceLocation","title":"<code>ResourceLocation</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>/api/maps</p> Source code in <code>camply/containers/gtc_api_responses.py</code> <pre><code>class ResourceLocation(CamplyModel):\n\"\"\"\n    /api/maps\n    \"\"\"\nid: Optional[int]\nrec_area_id: int\npark_alerts: Optional[str]\nresource_categories: Optional[List[int]]\nresource_location_id: Optional[int]\nresource_location_name: str\nregion_name: str\n</code></pre>"},{"location":"reference/containers/search_model/","title":"search_model","text":"<p>Pydantic model for YAML files</p>"},{"location":"reference/containers/search_model/#camply.containers.search_model.StrEnum","title":"<code>StrEnum</code>","text":"<p>         Bases: <code>str</code>, <code>Enum</code></p> <p>String Enum</p> Source code in <code>camply/containers/search_model.py</code> <pre><code>class StrEnum(str, Enum):\n\"\"\"\n    String Enum\n    \"\"\"\n</code></pre>"},{"location":"reference/containers/search_model/#camply.containers.search_model.YamlSearchFile","title":"<code>YamlSearchFile</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>Campsite Search Data Model</p> Source code in <code>camply/containers/search_model.py</code> <pre><code>class YamlSearchFile(CamplyModel):\n\"\"\"\n    Campsite Search Data Model\n    \"\"\"\nprovider: ProviderEnum = Field(\ndescription=\"Campsite provider\", default=\"RecreationDotGov\"\n)\nrecreation_area: ArrayOrSingle = None\ncampgrounds: ArrayOrSingle = None\ncampsites: ArrayOrSingle = None\nstart_date: Union[datetime.date, List[datetime.date]]\nend_date: Union[datetime.date, List[datetime.date]]\ndays: Optional[List[str]] = None\nweekends: bool = False\nnights: int = 1\ncontinuous: bool = True\npolling_interval: int = SearchConfig.RECOMMENDED_POLLING_INTERVAL\nnotifications: ArrayOrSingleStr = \"silent\"\nsearch_forever: bool = False\nsearch_once: bool = False\nnotify_first_try: bool = False\nequipment: ArrayOrSingleEquipment = None\noffline_search: bool = False\noffline_search_path: Optional[str] = None\n@validator(\"provider\", pre=True)\ndef validate_provider(cls, value):\n\"\"\"\n        Validate provider\n        \"\"\"\nlowercase_enum_dict = {\nkey.lower(): key for key in ProviderEnum.__members__.keys()\n}\nif value.lower() in lowercase_enum_dict.keys():\nreturn lowercase_enum_dict[value.lower()]\nelse:\nreturn value\n@validator(\"equipment\", pre=True)\ndef validate_equipment(cls, value) -&gt; ArrayOrSingleEquipment:\n\"\"\"\n        Validate equipment\n        \"\"\"\nequipment_tuple_length = 2\nif (\nisinstance(value, list)\nand len(value) == equipment_tuple_length\nand isinstance(value[0], str)\n):\nreturn [tuple(value)]\nelse:\nreturn value\n</code></pre>"},{"location":"reference/containers/search_model/#camply.containers.search_model.YamlSearchFile.validate_equipment","title":"<code>validate_equipment(value)</code>","text":"<p>Validate equipment</p> Source code in <code>camply/containers/search_model.py</code> <pre><code>@validator(\"equipment\", pre=True)\ndef validate_equipment(cls, value) -&gt; ArrayOrSingleEquipment:\n\"\"\"\n    Validate equipment\n    \"\"\"\nequipment_tuple_length = 2\nif (\nisinstance(value, list)\nand len(value) == equipment_tuple_length\nand isinstance(value[0], str)\n):\nreturn [tuple(value)]\nelse:\nreturn value\n</code></pre>"},{"location":"reference/containers/search_model/#camply.containers.search_model.YamlSearchFile.validate_provider","title":"<code>validate_provider(value)</code>","text":"<p>Validate provider</p> Source code in <code>camply/containers/search_model.py</code> <pre><code>@validator(\"provider\", pre=True)\ndef validate_provider(cls, value):\n\"\"\"\n    Validate provider\n    \"\"\"\nlowercase_enum_dict = {\nkey.lower(): key for key in ProviderEnum.__members__.keys()\n}\nif value.lower() in lowercase_enum_dict.keys():\nreturn lowercase_enum_dict[value.lower()]\nelse:\nreturn value\n</code></pre>"},{"location":"reference/containers/usedirect/","title":"usedirect","text":"<p>UseDirect API Responses</p>"},{"location":"reference/containers/usedirect/#camply.containers.usedirect.UseDirectAmenity","title":"<code>UseDirectAmenity</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>UseDirect: Amenities</p> Source code in <code>camply/containers/usedirect.py</code> <pre><code>class UseDirectAmenity(CamplyModel):\n\"\"\"\n    UseDirect: Amenities\n    \"\"\"\nAmenityId: int\nName: str\nShortName: str\nAmenityType: Optional[str]\nIsSearchable: Optional[bool]\nDescription: Optional[str]\nOrderBy: Optional[int]\nIDate: Optional[datetime.datetime]\nUDate: Optional[datetime.datetime]\nImagePath: Optional[str]\nUCashierName: Optional[str]\nUStoreId: Optional[int]\nIsADA: Optional[bool]\nValue: Optional[Any]\n</code></pre>"},{"location":"reference/containers/usedirect/#camply.containers.usedirect.UseDirectAvailabilityFacility","title":"<code>UseDirectAvailabilityFacility</code>","text":"<p>         Bases: <code>UseDirectFacility</code></p> <p>UseDirect: Facility w/ Availability</p> Source code in <code>camply/containers/usedirect.py</code> <pre><code>class UseDirectAvailabilityFacility(UseDirectFacility):\n\"\"\"\n    UseDirect: Facility w/ Availability\n    \"\"\"\nFacilityMapSize: Optional[bool]\nFacilityImage: Optional[str]\nFacilityImageVBT: Optional[str]\nDatesInSeason: Optional[int]\nDatesOutOfSeason: Optional[int]\nSeasonDates: Optional[Dict[datetime.datetime, bool]] = {}\nTrafficStatuses: Optional[Dict[str, Any]] = {}\nUnitCount: Optional[int]\nAvailableUnitCount: Optional[int]\nSliceCount: Optional[int]\nAvailableSliceCount: Optional[int]\nTimebaseMaxHours: Optional[int]\nTimebaseMinHours: Optional[int]\nTimebaseDuration: Optional[float]\nIsReservationDraw: Optional[bool]\nDrawBookingStartDate: Optional[datetime.datetime]\nDrawBookingEndDate: Optional[datetime.datetime]\nUnits: Optional[Dict[str, UseDirectAvailabilityUnit]]\n</code></pre>"},{"location":"reference/containers/usedirect/#camply.containers.usedirect.UseDirectAvailabilityResponse","title":"<code>UseDirectAvailabilityResponse</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>API Response from /rdr/rdr/search/grid</p> Source code in <code>camply/containers/usedirect.py</code> <pre><code>class UseDirectAvailabilityResponse(CamplyModel):\n\"\"\"\n    API Response from /rdr/rdr/search/grid\n    \"\"\"\nMessage: str\nFilters: Optional[Dict[str, Any]] = {}\nUnitTypeId: int\nStartDate: Optional[datetime.date]\nEndDate: Optional[datetime.date]\nNightsRequested: Optional[int]\nNightsActual: Optional[int]\nTodayDate: Optional[datetime.date]\nTimeZone: Optional[str]\nTimeStamp: Optional[datetime.datetime]\nMinDate: Optional[datetime.date]\nMaxDate: Optional[datetime.date]\nAvailableUnitsOnly: Optional[bool]\nUnitSort: Optional[str]\nTimeGrid: Optional[bool]\nForUnit: Optional[bool]\nUnitId: Optional[int]\nTimeBetween: Optional[str]\nTimeBetweenEval: Optional[str]\nFacility: Optional[UseDirectAvailabilityFacility]\n</code></pre>"},{"location":"reference/containers/usedirect/#camply.containers.usedirect.UseDirectAvailabilitySlice","title":"<code>UseDirectAvailabilitySlice</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>Slice of Availability per Date</p> Source code in <code>camply/containers/usedirect.py</code> <pre><code>class UseDirectAvailabilitySlice(CamplyModel):\n\"\"\"\n    Slice of Availability per Date\n    \"\"\"\nDate: datetime.date\nIsFree: bool\nIsBlocked: Optional[bool]\nIsWalkin: Optional[bool]\nReservationId: Optional[int]\nLock: Any\nMinStay: Optional[int]\nIsReservationDraw: Optional[bool]\n</code></pre>"},{"location":"reference/containers/usedirect/#camply.containers.usedirect.UseDirectAvailabilityUnit","title":"<code>UseDirectAvailabilityUnit</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>Unit of Availability in Availability Request</p> Source code in <code>camply/containers/usedirect.py</code> <pre><code>class UseDirectAvailabilityUnit(CamplyModel):\n\"\"\"\n    Unit of Availability in Availability Request\n    \"\"\"\nUnitId: Optional[int]\nName: Optional[str]\nShortName: Optional[str]\nRecentPopups: Optional[int]\nIsAda: Optional[bool]\nAllowWebBooking: Optional[bool]\nMapInfo: Optional[Dict[str, Any]] = {}\nIsWebViewable: Optional[bool]\nIsFiltered: Optional[bool]\nUnitCategoryId: Optional[int]\nSleepingUnitIds: Optional[List[int]]\nUnitTypeGroupId: Optional[int]\nUnitTypeId: Optional[int]\nUseType: Optional[int]\nVehicleLength: Optional[int]\nOrderBy: Optional[int]\nOrderByRaw: Optional[int]\nSliceCount: Optional[int]\nAvailableCount: Optional[int]\nSlices: Optional[Dict[datetime.datetime, UseDirectAvailabilitySlice]] = {}\nStartTime: Any\nEndTime: Any\nFacilityId: Optional[int]\n</code></pre>"},{"location":"reference/containers/usedirect/#camply.containers.usedirect.UseDirectCityPark","title":"<code>UseDirectCityPark</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>UseDirect: City Parks</p> Source code in <code>camply/containers/usedirect.py</code> <pre><code>class UseDirectCityPark(CamplyModel):\n\"\"\"\n    UseDirect: City Parks\n    \"\"\"\nCityParkId: int\nName: str\nLatitude: float\nLongitude: float\nIsActive: bool\nEntityType: Optional[str]\nEnterpriseId: Optional[int]\nParkSize: Optional[str]\nPlaceId: int\n</code></pre>"},{"location":"reference/containers/usedirect/#camply.containers.usedirect.UseDirectDetailedPlace","title":"<code>UseDirectDetailedPlace</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>https://calirdr.usedirect.com/RDR/rdr/fd/places</p> Source code in <code>camply/containers/usedirect.py</code> <pre><code>class UseDirectDetailedPlace(CamplyModel):\n\"\"\"\n    https://calirdr.usedirect.com/RDR/rdr/fd/places\n    \"\"\"\nPlaceId: int\nName: str\nDescription: Optional[str]\nParkSize: Optional[str]\nLatitude: Optional[float]\nLongitude: Optional[float]\nParkCategoryId: Optional[int]\nParkActivity: Optional[int]\nParkPopularity: Optional[int]\nIsAvailableForGreatwalk: Optional[bool]\nFacilityDefaultZoom: Optional[int]\nRegionId: Optional[int]\nShortName: Optional[str]\nOrderBy: Optional[int]\nAllowWebBooking: Optional[bool]\nInventoryLocking: Optional[bool]\nInventoryLockDuration: Optional[int]\nUsePrepend: Optional[bool]\nPrependCode: Optional[str]\nAddress1: Optional[str]\nAddress2: Optional[str]\nCity: Optional[str]\nState: Optional[str]\nZip: Optional[str]\nVoicePhone: Optional[str]\nUDate: datetime.datetime\nUserId: Optional[int]\nRowGuid: Optional[str]\nIsWebViewable: Optional[bool]\nWeekdayCheckdays: Optional[int]\nWeekendCheckdays: Optional[int]\n</code></pre>"},{"location":"reference/containers/usedirect/#camply.containers.usedirect.UseDirectFacility","title":"<code>UseDirectFacility</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>Campground Representation for UseDirect</p> Source code in <code>camply/containers/usedirect.py</code> <pre><code>class UseDirectFacility(CamplyModel):\n\"\"\"\n    Campground Representation for UseDirect\n    \"\"\"\nFacilityId: int\nName: Optional[str]\nDescription: Optional[str]\nRateMessage: Optional[str]\nFacilityType: Optional[int]\nFacilityTypeNew: Optional[int]\nInSeason: Optional[bool]\nAvailable: Optional[bool]\nAvailableFiltered: Optional[bool]\nRestrictions: Optional[UseDirectRestrictions]\nLatitude: Optional[float]\nLongitude: Optional[float]\nCategory: Optional[str]\nEnableCheckOccupancy: Optional[bool]\nAvailableOccupancy: Any\nFacilityAllowWebBooking: Optional[bool]\nUnitTypes: Optional[Dict[int, UseDirectUnitType]] = {}\nIsAvailableForGroup: Optional[bool]\nIsAvailableForPatron: Optional[bool]\nIsAvailableForEducationalGroup: Optional[bool]\nIsAvailableForCto: Optional[bool]\nFacilityBehaviourType: Optional[int]\n</code></pre>"},{"location":"reference/containers/usedirect/#camply.containers.usedirect.UseDirectFacilityMetadata","title":"<code>UseDirectFacilityMetadata</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>UseDirect: Facility Metadata</p> Source code in <code>camply/containers/usedirect.py</code> <pre><code>class UseDirectFacilityMetadata(CamplyModel):\n\"\"\"\n    UseDirect: Facility Metadata\n    \"\"\"\nFacilityId: int\nRegionId: Optional[int]\nPlaceId: int\nName: str\nShortName: Optional[str]\nDescription: Optional[str]\nOrderBy: Optional[int]\nFacilityType: Optional[int]\nUsePrepend: Optional[bool]\nPrependCode: Optional[str]\nAllowWebBooking: Optional[bool]\nAutoOpenInventory: Optional[bool]\nUDate: Optional[datetime.datetime]\nRowGuid: Optional[str]\nFacilityTypeNew: Optional[int]\nMaxPersonOccupancy: Optional[int]\nIsAvailableForGroup: Optional[bool]\nIsAvailableForEducationalGroup: Optional[bool]\nIsAvailableForCto: Optional[bool]\nIsCaptcha: Optional[bool]\nFacilityBehaviourType: Optional[int]\nEnableCheckOccupancy: Optional[bool]\nIsTrail: Optional[bool]\nTimebaseMaxHours: Optional[int]\nTimebaseMinHours: Optional[int]\nTimebaseDuration: Optional[int]\n</code></pre>"},{"location":"reference/containers/usedirect/#camply.containers.usedirect.UseDirectMetadata","title":"<code>UseDirectMetadata</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>Campground Metadata Responses</p> Source code in <code>camply/containers/usedirect.py</code> <pre><code>class UseDirectMetadata(CamplyModel):\n\"\"\"\n    Campground Metadata Responses\n    \"\"\"\nMessage: str\nUnitCategories: Optional[List[UseDirectUnitCategory]] = []\nNightlySleepingUnits: Optional[List[UseDirectNightlySleepingUnit]] = []\nMinVehicleLengths: Optional[List[UseDirectMinVehicleLength]] = []\nUnitTypesGroups: Optional[List[UseDirectUnitTypeGroup]] = []\nPlaceHighlights: Optional[List[Any]] = []\nAllAmenity: Optional[List[UseDirectAmenity]] = []\n</code></pre>"},{"location":"reference/containers/usedirect/#camply.containers.usedirect.UseDirectMinVehicleLength","title":"<code>UseDirectMinVehicleLength</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>UseDirect: Vehicle Length</p> Source code in <code>camply/containers/usedirect.py</code> <pre><code>class UseDirectMinVehicleLength(CamplyModel):\n\"\"\"\n    UseDirect: Vehicle Length\n    \"\"\"\nSleepingUnitId: int\nMinVehicleLength: int\nMinVehicleName: str\nIcon: Optional[str]\n</code></pre>"},{"location":"reference/containers/usedirect/#camply.containers.usedirect.UseDirectNightlySleepingUnit","title":"<code>UseDirectNightlySleepingUnit</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>UseDirect: Nightly Sleeping Units</p> Source code in <code>camply/containers/usedirect.py</code> <pre><code>class UseDirectNightlySleepingUnit(CamplyModel):\n\"\"\"\n    UseDirect: Nightly Sleeping Units\n    \"\"\"\nUnitCategoryId: int\nSleepingUnitId: int\nSleepingUnitName: str\nIsWheeled: Optional[bool]\nIcon: Optional[str]\n</code></pre>"},{"location":"reference/containers/usedirect/#camply.containers.usedirect.UseDirectPlace","title":"<code>UseDirectPlace</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>UseDirect: Place Object</p> Source code in <code>camply/containers/usedirect.py</code> <pre><code>class UseDirectPlace(CamplyModel):\n\"\"\"\n    UseDirect: Place Object\n    \"\"\"\nPlaceId: int\nName: str\nDescription: Optional[str]\nHasAlerts: Optional[bool]\nIsFavourite: Optional[bool]\nAllhighlights: Optional[str]\nUrl: Optional[str]\nImageUrl: Optional[str]\nBannerUrl: Optional[str]\nParkSize: Optional[str]\nLatitude: Optional[float]\nLongitude: Optional[float]\nTimeZone: Optional[str]\nTimeStamp: Optional[datetime.datetime]\nMilesFromSelected: Optional[int]\nAvailable: bool\nAvailableFiltered: Optional[bool]\nParkCategoryId: Optional[int]\nParkActivity: Optional[int]\nParkPopularity: Optional[int]\nAvailableUnitCount: Optional[int]\nRestrictions: Optional[UseDirectRestrictions]\nFacilities: Optional[Dict[int, UseDirectFacility]] = {}\nIsAvailableForGreatwalk: Optional[bool]\nFacilityDefaultZoom: Optional[int]\n</code></pre>"},{"location":"reference/containers/usedirect/#camply.containers.usedirect.UseDirectRestrictions","title":"<code>UseDirectRestrictions</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>UseDirect: Campsite Restrictions</p> Source code in <code>camply/containers/usedirect.py</code> <pre><code>class UseDirectRestrictions(CamplyModel):\n\"\"\"\n    UseDirect: Campsite Restrictions\n    \"\"\"\nFutureBookingStarts: Optional[datetime.datetime]\nFutureBookingEnds: Optional[datetime.datetime]\nMinimumStay: Optional[int]\nMaximumStay: Optional[int]\nIsRestrictionValid: Optional[bool]\nTime: Optional[str]\n</code></pre>"},{"location":"reference/containers/usedirect/#camply.containers.usedirect.UseDirectUnitCategory","title":"<code>UseDirectUnitCategory</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>UseDirect: Unit Categories</p> Source code in <code>camply/containers/usedirect.py</code> <pre><code>class UseDirectUnitCategory(CamplyModel):\n\"\"\"\n    UseDirect: Unit Categories\n    \"\"\"\nUnitCategoryId: int\nUnitCategoryName: str\nHasEquipment: Optional[bool]\nIcon: Optional[str]\n</code></pre>"},{"location":"reference/containers/usedirect/#camply.containers.usedirect.UseDirectUnitType","title":"<code>UseDirectUnitType</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>UseDirect: Unit Types</p> Source code in <code>camply/containers/usedirect.py</code> <pre><code>class UseDirectUnitType(CamplyModel):\n\"\"\"\n    UseDirect: Unit Types\n    \"\"\"\nUnitTypeId: int\nUseType: int\nName: str\nAvailable: bool\nAvailableFiltered: Optional[bool]\nUnitCategoryId: Optional[int]\nUnitTypeGroupId: Optional[int]\nMaxVehicleLength: Optional[int]\nHasAda: Optional[bool]\nRestrictions: Optional[Any]\nAvailableCount: Optional[int]\n</code></pre>"},{"location":"reference/containers/usedirect/#camply.containers.usedirect.UseDirectUnitTypeGroup","title":"<code>UseDirectUnitTypeGroup</code>","text":"<p>         Bases: <code>CamplyModel</code></p> <p>UseDirect: Unit Type Groups</p> Source code in <code>camply/containers/usedirect.py</code> <pre><code>class UseDirectUnitTypeGroup(CamplyModel):\n\"\"\"\n    UseDirect: Unit Type Groups\n    \"\"\"\nUnitCategoryId: int\nUnitTypesGroupId: int\nUnitTypesGroupName: str\nIcon: Optional[str]\n</code></pre>"},{"location":"reference/notifications/","title":"notifications","text":"<p>Notifications init file</p>"},{"location":"reference/notifications/#camply.notifications.AppriseNotifications","title":"<code>AppriseNotifications</code>","text":"<p>         Bases: <code>BaseNotifications</code></p> <p>Push Notifications via Apprise</p> Source code in <code>camply/notifications/apprise.py</code> <pre><code>class AppriseNotifications(BaseNotifications):\n\"\"\"\n    Push Notifications via Apprise\n    \"\"\"\ndef __init__(self):\nsuper().__init__()\ntry:\nimport apprise\nexcept ImportError as ie:\nraise RuntimeError(\n\"Looks like `apprise` isn't installed. Install it with `pip install camply[apprise]`\"\n) from ie\nif any(\n[\nAppriseConfig.APPRISE_URL is None,\n]\n):\nwarning_message = (\n\"Apprise is not configured properly. To send Apprise notifications \"\n\"make sure to run `camply configure` or set the \"\n\"proper environment variable: `APPRISE_URL`.\"\n)\nlogger.error(warning_message)\nraise EnvironmentError(warning_message)\nself.client = apprise.Apprise()\nself.client.add(AppriseConfig.APPRISE_URL)\nlogger.info(\"Apprise: will notify specified URL\")\ndef send_message(self, message: str, **kwargs):\n\"\"\"\n        Send a message via Apprise - if environment variables are configured\n        Parameters\n        ----------\n        message: str\n        \"\"\"\nself.client.notify(\nbody=message,\ntitle=\"Camply Notification\",\n)\ndef send_campsites(self, campsites: List[AvailableCampsite], **kwargs):\n\"\"\"\n        Send a message with a campsite object\n        Parameters\n        ----------\n        campsites: AvailableCampsite\n        \"\"\"\nfor campsite in campsites:\nmessage_title, formatted_dict = self.format_standard_campsites(\ncampsite=campsite,\n)\nfields = [f\"\ud83c\udfd5{message_title}\", \"\"]\nfor key, value in formatted_dict.items():\nfields.append(f\"{key}: {value}\")\nfields.append(\"\")\nfields.append(\"camply, the campsite finder \u26fa\ufe0f\")\ncomposed_message = \"\\n\".join(fields)\nself.send_message(message=composed_message)\n</code></pre>"},{"location":"reference/notifications/#camply.notifications.apprise.AppriseNotifications.send_campsites","title":"<code>send_campsites(campsites, **kwargs)</code>","text":"<p>Send a message with a campsite object</p> <p>Parameters:</p> Name Type Description Default <code>campsites</code> <code>List[AvailableCampsite]</code> required Source code in <code>camply/notifications/apprise.py</code> <pre><code>def send_campsites(self, campsites: List[AvailableCampsite], **kwargs):\n\"\"\"\n    Send a message with a campsite object\n    Parameters\n    ----------\n    campsites: AvailableCampsite\n    \"\"\"\nfor campsite in campsites:\nmessage_title, formatted_dict = self.format_standard_campsites(\ncampsite=campsite,\n)\nfields = [f\"\ud83c\udfd5{message_title}\", \"\"]\nfor key, value in formatted_dict.items():\nfields.append(f\"{key}: {value}\")\nfields.append(\"\")\nfields.append(\"camply, the campsite finder \u26fa\ufe0f\")\ncomposed_message = \"\\n\".join(fields)\nself.send_message(message=composed_message)\n</code></pre>"},{"location":"reference/notifications/#camply.notifications.apprise.AppriseNotifications.send_message","title":"<code>send_message(message, **kwargs)</code>","text":"<p>Send a message via Apprise - if environment variables are configured</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> required Source code in <code>camply/notifications/apprise.py</code> <pre><code>def send_message(self, message: str, **kwargs):\n\"\"\"\n    Send a message via Apprise - if environment variables are configured\n    Parameters\n    ----------\n    message: str\n    \"\"\"\nself.client.notify(\nbody=message,\ntitle=\"Camply Notification\",\n)\n</code></pre>"},{"location":"reference/notifications/#camply.notifications.EmailNotifications","title":"<code>EmailNotifications</code>","text":"<p>         Bases: <code>BaseNotifications</code></p> <p>Notifications via Email</p> Source code in <code>camply/notifications/email_notifications.py</code> <pre><code>class EmailNotifications(BaseNotifications):\n\"\"\"\n    Notifications via Email\n    \"\"\"\nemail_subject = EmailConfig.EMAIL_SUBJECT_LINE\nemail_from = EmailConfig.EMAIL_FROM_ADDRESS\nemail_to = EmailConfig.EMAIL_TO_ADDRESS\nemail_username = EmailConfig.EMAIL_USERNAME\n_email_password = EmailConfig.EMAIL_PASSWORD\nemail_smtp_server = EmailConfig.EMAIL_SMTP_SERVER\nemail_smtp_server_port = EmailConfig.EMAIL_SMTP_PORT\ndef __init__(self):\n\"\"\"\n        Data Validation\n        **kwargs\n            Accepts: from, to, subject, username, password, server, port\n        \"\"\"\nsuper().__init__()\n# PERFORM SOME VALIDATION\nif any(\n[\nEmailConfig.EMAIL_TO_ADDRESS in [None, \"\"],\nEmailConfig.EMAIL_USERNAME in [None, \"\"],\nEmailConfig.EMAIL_PASSWORD in [None, \"\"],\n]\n):\nvariable_names = \"\\n\\t\".join(EmailConfig.ENVIRONMENT_VARIABLE_NAMES)\noptional_variable_names = \"\\n\\t\".join(\nEmailConfig.OPTIONAL_ENVIRONMENT_VARIABLE\n)\nerror_message = (\n\"Email Notification Auth Parameters not set. Run `camply configure` \"\nf\"or set the following Environment Variables:\\n\\t{variable_names}\"\n\"\\nOptional Environment Variables:\\n\\t\"\nf\"{optional_variable_names}\"\n)\nlogger.error(error_message)\nraise EnvironmentError(error_message)\n# ATTEMPT AN EMAIL LOGIN AT INIT TO THROW ERRORS EARLY\n_email_server = SMTP_SSL(\nself.email_smtp_server,\nself.email_smtp_server_port,\n)\n_email_server.ehlo()\n_email_server.login(\nuser=self.email_username,\npassword=self._email_password,\n)\n_email_server.quit()\ndef send_message(self, message: str, **kwargs) -&gt; None:\n\"\"\"\n        Send a message via Email\n        Parameters\n        ----------\n        message: str\n            Email Body\n        **kwargs\n            Accepts: from, to, subject, username, password, server, port\n        Returns\n        -------\n        object\n        \"\"\"\nemail = EmailMessage()\nemail.set_content(message)\nemail[\"Subject\"] = kwargs.get(\"subject\", self.email_subject)\nemail[\"From\"] = kwargs.get(\"from\", self.email_from)\nemail[\"To\"] = kwargs.get(\"to\", self.email_to)\nemail_server_user = kwargs.get(\"username\", self.email_username)\nemail_server_password = kwargs.get(\"password\", self._email_password)\nemail_server_smtp_server = kwargs.get(\"server\", self.email_smtp_server)\nemail_server_smtp_server_port = kwargs.get(\"port\", self.email_smtp_server_port)\nemail_server = SMTP_SSL(email_server_smtp_server, email_server_smtp_server_port)\nemail_server.ehlo()\nemail_server.login(user=email_server_user, password=email_server_password)\nlogger.info(f\"Sending Email to {email['To']}: {email['Subject']}\")\nemail_server.send_message(email)\nlogger.info(\"Email sent successfully\")\nemail_server.quit()\ndef send_campsites(self, campsites: List[AvailableCampsite], **kwargs) -&gt; None:\n\"\"\"\n        Send a message with a campsite object\n        Parameters\n        ----------\n        campsites: List[AvailableCampsite]\n        \"\"\"\nmaster_email_body_list = []\nfor campsite in campsites:\nmessage_title, formatted_dict = self.format_standard_campsites(\ncampsite=campsite,\n)\nfields = [message_title]\nfor key, value in formatted_dict.items():\nif key == \"Permitted Equipment\":\nvalue = value.replace(\"\\n  - \", \"\\n  \\t  - \")\nfields.append(f\"\\t{key}: {value}\")\ncomposed_message = \"\\n\".join(fields) + \"\\n\\n\"\nmaster_email_body_list.append(composed_message)\nmaster_email_body = \"\\n\".join(master_email_body_list)\nif len(campsites) &gt; 0:\nself.send_message(message=master_email_body)\n</code></pre>"},{"location":"reference/notifications/#camply.notifications.email_notifications.EmailNotifications.__init__","title":"<code>__init__()</code>","text":"<p>Data Validation</p> <p>**kwargs     Accepts: from, to, subject, username, password, server, port</p> Source code in <code>camply/notifications/email_notifications.py</code> <pre><code>def __init__(self):\n\"\"\"\n    Data Validation\n    **kwargs\n        Accepts: from, to, subject, username, password, server, port\n    \"\"\"\nsuper().__init__()\n# PERFORM SOME VALIDATION\nif any(\n[\nEmailConfig.EMAIL_TO_ADDRESS in [None, \"\"],\nEmailConfig.EMAIL_USERNAME in [None, \"\"],\nEmailConfig.EMAIL_PASSWORD in [None, \"\"],\n]\n):\nvariable_names = \"\\n\\t\".join(EmailConfig.ENVIRONMENT_VARIABLE_NAMES)\noptional_variable_names = \"\\n\\t\".join(\nEmailConfig.OPTIONAL_ENVIRONMENT_VARIABLE\n)\nerror_message = (\n\"Email Notification Auth Parameters not set. Run `camply configure` \"\nf\"or set the following Environment Variables:\\n\\t{variable_names}\"\n\"\\nOptional Environment Variables:\\n\\t\"\nf\"{optional_variable_names}\"\n)\nlogger.error(error_message)\nraise EnvironmentError(error_message)\n# ATTEMPT AN EMAIL LOGIN AT INIT TO THROW ERRORS EARLY\n_email_server = SMTP_SSL(\nself.email_smtp_server,\nself.email_smtp_server_port,\n)\n_email_server.ehlo()\n_email_server.login(\nuser=self.email_username,\npassword=self._email_password,\n)\n_email_server.quit()\n</code></pre>"},{"location":"reference/notifications/#camply.notifications.email_notifications.EmailNotifications.send_campsites","title":"<code>send_campsites(campsites, **kwargs)</code>","text":"<p>Send a message with a campsite object</p> <p>Parameters:</p> Name Type Description Default <code>campsites</code> <code>List[AvailableCampsite]</code> required Source code in <code>camply/notifications/email_notifications.py</code> <pre><code>def send_campsites(self, campsites: List[AvailableCampsite], **kwargs) -&gt; None:\n\"\"\"\n    Send a message with a campsite object\n    Parameters\n    ----------\n    campsites: List[AvailableCampsite]\n    \"\"\"\nmaster_email_body_list = []\nfor campsite in campsites:\nmessage_title, formatted_dict = self.format_standard_campsites(\ncampsite=campsite,\n)\nfields = [message_title]\nfor key, value in formatted_dict.items():\nif key == \"Permitted Equipment\":\nvalue = value.replace(\"\\n  - \", \"\\n  \\t  - \")\nfields.append(f\"\\t{key}: {value}\")\ncomposed_message = \"\\n\".join(fields) + \"\\n\\n\"\nmaster_email_body_list.append(composed_message)\nmaster_email_body = \"\\n\".join(master_email_body_list)\nif len(campsites) &gt; 0:\nself.send_message(message=master_email_body)\n</code></pre>"},{"location":"reference/notifications/#camply.notifications.email_notifications.EmailNotifications.send_message","title":"<code>send_message(message, **kwargs)</code>","text":"<p>Send a message via Email</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Email Body</p> required <code>**kwargs</code> <p>Accepts: from, to, subject, username, password, server, port</p> <code>{}</code> <p>Returns:</p> Type Description <code>object</code> Source code in <code>camply/notifications/email_notifications.py</code> <pre><code>def send_message(self, message: str, **kwargs) -&gt; None:\n\"\"\"\n    Send a message via Email\n    Parameters\n    ----------\n    message: str\n        Email Body\n    **kwargs\n        Accepts: from, to, subject, username, password, server, port\n    Returns\n    -------\n    object\n    \"\"\"\nemail = EmailMessage()\nemail.set_content(message)\nemail[\"Subject\"] = kwargs.get(\"subject\", self.email_subject)\nemail[\"From\"] = kwargs.get(\"from\", self.email_from)\nemail[\"To\"] = kwargs.get(\"to\", self.email_to)\nemail_server_user = kwargs.get(\"username\", self.email_username)\nemail_server_password = kwargs.get(\"password\", self._email_password)\nemail_server_smtp_server = kwargs.get(\"server\", self.email_smtp_server)\nemail_server_smtp_server_port = kwargs.get(\"port\", self.email_smtp_server_port)\nemail_server = SMTP_SSL(email_server_smtp_server, email_server_smtp_server_port)\nemail_server.ehlo()\nemail_server.login(user=email_server_user, password=email_server_password)\nlogger.info(f\"Sending Email to {email['To']}: {email['Subject']}\")\nemail_server.send_message(email)\nlogger.info(\"Email sent successfully\")\nemail_server.quit()\n</code></pre>"},{"location":"reference/notifications/#camply.notifications.MultiNotifierProvider","title":"<code>MultiNotifierProvider</code>","text":"<p>         Bases: <code>BaseNotifications</code></p> <p>Notifications Supported from Multiple Providers</p> Source code in <code>camply/notifications/multi_provider_notifications.py</code> <pre><code>class MultiNotifierProvider(BaseNotifications):\n\"\"\"\n    Notifications Supported from Multiple Providers\n    \"\"\"\ndef __init__(self, provider: Union[str, List[str], BaseNotifications, None]):\n\"\"\"\n        Initialize with a Notifier Class Object, a string or list of strings\n        Parameters\n        ----------\n        provider: Union[str, List[str], BaseNotifications, None]\n            Provider String, Comma Separated Provider String, or list of provider\n            strings\n        \"\"\"\nsuper().__init__()\nself.providers = [SilentNotifications()]\nif isinstance(provider, str):\nprovider = [prov_string.strip() for prov_string in provider.split(\",\")]\nfor notifier_object in provider:\nif isinstance(notifier_object, BaseNotifications):\nnotifier = notifier_object\nelif isinstance(notifier_object, str):\nnotifier = CAMPSITE_NOTIFICATIONS.get(notifier_object.lower(), None)()\nelif notifier_object is None:\nnotifier = None\nelse:\nraise NotificationError(\n\"You must provide a proper Notification Identifier\"\n)\nif notifier is not None and not isinstance(notifier, SilentNotifications):\nself.providers.append(notifier)\ndef send_message(self, message: str, **kwargs):\n\"\"\"\n        Send a message\n        Parameters\n        ----------\n        message: str\n            Message Text\n        **kwargs\n            All kwargs passed to underlying notification method\n        \"\"\"\nfor provider in self.providers:\nprovider.send_message(message=message, **kwargs)\ndef send_campsites(self, campsites: List[AvailableCampsite], **kwargs):\n\"\"\"\n        Send a message with a campsite object\n        Parameters\n        ----------\n        campsites: List[AvailableCampsite]\n        \"\"\"\nfor provider in self.providers:\nprovider.send_campsites(campsites=campsites, **kwargs)\ndef log_providers(self) -&gt; None:\n\"\"\"\n        Log All Providers\n        Returns\n        -------\n        None\n        \"\"\"\nprovider_names = [str(provider) for provider in self.providers]\nlogger.info(f\"Notifications active via: {', '.join(provider_names)}\")\nif len(self.providers) == 1:\nlogger.info(\nf\"Only {self.providers[0]} enabled. \"\n\"I hope you're watching these logs.\"\n)\ndef last_gasp(self, error: Exception) -&gt; None:\n\"\"\"\n        Make a `last gasp` notification before exiting\n        Returns\n        -------\n        None\n        \"\"\"\nlogger.info(\"Exception encountered, emitting notification last gasp.\")\ndate_string = datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\nerror_string = str(error)\nerror_message = (\n\"camply encountered an error and exited \ud83d\ude1f \"\nf\"[{date_string}] - ({error.__class__.__name__}) {error_string}\"\n)\nfor provider in self.providers:\nprovider.send_message(error_message)\nraise RuntimeError(error_message) from error\n</code></pre>"},{"location":"reference/notifications/#camply.notifications.multi_provider_notifications.MultiNotifierProvider.__init__","title":"<code>__init__(provider)</code>","text":"<p>Initialize with a Notifier Class Object, a string or list of strings</p> <p>Parameters:</p> Name Type Description Default <code>provider</code> <code>Union[str, List[str], BaseNotifications, None]</code> <p>Provider String, Comma Separated Provider String, or list of provider strings</p> required Source code in <code>camply/notifications/multi_provider_notifications.py</code> <pre><code>def __init__(self, provider: Union[str, List[str], BaseNotifications, None]):\n\"\"\"\n    Initialize with a Notifier Class Object, a string or list of strings\n    Parameters\n    ----------\n    provider: Union[str, List[str], BaseNotifications, None]\n        Provider String, Comma Separated Provider String, or list of provider\n        strings\n    \"\"\"\nsuper().__init__()\nself.providers = [SilentNotifications()]\nif isinstance(provider, str):\nprovider = [prov_string.strip() for prov_string in provider.split(\",\")]\nfor notifier_object in provider:\nif isinstance(notifier_object, BaseNotifications):\nnotifier = notifier_object\nelif isinstance(notifier_object, str):\nnotifier = CAMPSITE_NOTIFICATIONS.get(notifier_object.lower(), None)()\nelif notifier_object is None:\nnotifier = None\nelse:\nraise NotificationError(\n\"You must provide a proper Notification Identifier\"\n)\nif notifier is not None and not isinstance(notifier, SilentNotifications):\nself.providers.append(notifier)\n</code></pre>"},{"location":"reference/notifications/#camply.notifications.multi_provider_notifications.MultiNotifierProvider.last_gasp","title":"<code>last_gasp(error)</code>","text":"<p>Make a <code>last gasp</code> notification before exiting</p> <p>Returns:</p> Type Description <code>None</code> Source code in <code>camply/notifications/multi_provider_notifications.py</code> <pre><code>def last_gasp(self, error: Exception) -&gt; None:\n\"\"\"\n    Make a `last gasp` notification before exiting\n    Returns\n    -------\n    None\n    \"\"\"\nlogger.info(\"Exception encountered, emitting notification last gasp.\")\ndate_string = datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\nerror_string = str(error)\nerror_message = (\n\"camply encountered an error and exited \ud83d\ude1f \"\nf\"[{date_string}] - ({error.__class__.__name__}) {error_string}\"\n)\nfor provider in self.providers:\nprovider.send_message(error_message)\nraise RuntimeError(error_message) from error\n</code></pre>"},{"location":"reference/notifications/#camply.notifications.multi_provider_notifications.MultiNotifierProvider.log_providers","title":"<code>log_providers()</code>","text":"<p>Log All Providers</p> <p>Returns:</p> Type Description <code>None</code> Source code in <code>camply/notifications/multi_provider_notifications.py</code> <pre><code>def log_providers(self) -&gt; None:\n\"\"\"\n    Log All Providers\n    Returns\n    -------\n    None\n    \"\"\"\nprovider_names = [str(provider) for provider in self.providers]\nlogger.info(f\"Notifications active via: {', '.join(provider_names)}\")\nif len(self.providers) == 1:\nlogger.info(\nf\"Only {self.providers[0]} enabled. \"\n\"I hope you're watching these logs.\"\n)\n</code></pre>"},{"location":"reference/notifications/#camply.notifications.multi_provider_notifications.MultiNotifierProvider.send_campsites","title":"<code>send_campsites(campsites, **kwargs)</code>","text":"<p>Send a message with a campsite object</p> <p>Parameters:</p> Name Type Description Default <code>campsites</code> <code>List[AvailableCampsite]</code> required Source code in <code>camply/notifications/multi_provider_notifications.py</code> <pre><code>def send_campsites(self, campsites: List[AvailableCampsite], **kwargs):\n\"\"\"\n    Send a message with a campsite object\n    Parameters\n    ----------\n    campsites: List[AvailableCampsite]\n    \"\"\"\nfor provider in self.providers:\nprovider.send_campsites(campsites=campsites, **kwargs)\n</code></pre>"},{"location":"reference/notifications/#camply.notifications.multi_provider_notifications.MultiNotifierProvider.send_message","title":"<code>send_message(message, **kwargs)</code>","text":"<p>Send a message</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Message Text</p> required <code>**kwargs</code> <p>All kwargs passed to underlying notification method</p> <code>{}</code> Source code in <code>camply/notifications/multi_provider_notifications.py</code> <pre><code>def send_message(self, message: str, **kwargs):\n\"\"\"\n    Send a message\n    Parameters\n    ----------\n    message: str\n        Message Text\n    **kwargs\n        All kwargs passed to underlying notification method\n    \"\"\"\nfor provider in self.providers:\nprovider.send_message(message=message, **kwargs)\n</code></pre>"},{"location":"reference/notifications/#camply.notifications.PushbulletNotifications","title":"<code>PushbulletNotifications</code>","text":"<p>         Bases: <code>BaseNotifications</code></p> <p>Push Notifications via PushBullet</p> Source code in <code>camply/notifications/pushbullet.py</code> <pre><code>class PushbulletNotifications(BaseNotifications):\n\"\"\"\n    Push Notifications via PushBullet\n    \"\"\"\ndef __init__(self):\nsuper().__init__()\npushbullet_headers = PushbulletConfig.API_HEADERS.copy()\npushbullet_headers.update({\"Access-Token\": PushbulletConfig.API_TOKEN})\nself.session.headers.update(pushbullet_headers)\nif any([PushbulletConfig.API_TOKEN is None, PushbulletConfig.API_TOKEN == \"\"]):\nwarning_message = (\n\"Pushbullet is not configured properly. To send Pushbullet messages \"\n\"make sure to run `camply configure` or set the \"\n\"proper environment variable: `PUSHBULLET_API_TOKEN`.\"\n)\nlogger.error(warning_message)\nraise EnvironmentError(warning_message)\ndef send_message(self, message: str, **kwargs) -&gt; requests.Response:\n\"\"\"\n        Send a message via PushBullet - if environment variables are configured\n        Parameters\n        ----------\n        message: str\n        Returns\n        -------\n        requests.Response\n        \"\"\"\nmessage_type = kwargs.pop(\"type\", \"note\")\nmessage_title = kwargs.pop(\"title\", \"Camply Notification\")\nmessage_json = dict(\ntype=message_type, title=message_title, body=message, **kwargs\n)\nlogger.debug(message_json)\nresponse = self.session.post(\nurl=PushbulletConfig.PUSHBULLET_API_ENDPOINT,\njson=message_json,\n)\ntry:\nresponse.raise_for_status()\nexcept requests.HTTPError as he:\nlogger.warning(\n\"Notifications weren't able to be sent to Pushbullet. \"\n\"Your configuration might be incorrect.\"\n)\nraise ConnectionError(response.text) from he\nreturn response\ndef send_campsites(self, campsites: List[AvailableCampsite], **kwargs):\n\"\"\"\n        Send a message with a campsite object\n        Parameters\n        ----------\n        campsites: AvailableCampsite\n        \"\"\"\nfor campsite in campsites:\nmessage_title, formatted_dict = self.format_standard_campsites(\ncampsite=campsite,\n)\nfields = []\nfor key, value in formatted_dict.items():\nfields.append(f\"{key}: {value}\")\ncomposed_message = \"\\n\".join(fields)\nself.send_message(\nmessage=composed_message, title=message_title, type=\"note\"\n)\n</code></pre>"},{"location":"reference/notifications/#camply.notifications.pushbullet.PushbulletNotifications.send_campsites","title":"<code>send_campsites(campsites, **kwargs)</code>","text":"<p>Send a message with a campsite object</p> <p>Parameters:</p> Name Type Description Default <code>campsites</code> <code>List[AvailableCampsite]</code> required Source code in <code>camply/notifications/pushbullet.py</code> <pre><code>def send_campsites(self, campsites: List[AvailableCampsite], **kwargs):\n\"\"\"\n    Send a message with a campsite object\n    Parameters\n    ----------\n    campsites: AvailableCampsite\n    \"\"\"\nfor campsite in campsites:\nmessage_title, formatted_dict = self.format_standard_campsites(\ncampsite=campsite,\n)\nfields = []\nfor key, value in formatted_dict.items():\nfields.append(f\"{key}: {value}\")\ncomposed_message = \"\\n\".join(fields)\nself.send_message(\nmessage=composed_message, title=message_title, type=\"note\"\n)\n</code></pre>"},{"location":"reference/notifications/#camply.notifications.pushbullet.PushbulletNotifications.send_message","title":"<code>send_message(message, **kwargs)</code>","text":"<p>Send a message via PushBullet - if environment variables are configured</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> required <p>Returns:</p> Type Description <code>requests.Response</code> Source code in <code>camply/notifications/pushbullet.py</code> <pre><code>def send_message(self, message: str, **kwargs) -&gt; requests.Response:\n\"\"\"\n    Send a message via PushBullet - if environment variables are configured\n    Parameters\n    ----------\n    message: str\n    Returns\n    -------\n    requests.Response\n    \"\"\"\nmessage_type = kwargs.pop(\"type\", \"note\")\nmessage_title = kwargs.pop(\"title\", \"Camply Notification\")\nmessage_json = dict(\ntype=message_type, title=message_title, body=message, **kwargs\n)\nlogger.debug(message_json)\nresponse = self.session.post(\nurl=PushbulletConfig.PUSHBULLET_API_ENDPOINT,\njson=message_json,\n)\ntry:\nresponse.raise_for_status()\nexcept requests.HTTPError as he:\nlogger.warning(\n\"Notifications weren't able to be sent to Pushbullet. \"\n\"Your configuration might be incorrect.\"\n)\nraise ConnectionError(response.text) from he\nreturn response\n</code></pre>"},{"location":"reference/notifications/#camply.notifications.PushoverNotifications","title":"<code>PushoverNotifications</code>","text":"<p>         Bases: <code>BaseNotifications</code>, <code>logging.StreamHandler</code></p> <p>Push Notifications via Pushover + a Logging Handler</p> Source code in <code>camply/notifications/pushover.py</code> <pre><code>class PushoverNotifications(BaseNotifications, logging.StreamHandler):\n\"\"\"\n    Push Notifications via Pushover + a Logging Handler\n    \"\"\"\ndef __init__(self, level: Optional[int] = logging.INFO):\nsuper().__init__()\nself.session.headers.update(PushoverConfig.API_HEADERS)\nlogging.StreamHandler.__init__(self)\nself.setLevel(level=level)\nif any([PushoverConfig.PUSH_USER is None, PushoverConfig.PUSH_USER == \"\"]):\nwarning_message = (\n\"Pushover is not configured properly. To send pushover messages \"\n\"make sure to run `camply configure` or set the \"\n\"proper environment variables: `PUSHOVER_PUSH_USER`, \"\n\"`PUSHOVER_PUSH_TOKEN`.\"\n)\nlogger.error(warning_message)\nraise EnvironmentError(warning_message)\ndef send_message(self, message: str, **kwargs) -&gt; requests.Response:\n\"\"\"\n        Send a message via Pushover - if environment variables are configured\n        Parameters\n        ----------\n        message: str\n        Returns\n        -------\n        requests.Response\n        \"\"\"\ntoken = (\nPushoverConfig.PUSH_TOKEN\nif PushoverConfig.PUSH_TOKEN not in [None, \"\"]\nelse base64.b64decode(PushoverConfig.PUSHOVER_DEFAULT_API_TOKEN).decode(\n\"utf-8\"\n)\n)\nresponse = self.session.post(\nurl=PushoverConfig.PUSHOVER_API_ENDPOINT,\nparams=dict(\ntoken=token, user=PushoverConfig.PUSH_USER, message=message, **kwargs\n),\n)\ntry:\nresponse.raise_for_status()\nexcept requests.HTTPError as he:\nlogger.warning(\n\"Notifications weren't able to be sent to Pushover. \"\n\"Your configuration might be incorrect.\"\n)\nraise ConnectionError(response.text) from he\nreturn response\ndef emit(self, record: logging.LogRecord):\n\"\"\"\n        Produce a logging record\n        Parameters\n        ----------\n        record: str\n            Message to log\n        \"\"\"\nlog_formatted_message = \"[{:&gt;10}]: {}\".format(\nrecord.levelname.upper(), record.msg\n)\ntitle = f\"Pushover {record.levelname.title()} Message\"\nself.send_message(message=log_formatted_message, title=title)\ndef send_campsites(self, campsites: List[AvailableCampsite], **kwargs):\n\"\"\"\n        Send a message with a campsite object\n        Parameters\n        ----------\n        campsites: AvailableCampsite\n        \"\"\"\nfor campsite in campsites:\nmessage_title, formatted_dict = self.format_standard_campsites(\ncampsite=campsite,\n)\nfields = []\nfor key, value in formatted_dict.items():\nif key == \"Booking Link\":\nvalue = f\"&lt;a href='{value}'&gt;{value}&lt;/a&gt;\"\nfields.append(f\"&lt;b&gt;{key}:&lt;/b&gt; {value}\")\ncomposed_message = \"\\n\".join(fields)\nself.send_message(message=composed_message, title=message_title, html=1)\n</code></pre>"},{"location":"reference/notifications/#camply.notifications.pushover.PushoverNotifications.emit","title":"<code>emit(record)</code>","text":"<p>Produce a logging record</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>logging.LogRecord</code> <p>Message to log</p> required Source code in <code>camply/notifications/pushover.py</code> <pre><code>def emit(self, record: logging.LogRecord):\n\"\"\"\n    Produce a logging record\n    Parameters\n    ----------\n    record: str\n        Message to log\n    \"\"\"\nlog_formatted_message = \"[{:&gt;10}]: {}\".format(\nrecord.levelname.upper(), record.msg\n)\ntitle = f\"Pushover {record.levelname.title()} Message\"\nself.send_message(message=log_formatted_message, title=title)\n</code></pre>"},{"location":"reference/notifications/#camply.notifications.pushover.PushoverNotifications.send_campsites","title":"<code>send_campsites(campsites, **kwargs)</code>","text":"<p>Send a message with a campsite object</p> <p>Parameters:</p> Name Type Description Default <code>campsites</code> <code>List[AvailableCampsite]</code> required Source code in <code>camply/notifications/pushover.py</code> <pre><code>def send_campsites(self, campsites: List[AvailableCampsite], **kwargs):\n\"\"\"\n    Send a message with a campsite object\n    Parameters\n    ----------\n    campsites: AvailableCampsite\n    \"\"\"\nfor campsite in campsites:\nmessage_title, formatted_dict = self.format_standard_campsites(\ncampsite=campsite,\n)\nfields = []\nfor key, value in formatted_dict.items():\nif key == \"Booking Link\":\nvalue = f\"&lt;a href='{value}'&gt;{value}&lt;/a&gt;\"\nfields.append(f\"&lt;b&gt;{key}:&lt;/b&gt; {value}\")\ncomposed_message = \"\\n\".join(fields)\nself.send_message(message=composed_message, title=message_title, html=1)\n</code></pre>"},{"location":"reference/notifications/#camply.notifications.pushover.PushoverNotifications.send_message","title":"<code>send_message(message, **kwargs)</code>","text":"<p>Send a message via Pushover - if environment variables are configured</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> required <p>Returns:</p> Type Description <code>requests.Response</code> Source code in <code>camply/notifications/pushover.py</code> <pre><code>def send_message(self, message: str, **kwargs) -&gt; requests.Response:\n\"\"\"\n    Send a message via Pushover - if environment variables are configured\n    Parameters\n    ----------\n    message: str\n    Returns\n    -------\n    requests.Response\n    \"\"\"\ntoken = (\nPushoverConfig.PUSH_TOKEN\nif PushoverConfig.PUSH_TOKEN not in [None, \"\"]\nelse base64.b64decode(PushoverConfig.PUSHOVER_DEFAULT_API_TOKEN).decode(\n\"utf-8\"\n)\n)\nresponse = self.session.post(\nurl=PushoverConfig.PUSHOVER_API_ENDPOINT,\nparams=dict(\ntoken=token, user=PushoverConfig.PUSH_USER, message=message, **kwargs\n),\n)\ntry:\nresponse.raise_for_status()\nexcept requests.HTTPError as he:\nlogger.warning(\n\"Notifications weren't able to be sent to Pushover. \"\n\"Your configuration might be incorrect.\"\n)\nraise ConnectionError(response.text) from he\nreturn response\n</code></pre>"},{"location":"reference/notifications/#camply.notifications.SilentNotifications","title":"<code>SilentNotifications</code>","text":"<p>         Bases: <code>BaseNotifications</code></p> <p>Silent Notifications</p> Source code in <code>camply/notifications/silent_notifications.py</code> <pre><code>class SilentNotifications(BaseNotifications):\n\"\"\"\n    Silent Notifications\n    \"\"\"\ndef send_message(self, message: str, **kwargs) -&gt; None:\n\"\"\"\n        Send a message via Email\n        Parameters\n        ----------\n        message: str\n            Email Body\n        **kwargs\n            kwargs are disregarded\n        Returns\n        -------\n        None\n        \"\"\"\nlogger.debug(f\"SilentNotification: {message}\")\ndef send_campsites(self, campsites: List[AvailableCampsite], **kwargs):\n\"\"\"\n        Send a message with a campsite object\n        Parameters\n        ----------\n        campsites: List[AvailableCampsite]\n        \"\"\"\nfor campsite in campsites:\ncampsite_tuple = (\n(\nf\"{campsite.booking_date.strftime('%Y-%m-%d')} - \"\nf\"{campsite.booking_end_date.strftime('%Y-%m-%d')}\"\n),\ncampsite.campsite_type,\ncampsite.campsite_site_name,\ncampsite.recreation_area,\ncampsite.facility_name,\ncampsite.booking_url,\n)\nmessage_string = \"\\n\\t\u2022 \" + \"\\n\\t\u2022 \".join(campsite_tuple)\nself.send_message(message_string)\ncampsite_formatted = pformat(campsite.dict())\nlogger.debug(\"Campsite Info: \" + campsite_formatted)\n</code></pre>"},{"location":"reference/notifications/#camply.notifications.silent_notifications.SilentNotifications.send_campsites","title":"<code>send_campsites(campsites, **kwargs)</code>","text":"<p>Send a message with a campsite object</p> <p>Parameters:</p> Name Type Description Default <code>campsites</code> <code>List[AvailableCampsite]</code> required Source code in <code>camply/notifications/silent_notifications.py</code> <pre><code>def send_campsites(self, campsites: List[AvailableCampsite], **kwargs):\n\"\"\"\n    Send a message with a campsite object\n    Parameters\n    ----------\n    campsites: List[AvailableCampsite]\n    \"\"\"\nfor campsite in campsites:\ncampsite_tuple = (\n(\nf\"{campsite.booking_date.strftime('%Y-%m-%d')} - \"\nf\"{campsite.booking_end_date.strftime('%Y-%m-%d')}\"\n),\ncampsite.campsite_type,\ncampsite.campsite_site_name,\ncampsite.recreation_area,\ncampsite.facility_name,\ncampsite.booking_url,\n)\nmessage_string = \"\\n\\t\u2022 \" + \"\\n\\t\u2022 \".join(campsite_tuple)\nself.send_message(message_string)\ncampsite_formatted = pformat(campsite.dict())\nlogger.debug(\"Campsite Info: \" + campsite_formatted)\n</code></pre>"},{"location":"reference/notifications/#camply.notifications.silent_notifications.SilentNotifications.send_message","title":"<code>send_message(message, **kwargs)</code>","text":"<p>Send a message via Email</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Email Body</p> required <code>**kwargs</code> <p>kwargs are disregarded</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> Source code in <code>camply/notifications/silent_notifications.py</code> <pre><code>def send_message(self, message: str, **kwargs) -&gt; None:\n\"\"\"\n    Send a message via Email\n    Parameters\n    ----------\n    message: str\n        Email Body\n    **kwargs\n        kwargs are disregarded\n    Returns\n    -------\n    None\n    \"\"\"\nlogger.debug(f\"SilentNotification: {message}\")\n</code></pre>"},{"location":"reference/notifications/#camply.notifications.SlackNotifications","title":"<code>SlackNotifications</code>","text":"<p>         Bases: <code>BaseNotifications</code></p> <p>Push Notifications via Slack</p> Source code in <code>camply/notifications/slack.py</code> <pre><code>class SlackNotifications(BaseNotifications):\n\"\"\"\n    Push Notifications via Slack\n    \"\"\"\ndef __init__(self):\nsuper().__init__()\nself.session.headers.update({\"Content-Type\": \"application/json\"})\nif any([SlackConfig.SLACK_WEBHOOK is None, SlackConfig.SLACK_WEBHOOK == \"\"]):\nwarning_message = (\n\"Slack is not configured properly. To send Slack messages \"\n\"make sure to run `camply configure` or set the \"\n\"proper environment variable: `SLACK_WEBHOOK`.\"\n)\nlogger.error(warning_message)\nraise EnvironmentError(warning_message)\ndef send_message(self, message: str, **kwargs) -&gt; requests.Response:\n\"\"\"\n        Send a message via Slack - if environment variables are configured.\n        Parameters\n        ----------\n        message: str\n        Returns\n        -------\n        requests.Response\n        \"\"\"\nmessage_blocks = kwargs.pop(\"blocks\", [])\nmessage_json = {\n\"text\": message,\n}\nif message_blocks:\nmessage_json = {\n\"blocks\": message_blocks,\n}\nlogger.debug(message_json)\nresponse = self.session.post(\nurl=SlackConfig.SLACK_WEBHOOK,\njson=message_json,\n)\ntry:\nresponse.raise_for_status()\nexcept requests.HTTPError as he:\nlogger.warning(\n\"Notifications weren't able to be sent to Slack. \"\n\"Your configuration might be incorrect.\"\n)\nraise ConnectionError(response.text) from he\nreturn response\ndef send_campsites(self, campsites: List[AvailableCampsite], **kwargs):\n\"\"\"\n        Send a message with a campsite object\n        Parameters\n        ----------\n        campsites: AvailableCampsite\n        \"\"\"\nfor campsite in campsites:\nmessage_title, formatted_dict = self.format_standard_campsites(\ncampsite=campsite,\n)\nfields = []\nfor key, value in formatted_dict.items():\nfields.append(\n{\n\"type\": \"mrkdwn\",\n\"text\": f\"*{key}*\",\n}\n)\nif key in [\"Permitted Equipment\", \"Booking Link\"]:\ndata_type = \"mrkdwn\"\nelse:\ndata_type = \"plain_text\"\nfields.append(\n{\n\"type\": data_type,\n\"text\": str(value),\n}\n)\nblocks = []\nblocks.append(\n{\n\"type\": \"header\",\n\"text\": {\n\"type\": \"plain_text\",\n\"text\": message_title,\n},\n}\n)\n# Slack only allows 10 fields (k+v) per section\nfor chunk in range(0, len(fields) + 1, 10):\nchunk_max = chunk + 10\nblocks.append(\n{\n\"type\": \"section\",\n\"fields\": fields[chunk:chunk_max],\n}\n)\nself.send_message(\nmessage=message_title,\nblocks=blocks,\n)\n</code></pre>"},{"location":"reference/notifications/#camply.notifications.slack.SlackNotifications.send_campsites","title":"<code>send_campsites(campsites, **kwargs)</code>","text":"<p>Send a message with a campsite object</p> <p>Parameters:</p> Name Type Description Default <code>campsites</code> <code>List[AvailableCampsite]</code> required Source code in <code>camply/notifications/slack.py</code> <pre><code>def send_campsites(self, campsites: List[AvailableCampsite], **kwargs):\n\"\"\"\n    Send a message with a campsite object\n    Parameters\n    ----------\n    campsites: AvailableCampsite\n    \"\"\"\nfor campsite in campsites:\nmessage_title, formatted_dict = self.format_standard_campsites(\ncampsite=campsite,\n)\nfields = []\nfor key, value in formatted_dict.items():\nfields.append(\n{\n\"type\": \"mrkdwn\",\n\"text\": f\"*{key}*\",\n}\n)\nif key in [\"Permitted Equipment\", \"Booking Link\"]:\ndata_type = \"mrkdwn\"\nelse:\ndata_type = \"plain_text\"\nfields.append(\n{\n\"type\": data_type,\n\"text\": str(value),\n}\n)\nblocks = []\nblocks.append(\n{\n\"type\": \"header\",\n\"text\": {\n\"type\": \"plain_text\",\n\"text\": message_title,\n},\n}\n)\n# Slack only allows 10 fields (k+v) per section\nfor chunk in range(0, len(fields) + 1, 10):\nchunk_max = chunk + 10\nblocks.append(\n{\n\"type\": \"section\",\n\"fields\": fields[chunk:chunk_max],\n}\n)\nself.send_message(\nmessage=message_title,\nblocks=blocks,\n)\n</code></pre>"},{"location":"reference/notifications/#camply.notifications.slack.SlackNotifications.send_message","title":"<code>send_message(message, **kwargs)</code>","text":"<p>Send a message via Slack - if environment variables are configured.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> required <p>Returns:</p> Type Description <code>requests.Response</code> Source code in <code>camply/notifications/slack.py</code> <pre><code>def send_message(self, message: str, **kwargs) -&gt; requests.Response:\n\"\"\"\n    Send a message via Slack - if environment variables are configured.\n    Parameters\n    ----------\n    message: str\n    Returns\n    -------\n    requests.Response\n    \"\"\"\nmessage_blocks = kwargs.pop(\"blocks\", [])\nmessage_json = {\n\"text\": message,\n}\nif message_blocks:\nmessage_json = {\n\"blocks\": message_blocks,\n}\nlogger.debug(message_json)\nresponse = self.session.post(\nurl=SlackConfig.SLACK_WEBHOOK,\njson=message_json,\n)\ntry:\nresponse.raise_for_status()\nexcept requests.HTTPError as he:\nlogger.warning(\n\"Notifications weren't able to be sent to Slack. \"\n\"Your configuration might be incorrect.\"\n)\nraise ConnectionError(response.text) from he\nreturn response\n</code></pre>"},{"location":"reference/notifications/#camply.notifications.TelegramNotifications","title":"<code>TelegramNotifications</code>","text":"<p>         Bases: <code>BaseNotifications</code></p> <p>Push Notifications via Telegram</p> Source code in <code>camply/notifications/telegram.py</code> <pre><code>class TelegramNotifications(BaseNotifications):\n\"\"\"\n    Push Notifications via Telegram\n    \"\"\"\ndef __init__(self):\nsuper().__init__()\nself.session.headers.update(TelegramConfig.API_HEADERS)\nif any(\n[\nTelegramConfig.BOT_TOKEN is None,\nTelegramConfig.BOT_TOKEN == \"\",\nTelegramConfig.CHAT_ID is None,\nTelegramConfig.CHAT_ID == \"\",\n]\n):\nwarning_message = (\n\"Telegram is not configured properly. To send Telegram messages \"\n\"make sure to run `camply configure` or set the \"\n\"proper environment variables: `TELEGRAM_BOT_TOKEN` and `TELEGRAM_CHAT_ID`.\"\n)\nlogger.error(warning_message)\nraise EnvironmentError(warning_message)\ndef send_message(self, message: str, escaped=False, **kwargs) -&gt; requests.Response:\n\"\"\"\n        Send a message via Telegram - if environment variables are configured\n        Parameters\n        ----------\n        message: str\n        escaped: bool\n        Returns\n        -------\n        requests.Response\n        \"\"\"\nif not escaped:\nmessage = self.escape_text(message)\nmessage_json = TelegramConfig.API_CONTENT.copy()\nmessage_json.update({\"text\": message})\nlogger.debug(message_json)\nresponse = self.session.post(url=TelegramConfig.API_ENDPOINT, json=message_json)\ntry:\nresponse.raise_for_status()\nexcept requests.HTTPError as he:\nlogger.warning(\n\"Notifications weren't able to be sent to Telegram. \"\n\"Your configuration might be incorrect.\"\n)\nraise ConnectionError(response.text) from he\nreturn response\n@staticmethod\ndef escape_text(message: str) -&gt; str:\n\"\"\"\n        Escape a message for use in Telegram\n        Parameters\n        ----------\n        message: str\n        Returns\n        -------\n        String\n        \"\"\"\nfields = [\n\"_\",\n\"*\",\n\"[\",\n\"]\",\n\"(\",\n\")\",\n\"~\",\n\"`\",\n\"&gt;\",\n\"#\",\n\"+\",\n\"-\",\n\"=\",\n\"|\",\n\"{\",\n\"}\",\n\".\",\n\"!\",\n]\nfor f in fields:\nmessage = message.replace(f, f\"\\\\{f}\")\nreturn message\ndef send_campsites(self, campsites: List[AvailableCampsite], **kwargs):\n\"\"\"\n        Send a message with a campsite object\n        Parameters\n        ----------\n        campsites: AvailableCampsite\n        \"\"\"\nfor campsite in campsites:\nmessage_title, formatted_dict = self.format_standard_campsites(\ncampsite=campsite,\n)\nfields = []\nfor key, value in formatted_dict.items():\nfields.append(self.escape_text(f\"{key}: {value}\"))\nmessage_fields = \"\\n\".join(fields)\nmessage = f\"*{self.escape_text(message_title)}*\\n{message_fields}\"\nself.send_message(message, escaped=True)\n</code></pre>"},{"location":"reference/notifications/#camply.notifications.telegram.TelegramNotifications.escape_text","title":"<code>escape_text(message)</code>  <code>staticmethod</code>","text":"<p>Escape a message for use in Telegram</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> required <p>Returns:</p> Type Description <code>String</code> Source code in <code>camply/notifications/telegram.py</code> <pre><code>@staticmethod\ndef escape_text(message: str) -&gt; str:\n\"\"\"\n    Escape a message for use in Telegram\n    Parameters\n    ----------\n    message: str\n    Returns\n    -------\n    String\n    \"\"\"\nfields = [\n\"_\",\n\"*\",\n\"[\",\n\"]\",\n\"(\",\n\")\",\n\"~\",\n\"`\",\n\"&gt;\",\n\"#\",\n\"+\",\n\"-\",\n\"=\",\n\"|\",\n\"{\",\n\"}\",\n\".\",\n\"!\",\n]\nfor f in fields:\nmessage = message.replace(f, f\"\\\\{f}\")\nreturn message\n</code></pre>"},{"location":"reference/notifications/#camply.notifications.telegram.TelegramNotifications.send_campsites","title":"<code>send_campsites(campsites, **kwargs)</code>","text":"<p>Send a message with a campsite object</p> <p>Parameters:</p> Name Type Description Default <code>campsites</code> <code>List[AvailableCampsite]</code> required Source code in <code>camply/notifications/telegram.py</code> <pre><code>def send_campsites(self, campsites: List[AvailableCampsite], **kwargs):\n\"\"\"\n    Send a message with a campsite object\n    Parameters\n    ----------\n    campsites: AvailableCampsite\n    \"\"\"\nfor campsite in campsites:\nmessage_title, formatted_dict = self.format_standard_campsites(\ncampsite=campsite,\n)\nfields = []\nfor key, value in formatted_dict.items():\nfields.append(self.escape_text(f\"{key}: {value}\"))\nmessage_fields = \"\\n\".join(fields)\nmessage = f\"*{self.escape_text(message_title)}*\\n{message_fields}\"\nself.send_message(message, escaped=True)\n</code></pre>"},{"location":"reference/notifications/#camply.notifications.telegram.TelegramNotifications.send_message","title":"<code>send_message(message, escaped=False, **kwargs)</code>","text":"<p>Send a message via Telegram - if environment variables are configured</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> required <code>escaped</code> <code>False</code> <p>Returns:</p> Type Description <code>requests.Response</code> Source code in <code>camply/notifications/telegram.py</code> <pre><code>def send_message(self, message: str, escaped=False, **kwargs) -&gt; requests.Response:\n\"\"\"\n    Send a message via Telegram - if environment variables are configured\n    Parameters\n    ----------\n    message: str\n    escaped: bool\n    Returns\n    -------\n    requests.Response\n    \"\"\"\nif not escaped:\nmessage = self.escape_text(message)\nmessage_json = TelegramConfig.API_CONTENT.copy()\nmessage_json.update({\"text\": message})\nlogger.debug(message_json)\nresponse = self.session.post(url=TelegramConfig.API_ENDPOINT, json=message_json)\ntry:\nresponse.raise_for_status()\nexcept requests.HTTPError as he:\nlogger.warning(\n\"Notifications weren't able to be sent to Telegram. \"\n\"Your configuration might be incorrect.\"\n)\nraise ConnectionError(response.text) from he\nreturn response\n</code></pre>"},{"location":"reference/notifications/#camply.notifications.TwilioNotifications","title":"<code>TwilioNotifications</code>","text":"<p>         Bases: <code>BaseNotifications</code></p> <p>Push Notifications via Twilio</p> Source code in <code>camply/notifications/twilio.py</code> <pre><code>class TwilioNotifications(BaseNotifications):\n\"\"\"\n    Push Notifications via Twilio\n    \"\"\"\ndef __init__(self):\nsuper().__init__()\ntry:\nfrom twilio.rest import Client\nexcept ImportError as ie:\nraise RuntimeError(\n\"Looks like `twilio` isn't installed. Install it with `pip install camply[twilio]`\"\n) from ie\nif any(\n[\nTwilioConfig.ACCOUNT_SID is None,\nTwilioConfig.ACCOUNT_SID == \"\",\nTwilioConfig.AUTH_TOKEN is None,\nTwilioConfig.AUTH_TOKEN == \"\",\n]\n):\nwarning_message = (\n\"Twilio is not configured properly. To send Twilio messages \"\n\"make sure to run `camply configure` or set the \"\n\"proper environment variable: `TWILIO_ACCOUNT_SID`, `TWILIO_AUTH_TOKEN`.\"\n)\nlogger.error(warning_message)\nraise EnvironmentError(warning_message)\nself.client = Client(TwilioConfig.ACCOUNT_SID, TwilioConfig.AUTH_TOKEN)\nself.phone_nums = TwilioConfig.DEST_NUMBERS.split(\",\")\nlogger.info(\n\"Twilio: will notify these phone numbers: \" + \", \".join(self.phone_nums)\n)\ndef send_message(self, message: str, **kwargs):\n\"\"\"\n        Send a message via Twilio - if environment variables are configured\n        Parameters\n        ----------\n        message: str\n        \"\"\"\nfor phone_num in self.phone_nums:\nself.client.messages.create(\nto=phone_num, from_=TwilioConfig.SOURCE_NUMBER, body=message\n)\ndef send_campsites(self, campsites: List[AvailableCampsite], **kwargs):\n\"\"\"\n        Send a message with a campsite object\n        Parameters\n        ----------\n        campsites: AvailableCampsite\n        \"\"\"\nfor campsite in campsites:\nmessage_title, formatted_dict = self.format_standard_campsites(\ncampsite=campsite,\n)\nfields = [f\"\ud83c\udfd5{message_title}\", \"\"]\nfor key, value in formatted_dict.items():\nfields.append(f\"{key}: {value}\")\nfields.append(\"\")\nfields.append(\"camply, the campsite finder \u26fa\ufe0f\")\ncomposed_message = \"\\n\".join(fields)\nself.send_message(message=composed_message)\n</code></pre>"},{"location":"reference/notifications/#camply.notifications.twilio.TwilioNotifications.send_campsites","title":"<code>send_campsites(campsites, **kwargs)</code>","text":"<p>Send a message with a campsite object</p> <p>Parameters:</p> Name Type Description Default <code>campsites</code> <code>List[AvailableCampsite]</code> required Source code in <code>camply/notifications/twilio.py</code> <pre><code>def send_campsites(self, campsites: List[AvailableCampsite], **kwargs):\n\"\"\"\n    Send a message with a campsite object\n    Parameters\n    ----------\n    campsites: AvailableCampsite\n    \"\"\"\nfor campsite in campsites:\nmessage_title, formatted_dict = self.format_standard_campsites(\ncampsite=campsite,\n)\nfields = [f\"\ud83c\udfd5{message_title}\", \"\"]\nfor key, value in formatted_dict.items():\nfields.append(f\"{key}: {value}\")\nfields.append(\"\")\nfields.append(\"camply, the campsite finder \u26fa\ufe0f\")\ncomposed_message = \"\\n\".join(fields)\nself.send_message(message=composed_message)\n</code></pre>"},{"location":"reference/notifications/#camply.notifications.twilio.TwilioNotifications.send_message","title":"<code>send_message(message, **kwargs)</code>","text":"<p>Send a message via Twilio - if environment variables are configured</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> required Source code in <code>camply/notifications/twilio.py</code> <pre><code>def send_message(self, message: str, **kwargs):\n\"\"\"\n    Send a message via Twilio - if environment variables are configured\n    Parameters\n    ----------\n    message: str\n    \"\"\"\nfor phone_num in self.phone_nums:\nself.client.messages.create(\nto=phone_num, from_=TwilioConfig.SOURCE_NUMBER, body=message\n)\n</code></pre>"},{"location":"reference/notifications/apprise/","title":"apprise","text":"<p>Push Notifications via Apprise</p>"},{"location":"reference/notifications/apprise/#camply.notifications.apprise.AppriseNotifications","title":"<code>AppriseNotifications</code>","text":"<p>         Bases: <code>BaseNotifications</code></p> <p>Push Notifications via Apprise</p> Source code in <code>camply/notifications/apprise.py</code> <pre><code>class AppriseNotifications(BaseNotifications):\n\"\"\"\n    Push Notifications via Apprise\n    \"\"\"\ndef __init__(self):\nsuper().__init__()\ntry:\nimport apprise\nexcept ImportError as ie:\nraise RuntimeError(\n\"Looks like `apprise` isn't installed. Install it with `pip install camply[apprise]`\"\n) from ie\nif any(\n[\nAppriseConfig.APPRISE_URL is None,\n]\n):\nwarning_message = (\n\"Apprise is not configured properly. To send Apprise notifications \"\n\"make sure to run `camply configure` or set the \"\n\"proper environment variable: `APPRISE_URL`.\"\n)\nlogger.error(warning_message)\nraise EnvironmentError(warning_message)\nself.client = apprise.Apprise()\nself.client.add(AppriseConfig.APPRISE_URL)\nlogger.info(\"Apprise: will notify specified URL\")\ndef send_message(self, message: str, **kwargs):\n\"\"\"\n        Send a message via Apprise - if environment variables are configured\n        Parameters\n        ----------\n        message: str\n        \"\"\"\nself.client.notify(\nbody=message,\ntitle=\"Camply Notification\",\n)\ndef send_campsites(self, campsites: List[AvailableCampsite], **kwargs):\n\"\"\"\n        Send a message with a campsite object\n        Parameters\n        ----------\n        campsites: AvailableCampsite\n        \"\"\"\nfor campsite in campsites:\nmessage_title, formatted_dict = self.format_standard_campsites(\ncampsite=campsite,\n)\nfields = [f\"\ud83c\udfd5{message_title}\", \"\"]\nfor key, value in formatted_dict.items():\nfields.append(f\"{key}: {value}\")\nfields.append(\"\")\nfields.append(\"camply, the campsite finder \u26fa\ufe0f\")\ncomposed_message = \"\\n\".join(fields)\nself.send_message(message=composed_message)\n</code></pre>"},{"location":"reference/notifications/apprise/#camply.notifications.apprise.AppriseNotifications.send_campsites","title":"<code>send_campsites(campsites, **kwargs)</code>","text":"<p>Send a message with a campsite object</p> <p>Parameters:</p> Name Type Description Default <code>campsites</code> <code>List[AvailableCampsite]</code> required Source code in <code>camply/notifications/apprise.py</code> <pre><code>def send_campsites(self, campsites: List[AvailableCampsite], **kwargs):\n\"\"\"\n    Send a message with a campsite object\n    Parameters\n    ----------\n    campsites: AvailableCampsite\n    \"\"\"\nfor campsite in campsites:\nmessage_title, formatted_dict = self.format_standard_campsites(\ncampsite=campsite,\n)\nfields = [f\"\ud83c\udfd5{message_title}\", \"\"]\nfor key, value in formatted_dict.items():\nfields.append(f\"{key}: {value}\")\nfields.append(\"\")\nfields.append(\"camply, the campsite finder \u26fa\ufe0f\")\ncomposed_message = \"\\n\".join(fields)\nself.send_message(message=composed_message)\n</code></pre>"},{"location":"reference/notifications/apprise/#camply.notifications.apprise.AppriseNotifications.send_message","title":"<code>send_message(message, **kwargs)</code>","text":"<p>Send a message via Apprise - if environment variables are configured</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> required Source code in <code>camply/notifications/apprise.py</code> <pre><code>def send_message(self, message: str, **kwargs):\n\"\"\"\n    Send a message via Apprise - if environment variables are configured\n    Parameters\n    ----------\n    message: str\n    \"\"\"\nself.client.notify(\nbody=message,\ntitle=\"Camply Notification\",\n)\n</code></pre>"},{"location":"reference/notifications/base_notifications/","title":"base_notifications","text":"<p>Push Notifications Template</p>"},{"location":"reference/notifications/base_notifications/#camply.notifications.base_notifications.BaseNotifications","title":"<code>BaseNotifications</code>","text":"<p>         Bases: <code>ABC</code></p> <p>Base Notifications</p> Source code in <code>camply/notifications/base_notifications.py</code> <pre><code>class BaseNotifications(ABC):\n\"\"\"\n    Base Notifications\n    \"\"\"\ndef __init__(self) -&gt; None:\n\"\"\"\n        Instantiate with a Requests Session\n        \"\"\"\nself.session = requests.Session()\ndef __repr__(self) -&gt; str:\n\"\"\"\n        String Representation\n        \"\"\"\nreturn f\"&lt;{self.__class__.__name__}&gt;\"\n@abstractmethod\ndef send_message(self, message: str, **kwargs):\n\"\"\"\n        Send a message\n        Parameters\n        ----------\n        message: str\n            Message Text\n        **kwargs\n            All kwargs passed to underlying notification method\n        \"\"\"\npass\n@abstractmethod\ndef send_campsites(self, campsites: List[AvailableCampsite], **kwargs):\n\"\"\"\n        Send a message with a campsite object\n        Parameters\n        ----------\n        campsites: List[AvailableCampsite]\n        \"\"\"\npass\n@classmethod\ndef format_standard_campsites(\ncls, campsite: AvailableCampsite\n) -&gt; Tuple[str, Dict[str, str]]:\n\"\"\"\n        Format Standard Message\n        \"\"\"\nfields = {}\nmessage_title = \" | \".join(\n[\ncampsite.recreation_area,\ncampsite.facility_name,\ncampsite.booking_date.strftime(\"%Y-%m-%d\"),\n]\n)\nfor key, value in campsite.dict().items():\nif key in [\nCampsiteContainerFields.BOOKING_DATE,\nCampsiteContainerFields.BOOKING_END_DATE,\n]:\nvalue: datetime.date\nvalue: str = value.strftime(\"%Y-%m-%d\")\nelif key == CampsiteContainerFields.BOOKING_URL:\nkey = \"booking_link\"\nelif key == CampsiteContainerFields.PERMITTED_EQUIPMENT:\nequipment = (\n[]\nif campsite.permitted_equipment is None\nelse campsite.permitted_equipment\n)\nvalue = \"\\n  - \" + \"\\n  - \".join(\n{item.equipment_name for item in equipment}\n)\nif key not in [CampsiteContainerFields.CAMPSITE_ATTRIBUTES]:\nformatted_key = key.replace(\"_\", \" \").title()\nfields[formatted_key] = value\nreturn message_title, fields\n</code></pre>"},{"location":"reference/notifications/base_notifications/#camply.notifications.base_notifications.BaseNotifications.__init__","title":"<code>__init__()</code>","text":"<p>Instantiate with a Requests Session</p> Source code in <code>camply/notifications/base_notifications.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"\n    Instantiate with a Requests Session\n    \"\"\"\nself.session = requests.Session()\n</code></pre>"},{"location":"reference/notifications/base_notifications/#camply.notifications.base_notifications.BaseNotifications.__repr__","title":"<code>__repr__()</code>","text":"<p>String Representation</p> Source code in <code>camply/notifications/base_notifications.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"\n    String Representation\n    \"\"\"\nreturn f\"&lt;{self.__class__.__name__}&gt;\"\n</code></pre>"},{"location":"reference/notifications/base_notifications/#camply.notifications.base_notifications.BaseNotifications.format_standard_campsites","title":"<code>format_standard_campsites(campsite)</code>  <code>classmethod</code>","text":"<p>Format Standard Message</p> Source code in <code>camply/notifications/base_notifications.py</code> <pre><code>@classmethod\ndef format_standard_campsites(\ncls, campsite: AvailableCampsite\n) -&gt; Tuple[str, Dict[str, str]]:\n\"\"\"\n    Format Standard Message\n    \"\"\"\nfields = {}\nmessage_title = \" | \".join(\n[\ncampsite.recreation_area,\ncampsite.facility_name,\ncampsite.booking_date.strftime(\"%Y-%m-%d\"),\n]\n)\nfor key, value in campsite.dict().items():\nif key in [\nCampsiteContainerFields.BOOKING_DATE,\nCampsiteContainerFields.BOOKING_END_DATE,\n]:\nvalue: datetime.date\nvalue: str = value.strftime(\"%Y-%m-%d\")\nelif key == CampsiteContainerFields.BOOKING_URL:\nkey = \"booking_link\"\nelif key == CampsiteContainerFields.PERMITTED_EQUIPMENT:\nequipment = (\n[]\nif campsite.permitted_equipment is None\nelse campsite.permitted_equipment\n)\nvalue = \"\\n  - \" + \"\\n  - \".join(\n{item.equipment_name for item in equipment}\n)\nif key not in [CampsiteContainerFields.CAMPSITE_ATTRIBUTES]:\nformatted_key = key.replace(\"_\", \" \").title()\nfields[formatted_key] = value\nreturn message_title, fields\n</code></pre>"},{"location":"reference/notifications/base_notifications/#camply.notifications.base_notifications.BaseNotifications.send_campsites","title":"<code>send_campsites(campsites, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Send a message with a campsite object</p> <p>Parameters:</p> Name Type Description Default <code>campsites</code> <code>List[AvailableCampsite]</code> required Source code in <code>camply/notifications/base_notifications.py</code> <pre><code>@abstractmethod\ndef send_campsites(self, campsites: List[AvailableCampsite], **kwargs):\n\"\"\"\n    Send a message with a campsite object\n    Parameters\n    ----------\n    campsites: List[AvailableCampsite]\n    \"\"\"\npass\n</code></pre>"},{"location":"reference/notifications/base_notifications/#camply.notifications.base_notifications.BaseNotifications.send_message","title":"<code>send_message(message, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Send a message</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Message Text</p> required <code>**kwargs</code> <p>All kwargs passed to underlying notification method</p> <code>{}</code> Source code in <code>camply/notifications/base_notifications.py</code> <pre><code>@abstractmethod\ndef send_message(self, message: str, **kwargs):\n\"\"\"\n    Send a message\n    Parameters\n    ----------\n    message: str\n        Message Text\n    **kwargs\n        All kwargs passed to underlying notification method\n    \"\"\"\npass\n</code></pre>"},{"location":"reference/notifications/base_notifications/#camply.notifications.base_notifications.NotificationError","title":"<code>NotificationError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Notification Exceptions</p> Source code in <code>camply/notifications/base_notifications.py</code> <pre><code>class NotificationError(Exception):\n\"\"\"\n    Notification Exceptions\n    \"\"\"\n</code></pre>"},{"location":"reference/notifications/email_notifications/","title":"email_notifications","text":"<p>Push Notifications via Pushover</p>"},{"location":"reference/notifications/email_notifications/#camply.notifications.email_notifications.EmailNotifications","title":"<code>EmailNotifications</code>","text":"<p>         Bases: <code>BaseNotifications</code></p> <p>Notifications via Email</p> Source code in <code>camply/notifications/email_notifications.py</code> <pre><code>class EmailNotifications(BaseNotifications):\n\"\"\"\n    Notifications via Email\n    \"\"\"\nemail_subject = EmailConfig.EMAIL_SUBJECT_LINE\nemail_from = EmailConfig.EMAIL_FROM_ADDRESS\nemail_to = EmailConfig.EMAIL_TO_ADDRESS\nemail_username = EmailConfig.EMAIL_USERNAME\n_email_password = EmailConfig.EMAIL_PASSWORD\nemail_smtp_server = EmailConfig.EMAIL_SMTP_SERVER\nemail_smtp_server_port = EmailConfig.EMAIL_SMTP_PORT\ndef __init__(self):\n\"\"\"\n        Data Validation\n        **kwargs\n            Accepts: from, to, subject, username, password, server, port\n        \"\"\"\nsuper().__init__()\n# PERFORM SOME VALIDATION\nif any(\n[\nEmailConfig.EMAIL_TO_ADDRESS in [None, \"\"],\nEmailConfig.EMAIL_USERNAME in [None, \"\"],\nEmailConfig.EMAIL_PASSWORD in [None, \"\"],\n]\n):\nvariable_names = \"\\n\\t\".join(EmailConfig.ENVIRONMENT_VARIABLE_NAMES)\noptional_variable_names = \"\\n\\t\".join(\nEmailConfig.OPTIONAL_ENVIRONMENT_VARIABLE\n)\nerror_message = (\n\"Email Notification Auth Parameters not set. Run `camply configure` \"\nf\"or set the following Environment Variables:\\n\\t{variable_names}\"\n\"\\nOptional Environment Variables:\\n\\t\"\nf\"{optional_variable_names}\"\n)\nlogger.error(error_message)\nraise EnvironmentError(error_message)\n# ATTEMPT AN EMAIL LOGIN AT INIT TO THROW ERRORS EARLY\n_email_server = SMTP_SSL(\nself.email_smtp_server,\nself.email_smtp_server_port,\n)\n_email_server.ehlo()\n_email_server.login(\nuser=self.email_username,\npassword=self._email_password,\n)\n_email_server.quit()\ndef send_message(self, message: str, **kwargs) -&gt; None:\n\"\"\"\n        Send a message via Email\n        Parameters\n        ----------\n        message: str\n            Email Body\n        **kwargs\n            Accepts: from, to, subject, username, password, server, port\n        Returns\n        -------\n        object\n        \"\"\"\nemail = EmailMessage()\nemail.set_content(message)\nemail[\"Subject\"] = kwargs.get(\"subject\", self.email_subject)\nemail[\"From\"] = kwargs.get(\"from\", self.email_from)\nemail[\"To\"] = kwargs.get(\"to\", self.email_to)\nemail_server_user = kwargs.get(\"username\", self.email_username)\nemail_server_password = kwargs.get(\"password\", self._email_password)\nemail_server_smtp_server = kwargs.get(\"server\", self.email_smtp_server)\nemail_server_smtp_server_port = kwargs.get(\"port\", self.email_smtp_server_port)\nemail_server = SMTP_SSL(email_server_smtp_server, email_server_smtp_server_port)\nemail_server.ehlo()\nemail_server.login(user=email_server_user, password=email_server_password)\nlogger.info(f\"Sending Email to {email['To']}: {email['Subject']}\")\nemail_server.send_message(email)\nlogger.info(\"Email sent successfully\")\nemail_server.quit()\ndef send_campsites(self, campsites: List[AvailableCampsite], **kwargs) -&gt; None:\n\"\"\"\n        Send a message with a campsite object\n        Parameters\n        ----------\n        campsites: List[AvailableCampsite]\n        \"\"\"\nmaster_email_body_list = []\nfor campsite in campsites:\nmessage_title, formatted_dict = self.format_standard_campsites(\ncampsite=campsite,\n)\nfields = [message_title]\nfor key, value in formatted_dict.items():\nif key == \"Permitted Equipment\":\nvalue = value.replace(\"\\n  - \", \"\\n  \\t  - \")\nfields.append(f\"\\t{key}: {value}\")\ncomposed_message = \"\\n\".join(fields) + \"\\n\\n\"\nmaster_email_body_list.append(composed_message)\nmaster_email_body = \"\\n\".join(master_email_body_list)\nif len(campsites) &gt; 0:\nself.send_message(message=master_email_body)\n</code></pre>"},{"location":"reference/notifications/email_notifications/#camply.notifications.email_notifications.EmailNotifications.__init__","title":"<code>__init__()</code>","text":"<p>Data Validation</p> <p>**kwargs     Accepts: from, to, subject, username, password, server, port</p> Source code in <code>camply/notifications/email_notifications.py</code> <pre><code>def __init__(self):\n\"\"\"\n    Data Validation\n    **kwargs\n        Accepts: from, to, subject, username, password, server, port\n    \"\"\"\nsuper().__init__()\n# PERFORM SOME VALIDATION\nif any(\n[\nEmailConfig.EMAIL_TO_ADDRESS in [None, \"\"],\nEmailConfig.EMAIL_USERNAME in [None, \"\"],\nEmailConfig.EMAIL_PASSWORD in [None, \"\"],\n]\n):\nvariable_names = \"\\n\\t\".join(EmailConfig.ENVIRONMENT_VARIABLE_NAMES)\noptional_variable_names = \"\\n\\t\".join(\nEmailConfig.OPTIONAL_ENVIRONMENT_VARIABLE\n)\nerror_message = (\n\"Email Notification Auth Parameters not set. Run `camply configure` \"\nf\"or set the following Environment Variables:\\n\\t{variable_names}\"\n\"\\nOptional Environment Variables:\\n\\t\"\nf\"{optional_variable_names}\"\n)\nlogger.error(error_message)\nraise EnvironmentError(error_message)\n# ATTEMPT AN EMAIL LOGIN AT INIT TO THROW ERRORS EARLY\n_email_server = SMTP_SSL(\nself.email_smtp_server,\nself.email_smtp_server_port,\n)\n_email_server.ehlo()\n_email_server.login(\nuser=self.email_username,\npassword=self._email_password,\n)\n_email_server.quit()\n</code></pre>"},{"location":"reference/notifications/email_notifications/#camply.notifications.email_notifications.EmailNotifications.send_campsites","title":"<code>send_campsites(campsites, **kwargs)</code>","text":"<p>Send a message with a campsite object</p> <p>Parameters:</p> Name Type Description Default <code>campsites</code> <code>List[AvailableCampsite]</code> required Source code in <code>camply/notifications/email_notifications.py</code> <pre><code>def send_campsites(self, campsites: List[AvailableCampsite], **kwargs) -&gt; None:\n\"\"\"\n    Send a message with a campsite object\n    Parameters\n    ----------\n    campsites: List[AvailableCampsite]\n    \"\"\"\nmaster_email_body_list = []\nfor campsite in campsites:\nmessage_title, formatted_dict = self.format_standard_campsites(\ncampsite=campsite,\n)\nfields = [message_title]\nfor key, value in formatted_dict.items():\nif key == \"Permitted Equipment\":\nvalue = value.replace(\"\\n  - \", \"\\n  \\t  - \")\nfields.append(f\"\\t{key}: {value}\")\ncomposed_message = \"\\n\".join(fields) + \"\\n\\n\"\nmaster_email_body_list.append(composed_message)\nmaster_email_body = \"\\n\".join(master_email_body_list)\nif len(campsites) &gt; 0:\nself.send_message(message=master_email_body)\n</code></pre>"},{"location":"reference/notifications/email_notifications/#camply.notifications.email_notifications.EmailNotifications.send_message","title":"<code>send_message(message, **kwargs)</code>","text":"<p>Send a message via Email</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Email Body</p> required <code>**kwargs</code> <p>Accepts: from, to, subject, username, password, server, port</p> <code>{}</code> <p>Returns:</p> Type Description <code>object</code> Source code in <code>camply/notifications/email_notifications.py</code> <pre><code>def send_message(self, message: str, **kwargs) -&gt; None:\n\"\"\"\n    Send a message via Email\n    Parameters\n    ----------\n    message: str\n        Email Body\n    **kwargs\n        Accepts: from, to, subject, username, password, server, port\n    Returns\n    -------\n    object\n    \"\"\"\nemail = EmailMessage()\nemail.set_content(message)\nemail[\"Subject\"] = kwargs.get(\"subject\", self.email_subject)\nemail[\"From\"] = kwargs.get(\"from\", self.email_from)\nemail[\"To\"] = kwargs.get(\"to\", self.email_to)\nemail_server_user = kwargs.get(\"username\", self.email_username)\nemail_server_password = kwargs.get(\"password\", self._email_password)\nemail_server_smtp_server = kwargs.get(\"server\", self.email_smtp_server)\nemail_server_smtp_server_port = kwargs.get(\"port\", self.email_smtp_server_port)\nemail_server = SMTP_SSL(email_server_smtp_server, email_server_smtp_server_port)\nemail_server.ehlo()\nemail_server.login(user=email_server_user, password=email_server_password)\nlogger.info(f\"Sending Email to {email['To']}: {email['Subject']}\")\nemail_server.send_message(email)\nlogger.info(\"Email sent successfully\")\nemail_server.quit()\n</code></pre>"},{"location":"reference/notifications/multi_provider_notifications/","title":"multi_provider_notifications","text":"<p>Default Notifier: Silent + Extras</p>"},{"location":"reference/notifications/multi_provider_notifications/#camply.notifications.multi_provider_notifications.MultiNotifierProvider","title":"<code>MultiNotifierProvider</code>","text":"<p>         Bases: <code>BaseNotifications</code></p> <p>Notifications Supported from Multiple Providers</p> Source code in <code>camply/notifications/multi_provider_notifications.py</code> <pre><code>class MultiNotifierProvider(BaseNotifications):\n\"\"\"\n    Notifications Supported from Multiple Providers\n    \"\"\"\ndef __init__(self, provider: Union[str, List[str], BaseNotifications, None]):\n\"\"\"\n        Initialize with a Notifier Class Object, a string or list of strings\n        Parameters\n        ----------\n        provider: Union[str, List[str], BaseNotifications, None]\n            Provider String, Comma Separated Provider String, or list of provider\n            strings\n        \"\"\"\nsuper().__init__()\nself.providers = [SilentNotifications()]\nif isinstance(provider, str):\nprovider = [prov_string.strip() for prov_string in provider.split(\",\")]\nfor notifier_object in provider:\nif isinstance(notifier_object, BaseNotifications):\nnotifier = notifier_object\nelif isinstance(notifier_object, str):\nnotifier = CAMPSITE_NOTIFICATIONS.get(notifier_object.lower(), None)()\nelif notifier_object is None:\nnotifier = None\nelse:\nraise NotificationError(\n\"You must provide a proper Notification Identifier\"\n)\nif notifier is not None and not isinstance(notifier, SilentNotifications):\nself.providers.append(notifier)\ndef send_message(self, message: str, **kwargs):\n\"\"\"\n        Send a message\n        Parameters\n        ----------\n        message: str\n            Message Text\n        **kwargs\n            All kwargs passed to underlying notification method\n        \"\"\"\nfor provider in self.providers:\nprovider.send_message(message=message, **kwargs)\ndef send_campsites(self, campsites: List[AvailableCampsite], **kwargs):\n\"\"\"\n        Send a message with a campsite object\n        Parameters\n        ----------\n        campsites: List[AvailableCampsite]\n        \"\"\"\nfor provider in self.providers:\nprovider.send_campsites(campsites=campsites, **kwargs)\ndef log_providers(self) -&gt; None:\n\"\"\"\n        Log All Providers\n        Returns\n        -------\n        None\n        \"\"\"\nprovider_names = [str(provider) for provider in self.providers]\nlogger.info(f\"Notifications active via: {', '.join(provider_names)}\")\nif len(self.providers) == 1:\nlogger.info(\nf\"Only {self.providers[0]} enabled. \"\n\"I hope you're watching these logs.\"\n)\ndef last_gasp(self, error: Exception) -&gt; None:\n\"\"\"\n        Make a `last gasp` notification before exiting\n        Returns\n        -------\n        None\n        \"\"\"\nlogger.info(\"Exception encountered, emitting notification last gasp.\")\ndate_string = datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\nerror_string = str(error)\nerror_message = (\n\"camply encountered an error and exited \ud83d\ude1f \"\nf\"[{date_string}] - ({error.__class__.__name__}) {error_string}\"\n)\nfor provider in self.providers:\nprovider.send_message(error_message)\nraise RuntimeError(error_message) from error\n</code></pre>"},{"location":"reference/notifications/multi_provider_notifications/#camply.notifications.multi_provider_notifications.MultiNotifierProvider.__init__","title":"<code>__init__(provider)</code>","text":"<p>Initialize with a Notifier Class Object, a string or list of strings</p> <p>Parameters:</p> Name Type Description Default <code>provider</code> <code>Union[str, List[str], BaseNotifications, None]</code> <p>Provider String, Comma Separated Provider String, or list of provider strings</p> required Source code in <code>camply/notifications/multi_provider_notifications.py</code> <pre><code>def __init__(self, provider: Union[str, List[str], BaseNotifications, None]):\n\"\"\"\n    Initialize with a Notifier Class Object, a string or list of strings\n    Parameters\n    ----------\n    provider: Union[str, List[str], BaseNotifications, None]\n        Provider String, Comma Separated Provider String, or list of provider\n        strings\n    \"\"\"\nsuper().__init__()\nself.providers = [SilentNotifications()]\nif isinstance(provider, str):\nprovider = [prov_string.strip() for prov_string in provider.split(\",\")]\nfor notifier_object in provider:\nif isinstance(notifier_object, BaseNotifications):\nnotifier = notifier_object\nelif isinstance(notifier_object, str):\nnotifier = CAMPSITE_NOTIFICATIONS.get(notifier_object.lower(), None)()\nelif notifier_object is None:\nnotifier = None\nelse:\nraise NotificationError(\n\"You must provide a proper Notification Identifier\"\n)\nif notifier is not None and not isinstance(notifier, SilentNotifications):\nself.providers.append(notifier)\n</code></pre>"},{"location":"reference/notifications/multi_provider_notifications/#camply.notifications.multi_provider_notifications.MultiNotifierProvider.last_gasp","title":"<code>last_gasp(error)</code>","text":"<p>Make a <code>last gasp</code> notification before exiting</p> <p>Returns:</p> Type Description <code>None</code> Source code in <code>camply/notifications/multi_provider_notifications.py</code> <pre><code>def last_gasp(self, error: Exception) -&gt; None:\n\"\"\"\n    Make a `last gasp` notification before exiting\n    Returns\n    -------\n    None\n    \"\"\"\nlogger.info(\"Exception encountered, emitting notification last gasp.\")\ndate_string = datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\nerror_string = str(error)\nerror_message = (\n\"camply encountered an error and exited \ud83d\ude1f \"\nf\"[{date_string}] - ({error.__class__.__name__}) {error_string}\"\n)\nfor provider in self.providers:\nprovider.send_message(error_message)\nraise RuntimeError(error_message) from error\n</code></pre>"},{"location":"reference/notifications/multi_provider_notifications/#camply.notifications.multi_provider_notifications.MultiNotifierProvider.log_providers","title":"<code>log_providers()</code>","text":"<p>Log All Providers</p> <p>Returns:</p> Type Description <code>None</code> Source code in <code>camply/notifications/multi_provider_notifications.py</code> <pre><code>def log_providers(self) -&gt; None:\n\"\"\"\n    Log All Providers\n    Returns\n    -------\n    None\n    \"\"\"\nprovider_names = [str(provider) for provider in self.providers]\nlogger.info(f\"Notifications active via: {', '.join(provider_names)}\")\nif len(self.providers) == 1:\nlogger.info(\nf\"Only {self.providers[0]} enabled. \"\n\"I hope you're watching these logs.\"\n)\n</code></pre>"},{"location":"reference/notifications/multi_provider_notifications/#camply.notifications.multi_provider_notifications.MultiNotifierProvider.send_campsites","title":"<code>send_campsites(campsites, **kwargs)</code>","text":"<p>Send a message with a campsite object</p> <p>Parameters:</p> Name Type Description Default <code>campsites</code> <code>List[AvailableCampsite]</code> required Source code in <code>camply/notifications/multi_provider_notifications.py</code> <pre><code>def send_campsites(self, campsites: List[AvailableCampsite], **kwargs):\n\"\"\"\n    Send a message with a campsite object\n    Parameters\n    ----------\n    campsites: List[AvailableCampsite]\n    \"\"\"\nfor provider in self.providers:\nprovider.send_campsites(campsites=campsites, **kwargs)\n</code></pre>"},{"location":"reference/notifications/multi_provider_notifications/#camply.notifications.multi_provider_notifications.MultiNotifierProvider.send_message","title":"<code>send_message(message, **kwargs)</code>","text":"<p>Send a message</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Message Text</p> required <code>**kwargs</code> <p>All kwargs passed to underlying notification method</p> <code>{}</code> Source code in <code>camply/notifications/multi_provider_notifications.py</code> <pre><code>def send_message(self, message: str, **kwargs):\n\"\"\"\n    Send a message\n    Parameters\n    ----------\n    message: str\n        Message Text\n    **kwargs\n        All kwargs passed to underlying notification method\n    \"\"\"\nfor provider in self.providers:\nprovider.send_message(message=message, **kwargs)\n</code></pre>"},{"location":"reference/notifications/ntfy/","title":"ntfy","text":"<p>Push Notifications via ntfy.sh</p>"},{"location":"reference/notifications/ntfy/#camply.notifications.ntfy.NtfyNotifications","title":"<code>NtfyNotifications</code>","text":"<p>         Bases: <code>BaseNotifications</code></p> <p>Push Notifications via Ntfy</p> Source code in <code>camply/notifications/ntfy.py</code> <pre><code>class NtfyNotifications(BaseNotifications):\n\"\"\"\n    Push Notifications via Ntfy\n    \"\"\"\ndef __init__(self):\nsuper().__init__()\nif any([NtfyConfig.NTFY_TOPIC is None, NtfyConfig.NTFY_TOPIC == \"\"]):\nwarning_message = (\n\"Ntfy is not configured properly. To send Ntfy messages \"\n\"set the proper environment variable: `NTFY_TOPIC`.\"\n)\nlogger.error(warning_message)\nraise EnvironmentError(warning_message)\ndef send_message(self, message: str, **kwargs) -&gt; requests.Response:\n\"\"\"\n        Send a message via Ntfy - if environment variables are configured\n        Parameters\n        ----------\n        message: str\n        Returns\n        -------\n        requests.Response\n        \"\"\"\nresponse = self.session.post(\nurl=NtfyConfig.NTFY_API_ENDPOINT + NtfyConfig.NTFY_TOPIC,\ndata=message.encode(\"utf-8\"),\nheaders={\n\"Title\": kwargs.get(\"title\", \"Camply Notification\"),\n\"Click\": kwargs.get(\"url\", \"\"),\n},\n)\ntry:\nresponse.raise_for_status()\nexcept requests.HTTPError as he:\nlogger.warning(\n\"Notifications weren't able to be sent to Ntfy. \"\n\"Your configuration might be incorrect.\"\n)\nraise ConnectionError(response.text) from he\nreturn response\ndef send_campsites(self, campsites: List[AvailableCampsite], **kwargs):\n\"\"\"\n        Send a message with a campsite object\n        Parameters\n        ----------\n        campsites: AvailableCampsite\n        \"\"\"\nfor campsite in campsites:\nmessage_title, formatted_dict = self.format_standard_campsites(\ncampsite=campsite,\n)\nfields = []\nfor key, value in formatted_dict.items():\nfields.append(f\"{key}: {value}\")\ncomposed_message = \"\\n\".join(fields)\nself.send_message(\nmessage=composed_message,\ntitle=message_title,\nurl=formatted_dict.get(\"Booking Link\", \"\"),\n)\n</code></pre>"},{"location":"reference/notifications/ntfy/#camply.notifications.ntfy.NtfyNotifications.send_campsites","title":"<code>send_campsites(campsites, **kwargs)</code>","text":"<p>Send a message with a campsite object</p> <p>Parameters:</p> Name Type Description Default <code>campsites</code> <code>List[AvailableCampsite]</code> required Source code in <code>camply/notifications/ntfy.py</code> <pre><code>def send_campsites(self, campsites: List[AvailableCampsite], **kwargs):\n\"\"\"\n    Send a message with a campsite object\n    Parameters\n    ----------\n    campsites: AvailableCampsite\n    \"\"\"\nfor campsite in campsites:\nmessage_title, formatted_dict = self.format_standard_campsites(\ncampsite=campsite,\n)\nfields = []\nfor key, value in formatted_dict.items():\nfields.append(f\"{key}: {value}\")\ncomposed_message = \"\\n\".join(fields)\nself.send_message(\nmessage=composed_message,\ntitle=message_title,\nurl=formatted_dict.get(\"Booking Link\", \"\"),\n)\n</code></pre>"},{"location":"reference/notifications/ntfy/#camply.notifications.ntfy.NtfyNotifications.send_message","title":"<code>send_message(message, **kwargs)</code>","text":"<p>Send a message via Ntfy - if environment variables are configured</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> required <p>Returns:</p> Type Description <code>requests.Response</code> Source code in <code>camply/notifications/ntfy.py</code> <pre><code>def send_message(self, message: str, **kwargs) -&gt; requests.Response:\n\"\"\"\n    Send a message via Ntfy - if environment variables are configured\n    Parameters\n    ----------\n    message: str\n    Returns\n    -------\n    requests.Response\n    \"\"\"\nresponse = self.session.post(\nurl=NtfyConfig.NTFY_API_ENDPOINT + NtfyConfig.NTFY_TOPIC,\ndata=message.encode(\"utf-8\"),\nheaders={\n\"Title\": kwargs.get(\"title\", \"Camply Notification\"),\n\"Click\": kwargs.get(\"url\", \"\"),\n},\n)\ntry:\nresponse.raise_for_status()\nexcept requests.HTTPError as he:\nlogger.warning(\n\"Notifications weren't able to be sent to Ntfy. \"\n\"Your configuration might be incorrect.\"\n)\nraise ConnectionError(response.text) from he\nreturn response\n</code></pre>"},{"location":"reference/notifications/pushbullet/","title":"pushbullet","text":"<p>Push Notifications via Pushbullet</p>"},{"location":"reference/notifications/pushbullet/#camply.notifications.pushbullet.PushbulletNotifications","title":"<code>PushbulletNotifications</code>","text":"<p>         Bases: <code>BaseNotifications</code></p> <p>Push Notifications via PushBullet</p> Source code in <code>camply/notifications/pushbullet.py</code> <pre><code>class PushbulletNotifications(BaseNotifications):\n\"\"\"\n    Push Notifications via PushBullet\n    \"\"\"\ndef __init__(self):\nsuper().__init__()\npushbullet_headers = PushbulletConfig.API_HEADERS.copy()\npushbullet_headers.update({\"Access-Token\": PushbulletConfig.API_TOKEN})\nself.session.headers.update(pushbullet_headers)\nif any([PushbulletConfig.API_TOKEN is None, PushbulletConfig.API_TOKEN == \"\"]):\nwarning_message = (\n\"Pushbullet is not configured properly. To send Pushbullet messages \"\n\"make sure to run `camply configure` or set the \"\n\"proper environment variable: `PUSHBULLET_API_TOKEN`.\"\n)\nlogger.error(warning_message)\nraise EnvironmentError(warning_message)\ndef send_message(self, message: str, **kwargs) -&gt; requests.Response:\n\"\"\"\n        Send a message via PushBullet - if environment variables are configured\n        Parameters\n        ----------\n        message: str\n        Returns\n        -------\n        requests.Response\n        \"\"\"\nmessage_type = kwargs.pop(\"type\", \"note\")\nmessage_title = kwargs.pop(\"title\", \"Camply Notification\")\nmessage_json = dict(\ntype=message_type, title=message_title, body=message, **kwargs\n)\nlogger.debug(message_json)\nresponse = self.session.post(\nurl=PushbulletConfig.PUSHBULLET_API_ENDPOINT,\njson=message_json,\n)\ntry:\nresponse.raise_for_status()\nexcept requests.HTTPError as he:\nlogger.warning(\n\"Notifications weren't able to be sent to Pushbullet. \"\n\"Your configuration might be incorrect.\"\n)\nraise ConnectionError(response.text) from he\nreturn response\ndef send_campsites(self, campsites: List[AvailableCampsite], **kwargs):\n\"\"\"\n        Send a message with a campsite object\n        Parameters\n        ----------\n        campsites: AvailableCampsite\n        \"\"\"\nfor campsite in campsites:\nmessage_title, formatted_dict = self.format_standard_campsites(\ncampsite=campsite,\n)\nfields = []\nfor key, value in formatted_dict.items():\nfields.append(f\"{key}: {value}\")\ncomposed_message = \"\\n\".join(fields)\nself.send_message(\nmessage=composed_message, title=message_title, type=\"note\"\n)\n</code></pre>"},{"location":"reference/notifications/pushbullet/#camply.notifications.pushbullet.PushbulletNotifications.send_campsites","title":"<code>send_campsites(campsites, **kwargs)</code>","text":"<p>Send a message with a campsite object</p> <p>Parameters:</p> Name Type Description Default <code>campsites</code> <code>List[AvailableCampsite]</code> required Source code in <code>camply/notifications/pushbullet.py</code> <pre><code>def send_campsites(self, campsites: List[AvailableCampsite], **kwargs):\n\"\"\"\n    Send a message with a campsite object\n    Parameters\n    ----------\n    campsites: AvailableCampsite\n    \"\"\"\nfor campsite in campsites:\nmessage_title, formatted_dict = self.format_standard_campsites(\ncampsite=campsite,\n)\nfields = []\nfor key, value in formatted_dict.items():\nfields.append(f\"{key}: {value}\")\ncomposed_message = \"\\n\".join(fields)\nself.send_message(\nmessage=composed_message, title=message_title, type=\"note\"\n)\n</code></pre>"},{"location":"reference/notifications/pushbullet/#camply.notifications.pushbullet.PushbulletNotifications.send_message","title":"<code>send_message(message, **kwargs)</code>","text":"<p>Send a message via PushBullet - if environment variables are configured</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> required <p>Returns:</p> Type Description <code>requests.Response</code> Source code in <code>camply/notifications/pushbullet.py</code> <pre><code>def send_message(self, message: str, **kwargs) -&gt; requests.Response:\n\"\"\"\n    Send a message via PushBullet - if environment variables are configured\n    Parameters\n    ----------\n    message: str\n    Returns\n    -------\n    requests.Response\n    \"\"\"\nmessage_type = kwargs.pop(\"type\", \"note\")\nmessage_title = kwargs.pop(\"title\", \"Camply Notification\")\nmessage_json = dict(\ntype=message_type, title=message_title, body=message, **kwargs\n)\nlogger.debug(message_json)\nresponse = self.session.post(\nurl=PushbulletConfig.PUSHBULLET_API_ENDPOINT,\njson=message_json,\n)\ntry:\nresponse.raise_for_status()\nexcept requests.HTTPError as he:\nlogger.warning(\n\"Notifications weren't able to be sent to Pushbullet. \"\n\"Your configuration might be incorrect.\"\n)\nraise ConnectionError(response.text) from he\nreturn response\n</code></pre>"},{"location":"reference/notifications/pushover/","title":"pushover","text":"<p>Push Notifications via Pushover</p>"},{"location":"reference/notifications/pushover/#camply.notifications.pushover.PushoverNotifications","title":"<code>PushoverNotifications</code>","text":"<p>         Bases: <code>BaseNotifications</code>, <code>logging.StreamHandler</code></p> <p>Push Notifications via Pushover + a Logging Handler</p> Source code in <code>camply/notifications/pushover.py</code> <pre><code>class PushoverNotifications(BaseNotifications, logging.StreamHandler):\n\"\"\"\n    Push Notifications via Pushover + a Logging Handler\n    \"\"\"\ndef __init__(self, level: Optional[int] = logging.INFO):\nsuper().__init__()\nself.session.headers.update(PushoverConfig.API_HEADERS)\nlogging.StreamHandler.__init__(self)\nself.setLevel(level=level)\nif any([PushoverConfig.PUSH_USER is None, PushoverConfig.PUSH_USER == \"\"]):\nwarning_message = (\n\"Pushover is not configured properly. To send pushover messages \"\n\"make sure to run `camply configure` or set the \"\n\"proper environment variables: `PUSHOVER_PUSH_USER`, \"\n\"`PUSHOVER_PUSH_TOKEN`.\"\n)\nlogger.error(warning_message)\nraise EnvironmentError(warning_message)\ndef send_message(self, message: str, **kwargs) -&gt; requests.Response:\n\"\"\"\n        Send a message via Pushover - if environment variables are configured\n        Parameters\n        ----------\n        message: str\n        Returns\n        -------\n        requests.Response\n        \"\"\"\ntoken = (\nPushoverConfig.PUSH_TOKEN\nif PushoverConfig.PUSH_TOKEN not in [None, \"\"]\nelse base64.b64decode(PushoverConfig.PUSHOVER_DEFAULT_API_TOKEN).decode(\n\"utf-8\"\n)\n)\nresponse = self.session.post(\nurl=PushoverConfig.PUSHOVER_API_ENDPOINT,\nparams=dict(\ntoken=token, user=PushoverConfig.PUSH_USER, message=message, **kwargs\n),\n)\ntry:\nresponse.raise_for_status()\nexcept requests.HTTPError as he:\nlogger.warning(\n\"Notifications weren't able to be sent to Pushover. \"\n\"Your configuration might be incorrect.\"\n)\nraise ConnectionError(response.text) from he\nreturn response\ndef emit(self, record: logging.LogRecord):\n\"\"\"\n        Produce a logging record\n        Parameters\n        ----------\n        record: str\n            Message to log\n        \"\"\"\nlog_formatted_message = \"[{:&gt;10}]: {}\".format(\nrecord.levelname.upper(), record.msg\n)\ntitle = f\"Pushover {record.levelname.title()} Message\"\nself.send_message(message=log_formatted_message, title=title)\ndef send_campsites(self, campsites: List[AvailableCampsite], **kwargs):\n\"\"\"\n        Send a message with a campsite object\n        Parameters\n        ----------\n        campsites: AvailableCampsite\n        \"\"\"\nfor campsite in campsites:\nmessage_title, formatted_dict = self.format_standard_campsites(\ncampsite=campsite,\n)\nfields = []\nfor key, value in formatted_dict.items():\nif key == \"Booking Link\":\nvalue = f\"&lt;a href='{value}'&gt;{value}&lt;/a&gt;\"\nfields.append(f\"&lt;b&gt;{key}:&lt;/b&gt; {value}\")\ncomposed_message = \"\\n\".join(fields)\nself.send_message(message=composed_message, title=message_title, html=1)\n</code></pre>"},{"location":"reference/notifications/pushover/#camply.notifications.pushover.PushoverNotifications.emit","title":"<code>emit(record)</code>","text":"<p>Produce a logging record</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>logging.LogRecord</code> <p>Message to log</p> required Source code in <code>camply/notifications/pushover.py</code> <pre><code>def emit(self, record: logging.LogRecord):\n\"\"\"\n    Produce a logging record\n    Parameters\n    ----------\n    record: str\n        Message to log\n    \"\"\"\nlog_formatted_message = \"[{:&gt;10}]: {}\".format(\nrecord.levelname.upper(), record.msg\n)\ntitle = f\"Pushover {record.levelname.title()} Message\"\nself.send_message(message=log_formatted_message, title=title)\n</code></pre>"},{"location":"reference/notifications/pushover/#camply.notifications.pushover.PushoverNotifications.send_campsites","title":"<code>send_campsites(campsites, **kwargs)</code>","text":"<p>Send a message with a campsite object</p> <p>Parameters:</p> Name Type Description Default <code>campsites</code> <code>List[AvailableCampsite]</code> required Source code in <code>camply/notifications/pushover.py</code> <pre><code>def send_campsites(self, campsites: List[AvailableCampsite], **kwargs):\n\"\"\"\n    Send a message with a campsite object\n    Parameters\n    ----------\n    campsites: AvailableCampsite\n    \"\"\"\nfor campsite in campsites:\nmessage_title, formatted_dict = self.format_standard_campsites(\ncampsite=campsite,\n)\nfields = []\nfor key, value in formatted_dict.items():\nif key == \"Booking Link\":\nvalue = f\"&lt;a href='{value}'&gt;{value}&lt;/a&gt;\"\nfields.append(f\"&lt;b&gt;{key}:&lt;/b&gt; {value}\")\ncomposed_message = \"\\n\".join(fields)\nself.send_message(message=composed_message, title=message_title, html=1)\n</code></pre>"},{"location":"reference/notifications/pushover/#camply.notifications.pushover.PushoverNotifications.send_message","title":"<code>send_message(message, **kwargs)</code>","text":"<p>Send a message via Pushover - if environment variables are configured</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> required <p>Returns:</p> Type Description <code>requests.Response</code> Source code in <code>camply/notifications/pushover.py</code> <pre><code>def send_message(self, message: str, **kwargs) -&gt; requests.Response:\n\"\"\"\n    Send a message via Pushover - if environment variables are configured\n    Parameters\n    ----------\n    message: str\n    Returns\n    -------\n    requests.Response\n    \"\"\"\ntoken = (\nPushoverConfig.PUSH_TOKEN\nif PushoverConfig.PUSH_TOKEN not in [None, \"\"]\nelse base64.b64decode(PushoverConfig.PUSHOVER_DEFAULT_API_TOKEN).decode(\n\"utf-8\"\n)\n)\nresponse = self.session.post(\nurl=PushoverConfig.PUSHOVER_API_ENDPOINT,\nparams=dict(\ntoken=token, user=PushoverConfig.PUSH_USER, message=message, **kwargs\n),\n)\ntry:\nresponse.raise_for_status()\nexcept requests.HTTPError as he:\nlogger.warning(\n\"Notifications weren't able to be sent to Pushover. \"\n\"Your configuration might be incorrect.\"\n)\nraise ConnectionError(response.text) from he\nreturn response\n</code></pre>"},{"location":"reference/notifications/silent_notifications/","title":"silent_notifications","text":"<p>Silent Notifications</p>"},{"location":"reference/notifications/silent_notifications/#camply.notifications.silent_notifications.SilentNotifications","title":"<code>SilentNotifications</code>","text":"<p>         Bases: <code>BaseNotifications</code></p> <p>Silent Notifications</p> Source code in <code>camply/notifications/silent_notifications.py</code> <pre><code>class SilentNotifications(BaseNotifications):\n\"\"\"\n    Silent Notifications\n    \"\"\"\ndef send_message(self, message: str, **kwargs) -&gt; None:\n\"\"\"\n        Send a message via Email\n        Parameters\n        ----------\n        message: str\n            Email Body\n        **kwargs\n            kwargs are disregarded\n        Returns\n        -------\n        None\n        \"\"\"\nlogger.debug(f\"SilentNotification: {message}\")\ndef send_campsites(self, campsites: List[AvailableCampsite], **kwargs):\n\"\"\"\n        Send a message with a campsite object\n        Parameters\n        ----------\n        campsites: List[AvailableCampsite]\n        \"\"\"\nfor campsite in campsites:\ncampsite_tuple = (\n(\nf\"{campsite.booking_date.strftime('%Y-%m-%d')} - \"\nf\"{campsite.booking_end_date.strftime('%Y-%m-%d')}\"\n),\ncampsite.campsite_type,\ncampsite.campsite_site_name,\ncampsite.recreation_area,\ncampsite.facility_name,\ncampsite.booking_url,\n)\nmessage_string = \"\\n\\t\u2022 \" + \"\\n\\t\u2022 \".join(campsite_tuple)\nself.send_message(message_string)\ncampsite_formatted = pformat(campsite.dict())\nlogger.debug(\"Campsite Info: \" + campsite_formatted)\n</code></pre>"},{"location":"reference/notifications/silent_notifications/#camply.notifications.silent_notifications.SilentNotifications.send_campsites","title":"<code>send_campsites(campsites, **kwargs)</code>","text":"<p>Send a message with a campsite object</p> <p>Parameters:</p> Name Type Description Default <code>campsites</code> <code>List[AvailableCampsite]</code> required Source code in <code>camply/notifications/silent_notifications.py</code> <pre><code>def send_campsites(self, campsites: List[AvailableCampsite], **kwargs):\n\"\"\"\n    Send a message with a campsite object\n    Parameters\n    ----------\n    campsites: List[AvailableCampsite]\n    \"\"\"\nfor campsite in campsites:\ncampsite_tuple = (\n(\nf\"{campsite.booking_date.strftime('%Y-%m-%d')} - \"\nf\"{campsite.booking_end_date.strftime('%Y-%m-%d')}\"\n),\ncampsite.campsite_type,\ncampsite.campsite_site_name,\ncampsite.recreation_area,\ncampsite.facility_name,\ncampsite.booking_url,\n)\nmessage_string = \"\\n\\t\u2022 \" + \"\\n\\t\u2022 \".join(campsite_tuple)\nself.send_message(message_string)\ncampsite_formatted = pformat(campsite.dict())\nlogger.debug(\"Campsite Info: \" + campsite_formatted)\n</code></pre>"},{"location":"reference/notifications/silent_notifications/#camply.notifications.silent_notifications.SilentNotifications.send_message","title":"<code>send_message(message, **kwargs)</code>","text":"<p>Send a message via Email</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Email Body</p> required <code>**kwargs</code> <p>kwargs are disregarded</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> Source code in <code>camply/notifications/silent_notifications.py</code> <pre><code>def send_message(self, message: str, **kwargs) -&gt; None:\n\"\"\"\n    Send a message via Email\n    Parameters\n    ----------\n    message: str\n        Email Body\n    **kwargs\n        kwargs are disregarded\n    Returns\n    -------\n    None\n    \"\"\"\nlogger.debug(f\"SilentNotification: {message}\")\n</code></pre>"},{"location":"reference/notifications/slack/","title":"slack","text":"<p>Push Notifications via Slack</p>"},{"location":"reference/notifications/slack/#camply.notifications.slack.SlackNotifications","title":"<code>SlackNotifications</code>","text":"<p>         Bases: <code>BaseNotifications</code></p> <p>Push Notifications via Slack</p> Source code in <code>camply/notifications/slack.py</code> <pre><code>class SlackNotifications(BaseNotifications):\n\"\"\"\n    Push Notifications via Slack\n    \"\"\"\ndef __init__(self):\nsuper().__init__()\nself.session.headers.update({\"Content-Type\": \"application/json\"})\nif any([SlackConfig.SLACK_WEBHOOK is None, SlackConfig.SLACK_WEBHOOK == \"\"]):\nwarning_message = (\n\"Slack is not configured properly. To send Slack messages \"\n\"make sure to run `camply configure` or set the \"\n\"proper environment variable: `SLACK_WEBHOOK`.\"\n)\nlogger.error(warning_message)\nraise EnvironmentError(warning_message)\ndef send_message(self, message: str, **kwargs) -&gt; requests.Response:\n\"\"\"\n        Send a message via Slack - if environment variables are configured.\n        Parameters\n        ----------\n        message: str\n        Returns\n        -------\n        requests.Response\n        \"\"\"\nmessage_blocks = kwargs.pop(\"blocks\", [])\nmessage_json = {\n\"text\": message,\n}\nif message_blocks:\nmessage_json = {\n\"blocks\": message_blocks,\n}\nlogger.debug(message_json)\nresponse = self.session.post(\nurl=SlackConfig.SLACK_WEBHOOK,\njson=message_json,\n)\ntry:\nresponse.raise_for_status()\nexcept requests.HTTPError as he:\nlogger.warning(\n\"Notifications weren't able to be sent to Slack. \"\n\"Your configuration might be incorrect.\"\n)\nraise ConnectionError(response.text) from he\nreturn response\ndef send_campsites(self, campsites: List[AvailableCampsite], **kwargs):\n\"\"\"\n        Send a message with a campsite object\n        Parameters\n        ----------\n        campsites: AvailableCampsite\n        \"\"\"\nfor campsite in campsites:\nmessage_title, formatted_dict = self.format_standard_campsites(\ncampsite=campsite,\n)\nfields = []\nfor key, value in formatted_dict.items():\nfields.append(\n{\n\"type\": \"mrkdwn\",\n\"text\": f\"*{key}*\",\n}\n)\nif key in [\"Permitted Equipment\", \"Booking Link\"]:\ndata_type = \"mrkdwn\"\nelse:\ndata_type = \"plain_text\"\nfields.append(\n{\n\"type\": data_type,\n\"text\": str(value),\n}\n)\nblocks = []\nblocks.append(\n{\n\"type\": \"header\",\n\"text\": {\n\"type\": \"plain_text\",\n\"text\": message_title,\n},\n}\n)\n# Slack only allows 10 fields (k+v) per section\nfor chunk in range(0, len(fields) + 1, 10):\nchunk_max = chunk + 10\nblocks.append(\n{\n\"type\": \"section\",\n\"fields\": fields[chunk:chunk_max],\n}\n)\nself.send_message(\nmessage=message_title,\nblocks=blocks,\n)\n</code></pre>"},{"location":"reference/notifications/slack/#camply.notifications.slack.SlackNotifications.send_campsites","title":"<code>send_campsites(campsites, **kwargs)</code>","text":"<p>Send a message with a campsite object</p> <p>Parameters:</p> Name Type Description Default <code>campsites</code> <code>List[AvailableCampsite]</code> required Source code in <code>camply/notifications/slack.py</code> <pre><code>def send_campsites(self, campsites: List[AvailableCampsite], **kwargs):\n\"\"\"\n    Send a message with a campsite object\n    Parameters\n    ----------\n    campsites: AvailableCampsite\n    \"\"\"\nfor campsite in campsites:\nmessage_title, formatted_dict = self.format_standard_campsites(\ncampsite=campsite,\n)\nfields = []\nfor key, value in formatted_dict.items():\nfields.append(\n{\n\"type\": \"mrkdwn\",\n\"text\": f\"*{key}*\",\n}\n)\nif key in [\"Permitted Equipment\", \"Booking Link\"]:\ndata_type = \"mrkdwn\"\nelse:\ndata_type = \"plain_text\"\nfields.append(\n{\n\"type\": data_type,\n\"text\": str(value),\n}\n)\nblocks = []\nblocks.append(\n{\n\"type\": \"header\",\n\"text\": {\n\"type\": \"plain_text\",\n\"text\": message_title,\n},\n}\n)\n# Slack only allows 10 fields (k+v) per section\nfor chunk in range(0, len(fields) + 1, 10):\nchunk_max = chunk + 10\nblocks.append(\n{\n\"type\": \"section\",\n\"fields\": fields[chunk:chunk_max],\n}\n)\nself.send_message(\nmessage=message_title,\nblocks=blocks,\n)\n</code></pre>"},{"location":"reference/notifications/slack/#camply.notifications.slack.SlackNotifications.send_message","title":"<code>send_message(message, **kwargs)</code>","text":"<p>Send a message via Slack - if environment variables are configured.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> required <p>Returns:</p> Type Description <code>requests.Response</code> Source code in <code>camply/notifications/slack.py</code> <pre><code>def send_message(self, message: str, **kwargs) -&gt; requests.Response:\n\"\"\"\n    Send a message via Slack - if environment variables are configured.\n    Parameters\n    ----------\n    message: str\n    Returns\n    -------\n    requests.Response\n    \"\"\"\nmessage_blocks = kwargs.pop(\"blocks\", [])\nmessage_json = {\n\"text\": message,\n}\nif message_blocks:\nmessage_json = {\n\"blocks\": message_blocks,\n}\nlogger.debug(message_json)\nresponse = self.session.post(\nurl=SlackConfig.SLACK_WEBHOOK,\njson=message_json,\n)\ntry:\nresponse.raise_for_status()\nexcept requests.HTTPError as he:\nlogger.warning(\n\"Notifications weren't able to be sent to Slack. \"\n\"Your configuration might be incorrect.\"\n)\nraise ConnectionError(response.text) from he\nreturn response\n</code></pre>"},{"location":"reference/notifications/telegram/","title":"telegram","text":"<p>Push Notifications via Telegram</p>"},{"location":"reference/notifications/telegram/#camply.notifications.telegram.TelegramNotifications","title":"<code>TelegramNotifications</code>","text":"<p>         Bases: <code>BaseNotifications</code></p> <p>Push Notifications via Telegram</p> Source code in <code>camply/notifications/telegram.py</code> <pre><code>class TelegramNotifications(BaseNotifications):\n\"\"\"\n    Push Notifications via Telegram\n    \"\"\"\ndef __init__(self):\nsuper().__init__()\nself.session.headers.update(TelegramConfig.API_HEADERS)\nif any(\n[\nTelegramConfig.BOT_TOKEN is None,\nTelegramConfig.BOT_TOKEN == \"\",\nTelegramConfig.CHAT_ID is None,\nTelegramConfig.CHAT_ID == \"\",\n]\n):\nwarning_message = (\n\"Telegram is not configured properly. To send Telegram messages \"\n\"make sure to run `camply configure` or set the \"\n\"proper environment variables: `TELEGRAM_BOT_TOKEN` and `TELEGRAM_CHAT_ID`.\"\n)\nlogger.error(warning_message)\nraise EnvironmentError(warning_message)\ndef send_message(self, message: str, escaped=False, **kwargs) -&gt; requests.Response:\n\"\"\"\n        Send a message via Telegram - if environment variables are configured\n        Parameters\n        ----------\n        message: str\n        escaped: bool\n        Returns\n        -------\n        requests.Response\n        \"\"\"\nif not escaped:\nmessage = self.escape_text(message)\nmessage_json = TelegramConfig.API_CONTENT.copy()\nmessage_json.update({\"text\": message})\nlogger.debug(message_json)\nresponse = self.session.post(url=TelegramConfig.API_ENDPOINT, json=message_json)\ntry:\nresponse.raise_for_status()\nexcept requests.HTTPError as he:\nlogger.warning(\n\"Notifications weren't able to be sent to Telegram. \"\n\"Your configuration might be incorrect.\"\n)\nraise ConnectionError(response.text) from he\nreturn response\n@staticmethod\ndef escape_text(message: str) -&gt; str:\n\"\"\"\n        Escape a message for use in Telegram\n        Parameters\n        ----------\n        message: str\n        Returns\n        -------\n        String\n        \"\"\"\nfields = [\n\"_\",\n\"*\",\n\"[\",\n\"]\",\n\"(\",\n\")\",\n\"~\",\n\"`\",\n\"&gt;\",\n\"#\",\n\"+\",\n\"-\",\n\"=\",\n\"|\",\n\"{\",\n\"}\",\n\".\",\n\"!\",\n]\nfor f in fields:\nmessage = message.replace(f, f\"\\\\{f}\")\nreturn message\ndef send_campsites(self, campsites: List[AvailableCampsite], **kwargs):\n\"\"\"\n        Send a message with a campsite object\n        Parameters\n        ----------\n        campsites: AvailableCampsite\n        \"\"\"\nfor campsite in campsites:\nmessage_title, formatted_dict = self.format_standard_campsites(\ncampsite=campsite,\n)\nfields = []\nfor key, value in formatted_dict.items():\nfields.append(self.escape_text(f\"{key}: {value}\"))\nmessage_fields = \"\\n\".join(fields)\nmessage = f\"*{self.escape_text(message_title)}*\\n{message_fields}\"\nself.send_message(message, escaped=True)\n</code></pre>"},{"location":"reference/notifications/telegram/#camply.notifications.telegram.TelegramNotifications.escape_text","title":"<code>escape_text(message)</code>  <code>staticmethod</code>","text":"<p>Escape a message for use in Telegram</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> required <p>Returns:</p> Type Description <code>String</code> Source code in <code>camply/notifications/telegram.py</code> <pre><code>@staticmethod\ndef escape_text(message: str) -&gt; str:\n\"\"\"\n    Escape a message for use in Telegram\n    Parameters\n    ----------\n    message: str\n    Returns\n    -------\n    String\n    \"\"\"\nfields = [\n\"_\",\n\"*\",\n\"[\",\n\"]\",\n\"(\",\n\")\",\n\"~\",\n\"`\",\n\"&gt;\",\n\"#\",\n\"+\",\n\"-\",\n\"=\",\n\"|\",\n\"{\",\n\"}\",\n\".\",\n\"!\",\n]\nfor f in fields:\nmessage = message.replace(f, f\"\\\\{f}\")\nreturn message\n</code></pre>"},{"location":"reference/notifications/telegram/#camply.notifications.telegram.TelegramNotifications.send_campsites","title":"<code>send_campsites(campsites, **kwargs)</code>","text":"<p>Send a message with a campsite object</p> <p>Parameters:</p> Name Type Description Default <code>campsites</code> <code>List[AvailableCampsite]</code> required Source code in <code>camply/notifications/telegram.py</code> <pre><code>def send_campsites(self, campsites: List[AvailableCampsite], **kwargs):\n\"\"\"\n    Send a message with a campsite object\n    Parameters\n    ----------\n    campsites: AvailableCampsite\n    \"\"\"\nfor campsite in campsites:\nmessage_title, formatted_dict = self.format_standard_campsites(\ncampsite=campsite,\n)\nfields = []\nfor key, value in formatted_dict.items():\nfields.append(self.escape_text(f\"{key}: {value}\"))\nmessage_fields = \"\\n\".join(fields)\nmessage = f\"*{self.escape_text(message_title)}*\\n{message_fields}\"\nself.send_message(message, escaped=True)\n</code></pre>"},{"location":"reference/notifications/telegram/#camply.notifications.telegram.TelegramNotifications.send_message","title":"<code>send_message(message, escaped=False, **kwargs)</code>","text":"<p>Send a message via Telegram - if environment variables are configured</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> required <code>escaped</code> <code>False</code> <p>Returns:</p> Type Description <code>requests.Response</code> Source code in <code>camply/notifications/telegram.py</code> <pre><code>def send_message(self, message: str, escaped=False, **kwargs) -&gt; requests.Response:\n\"\"\"\n    Send a message via Telegram - if environment variables are configured\n    Parameters\n    ----------\n    message: str\n    escaped: bool\n    Returns\n    -------\n    requests.Response\n    \"\"\"\nif not escaped:\nmessage = self.escape_text(message)\nmessage_json = TelegramConfig.API_CONTENT.copy()\nmessage_json.update({\"text\": message})\nlogger.debug(message_json)\nresponse = self.session.post(url=TelegramConfig.API_ENDPOINT, json=message_json)\ntry:\nresponse.raise_for_status()\nexcept requests.HTTPError as he:\nlogger.warning(\n\"Notifications weren't able to be sent to Telegram. \"\n\"Your configuration might be incorrect.\"\n)\nraise ConnectionError(response.text) from he\nreturn response\n</code></pre>"},{"location":"reference/notifications/twilio/","title":"twilio","text":"<p>Push Notifications via Twilio</p>"},{"location":"reference/notifications/twilio/#camply.notifications.twilio.TwilioNotifications","title":"<code>TwilioNotifications</code>","text":"<p>         Bases: <code>BaseNotifications</code></p> <p>Push Notifications via Twilio</p> Source code in <code>camply/notifications/twilio.py</code> <pre><code>class TwilioNotifications(BaseNotifications):\n\"\"\"\n    Push Notifications via Twilio\n    \"\"\"\ndef __init__(self):\nsuper().__init__()\ntry:\nfrom twilio.rest import Client\nexcept ImportError as ie:\nraise RuntimeError(\n\"Looks like `twilio` isn't installed. Install it with `pip install camply[twilio]`\"\n) from ie\nif any(\n[\nTwilioConfig.ACCOUNT_SID is None,\nTwilioConfig.ACCOUNT_SID == \"\",\nTwilioConfig.AUTH_TOKEN is None,\nTwilioConfig.AUTH_TOKEN == \"\",\n]\n):\nwarning_message = (\n\"Twilio is not configured properly. To send Twilio messages \"\n\"make sure to run `camply configure` or set the \"\n\"proper environment variable: `TWILIO_ACCOUNT_SID`, `TWILIO_AUTH_TOKEN`.\"\n)\nlogger.error(warning_message)\nraise EnvironmentError(warning_message)\nself.client = Client(TwilioConfig.ACCOUNT_SID, TwilioConfig.AUTH_TOKEN)\nself.phone_nums = TwilioConfig.DEST_NUMBERS.split(\",\")\nlogger.info(\n\"Twilio: will notify these phone numbers: \" + \", \".join(self.phone_nums)\n)\ndef send_message(self, message: str, **kwargs):\n\"\"\"\n        Send a message via Twilio - if environment variables are configured\n        Parameters\n        ----------\n        message: str\n        \"\"\"\nfor phone_num in self.phone_nums:\nself.client.messages.create(\nto=phone_num, from_=TwilioConfig.SOURCE_NUMBER, body=message\n)\ndef send_campsites(self, campsites: List[AvailableCampsite], **kwargs):\n\"\"\"\n        Send a message with a campsite object\n        Parameters\n        ----------\n        campsites: AvailableCampsite\n        \"\"\"\nfor campsite in campsites:\nmessage_title, formatted_dict = self.format_standard_campsites(\ncampsite=campsite,\n)\nfields = [f\"\ud83c\udfd5{message_title}\", \"\"]\nfor key, value in formatted_dict.items():\nfields.append(f\"{key}: {value}\")\nfields.append(\"\")\nfields.append(\"camply, the campsite finder \u26fa\ufe0f\")\ncomposed_message = \"\\n\".join(fields)\nself.send_message(message=composed_message)\n</code></pre>"},{"location":"reference/notifications/twilio/#camply.notifications.twilio.TwilioNotifications.send_campsites","title":"<code>send_campsites(campsites, **kwargs)</code>","text":"<p>Send a message with a campsite object</p> <p>Parameters:</p> Name Type Description Default <code>campsites</code> <code>List[AvailableCampsite]</code> required Source code in <code>camply/notifications/twilio.py</code> <pre><code>def send_campsites(self, campsites: List[AvailableCampsite], **kwargs):\n\"\"\"\n    Send a message with a campsite object\n    Parameters\n    ----------\n    campsites: AvailableCampsite\n    \"\"\"\nfor campsite in campsites:\nmessage_title, formatted_dict = self.format_standard_campsites(\ncampsite=campsite,\n)\nfields = [f\"\ud83c\udfd5{message_title}\", \"\"]\nfor key, value in formatted_dict.items():\nfields.append(f\"{key}: {value}\")\nfields.append(\"\")\nfields.append(\"camply, the campsite finder \u26fa\ufe0f\")\ncomposed_message = \"\\n\".join(fields)\nself.send_message(message=composed_message)\n</code></pre>"},{"location":"reference/notifications/twilio/#camply.notifications.twilio.TwilioNotifications.send_message","title":"<code>send_message(message, **kwargs)</code>","text":"<p>Send a message via Twilio - if environment variables are configured</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> required Source code in <code>camply/notifications/twilio.py</code> <pre><code>def send_message(self, message: str, **kwargs):\n\"\"\"\n    Send a message via Twilio - if environment variables are configured\n    Parameters\n    ----------\n    message: str\n    \"\"\"\nfor phone_num in self.phone_nums:\nself.client.messages.create(\nto=phone_num, from_=TwilioConfig.SOURCE_NUMBER, body=message\n)\n</code></pre>"},{"location":"reference/providers/","title":"providers","text":"<p>providers init file</p>"},{"location":"reference/providers/#camply.providers.AlabamaStateParks","title":"<code>AlabamaStateParks</code>","text":"<p>         Bases: <code>UseDirectProvider</code></p> <p>Alabama State Parks</p> Source code in <code>camply/providers/usedirect/variations.py</code> <pre><code>class AlabamaStateParks(UseDirectProvider):\n\"\"\"\n    Alabama State Parks\n    \"\"\"\nbase_url = \"https://alabamardr.usedirect.com\"\ncampground_url = \"https://www.reservealapark.com\"\nrdr_path = \"alabamardr\"\nbooking_path = \"AlabamaWebHome/Facilities/SearchViewUnitAvailabity.aspx\"\nbooking_path_params = False\nstate_code = \"AL\"\n</code></pre>"},{"location":"reference/providers/#camply.providers.ArizonaStateParks","title":"<code>ArizonaStateParks</code>","text":"<p>         Bases: <code>UseDirectProvider</code></p> <p>Arizona State Parks</p> Source code in <code>camply/providers/usedirect/variations.py</code> <pre><code>class ArizonaStateParks(UseDirectProvider):\n\"\"\"\n    Arizona State Parks\n    \"\"\"\nbase_url = \"https://azrdr.usedirect.com\"\ncampground_url = \"https://ArizonaStateParks.com\"\nrdr_path = \"azrdr\"\nbooking_path = \"reserve\"\nstate_code = \"AZ\"\n</code></pre>"},{"location":"reference/providers/#camply.providers.BaseProvider","title":"<code>BaseProvider</code>","text":"<p>         Bases: <code>ABC</code></p> <p>Base Provider Class</p> Source code in <code>camply/providers/base_provider.py</code> <pre><code>class BaseProvider(ABC):\n\"\"\"\n    Base Provider Class\n    \"\"\"\ndef __repr__(self):\n\"\"\"\n        String Representation\n        Returns\n        -------\n        str\n        \"\"\"\nreturn f\"&lt;{self.__class__.__name__}&gt;\"\ndef __init__(self):\n\"\"\"\n        Initialize with a session\n        \"\"\"\n_user_agent = UserAgent(use_external_data=False, browsers=[\"chrome\"]).chrome\nself.session = requests.Session()\nself.headers = {\"User-Agent\": _user_agent}\nself.session.headers = self.headers\nself.json_headers = self.headers.copy()\nself.json_headers.update({\"Content-Type\": \"application/json\"})\n@classmethod\ndef get_search_months(cls, search_days) -&gt; List[datetime]:\n\"\"\"\n        Get the Unique Months that need to be Searched\n        Returns\n        -------\n        search_months: List[datetime]\n            Datetime Months to search for reservations\n        \"\"\"\ntruncated_months = {day.replace(day=1) for day in search_days}\nif len(truncated_months) &gt; 1:\nlogger.info(\nf\"{len(truncated_months)} different months selected for search, \"\nf\"ranging from {min(search_days)} to {max(search_days)}\"\n)\nreturn sorted(truncated_months)\nelif len(truncated_months) == 0:\nlogger.error(SearchConfig.ERROR_MESSAGE)\nraise RuntimeError(SearchConfig.ERROR_MESSAGE)\nelse:\nreturn sorted(truncated_months)\n@abstractmethod\ndef find_campgrounds(self) -&gt; List[CampgroundFacility]:\n\"\"\"\n        List Recreation Areas for the provider\n        \"\"\"\n</code></pre>"},{"location":"reference/providers/#camply.providers.base_provider.BaseProvider.__init__","title":"<code>__init__()</code>","text":"<p>Initialize with a session</p> Source code in <code>camply/providers/base_provider.py</code> <pre><code>def __init__(self):\n\"\"\"\n    Initialize with a session\n    \"\"\"\n_user_agent = UserAgent(use_external_data=False, browsers=[\"chrome\"]).chrome\nself.session = requests.Session()\nself.headers = {\"User-Agent\": _user_agent}\nself.session.headers = self.headers\nself.json_headers = self.headers.copy()\nself.json_headers.update({\"Content-Type\": \"application/json\"})\n</code></pre>"},{"location":"reference/providers/#camply.providers.base_provider.BaseProvider.__repr__","title":"<code>__repr__()</code>","text":"<p>String Representation</p> <p>Returns:</p> Type Description <code>str</code> Source code in <code>camply/providers/base_provider.py</code> <pre><code>def __repr__(self):\n\"\"\"\n    String Representation\n    Returns\n    -------\n    str\n    \"\"\"\nreturn f\"&lt;{self.__class__.__name__}&gt;\"\n</code></pre>"},{"location":"reference/providers/#camply.providers.base_provider.BaseProvider.find_campgrounds","title":"<code>find_campgrounds()</code>  <code>abstractmethod</code>","text":"<p>List Recreation Areas for the provider</p> Source code in <code>camply/providers/base_provider.py</code> <pre><code>@abstractmethod\ndef find_campgrounds(self) -&gt; List[CampgroundFacility]:\n\"\"\"\n    List Recreation Areas for the provider\n    \"\"\"\n</code></pre>"},{"location":"reference/providers/#camply.providers.base_provider.BaseProvider.get_search_months","title":"<code>get_search_months(search_days)</code>  <code>classmethod</code>","text":"<p>Get the Unique Months that need to be Searched</p> <p>Returns:</p> Name Type Description <code>search_months</code> <code>List[datetime]</code> <p>Datetime Months to search for reservations</p> Source code in <code>camply/providers/base_provider.py</code> <pre><code>@classmethod\ndef get_search_months(cls, search_days) -&gt; List[datetime]:\n\"\"\"\n    Get the Unique Months that need to be Searched\n    Returns\n    -------\n    search_months: List[datetime]\n        Datetime Months to search for reservations\n    \"\"\"\ntruncated_months = {day.replace(day=1) for day in search_days}\nif len(truncated_months) &gt; 1:\nlogger.info(\nf\"{len(truncated_months)} different months selected for search, \"\nf\"ranging from {min(search_days)} to {max(search_days)}\"\n)\nreturn sorted(truncated_months)\nelif len(truncated_months) == 0:\nlogger.error(SearchConfig.ERROR_MESSAGE)\nraise RuntimeError(SearchConfig.ERROR_MESSAGE)\nelse:\nreturn sorted(truncated_months)\n</code></pre>"},{"location":"reference/providers/#camply.providers.FairfaxCountyParks","title":"<code>FairfaxCountyParks</code>","text":"<p>         Bases: <code>UseDirectProvider</code></p> <p>Fairfax County Parks</p> Source code in <code>camply/providers/usedirect/variations.py</code> <pre><code>class FairfaxCountyParks(UseDirectProvider):\n\"\"\"\n    Fairfax County Parks\n    \"\"\"\nbase_url = \"https://fairfaxrdr.usedirect.com\"\ncampground_url = \"https://fairfax.usedirect.com\"\nrdr_path = \"FCPARDR\"\nbooking_path = \"FairfaxFCPAWeb/Facilities/SearchViewUnitAvailabity.aspx\"\nbooking_path_params = False\nstate_code = \"VA\"\n</code></pre>"},{"location":"reference/providers/#camply.providers.FloridaStateParks","title":"<code>FloridaStateParks</code>","text":"<p>         Bases: <code>UseDirectProvider</code></p> <p>Florida State Parks</p> Source code in <code>camply/providers/usedirect/variations.py</code> <pre><code>class FloridaStateParks(UseDirectProvider):\n\"\"\"\n    Florida State Parks\n    \"\"\"\nbase_url = \"https://floridardr.usedirect.com\"\ncampground_url = \"https://www.reserve.floridastateparks.org\"\nrdr_path = \"FloridaRDR\"\nbooking_path = \"Web\"\nstate_code = \"FL\"\n</code></pre>"},{"location":"reference/providers/#camply.providers.GoingToCamp","title":"<code>GoingToCamp</code>","text":"<p>         Bases: <code>BaseProvider</code></p> <p>Going To Camp API provider</p> Source code in <code>camply/providers/going_to_camp/going_to_camp_provider.py</code> <pre><code>class GoingToCamp(BaseProvider):\n\"\"\"\n    Going To Camp API provider\n    \"\"\"\n@classmethod\ndef find_recreation_areas(\ncls, search_string: Optional[str] = None, **kwargs\n) -&gt; List[RecreationArea]:\n\"\"\"\n        Find Matching Recreation Areas based on search string\n        Parameters\n        ----------\n        search_string: Optional[str]\n            Search Keyword(s)\n        Returns\n        -------\n        filtered_responses: List[RecreationArea]\n            Array of Matching Recreation Areas\n        \"\"\"\nif search_string is not None:\nlogger.info(f'Searching for Recreation Areas matching: \"{search_string}\"')\nif not search_string or search_string == \"\":\nrec_areas = RECREATION_AREAS.values()\nlog_sorted_response(rec_areas)\nreturn rec_areas\nrec_areas = []\nfor _, rec_area in RECREATION_AREAS.items():\nif (\nsearch_string.lower() in rec_area.recreation_area.lower()\nor search_string.lower() in rec_area.recreation_area_location.lower()\n):\nrec_areas.append(rec_area)\nlog_sorted_response(rec_areas)\nreturn rec_areas\ndef rec_area_lookup(self, rec_area_id: int) -&gt; Tuple[str, RecreationArea]:\n\"\"\"\n        Lookup a recreation area by ID\n        Parameters\n        ----------\n        rec_area_id: int\n            The recreation area ID to lookup\n        Returns\n        -------\n        domain_name, rec_ara: Tuple[str, RecreationArea]\n            The rec area's domain name and the recreation area object\n        \"\"\"\nfor domain_name, rec_area in RECREATION_AREAS.items():\nif str(rec_area.recreation_area_id) == str(rec_area_id):\nreturn domain_name, rec_area\ndef find_campgrounds(\nself,\nsearch_string: str = None,\nrec_area_id: Optional[List[int]] = None,\ncampground_id: Optional[List[int]] = None,\ncampsite_id: Optional[List[int]] = None,\n**kwargs,\n) -&gt; List[CampgroundFacility]:\n\"\"\"\n        Find Campgrounds Given a Set of Search Criteria\n        Parameters\n        ----------\n        search_string: str\n            Search Keyword(s)\n        rec_area_id: Optional[List[int]]\n            Recreation Area ID by which to filter\n        campground_id: Optional[List[int]]\n            ID of the Campground\n        Returns\n        -------\n        facilities: List[CampgroundFacility]\n            Array of Matching Campgrounds\n        \"\"\"\nif rec_area_id in (None, [], ()):\nlogger.error(\n\"This provider requires --rec-area to be specified when seaching for campsites\"\n)\nsys.exit(1)\nreturn self.find_facilities_per_recreation_area(\nrec_area_id=rec_area_id,\ncampground_id=campground_id,\nsearch_string=search_string,\n)\ndef _get_attr_val(self, attribute, attribute_detail) -&gt; any:\nfor attr_value in attribute.get(\"values\", []):\nfor attribute_enum_detail in attribute_detail.get(\"values\"):\nif attribute_enum_detail[\"enumValue\"] == attr_value:\nreturn _fetch_nested_key(\nattribute_enum_detail, \"localizedValues\", 0, \"displayName\"\n)\ndef get_site_details(self, rec_area_id: int, resource_id: int):\n\"\"\"\n        Get the details about a site in a recreation area\n        Parameters\n        ----------\n        rec_area_id: int\n            Recreation Area ID by which to filter\n        resource_id: int\n        Returns\n        -------\n        details: Dict[str, str]\n            The details about the site\n        \"\"\"\nif not hasattr(self, \"_attribute_details\"):\nself._attribute_details = self._api_request(\nrec_area_id, \"ATTRIBUTE_DETAILS\"\n)\nattribute_details = self._attribute_details\nsite_details = self._api_request(\nrec_area_id, \"SITE_DETAILS\", {\"resourceId\": resource_id}\n)\nsite_attributes = {}\nfor attribute in site_details[\"definedAttributes\"]:\nattribute_detail = attribute_details[\nf\"{attribute['attributeDefinitionId']}\"\n]\nattribute_name = _fetch_nested_key(\nattribute_detail, \"localizedValues\", 0, \"displayName\"\n)\nattribute_value = attribute.get(\"value\")\nattribute_values = []\n# Attribute a multi-value enum\nif not attribute_value:\nattr_value = self._get_attr_val(attribute, attribute_detail)\nif not attr_value:\ncontinue\nattribute_values.append(attr_value)\nelse:\nattribute_values.append(f\"{attribute_value}\")\nsite_attributes[attribute_name] = \",\".join(attribute_values)\nsite_details[\"site_attributes\"] = site_attributes\nreturn site_details\ndef get_reservation_link(\nself,\nrec_area_domain_name,\nresource_location_id,\nmap_id,\nequipment_id,\nsub_equipment_id,\nparty_size,\nstart_date,\nend_date,\n):\n\"\"\"\n        Generate a URL which a site can be booked\n        Returns\n        -------\n        url: str\n            The reservation link URL\n        \"\"\"\nif not sub_equipment_id:\nsub_equipment_id = \"\"\nreturn (\n\"https://%s/create-booking/results?mapId=%s\"\n\"&amp;bookingCategoryId=0\"\n\"&amp;startDate=%s\"\n\"&amp;endDate=%s\"\n\"&amp;isReserving=true\"\n\"&amp;equipmentId=%s\"\n\"&amp;subEquipmentId=%s\"\n\"&amp;partySize=%s\"\n\"&amp;resourceLocationId=%s\"\n% (\nrec_area_domain_name,\nmap_id,\nstart_date.isoformat(),\nend_date.isoformat(),\nequipment_id,\nsub_equipment_id,\nparty_size,\nresource_location_id,\n)\n)\ndef find_facilities_per_recreation_area(\nself,\nrec_area_id: Optional[Union[List[int], int]] = None,\ncampground_id: Optional[Union[List[int], int]] = None,\nsearch_string: Optional[str] = None,\n**kwargs,\n) -&gt; List[CampgroundFacility]:\n\"\"\"\n        Find Matching Campsites by Recreation Area\n        Parameters\n        ----------\n        rec_area_id: Optional[Union[List[int], int]]\n            Recreation Area ID\n        campground_id: Optional[Union[List[int], int]]\n            Campground IDs\n        search_string: Optional[str]\n            A string to search for in the facility name\n        Returns\n        -------\n        campgrounds: List[CampgroundFacility]\n            Array of Matching Campsites\n        \"\"\"\nrec_area_id = make_list(rec_area_id, coerce=int)[0]\nlogger.info(\nf\"Retrieving Facility Information for Recreation Area ID: `{rec_area_id}`.\"\n)\nrec_area = None\nfor _, ra in RECREATION_AREAS.items():\nif str(ra.recreation_area_id) == str(rec_area_id):\nrec_area = ra\nif not rec_area:\nlogger.error(f\"Recreation area '{rec_area_id}' does not exist.\")\nsys.exit(1)\nself.campground_details = {}\napi_response = self._api_request(rec_area_id, \"LIST_CAMPGROUNDS\")\nfiltered_facilities = self._filter_facilities_responses(\nrec_area_id, facilities=api_response\n)\ncampgrounds = []\n# Fetch campgrounds details for all facilities\nfor camp_details in self._api_request(rec_area_id, \"CAMP_DETAILS\"):\nself.campground_details[camp_details[\"resourceLocationId\"]] = camp_details\n# If a search string is provided, make sure every facility name contains\n# the search string\nif search_string and search_string not in [[], (), \"\"]:\nfiltered_facilities = [\nf\nfor f in filtered_facilities\nif search_string.lower() in f.resource_location_name.lower()\n]\nfor facility in filtered_facilities:\n_, campground_facility = self._process_facilities_responses(\nrec_area, facility=facility\n)\nif not campground_facility:\ncontinue\nif not campground_id:\ncampgrounds.append(campground_facility)\ncampground_strings = make_list(campground_id, coerce=str)\nif (\ncampground_id\nand str(campground_facility.facility_id) in campground_strings\n):\ncampgrounds.append(campground_facility)\nlogger.info(f\"{len(campgrounds)} Matching Campgrounds Found\")\nlog_sorted_response(response_array=campgrounds)\nreturn campgrounds\ndef _hostname_for(self, recreation_area_id: int) -&gt; str:\nfor hostname, recreation_area in RECREATION_AREAS.items():\nif str(recreation_area.recreation_area_id) == str(recreation_area_id):\nreturn hostname\nreturn None\ndef _api_request(\nself,\nrec_area_id: int,\nendpoint_name: str,\nparams: Optional[Dict[str, str]] = None,\n) -&gt; str:\nif params is None:\nparams = {}\nhostname = self._hostname_for(rec_area_id)\nendpoint = ENDPOINTS.get(endpoint_name)\nurl = None\nif endpoint:\nurl = endpoint.format(hostname)\nuser_agent = {\n\"User-Agent\": UserAgent(use_external_data=False, browsers=[\"chrome\"]).chrome\n}\nresponse = requests.get(url=url, headers=user_agent, params=params, timeout=30)\nif response.ok is False:\nerror_message = \"Receiving bad data from GoingToCamp API: status_code: \"\nf\"{response.status_code}: {response.text}\"\nlogger.error(error_message)\nraise ConnectionError(error_message)\nreturn json.loads(response.content)\ndef _filter_facilities_responses(\nself, rec_area_id: int, facilities=List[Dict[str, Any]]\n) -&gt; List[ResourceLocation]:\n\"\"\"\n        Filter Facilities to Actual Reservable Campsites\n        Parameters\n        ----------\n        rec_area_id: int\n            Recreation Area ID\n        facilities: List[Dict[str, Any]]\n            List of facilities\n        Returns\n        -------\n        List[ResourceLocation]\n        \"\"\"\nfiltered_facilities = []\nfor facil in facilities:\ntry:\nlocation_name = _fetch_nested_key(\nfacil, \"localizedValues\", 0, \"fullName\"\n)\npark_alerts = _fetch_nested_key(\nfacil, \"park_alerts\", \"en-US\", 0, \"messageTitle\"\n)\nif not park_alerts:\npark_alerts = _fetch_nested_key(\nfacil, \"park_alerts\", \"en-CA\", 0, \"messageTitle\"\n)\nregion_name = _fetch_nested_key(facil, \"region\")\nfacility = ResourceLocation(\nid=None,\nregion_name=region_name if region_name else \"\",\npark_alerts=park_alerts,\nrec_area_id=rec_area_id,\nresource_categories=facil.get(\"resourceCategoryIds\"),\nresource_location_id=facil.get(\"resourceLocationId\"),\nresource_location_name=location_name,\n)\nexcept ValidationError as ve:\nlogger.error(\"That doesn't look like a valid Campground Facility\")\nlogger.error(facil)\nraise ProviderSearchError(\n\"Invalid Campground Facility Returned\"\n) from ve\nif not facility.resource_categories:\ncontinue\n# Resource categories from: /api/resourcecategory\nif any(\n[\nCAMP_SITE in facility.resource_categories,\nGROUP_SITE in facility.resource_categories,\nOVERFLOW_SITE in facility.resource_categories,\n]\n):\nfiltered_facilities.append(facility)\nreturn filtered_facilities\ndef _process_facilities_responses(\nself, rec_area: RecreationArea, facility: ResourceLocation\n) -&gt; Tuple[dict, Optional[CampgroundFacility]]:\n\"\"\"\n        Process Facilities Responses to be More Usable\n        Parameters\n        ----------\n        facility: dict\n        Returns\n        -------\n        Tuple[dict, CampgroundFacility]\n        \"\"\"\nself.campground_details[facility.resource_location_id]\nfacility.id = _fetch_nested_key(\nself.campground_details, facility.resource_location_id, \"mapId\"\n)\nif facility.region_name:\nformatted_recreation_area = (\nf\"{rec_area.recreation_area}, {facility.region_name}\"\n)\nelse:\nformatted_recreation_area = f\"{rec_area.recreation_area}\"\ncampground_facility = CampgroundFacility(\nfacility_name=facility.resource_location_name,\nrecreation_area=formatted_recreation_area,\nfacility_id=facility.resource_location_id,\nrecreation_area_id=facility.rec_area_id,\nmap_id=facility.id,\n)\nreturn facility, campground_facility\ndef _find_matching_resources(self, rec_area_id: int, search_filter: Dict[str, any]):\nresults = self._api_request(rec_area_id, \"MAPDATA\", search_filter)\navailability_details = {\nsearch_filter[\"mapId\"]: results[\"resourceAvailabilities\"]\n}\nreturn availability_details, list(results[\"mapLinkAvailabilities\"].keys())\ndef list_equipment_types(self, rec_area_id: int) -&gt; Dict[str, int]:\n\"\"\"\n        List equipment types available for a recreation area\n        Params\n        ------\n        rec_area_id: int\n            The ID of the recreation area\n        Returns\n        -------\n        types: List[GoingToCampEquipment]\n            A list of equipment types available to this rec area\n        \"\"\"\nresults = self._api_request(rec_area_id, \"LIST_EQUIPMENT\")\nequipment_types = []\n# Only allow equipment from non-group equipment category (the 0th\n# element in results)\nfor sub_category in results[0][\"subEquipmentCategories\"]:\nequipment_name = _fetch_nested_key(\nsub_category, \"localizedValues\", 0, \"name\"\n)\nequipment_id = sub_category[\"subEquipmentCategoryId\"]\nequipment_types.append(\nGoingToCampEquipment(\nequipment_name=equipment_name, equipment_type_id=equipment_id\n)\n)\nlog_sorted_response(response_array=equipment_types)\nreturn equipment_types\ndef list_site_availability(\nself,\ncampground: CampgroundFacility,\nstart_date: datetime.date,\nend_date: datetime.date,\nequipment_type_id: Optional[str],\n) -&gt; List[AvailableResource]:\n\"\"\"\n        Retrieve the Availability for all Sites in a Camp Area\n        Sites are filtered on the provided date range and compatible\n        equipment.\n        Returns\n        -------\n        available_sites: List[AvailableResource]\n            The list of available sites\n        \"\"\"\nsearch_filter = {\n\"mapId\": campground.map_id,\n\"resourceLocationId\": campground.facility_id,\n\"bookingCategoryId\": 0,\n\"startDate\": start_date.isoformat(),\n\"endDate\": end_date.isoformat(),\n\"isReserving\": True,\n\"getDailyAvailability\": False,\n\"partySize\": 1,\n\"numEquipment\": 1,\n\"equipmentCategoryId\": NON_GROUP_EQUIPMENT,\n\"filterData\": [],\n}\nif equipment_type_id:\nsearch_filter[\"subEquipmentCategoryId\"] = equipment_type_id\nresources, additional_resources = self._find_matching_resources(\ncampground.recreation_area_id, search_filter\n)\n# Resources are often deeply nested; fetch nested resources\nfor map_id in additional_resources:\nsearch_filter[\"mapId\"] = map_id\navail, _ = self._find_matching_resources(\ncampground.recreation_area_id, search_filter\n)\nresources.update(avail)\navailabilities = []\nfor map_id, resource_details in resources.items():\nfor resource_id, availability_details in resource_details.items():\nif availability_details[0][\"availability\"] == 0:\nar = AvailableResource(resource_id=resource_id, map_id=map_id)\navailabilities.append(ar)\nreturn availabilities\n</code></pre>"},{"location":"reference/providers/#camply.providers.going_to_camp.going_to_camp_provider.GoingToCamp.find_campgrounds","title":"<code>find_campgrounds(search_string=None, rec_area_id=None, campground_id=None, campsite_id=None, **kwargs)</code>","text":"<p>Find Campgrounds Given a Set of Search Criteria</p> <p>Parameters:</p> Name Type Description Default <code>search_string</code> <code>str</code> <p>Search Keyword(s)</p> <code>None</code> <code>rec_area_id</code> <code>Optional[List[int]]</code> <p>Recreation Area ID by which to filter</p> <code>None</code> <code>campground_id</code> <code>Optional[List[int]]</code> <p>ID of the Campground</p> <code>None</code> <p>Returns:</p> Name Type Description <code>facilities</code> <code>List[CampgroundFacility]</code> <p>Array of Matching Campgrounds</p> Source code in <code>camply/providers/going_to_camp/going_to_camp_provider.py</code> <pre><code>def find_campgrounds(\nself,\nsearch_string: str = None,\nrec_area_id: Optional[List[int]] = None,\ncampground_id: Optional[List[int]] = None,\ncampsite_id: Optional[List[int]] = None,\n**kwargs,\n) -&gt; List[CampgroundFacility]:\n\"\"\"\n    Find Campgrounds Given a Set of Search Criteria\n    Parameters\n    ----------\n    search_string: str\n        Search Keyword(s)\n    rec_area_id: Optional[List[int]]\n        Recreation Area ID by which to filter\n    campground_id: Optional[List[int]]\n        ID of the Campground\n    Returns\n    -------\n    facilities: List[CampgroundFacility]\n        Array of Matching Campgrounds\n    \"\"\"\nif rec_area_id in (None, [], ()):\nlogger.error(\n\"This provider requires --rec-area to be specified when seaching for campsites\"\n)\nsys.exit(1)\nreturn self.find_facilities_per_recreation_area(\nrec_area_id=rec_area_id,\ncampground_id=campground_id,\nsearch_string=search_string,\n)\n</code></pre>"},{"location":"reference/providers/#camply.providers.going_to_camp.going_to_camp_provider.GoingToCamp.find_facilities_per_recreation_area","title":"<code>find_facilities_per_recreation_area(rec_area_id=None, campground_id=None, search_string=None, **kwargs)</code>","text":"<p>Find Matching Campsites by Recreation Area</p> <p>Parameters:</p> Name Type Description Default <code>rec_area_id</code> <code>Optional[Union[List[int], int]]</code> <p>Recreation Area ID</p> <code>None</code> <code>campground_id</code> <code>Optional[Union[List[int], int]]</code> <p>Campground IDs</p> <code>None</code> <code>search_string</code> <code>Optional[str]</code> <p>A string to search for in the facility name</p> <code>None</code> <p>Returns:</p> Name Type Description <code>campgrounds</code> <code>List[CampgroundFacility]</code> <p>Array of Matching Campsites</p> Source code in <code>camply/providers/going_to_camp/going_to_camp_provider.py</code> <pre><code>def find_facilities_per_recreation_area(\nself,\nrec_area_id: Optional[Union[List[int], int]] = None,\ncampground_id: Optional[Union[List[int], int]] = None,\nsearch_string: Optional[str] = None,\n**kwargs,\n) -&gt; List[CampgroundFacility]:\n\"\"\"\n    Find Matching Campsites by Recreation Area\n    Parameters\n    ----------\n    rec_area_id: Optional[Union[List[int], int]]\n        Recreation Area ID\n    campground_id: Optional[Union[List[int], int]]\n        Campground IDs\n    search_string: Optional[str]\n        A string to search for in the facility name\n    Returns\n    -------\n    campgrounds: List[CampgroundFacility]\n        Array of Matching Campsites\n    \"\"\"\nrec_area_id = make_list(rec_area_id, coerce=int)[0]\nlogger.info(\nf\"Retrieving Facility Information for Recreation Area ID: `{rec_area_id}`.\"\n)\nrec_area = None\nfor _, ra in RECREATION_AREAS.items():\nif str(ra.recreation_area_id) == str(rec_area_id):\nrec_area = ra\nif not rec_area:\nlogger.error(f\"Recreation area '{rec_area_id}' does not exist.\")\nsys.exit(1)\nself.campground_details = {}\napi_response = self._api_request(rec_area_id, \"LIST_CAMPGROUNDS\")\nfiltered_facilities = self._filter_facilities_responses(\nrec_area_id, facilities=api_response\n)\ncampgrounds = []\n# Fetch campgrounds details for all facilities\nfor camp_details in self._api_request(rec_area_id, \"CAMP_DETAILS\"):\nself.campground_details[camp_details[\"resourceLocationId\"]] = camp_details\n# If a search string is provided, make sure every facility name contains\n# the search string\nif search_string and search_string not in [[], (), \"\"]:\nfiltered_facilities = [\nf\nfor f in filtered_facilities\nif search_string.lower() in f.resource_location_name.lower()\n]\nfor facility in filtered_facilities:\n_, campground_facility = self._process_facilities_responses(\nrec_area, facility=facility\n)\nif not campground_facility:\ncontinue\nif not campground_id:\ncampgrounds.append(campground_facility)\ncampground_strings = make_list(campground_id, coerce=str)\nif (\ncampground_id\nand str(campground_facility.facility_id) in campground_strings\n):\ncampgrounds.append(campground_facility)\nlogger.info(f\"{len(campgrounds)} Matching Campgrounds Found\")\nlog_sorted_response(response_array=campgrounds)\nreturn campgrounds\n</code></pre>"},{"location":"reference/providers/#camply.providers.going_to_camp.going_to_camp_provider.GoingToCamp.find_recreation_areas","title":"<code>find_recreation_areas(search_string=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Find Matching Recreation Areas based on search string</p> <p>Parameters:</p> Name Type Description Default <code>search_string</code> <code>Optional[str]</code> <p>Search Keyword(s)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>filtered_responses</code> <code>List[RecreationArea]</code> <p>Array of Matching Recreation Areas</p> Source code in <code>camply/providers/going_to_camp/going_to_camp_provider.py</code> <pre><code>@classmethod\ndef find_recreation_areas(\ncls, search_string: Optional[str] = None, **kwargs\n) -&gt; List[RecreationArea]:\n\"\"\"\n    Find Matching Recreation Areas based on search string\n    Parameters\n    ----------\n    search_string: Optional[str]\n        Search Keyword(s)\n    Returns\n    -------\n    filtered_responses: List[RecreationArea]\n        Array of Matching Recreation Areas\n    \"\"\"\nif search_string is not None:\nlogger.info(f'Searching for Recreation Areas matching: \"{search_string}\"')\nif not search_string or search_string == \"\":\nrec_areas = RECREATION_AREAS.values()\nlog_sorted_response(rec_areas)\nreturn rec_areas\nrec_areas = []\nfor _, rec_area in RECREATION_AREAS.items():\nif (\nsearch_string.lower() in rec_area.recreation_area.lower()\nor search_string.lower() in rec_area.recreation_area_location.lower()\n):\nrec_areas.append(rec_area)\nlog_sorted_response(rec_areas)\nreturn rec_areas\n</code></pre>"},{"location":"reference/providers/#camply.providers.going_to_camp.going_to_camp_provider.GoingToCamp.get_reservation_link","title":"<code>get_reservation_link(rec_area_domain_name, resource_location_id, map_id, equipment_id, sub_equipment_id, party_size, start_date, end_date)</code>","text":"<p>Generate a URL which a site can be booked</p> <p>Returns:</p> Name Type Description <code>url</code> <code>str</code> <p>The reservation link URL</p> Source code in <code>camply/providers/going_to_camp/going_to_camp_provider.py</code> <pre><code>def get_reservation_link(\nself,\nrec_area_domain_name,\nresource_location_id,\nmap_id,\nequipment_id,\nsub_equipment_id,\nparty_size,\nstart_date,\nend_date,\n):\n\"\"\"\n    Generate a URL which a site can be booked\n    Returns\n    -------\n    url: str\n        The reservation link URL\n    \"\"\"\nif not sub_equipment_id:\nsub_equipment_id = \"\"\nreturn (\n\"https://%s/create-booking/results?mapId=%s\"\n\"&amp;bookingCategoryId=0\"\n\"&amp;startDate=%s\"\n\"&amp;endDate=%s\"\n\"&amp;isReserving=true\"\n\"&amp;equipmentId=%s\"\n\"&amp;subEquipmentId=%s\"\n\"&amp;partySize=%s\"\n\"&amp;resourceLocationId=%s\"\n% (\nrec_area_domain_name,\nmap_id,\nstart_date.isoformat(),\nend_date.isoformat(),\nequipment_id,\nsub_equipment_id,\nparty_size,\nresource_location_id,\n)\n)\n</code></pre>"},{"location":"reference/providers/#camply.providers.going_to_camp.going_to_camp_provider.GoingToCamp.get_site_details","title":"<code>get_site_details(rec_area_id, resource_id)</code>","text":"<p>Get the details about a site in a recreation area</p> <p>Parameters:</p> Name Type Description Default <code>rec_area_id</code> <code>int</code> <p>Recreation Area ID by which to filter</p> required <code>resource_id</code> <code>int</code> required <p>Returns:</p> Name Type Description <code>details</code> <code>Dict[str, str]</code> <p>The details about the site</p> Source code in <code>camply/providers/going_to_camp/going_to_camp_provider.py</code> <pre><code>def get_site_details(self, rec_area_id: int, resource_id: int):\n\"\"\"\n    Get the details about a site in a recreation area\n    Parameters\n    ----------\n    rec_area_id: int\n        Recreation Area ID by which to filter\n    resource_id: int\n    Returns\n    -------\n    details: Dict[str, str]\n        The details about the site\n    \"\"\"\nif not hasattr(self, \"_attribute_details\"):\nself._attribute_details = self._api_request(\nrec_area_id, \"ATTRIBUTE_DETAILS\"\n)\nattribute_details = self._attribute_details\nsite_details = self._api_request(\nrec_area_id, \"SITE_DETAILS\", {\"resourceId\": resource_id}\n)\nsite_attributes = {}\nfor attribute in site_details[\"definedAttributes\"]:\nattribute_detail = attribute_details[\nf\"{attribute['attributeDefinitionId']}\"\n]\nattribute_name = _fetch_nested_key(\nattribute_detail, \"localizedValues\", 0, \"displayName\"\n)\nattribute_value = attribute.get(\"value\")\nattribute_values = []\n# Attribute a multi-value enum\nif not attribute_value:\nattr_value = self._get_attr_val(attribute, attribute_detail)\nif not attr_value:\ncontinue\nattribute_values.append(attr_value)\nelse:\nattribute_values.append(f\"{attribute_value}\")\nsite_attributes[attribute_name] = \",\".join(attribute_values)\nsite_details[\"site_attributes\"] = site_attributes\nreturn site_details\n</code></pre>"},{"location":"reference/providers/#camply.providers.going_to_camp.going_to_camp_provider.GoingToCamp.list_equipment_types","title":"<code>list_equipment_types(rec_area_id)</code>","text":"<p>List equipment types available for a recreation area</p>"},{"location":"reference/providers/#camply.providers.going_to_camp.going_to_camp_provider.GoingToCamp.list_equipment_types--params","title":"Params","text":"<p>rec_area_id: int     The ID of the recreation area</p> <p>Returns:</p> Name Type Description <code>types</code> <code>List[GoingToCampEquipment]</code> <p>A list of equipment types available to this rec area</p> Source code in <code>camply/providers/going_to_camp/going_to_camp_provider.py</code> <pre><code>def list_equipment_types(self, rec_area_id: int) -&gt; Dict[str, int]:\n\"\"\"\n    List equipment types available for a recreation area\n    Params\n    ------\n    rec_area_id: int\n        The ID of the recreation area\n    Returns\n    -------\n    types: List[GoingToCampEquipment]\n        A list of equipment types available to this rec area\n    \"\"\"\nresults = self._api_request(rec_area_id, \"LIST_EQUIPMENT\")\nequipment_types = []\n# Only allow equipment from non-group equipment category (the 0th\n# element in results)\nfor sub_category in results[0][\"subEquipmentCategories\"]:\nequipment_name = _fetch_nested_key(\nsub_category, \"localizedValues\", 0, \"name\"\n)\nequipment_id = sub_category[\"subEquipmentCategoryId\"]\nequipment_types.append(\nGoingToCampEquipment(\nequipment_name=equipment_name, equipment_type_id=equipment_id\n)\n)\nlog_sorted_response(response_array=equipment_types)\nreturn equipment_types\n</code></pre>"},{"location":"reference/providers/#camply.providers.going_to_camp.going_to_camp_provider.GoingToCamp.list_site_availability","title":"<code>list_site_availability(campground, start_date, end_date, equipment_type_id)</code>","text":"<p>Retrieve the Availability for all Sites in a Camp Area</p> <p>Sites are filtered on the provided date range and compatible equipment.</p> <p>Returns:</p> Name Type Description <code>available_sites</code> <code>List[AvailableResource]</code> <p>The list of available sites</p> Source code in <code>camply/providers/going_to_camp/going_to_camp_provider.py</code> <pre><code>def list_site_availability(\nself,\ncampground: CampgroundFacility,\nstart_date: datetime.date,\nend_date: datetime.date,\nequipment_type_id: Optional[str],\n) -&gt; List[AvailableResource]:\n\"\"\"\n    Retrieve the Availability for all Sites in a Camp Area\n    Sites are filtered on the provided date range and compatible\n    equipment.\n    Returns\n    -------\n    available_sites: List[AvailableResource]\n        The list of available sites\n    \"\"\"\nsearch_filter = {\n\"mapId\": campground.map_id,\n\"resourceLocationId\": campground.facility_id,\n\"bookingCategoryId\": 0,\n\"startDate\": start_date.isoformat(),\n\"endDate\": end_date.isoformat(),\n\"isReserving\": True,\n\"getDailyAvailability\": False,\n\"partySize\": 1,\n\"numEquipment\": 1,\n\"equipmentCategoryId\": NON_GROUP_EQUIPMENT,\n\"filterData\": [],\n}\nif equipment_type_id:\nsearch_filter[\"subEquipmentCategoryId\"] = equipment_type_id\nresources, additional_resources = self._find_matching_resources(\ncampground.recreation_area_id, search_filter\n)\n# Resources are often deeply nested; fetch nested resources\nfor map_id in additional_resources:\nsearch_filter[\"mapId\"] = map_id\navail, _ = self._find_matching_resources(\ncampground.recreation_area_id, search_filter\n)\nresources.update(avail)\navailabilities = []\nfor map_id, resource_details in resources.items():\nfor resource_id, availability_details in resource_details.items():\nif availability_details[0][\"availability\"] == 0:\nar = AvailableResource(resource_id=resource_id, map_id=map_id)\navailabilities.append(ar)\nreturn availabilities\n</code></pre>"},{"location":"reference/providers/#camply.providers.going_to_camp.going_to_camp_provider.GoingToCamp.rec_area_lookup","title":"<code>rec_area_lookup(rec_area_id)</code>","text":"<p>Lookup a recreation area by ID</p> <p>Parameters:</p> Name Type Description Default <code>rec_area_id</code> <code>int</code> <p>The recreation area ID to lookup</p> required <p>Returns:</p> Type Description <code>domain_name, rec_ara</code> <p>The rec area's domain name and the recreation area object</p> Source code in <code>camply/providers/going_to_camp/going_to_camp_provider.py</code> <pre><code>def rec_area_lookup(self, rec_area_id: int) -&gt; Tuple[str, RecreationArea]:\n\"\"\"\n    Lookup a recreation area by ID\n    Parameters\n    ----------\n    rec_area_id: int\n        The recreation area ID to lookup\n    Returns\n    -------\n    domain_name, rec_ara: Tuple[str, RecreationArea]\n        The rec area's domain name and the recreation area object\n    \"\"\"\nfor domain_name, rec_area in RECREATION_AREAS.items():\nif str(rec_area.recreation_area_id) == str(rec_area_id):\nreturn domain_name, rec_area\n</code></pre>"},{"location":"reference/providers/#camply.providers.MaricopaCountyParks","title":"<code>MaricopaCountyParks</code>","text":"<p>         Bases: <code>UseDirectProvider</code></p> <p>Maricopa County Parks</p> Source code in <code>camply/providers/usedirect/variations.py</code> <pre><code>class MaricopaCountyParks(UseDirectProvider):\n\"\"\"\n    Maricopa County Parks\n    \"\"\"\nbase_url = \"https://maricopardr.usedirect.com\"\ncampground_url = \"https://www.maricopacountyparks.org\"\nrdr_path = \"maricopardr\"\nbooking_path = \"MaricopaWeb/Facilities/SearchViewUnitAvailabity.aspx\"\nbooking_path_params = False\nstate_code = \"AZ\"\n</code></pre>"},{"location":"reference/providers/#camply.providers.MinnesotaStateParks","title":"<code>MinnesotaStateParks</code>","text":"<p>         Bases: <code>UseDirectProvider</code></p> <p>Minnesota State Parks</p> Source code in <code>camply/providers/usedirect/variations.py</code> <pre><code>class MinnesotaStateParks(UseDirectProvider):\n\"\"\"\n    Minnesota State Parks\n    \"\"\"\nbase_url = \"https://mnrdr.usedirect.com\"\ncampground_url = \"https://reservemn.usedirect.com\"\nrdr_path = \"minnesotardr\"\nbooking_path = \"MinnesotaWeb\"\nstate_code = \"MN\"\n</code></pre>"},{"location":"reference/providers/#camply.providers.MissouriStateParks","title":"<code>MissouriStateParks</code>","text":"<p>         Bases: <code>UseDirectProvider</code></p> <p>Missouri State Parks</p> Source code in <code>camply/providers/usedirect/variations.py</code> <pre><code>class MissouriStateParks(UseDirectProvider):\n\"\"\"\n    Missouri State Parks\n    \"\"\"\nbase_url = \"https://msprdr.usedirect.com\"\ncampground_url = \"https://icampmo1.usedirect.com\"\nrdr_path = \"msprdr\"\nbooking_path = \"MSPWeb\"\nstate_code = \"MO\"\n</code></pre>"},{"location":"reference/providers/#camply.providers.NorthernTerritory","title":"<code>NorthernTerritory</code>","text":"<p>         Bases: <code>UseDirectProvider</code></p> <p>Australian NorthernTerritory</p> Source code in <code>camply/providers/usedirect/variations.py</code> <pre><code>class NorthernTerritory(UseDirectProvider):\n\"\"\"\n    Australian NorthernTerritory\n    \"\"\"\nbase_url = \"https://northernterritoryrdr.usedirect.com\"\ncampground_url = \"https://parkbookings.nt.gov.au\"\nrdr_path = \"NorthernTerritoryRDR\"\nbooking_path = \"Web/Facilities/SearchViewUnitAvailabity.aspx\"\nbooking_path_params = False\nstate_code = \"NT\"\n</code></pre>"},{"location":"reference/providers/#camply.providers.OhioStateParks","title":"<code>OhioStateParks</code>","text":"<p>         Bases: <code>UseDirectProvider</code></p> <p>Ohio State Parks</p> Source code in <code>camply/providers/usedirect/variations.py</code> <pre><code>class OhioStateParks(UseDirectProvider):\n\"\"\"\n    Ohio State Parks\n    \"\"\"\nbase_url = \"https://ohiordr.usedirect.com\"\ncampground_url = \"https://www.OhioStateParks.com\"\nrdr_path = \"ohiordr\"\nbooking_path = \"OhioCampWeb\"\nstate_code = \"OH\"\n</code></pre>"},{"location":"reference/providers/#camply.providers.OregonMetro","title":"<code>OregonMetro</code>","text":"<p>         Bases: <code>UseDirectProvider</code></p> <p>Oregon Metro Parks</p> Source code in <code>camply/providers/usedirect/variations.py</code> <pre><code>class OregonMetro(UseDirectProvider):\n\"\"\"\n    Oregon Metro Parks\n    \"\"\"\nbase_url = \"https://oregonrdr.usedirect.com\"\ncampground_url = \"https://reservemetro.usedirect.com\"\nrdr_path = \"oregonmetrordr\"\nbooking_path = \"MetroWeb/Facilities/SearchViewUnitAvailabity.aspx\"\nbooking_path_params = False\nstate_code = \"OR\"\n</code></pre>"},{"location":"reference/providers/#camply.providers.RecreationDotGov","title":"<code>RecreationDotGov</code>","text":"<p>         Bases: <code>RecreationDotGovBase</code></p> <p>Recreation.gov: Campsite Searcher</p> Source code in <code>camply/providers/recreation_dot_gov/recdotgov_camps.py</code> <pre><code>class RecreationDotGov(RecreationDotGovBase):\n\"\"\"\n    Recreation.gov: Campsite Searcher\n    \"\"\"\nfacility_type = RIDBConfig.CAMPGROUND_FACILITY_FIELD_QUALIFIER\nresource_api_path = RIDBConfig.CAMPSITE_API_PATH\nactivity_name = \"CAMPING\"\napi_response_class = CampsiteResponse\napi_base_path = RecreationBookingConfig.API_BASE_PATH\napi_search_result_class = RecDotGovCampsite\napi_search_result_key = \"campsite_id\"\ndef paginate_recdotgov_campsites(\nself, facility_id: int, equipment: Optional[List[str]] = None\n) -&gt; List[RecDotGovCampsite]:\n\"\"\"\n        Paginate through the RecDotGov Campsite Metadata\n        \"\"\"\nresults = 0\ncontinue_paginate = True\nendpoint_url = api_utils.generate_url(\nscheme=RecreationBookingConfig.API_SCHEME,\nnetloc=RecreationBookingConfig.API_NET_LOC,\npath=\"api/search/campsites\",\n)\nfq_list = [f\"asset_id:{facility_id}\"]\nif isinstance(equipment, list) and len(equipment) &gt; 0:\nfor item in equipment:\nfq_list.append(f\"campsite_equipment_name:{item}\")\nparams = {\n\"start\": 0,\n\"size\": 1000,\n\"fq\": fq_list,\n\"include_non_site_specific_campsites\": True,\n}\ncampsites: List[RecDotGovCampsite] = []\nwhile continue_paginate is True:\nresponse = self.make_recdotgov_request_retry(\nmethod=\"GET\",\nurl=endpoint_url,\nparams=params,\n)\nreturned_data = json.loads(response.content)\ncampsite_response = RecDotGovCampsiteResponse(**returned_data)\ncampsites += campsite_response.campsites\nresults += campsite_response.size\nparams.update(start=results)\nif results == campsite_response.total:\ncontinue_paginate = False\nreturn campsites\ndef make_recdotgov_availability_request(\nself,\ncampground_id: int,\nmonth: datetime,\n) -&gt; requests.Response:\n\"\"\"\n        Make a request to the RecreationDotGov API\n        Parameters\n        ----------\n        campground_id\n        month\n        Returns\n        -------\n        requests.Response\n        \"\"\"\napi_endpoint = self._rec_availability_get_endpoint(\npath=f\"{campground_id}/{RecreationBookingConfig.API_MONTH_PATH}\"\n)\nformatted_month = month.strftime(\"%Y-%m-01T00:00:00.000Z\")\nquery_params = {\"start_date\": formatted_month}\nreturn self.make_recdotgov_request(\nmethod=\"GET\",\nurl=api_endpoint,\nparams=query_params,\n)\n@classmethod\ndef _items_to_unique_dicts(\ncls, item: Union[List[Dict[str, Any]], pd.Series]\n) -&gt; List[Dict[str, Any]]:\n\"\"\"\n        Ensure the proper items are parsed for equipment and attributes\n        \"\"\"\nif isinstance(item, pd.Series):\nlist_of_dicts = list(chain.from_iterable(item.tolist()))\nunique_list_of_dicts = [\ndict(s) for s in {frozenset(d.items()) for d in list_of_dicts}\n]\nreturn unique_list_of_dicts\nelse:\nreturn item\n@classmethod\ndef _get_equipment_and_attributes(\ncls,\ncampsite_id: int,\ncampsite_metadata: pd.DataFrame,\n) -&gt; Tuple[List[Dict[str, Any]], List[Dict[str, Any]]]:\n\"\"\"\n        Index a DataFrame in a Complicated Way\n        \"\"\"\ntry:\nequipment = campsite_metadata.at[campsite_id, \"permitted_equipment\"]\nexcept LookupError:\nequipment = None\ntry:\nattributes = campsite_metadata.at[campsite_id, \"attributes\"]\nexcept LookupError:\nattributes = None\nequipment = cls._items_to_unique_dicts(item=equipment)\nattributes = cls._items_to_unique_dicts(item=attributes)\nreturn equipment, attributes\n@classmethod\ndef process_campsite_availability(\ncls,\navailability: Dict[str, Any],\nrecreation_area: str,\nrecreation_area_id: int,\nfacility_name: str,\nfacility_id: int,\nmonth: datetime,\ncampsite_metadata: pd.DataFrame,\n) -&gt; List[Optional[AvailableCampsite]]:\n\"\"\"\n        Parse the JSON Response and return availabilities\n        Parameters\n        ----------\n        availability: Dict[str, Any]\n            API Response\n        recreation_area: str\n            Name of Recreation Area\n        recreation_area_id: int\n            ID of Recreation Area\n        facility_name: str\n            Campground Facility Name\n        facility_id: int\n            Campground Facility ID\n        month: datetime\n            Month to Process\n        campsite_metadata: pd.DataFrame\n            Metadata Fetched from the Recreation.gov API about the Campsites\n        Returns\n        -------\n        total_campsite_availability: List[Optional[AvailableCampsite]]\n            Any monthly availabilities\n        \"\"\"\ntotal_campsite_availability: List[Optional[AvailableCampsite]] = []\ncampsite_data = CampsiteAvailabilityResponse(**availability)\nfor campsite_id, site_related_data in campsite_data.campsites.items():\nfor (\nmatching_date,\navailability_status,\n) in site_related_data.availabilities.items():\nif (\navailability_status\nnot in RecreationBookingConfig.CAMPSITE_UNAVAILABLE_STRINGS\n):\nbooking_url = (\nf\"{RecreationBookingConfig.CAMPSITE_BOOKING_URL}/{campsite_id}\"\n)\nequipment, attributes = cls._get_equipment_and_attributes(\ncampsite_id=campsite_id, campsite_metadata=campsite_metadata\n)\navailable_campsite = AvailableCampsite(\ncampsite_id=campsite_id,\nbooking_date=matching_date,\nbooking_end_date=matching_date + timedelta(days=1),\nbooking_nights=1,\ncampsite_site_name=site_related_data.site,\ncampsite_loop_name=site_related_data.loop,\ncampsite_type=site_related_data.campsite_type,\ncampsite_occupancy=(\nsite_related_data.min_num_people,\nsite_related_data.max_num_people,\n),\ncampsite_use_type=site_related_data.type_of_use,\navailability_status=availability_status,\nrecreation_area=recreation_area,\nrecreation_area_id=recreation_area_id,\nfacility_name=facility_name,\nfacility_id=facility_id,\nbooking_url=booking_url,\npermitted_equipment=equipment,\ncampsite_attributes=attributes,\n)\ntotal_campsite_availability.append(available_campsite)\nreturn total_campsite_availability\n</code></pre>"},{"location":"reference/providers/#camply.providers.recreation_dot_gov.recdotgov_camps.RecreationDotGov.make_recdotgov_availability_request","title":"<code>make_recdotgov_availability_request(campground_id, month)</code>","text":"<p>Make a request to the RecreationDotGov API</p> <p>Parameters:</p> Name Type Description Default <code>campground_id</code> <code>int</code> required <code>month</code> <code>datetime</code> required <p>Returns:</p> Type Description <code>requests.Response</code> Source code in <code>camply/providers/recreation_dot_gov/recdotgov_camps.py</code> <pre><code>def make_recdotgov_availability_request(\nself,\ncampground_id: int,\nmonth: datetime,\n) -&gt; requests.Response:\n\"\"\"\n    Make a request to the RecreationDotGov API\n    Parameters\n    ----------\n    campground_id\n    month\n    Returns\n    -------\n    requests.Response\n    \"\"\"\napi_endpoint = self._rec_availability_get_endpoint(\npath=f\"{campground_id}/{RecreationBookingConfig.API_MONTH_PATH}\"\n)\nformatted_month = month.strftime(\"%Y-%m-01T00:00:00.000Z\")\nquery_params = {\"start_date\": formatted_month}\nreturn self.make_recdotgov_request(\nmethod=\"GET\",\nurl=api_endpoint,\nparams=query_params,\n)\n</code></pre>"},{"location":"reference/providers/#camply.providers.recreation_dot_gov.recdotgov_camps.RecreationDotGov.paginate_recdotgov_campsites","title":"<code>paginate_recdotgov_campsites(facility_id, equipment=None)</code>","text":"<p>Paginate through the RecDotGov Campsite Metadata</p> Source code in <code>camply/providers/recreation_dot_gov/recdotgov_camps.py</code> <pre><code>def paginate_recdotgov_campsites(\nself, facility_id: int, equipment: Optional[List[str]] = None\n) -&gt; List[RecDotGovCampsite]:\n\"\"\"\n    Paginate through the RecDotGov Campsite Metadata\n    \"\"\"\nresults = 0\ncontinue_paginate = True\nendpoint_url = api_utils.generate_url(\nscheme=RecreationBookingConfig.API_SCHEME,\nnetloc=RecreationBookingConfig.API_NET_LOC,\npath=\"api/search/campsites\",\n)\nfq_list = [f\"asset_id:{facility_id}\"]\nif isinstance(equipment, list) and len(equipment) &gt; 0:\nfor item in equipment:\nfq_list.append(f\"campsite_equipment_name:{item}\")\nparams = {\n\"start\": 0,\n\"size\": 1000,\n\"fq\": fq_list,\n\"include_non_site_specific_campsites\": True,\n}\ncampsites: List[RecDotGovCampsite] = []\nwhile continue_paginate is True:\nresponse = self.make_recdotgov_request_retry(\nmethod=\"GET\",\nurl=endpoint_url,\nparams=params,\n)\nreturned_data = json.loads(response.content)\ncampsite_response = RecDotGovCampsiteResponse(**returned_data)\ncampsites += campsite_response.campsites\nresults += campsite_response.size\nparams.update(start=results)\nif results == campsite_response.total:\ncontinue_paginate = False\nreturn campsites\n</code></pre>"},{"location":"reference/providers/#camply.providers.recreation_dot_gov.recdotgov_camps.RecreationDotGov.process_campsite_availability","title":"<code>process_campsite_availability(availability, recreation_area, recreation_area_id, facility_name, facility_id, month, campsite_metadata)</code>  <code>classmethod</code>","text":"<p>Parse the JSON Response and return availabilities</p> <p>Parameters:</p> Name Type Description Default <code>availability</code> <code>Dict[str, Any]</code> <p>API Response</p> required <code>recreation_area</code> <code>str</code> <p>Name of Recreation Area</p> required <code>recreation_area_id</code> <code>int</code> <p>ID of Recreation Area</p> required <code>facility_name</code> <code>str</code> <p>Campground Facility Name</p> required <code>facility_id</code> <code>int</code> <p>Campground Facility ID</p> required <code>month</code> <code>datetime</code> <p>Month to Process</p> required <code>campsite_metadata</code> <code>pd.DataFrame</code> <p>Metadata Fetched from the Recreation.gov API about the Campsites</p> required <p>Returns:</p> Name Type Description <code>total_campsite_availability</code> <code>List[Optional[AvailableCampsite]]</code> <p>Any monthly availabilities</p> Source code in <code>camply/providers/recreation_dot_gov/recdotgov_camps.py</code> <pre><code>@classmethod\ndef process_campsite_availability(\ncls,\navailability: Dict[str, Any],\nrecreation_area: str,\nrecreation_area_id: int,\nfacility_name: str,\nfacility_id: int,\nmonth: datetime,\ncampsite_metadata: pd.DataFrame,\n) -&gt; List[Optional[AvailableCampsite]]:\n\"\"\"\n    Parse the JSON Response and return availabilities\n    Parameters\n    ----------\n    availability: Dict[str, Any]\n        API Response\n    recreation_area: str\n        Name of Recreation Area\n    recreation_area_id: int\n        ID of Recreation Area\n    facility_name: str\n        Campground Facility Name\n    facility_id: int\n        Campground Facility ID\n    month: datetime\n        Month to Process\n    campsite_metadata: pd.DataFrame\n        Metadata Fetched from the Recreation.gov API about the Campsites\n    Returns\n    -------\n    total_campsite_availability: List[Optional[AvailableCampsite]]\n        Any monthly availabilities\n    \"\"\"\ntotal_campsite_availability: List[Optional[AvailableCampsite]] = []\ncampsite_data = CampsiteAvailabilityResponse(**availability)\nfor campsite_id, site_related_data in campsite_data.campsites.items():\nfor (\nmatching_date,\navailability_status,\n) in site_related_data.availabilities.items():\nif (\navailability_status\nnot in RecreationBookingConfig.CAMPSITE_UNAVAILABLE_STRINGS\n):\nbooking_url = (\nf\"{RecreationBookingConfig.CAMPSITE_BOOKING_URL}/{campsite_id}\"\n)\nequipment, attributes = cls._get_equipment_and_attributes(\ncampsite_id=campsite_id, campsite_metadata=campsite_metadata\n)\navailable_campsite = AvailableCampsite(\ncampsite_id=campsite_id,\nbooking_date=matching_date,\nbooking_end_date=matching_date + timedelta(days=1),\nbooking_nights=1,\ncampsite_site_name=site_related_data.site,\ncampsite_loop_name=site_related_data.loop,\ncampsite_type=site_related_data.campsite_type,\ncampsite_occupancy=(\nsite_related_data.min_num_people,\nsite_related_data.max_num_people,\n),\ncampsite_use_type=site_related_data.type_of_use,\navailability_status=availability_status,\nrecreation_area=recreation_area,\nrecreation_area_id=recreation_area_id,\nfacility_name=facility_name,\nfacility_id=facility_id,\nbooking_url=booking_url,\npermitted_equipment=equipment,\ncampsite_attributes=attributes,\n)\ntotal_campsite_availability.append(available_campsite)\nreturn total_campsite_availability\n</code></pre>"},{"location":"reference/providers/#camply.providers.RecreationDotGovDailyTicket","title":"<code>RecreationDotGovDailyTicket</code>","text":"<p>         Bases: <code>RecreationDotGovDailyMixin</code>, <code>RecreationDotGovTicket</code></p> <p>RecreationDotGovTicket: Daily</p> <p>Daily MixIn for Tickets</p> Source code in <code>camply/providers/recreation_dot_gov/recdotgov_tours.py</code> <pre><code>class RecreationDotGovDailyTicket(RecreationDotGovDailyMixin, RecreationDotGovTicket):\n\"\"\"\n    RecreationDotGovTicket: Daily\n    Daily MixIn for Tickets\n    \"\"\"\n</code></pre>"},{"location":"reference/providers/#camply.providers.RecreationDotGovDailyTimedEntry","title":"<code>RecreationDotGovDailyTimedEntry</code>","text":"<p>         Bases: <code>RecreationDotGovDailyMixin</code>, <code>RecreationDotGovTimedEntry</code></p> <p>RecreationDotGovTimedEntry: Daily</p> <p>Daily MixIn for Tours</p> Source code in <code>camply/providers/recreation_dot_gov/recdotgov_tours.py</code> <pre><code>class RecreationDotGovDailyTimedEntry(\nRecreationDotGovDailyMixin, RecreationDotGovTimedEntry\n):\n\"\"\"\n    RecreationDotGovTimedEntry: Daily\n    Daily MixIn for Tours\n    \"\"\"\n</code></pre>"},{"location":"reference/providers/#camply.providers.RecreationDotGovTicket","title":"<code>RecreationDotGovTicket</code>","text":"<p>         Bases: <code>RecreationDotGovTours</code></p> <p>RecreationDotGovTicket</p> <p>Tickets for Tours</p> Source code in <code>camply/providers/recreation_dot_gov/recdotgov_tours.py</code> <pre><code>class RecreationDotGovTicket(RecreationDotGovTours):\n\"\"\"\n    RecreationDotGovTicket\n    Tickets for Tours\n    \"\"\"\nfacility_type = RIDBConfig.TICKET_FACILITY_FIELD_QUALIFIER\napi_search_fq = \"entity_type:tour\"\napi_base_path = \"api/ticket/availability/facility/\"\nbooking_url = \"https://www.recreation.gov/ticket/{facility_id}/ticket/{tour_id}\"\n</code></pre>"},{"location":"reference/providers/#camply.providers.RecreationDotGovTimedEntry","title":"<code>RecreationDotGovTimedEntry</code>","text":"<p>         Bases: <code>RecreationDotGovTours</code></p> <p>RecreationDotGovTimedEntry</p> <p>Timed Entries</p> Source code in <code>camply/providers/recreation_dot_gov/recdotgov_tours.py</code> <pre><code>class RecreationDotGovTimedEntry(RecreationDotGovTours):\n\"\"\"\n    RecreationDotGovTimedEntry\n    Timed Entries\n    \"\"\"\nfacility_type = RIDBConfig.TIMED_ENTRY_FACILITY_FIELD_QUALIFIER\napi_search_fq = \"entity_type:timedentry_tour\"\napi_base_path = \"api/timedentry/availability/facility/\"\nbooking_url = (\n\"https://www.recreation.gov/timed-entry/{facility_id}/ticket/{tour_id}\"\n)\n</code></pre>"},{"location":"reference/providers/#camply.providers.ReserveCalifornia","title":"<code>ReserveCalifornia</code>","text":"<p>         Bases: <code>UseDirectProvider</code></p> <p>ReserveCalifornia</p> Source code in <code>camply/providers/usedirect/variations.py</code> <pre><code>class ReserveCalifornia(UseDirectProvider):\n\"\"\"\n    ReserveCalifornia\n    \"\"\"\nbase_url = \"https://calirdr.usedirect.com\"\ncampground_url = \"https://www.reservecalifornia.com\"\nstate_code = \"CA\"\n</code></pre>"},{"location":"reference/providers/#camply.providers.VirginiaStateParks","title":"<code>VirginiaStateParks</code>","text":"<p>         Bases: <code>UseDirectProvider</code></p> <p>Virginia State Parks</p> Source code in <code>camply/providers/usedirect/variations.py</code> <pre><code>class VirginiaStateParks(UseDirectProvider):\n\"\"\"\n    Virginia State Parks\n    \"\"\"\nbase_url = \"https://virginiardr.usedirect.com\"\ncampground_url = \"https://VirginiaStateParks.com\"\nrdr_path = \"virginiardr\"\nbooking_path = \"Web\"\nstate_code = \"VA\"\n</code></pre>"},{"location":"reference/providers/#camply.providers.Yellowstone","title":"<code>Yellowstone</code>","text":"<p>         Bases: <code>BaseProvider</code></p> <p>Scanner for Lodging in Yellowstone</p> Source code in <code>camply/providers/xanterra/yellowstone_lodging.py</code> <pre><code>class Yellowstone(BaseProvider):\n\"\"\"\n    Scanner for Lodging in Yellowstone\n    \"\"\"\nrecreation_area = RecreationArea(\nrecreation_area=YellowstoneConfig.YELLOWSTONE_RECREATION_AREA_FULL_NAME,\nrecreation_area_id=YellowstoneConfig.YELLOWSTONE_RECREATION_AREA_ID,\nrecreation_area_location=\"USA\",\n)\ndef _get_monthly_availability(self, month: datetime, nights: int = None) -&gt; dict:\n\"\"\"\n        Check All Lodging in Yellowstone for Campground Data\n        Returns\n        -------\n        data_availability: dict\n            Data Availability Dictionary\n        \"\"\"\nquery_dict = {\n\"date\": self._ensure_current_month(month=month),\n\"limit\": 31,\n\"rate_code\": YellowstoneConfig.RATE_CODE,\n}\nif nights is not None:\nquery_dict.update({\"nights\": nights})\napi_endpoint = self._get_api_endpoint(\nurl_path=YellowstoneConfig.YELLOWSTONE_LODGING_PATH, query=None\n)\nlogger.info(\nf\"Searching for Yellowstone Lodging Availability: {month.strftime('%B, %Y')}\"\n)\nall_resort_availability_data = self.make_yellowstone_request(\nendpoint=api_endpoint, params=query_dict\n)\nreturn all_resort_availability_data\n@staticmethod\n@tenacity.retry(\nwait=tenacity.wait_random_exponential(multiplier=3, max=1800),\nstop=tenacity.stop.stop_after_delay(6000),\n)\ndef _try_retry_get_data(endpoint: str, params: Optional[dict] = None) -&gt; dict:\n\"\"\"\n        Try and Retry Fetching Data from the Yellowstone API.\n        Unfortunately this is a required method to request the data since the\n        Yellowstone API doesn't always return data.\n        Parameters\n        ----------\n        endpoint: str\n            API Endpoint\n        params\n        Returns\n        -------\n        dict\n        \"\"\"\nyellowstone_headers = {}\nuser_agent = {\n\"User-Agent\": UserAgent(use_external_data=False, browsers=[\"chrome\"]).chrome\n}\nyellowstone_headers.update(user_agent)\nyellowstone_headers.update(STANDARD_HEADERS)\nyellowstone_headers.update(YellowstoneConfig.API_REFERRERS)\nresponse = requests.get(\nurl=endpoint, headers=yellowstone_headers, params=params, timeout=30\n)\nif response.ok is True and response.text.strip() != \"\":\nreturn loads(response.content)\nelse:\nerror_message = (\n\"Something went wrong with checking the \"\n\"Yellowstone Booking API. Will continue retrying.\"\n)\nlogger.warning(error_message)\nraise RuntimeError(error_message)\n@staticmethod\ndef make_yellowstone_request(endpoint: str, params: Optional[dict] = None) -&gt; dict:\n\"\"\"\n        Try and Retry Fetching Data from the Yellowstone API.\n        Unfortunately this is a required method to request the data since the\n        Yellowstone API doesn't always return data.\n        Parameters\n        ----------\n        endpoint: str\n            API Endpoint\n        params\n        Returns\n        -------\n        dict\n        \"\"\"\ntry:\ncontent = Yellowstone._try_retry_get_data(endpoint=endpoint, params=params)\nexcept RuntimeError as re:\nraise RuntimeError(f\"error_message: {re}\") from re\nreturn content\n@classmethod\ndef _get_api_endpoint(cls, url_path: str, query: Optional[dict] = None) -&gt; str:\n\"\"\"\n        Build the API Endpoint for All Yellowstone Lodging\n        \"\"\"\nif query is not None:\nquery_string = parse.urlencode(query=query)\nelse:\nquery_string = \"\"\nurl_components = {\n\"scheme\": YellowstoneConfig.API_SCHEME,\n\"netloc\": YellowstoneConfig.API_BASE_ENDPOINT,\n\"url\": url_path,\n\"params\": \"\",\n\"query\": query_string,\n\"fragment\": \"\",\n}\napi_endpoint = parse.urlunparse(tuple(url_components.values()))\nreturn api_endpoint\n@classmethod\ndef _return_lodging_url(\ncls, lodging_code: str, month: datetime, params: Optional[dict] = \"\"\n) -&gt; str:\n\"\"\"\n        Return a Browser Loadable URL to book from\n        Parameters\n        ----------\n        lodging_code: str\n            Lodging Code from API\n        month: datetime\n            Month to return bookings filtered to\n        params: Optional[dict]\n            Optional URL Parameters\n        Returns\n        -------\n        str\n            URL String\n        \"\"\"\nquery = {\n\"dateFrom\": month.strftime(\"%m-%d-%Y\"),\n\"adults\": 1,\n\"destination\": lodging_code,\n\"children\": 0,\n}\nif params is not None:\nquery.update(params)\nquery_string = parse.urlencode(query=query)\nurl_components = {\n\"scheme\": YellowstoneConfig.API_SCHEME,\n\"netloc\": YellowstoneConfig.WEBUI_BASE_ENDPOINT,\n\"url\": YellowstoneConfig.WEBUI_BOOKING_PATH,\n\"params\": \"\",\n\"query\": query_string,\n\"fragment\": \"\",\n}\nwebui_endpoint = parse.urlunparse(tuple(url_components.values()))\nreturn webui_endpoint\n@classmethod\ndef _compile_campground_availabilities(\ncls, availability: XantResortData\n) -&gt; List[dict]:\n\"\"\"\n        Gather Data about campground availabilities within a JSON Availability Objet\n        Parameters\n        ----------\n        availability: ResortData\n            JSON Availability Object\n        Returns\n        -------\n        available_campsites:  List[dict]\n            List of Availabilities as JSON\n        \"\"\"\navailable_campsites = []\nfor booking_date, daily_data in availability.availability.items():\ncamping_keys = [\nkey\nfor key in daily_data.keys()\nif YellowstoneConfig.LODGING_CAMPGROUND_QUALIFIER in key\n]\nfor hotel_code in camping_keys:\nhotel_data = daily_data[hotel_code]\ntry:\nhotel_title = hotel_data.rates[YellowstoneConfig.RATE_CODE].title\nhotel_rate_mins = hotel_data.rates[YellowstoneConfig.RATE_CODE].mins\nif hotel_rate_mins != {1: 0}:\nmin_capacity = min(hotel_rate_mins.keys())\nmax_capacity = max(hotel_rate_mins.keys())\ncapacity = (min_capacity, max_capacity)\ncampsite = {\n\"campsite_id\": None,\n\"booking_date\": booking_date,\n\"campsite_occupancy\": capacity,\n\"recreation_area\": YellowstoneConfig.YELLOWSTONE_RECREATION_AREA_NAME,\n\"recreation_area_id\": YellowstoneConfig.YELLOWSTONE_RECREATION_AREA_ID,\n\"facility_name\": hotel_title.replace(\n*YellowstoneConfig.YELLOWSTONE_CAMPGROUND_NAME_REPLACE\n),\n\"facility_id\": hotel_code,\n}\navailable_campsites.append(campsite)\nexcept KeyError:\npass\nlogger.info(\nf\"\\t{logging_utils.get_emoji(available_campsites)}\\t\"\nf\"{len(available_campsites)} sites found.\"\n)\nreturn available_campsites\ndef _gather_campsite_specific_availability(\nself,\navailable_campsites: List[dict],\nmonth: datetime,\nnights: Optional[int] = None,\n) -&gt; List[dict]:\n\"\"\"\n        Get campsite extra information\n        Given a DataFrame of campsite availability, return updated Data with details\n        about the actual campsites that are available (i.e Tent Size, RV Length, Etc)\n        Parameters\n        ----------\n        available_campsites: List[dict]\n            List of Available Campsites as JSON objects\n        month: datetime\n            Month object\n        Returns\n        -------\n        List[dict]\n        \"\"\"\navailable_room_array = []\navailability_df = DataFrame(data=available_campsites)\nif availability_df.empty is True:\nreturn available_room_array\nfor facility_id, _facility_df in availability_df.groupby(\nYellowstoneConfig.FACILITY_ID\n):\napi_endpoint = self._get_api_endpoint(\nurl_path=YellowstoneConfig.YELLOWSTONE_CAMPSITE_AVAILABILITY, query=None\n)\nparams = {\"date\": self._ensure_current_month(month=month), \"limit\": 31}\nif nights is not None:\nparams.update({\"nights\": nights})\ncampsite_data = self.make_yellowstone_request(\nendpoint=f\"{api_endpoint}/{facility_id}\", params=params\n)\ncampsite_availability = campsite_data[\nYellowstoneConfig.BOOKING_AVAILABILITY\n]\nbooking_dates = campsite_availability.keys()\navailabilities = self._process_daily_availability(\nbooking_dates=booking_dates,\ncampsite_availability=campsite_availability,\nfacility_id=facility_id,\n)\navailable_room_array += availabilities\nreturn available_room_array\n@classmethod\ndef _process_daily_availability(\ncls, booking_dates: List[str], campsite_availability: dict, facility_id: str\n) -&gt; List[dict]:\n\"\"\"\n        Process Monthly Availability\n        Parameters\n        ----------\n        booking_dates: List[str]\n            List of booking dates to process\n        campsite_availability: dict\n            Campsite availability dict\n        facility_id: str\n            Identification of the Facility\n        Returns\n        -------\n        List[dict]\n        \"\"\"\ndaily_availabilities = []\nfor booking_date_str in booking_dates:\ndaily_availability = campsite_availability[booking_date_str]\nif (\ndaily_availability[YellowstoneConfig.FACILITY_STATUS]\n== YellowstoneConfig.FACILITY_STATUS_QUALIFIER\n):\navailable_rooms = daily_availability[YellowstoneConfig.FACILITY_ROOMS]\nfor room in available_rooms:\nif room[YellowstoneConfig.FACILITY_AVAILABLE_QUALIFIER] &gt; 0:\ndaily_availabilities.append(\n{\n\"booking_date\": booking_date_str,\n\"facility_id\": facility_id,\n\"campsite_code\": room[\nYellowstoneConfig.FACILITY_ROOM_CODE\n],\n\"available\": room[\nYellowstoneConfig.FACILITY_AVAILABLE_QUALIFIER\n],\n\"price\": room[YellowstoneConfig.FACILITY_PRICE],\n}\n)\nreturn daily_availabilities\ndef _get_property_information(self, available_rooms: List[dict]) -&gt; List[dict]:\n\"\"\"\n        Gather Information About All Campgrounds / Hotels within Yellowstone\n        Parameters\n        ----------\n        available_rooms: List[dict]\n        Returns\n        -------\n        List[dict]\n        \"\"\"\nproperty_info_array = []\navailability_df = DataFrame(data=available_rooms)\nif availability_df.empty is True:\nreturn property_info_array\nfacility_identifiers = availability_df[YellowstoneConfig.FACILITY_ID].unique()\nfor facility_id in facility_identifiers:\napi_endpoint = self._get_api_endpoint(\nurl_path=YellowstoneConfig.YELLOWSTONE_PROPERTY_INFO, query=None\n)\ncampsite_info = self.make_yellowstone_request(\nendpoint=f\"{api_endpoint}/{facility_id}\"\n)\ncampsite_codes = campsite_info.keys()\nfor campsite_code in campsite_codes:\ncampsite_data = campsite_info[campsite_code]\nproperty_info_array.append(\n{\n\"facility_id\": facility_id,\n\"campsite_code\": campsite_code,\n\"campsite_title\": campsite_data[\nYellowstoneConfig.LODGING_TITLE\n],\n\"campsite_type\": campsite_data[\nYellowstoneConfig.FACILITY_TYPE\n].upper(),\n\"capacity\": (\ncampsite_data[YellowstoneConfig.LODGING_OCCUPANCY_BASE],\ncampsite_data[YellowstoneConfig.LODGING_OCCUPANCY_MAX],\n),\n}\n)\nreturn property_info_array\ndef get_monthly_campsites(\nself, month: datetime, nights: Optional[int] = None\n) -&gt; List[AvailableCampsite]:\n\"\"\"\n        Return All Campsites Available in a Given Month\n        Parameters\n        ----------\n        month: datetime\n            Month to Search\n        nights: Optional[int]\n            Search for consecutive nights\n        Returns\n        -------\n        List[AvailableCampsite]\n        \"\"\"\nnow = datetime.now().date()\nsearch_date = month.replace(day=1)\nif month &lt;= now:\nlogger.info(\n\"Cannot input search dates before today, adjusting search parameters.\"\n)\nsearch_date = search_date.replace(\nyear=now.year, month=now.month, day=now.day\n)\navailability_found = self._get_monthly_availability(\nmonth=search_date, nights=nights\n)\navailability = XantResortData(**availability_found)\nmonthly_campsites = self._compile_campground_availabilities(\navailability=availability\n)\ncampsite_data = DataFrame(\nmonthly_campsites, columns=YellowstoneConfig.CAMPSITE_DATA_COLUMNS\n).drop_duplicates()\nif campsite_data.empty is True:\nreturn []\navailable_room_array = self._gather_campsite_specific_availability(\navailable_campsites=monthly_campsites, month=month, nights=nights\n)\navailable_rooms = DataFrame(available_room_array)\nproperty_info = self._get_property_information(\navailable_rooms=available_room_array\n)\nproperties = DataFrame(property_info)\nmerged_campsites = available_rooms.merge(\nproperties,\non=[\nYellowstoneConfig.FACILITY_ID_COLUMN,\nYellowstoneConfig.CAMPSITE_ID_COLUMN,\n],\n)\nmerged_campsites[YellowstoneConfig.BOOKING_DATE_COLUMN] = to_datetime(\nmerged_campsites[YellowstoneConfig.BOOKING_DATE_COLUMN]\n)\nif nights is not None:\nnights_param = {\"nights\": nights}\nelse:\nnights_param = {\"nights\": 1}\nbooking_nights = nights_param.get(\"nights\")\nmerged_campsites[YellowstoneConfig.BOOKING_END_DATE_COLUMN] = merged_campsites[\nYellowstoneConfig.BOOKING_DATE_COLUMN\n] + timedelta(days=booking_nights)\nmerged_campsites[YellowstoneConfig.BOOKING_NIGHTS_COLUMN] = booking_nights\nfinal_campsites = merged_campsites.merge(\ncampsite_data, on=YellowstoneConfig.FACILITY_ID_COLUMN\n).sort_values(by=YellowstoneConfig.BOOKING_DATE_COLUMN)\nfinal_campsites[YellowstoneConfig.BOOKING_URL_COLUMN] = final_campsites.apply(\nlambda x: self._return_lodging_url(\nlodging_code=x.facility_id, month=x.booking_date, params=nights_param\n),\naxis=1,\n)\nall_monthly_campsite_array = self._df_to_campsites(campsite_df=final_campsites)\nreturn all_monthly_campsite_array\n@classmethod\ndef _df_to_campsites(cls, campsite_df: DataFrame) -&gt; List[AvailableCampsite]:\n\"\"\"\n        Transform a DataFrame into an array of AvailableCampsites\n        Parameters\n        ----------\n        campsite_df: DataFrame\n        Returns\n        -------\n        List[AvailableCampsite]\n        \"\"\"\nall_monthly_campsite_array = []\nfor _, row in campsite_df.iterrows():\ncampsite = AvailableCampsite(\ncampsite_id=row[YellowstoneConfig.CAMPSITE_ID_COLUMN],\nbooking_date=row[YellowstoneConfig.BOOKING_DATE_COLUMN],\nbooking_end_date=row[YellowstoneConfig.BOOKING_END_DATE_COLUMN],\nbooking_nights=row[YellowstoneConfig.BOOKING_NIGHTS_COLUMN],\ncampsite_site_name=row[YellowstoneConfig.CAMPSITE_SITE_NAME_COLUMN],\ncampsite_loop_name=YellowstoneConfig.YELLOWSTONE_LOOP_NAME,\ncampsite_type=row[YellowstoneConfig.CAMPSITE_TYPE_COLUMN],\ncampsite_occupancy=row[YellowstoneConfig.CAMPSITE_OCCUPANCY_COLUMN],\ncampsite_use_type=row[YellowstoneConfig.CAMPSITE_USE_TYPE_COLUMN],\navailability_status=YellowstoneConfig.CAMPSITE_AVAILABILITY_STATUS,\nrecreation_area=YellowstoneConfig.YELLOWSTONE_RECREATION_AREA_NAME,\nrecreation_area_id=YellowstoneConfig.YELLOWSTONE_RECREATION_AREA_ID,\nfacility_name=row[YellowstoneConfig.FACILITY_NAME_COLUMN],\nfacility_id=row[YellowstoneConfig.FACILITY_ID_COLUMN],\nbooking_url=row[YellowstoneConfig.BOOKING_URL_COLUMN],\n)\nall_monthly_campsite_array.append(campsite)\nreturn all_monthly_campsite_array\n@classmethod\ndef _ensure_current_month(cls, month: datetime) -&gt; datetime:\n\"\"\"\n        Ensure That We Never Give the Yellowstone API Dates in the past.\n        Parameters\n        ----------\n        month: datetime\n        Returns\n        -------\n        datetime\n        \"\"\"\nyellowstone_timezone = timezone(YellowstoneConfig.YELLOWSTONE_TIMEZONE)\nyellowstone_current_time = datetime.now(yellowstone_timezone).date()\ntoday = datetime(\nyear=yellowstone_current_time.year,\nmonth=yellowstone_current_time.month,\nday=yellowstone_current_time.day,\n).date()\nif today &gt; month:\nmonth = today\nreturn month\ndef find_campgrounds(self, **kwargs) -&gt; List[CampgroundFacility]:\n\"\"\"\n        Print the Campgrounds inside of Yellowstone\n        \"\"\"\nlog_sorted_response(YellowstoneConfig.YELLOWSTONE_CAMPGROUND_OBJECTS)\nreturn YellowstoneConfig.YELLOWSTONE_CAMPGROUND_OBJECTS\n</code></pre>"},{"location":"reference/providers/#camply.providers.xanterra.yellowstone_lodging.Yellowstone.find_campgrounds","title":"<code>find_campgrounds(**kwargs)</code>","text":"<p>Print the Campgrounds inside of Yellowstone</p> Source code in <code>camply/providers/xanterra/yellowstone_lodging.py</code> <pre><code>def find_campgrounds(self, **kwargs) -&gt; List[CampgroundFacility]:\n\"\"\"\n    Print the Campgrounds inside of Yellowstone\n    \"\"\"\nlog_sorted_response(YellowstoneConfig.YELLOWSTONE_CAMPGROUND_OBJECTS)\nreturn YellowstoneConfig.YELLOWSTONE_CAMPGROUND_OBJECTS\n</code></pre>"},{"location":"reference/providers/#camply.providers.xanterra.yellowstone_lodging.Yellowstone.get_monthly_campsites","title":"<code>get_monthly_campsites(month, nights=None)</code>","text":"<p>Return All Campsites Available in a Given Month</p> <p>Parameters:</p> Name Type Description Default <code>month</code> <code>datetime</code> <p>Month to Search</p> required <code>nights</code> <code>Optional[int]</code> <p>Search for consecutive nights</p> <code>None</code> <p>Returns:</p> Type Description <code>List[AvailableCampsite]</code> Source code in <code>camply/providers/xanterra/yellowstone_lodging.py</code> <pre><code>def get_monthly_campsites(\nself, month: datetime, nights: Optional[int] = None\n) -&gt; List[AvailableCampsite]:\n\"\"\"\n    Return All Campsites Available in a Given Month\n    Parameters\n    ----------\n    month: datetime\n        Month to Search\n    nights: Optional[int]\n        Search for consecutive nights\n    Returns\n    -------\n    List[AvailableCampsite]\n    \"\"\"\nnow = datetime.now().date()\nsearch_date = month.replace(day=1)\nif month &lt;= now:\nlogger.info(\n\"Cannot input search dates before today, adjusting search parameters.\"\n)\nsearch_date = search_date.replace(\nyear=now.year, month=now.month, day=now.day\n)\navailability_found = self._get_monthly_availability(\nmonth=search_date, nights=nights\n)\navailability = XantResortData(**availability_found)\nmonthly_campsites = self._compile_campground_availabilities(\navailability=availability\n)\ncampsite_data = DataFrame(\nmonthly_campsites, columns=YellowstoneConfig.CAMPSITE_DATA_COLUMNS\n).drop_duplicates()\nif campsite_data.empty is True:\nreturn []\navailable_room_array = self._gather_campsite_specific_availability(\navailable_campsites=monthly_campsites, month=month, nights=nights\n)\navailable_rooms = DataFrame(available_room_array)\nproperty_info = self._get_property_information(\navailable_rooms=available_room_array\n)\nproperties = DataFrame(property_info)\nmerged_campsites = available_rooms.merge(\nproperties,\non=[\nYellowstoneConfig.FACILITY_ID_COLUMN,\nYellowstoneConfig.CAMPSITE_ID_COLUMN,\n],\n)\nmerged_campsites[YellowstoneConfig.BOOKING_DATE_COLUMN] = to_datetime(\nmerged_campsites[YellowstoneConfig.BOOKING_DATE_COLUMN]\n)\nif nights is not None:\nnights_param = {\"nights\": nights}\nelse:\nnights_param = {\"nights\": 1}\nbooking_nights = nights_param.get(\"nights\")\nmerged_campsites[YellowstoneConfig.BOOKING_END_DATE_COLUMN] = merged_campsites[\nYellowstoneConfig.BOOKING_DATE_COLUMN\n] + timedelta(days=booking_nights)\nmerged_campsites[YellowstoneConfig.BOOKING_NIGHTS_COLUMN] = booking_nights\nfinal_campsites = merged_campsites.merge(\ncampsite_data, on=YellowstoneConfig.FACILITY_ID_COLUMN\n).sort_values(by=YellowstoneConfig.BOOKING_DATE_COLUMN)\nfinal_campsites[YellowstoneConfig.BOOKING_URL_COLUMN] = final_campsites.apply(\nlambda x: self._return_lodging_url(\nlodging_code=x.facility_id, month=x.booking_date, params=nights_param\n),\naxis=1,\n)\nall_monthly_campsite_array = self._df_to_campsites(campsite_df=final_campsites)\nreturn all_monthly_campsite_array\n</code></pre>"},{"location":"reference/providers/#camply.providers.xanterra.yellowstone_lodging.Yellowstone.make_yellowstone_request","title":"<code>make_yellowstone_request(endpoint, params=None)</code>  <code>staticmethod</code>","text":"<p>Try and Retry Fetching Data from the Yellowstone API.</p> <p>Unfortunately this is a required method to request the data since the Yellowstone API doesn't always return data.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>API Endpoint</p> required <code>params</code> <code>Optional[dict]</code> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> Source code in <code>camply/providers/xanterra/yellowstone_lodging.py</code> <pre><code>@staticmethod\ndef make_yellowstone_request(endpoint: str, params: Optional[dict] = None) -&gt; dict:\n\"\"\"\n    Try and Retry Fetching Data from the Yellowstone API.\n    Unfortunately this is a required method to request the data since the\n    Yellowstone API doesn't always return data.\n    Parameters\n    ----------\n    endpoint: str\n        API Endpoint\n    params\n    Returns\n    -------\n    dict\n    \"\"\"\ntry:\ncontent = Yellowstone._try_retry_get_data(endpoint=endpoint, params=params)\nexcept RuntimeError as re:\nraise RuntimeError(f\"error_message: {re}\") from re\nreturn content\n</code></pre>"},{"location":"reference/providers/base_provider/","title":"base_provider","text":"<p>BaseProvider Base Class</p>"},{"location":"reference/providers/base_provider/#camply.providers.base_provider.BaseProvider","title":"<code>BaseProvider</code>","text":"<p>         Bases: <code>ABC</code></p> <p>Base Provider Class</p> Source code in <code>camply/providers/base_provider.py</code> <pre><code>class BaseProvider(ABC):\n\"\"\"\n    Base Provider Class\n    \"\"\"\ndef __repr__(self):\n\"\"\"\n        String Representation\n        Returns\n        -------\n        str\n        \"\"\"\nreturn f\"&lt;{self.__class__.__name__}&gt;\"\ndef __init__(self):\n\"\"\"\n        Initialize with a session\n        \"\"\"\n_user_agent = UserAgent(use_external_data=False, browsers=[\"chrome\"]).chrome\nself.session = requests.Session()\nself.headers = {\"User-Agent\": _user_agent}\nself.session.headers = self.headers\nself.json_headers = self.headers.copy()\nself.json_headers.update({\"Content-Type\": \"application/json\"})\n@classmethod\ndef get_search_months(cls, search_days) -&gt; List[datetime]:\n\"\"\"\n        Get the Unique Months that need to be Searched\n        Returns\n        -------\n        search_months: List[datetime]\n            Datetime Months to search for reservations\n        \"\"\"\ntruncated_months = {day.replace(day=1) for day in search_days}\nif len(truncated_months) &gt; 1:\nlogger.info(\nf\"{len(truncated_months)} different months selected for search, \"\nf\"ranging from {min(search_days)} to {max(search_days)}\"\n)\nreturn sorted(truncated_months)\nelif len(truncated_months) == 0:\nlogger.error(SearchConfig.ERROR_MESSAGE)\nraise RuntimeError(SearchConfig.ERROR_MESSAGE)\nelse:\nreturn sorted(truncated_months)\n@abstractmethod\ndef find_campgrounds(self) -&gt; List[CampgroundFacility]:\n\"\"\"\n        List Recreation Areas for the provider\n        \"\"\"\n</code></pre>"},{"location":"reference/providers/base_provider/#camply.providers.base_provider.BaseProvider.__init__","title":"<code>__init__()</code>","text":"<p>Initialize with a session</p> Source code in <code>camply/providers/base_provider.py</code> <pre><code>def __init__(self):\n\"\"\"\n    Initialize with a session\n    \"\"\"\n_user_agent = UserAgent(use_external_data=False, browsers=[\"chrome\"]).chrome\nself.session = requests.Session()\nself.headers = {\"User-Agent\": _user_agent}\nself.session.headers = self.headers\nself.json_headers = self.headers.copy()\nself.json_headers.update({\"Content-Type\": \"application/json\"})\n</code></pre>"},{"location":"reference/providers/base_provider/#camply.providers.base_provider.BaseProvider.__repr__","title":"<code>__repr__()</code>","text":"<p>String Representation</p> <p>Returns:</p> Type Description <code>str</code> Source code in <code>camply/providers/base_provider.py</code> <pre><code>def __repr__(self):\n\"\"\"\n    String Representation\n    Returns\n    -------\n    str\n    \"\"\"\nreturn f\"&lt;{self.__class__.__name__}&gt;\"\n</code></pre>"},{"location":"reference/providers/base_provider/#camply.providers.base_provider.BaseProvider.find_campgrounds","title":"<code>find_campgrounds()</code>  <code>abstractmethod</code>","text":"<p>List Recreation Areas for the provider</p> Source code in <code>camply/providers/base_provider.py</code> <pre><code>@abstractmethod\ndef find_campgrounds(self) -&gt; List[CampgroundFacility]:\n\"\"\"\n    List Recreation Areas for the provider\n    \"\"\"\n</code></pre>"},{"location":"reference/providers/base_provider/#camply.providers.base_provider.BaseProvider.get_search_months","title":"<code>get_search_months(search_days)</code>  <code>classmethod</code>","text":"<p>Get the Unique Months that need to be Searched</p> <p>Returns:</p> Name Type Description <code>search_months</code> <code>List[datetime]</code> <p>Datetime Months to search for reservations</p> Source code in <code>camply/providers/base_provider.py</code> <pre><code>@classmethod\ndef get_search_months(cls, search_days) -&gt; List[datetime]:\n\"\"\"\n    Get the Unique Months that need to be Searched\n    Returns\n    -------\n    search_months: List[datetime]\n        Datetime Months to search for reservations\n    \"\"\"\ntruncated_months = {day.replace(day=1) for day in search_days}\nif len(truncated_months) &gt; 1:\nlogger.info(\nf\"{len(truncated_months)} different months selected for search, \"\nf\"ranging from {min(search_days)} to {max(search_days)}\"\n)\nreturn sorted(truncated_months)\nelif len(truncated_months) == 0:\nlogger.error(SearchConfig.ERROR_MESSAGE)\nraise RuntimeError(SearchConfig.ERROR_MESSAGE)\nelse:\nreturn sorted(truncated_months)\n</code></pre>"},{"location":"reference/providers/base_provider/#camply.providers.base_provider.ProviderError","title":"<code>ProviderError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>General Provider Error</p> Source code in <code>camply/providers/base_provider.py</code> <pre><code>class ProviderError(Exception):\n\"\"\"\n    General Provider Error\n    \"\"\"\n</code></pre>"},{"location":"reference/providers/base_provider/#camply.providers.base_provider.ProviderSearchError","title":"<code>ProviderSearchError</code>","text":"<p>         Bases: <code>ProviderError</code></p> <p>Searching Error</p> Source code in <code>camply/providers/base_provider.py</code> <pre><code>class ProviderSearchError(ProviderError):\n\"\"\"\n    Searching Error\n    \"\"\"\n</code></pre>"},{"location":"reference/providers/going_to_camp/","title":"going_to_camp","text":"<p>GoingToCamp init</p>"},{"location":"reference/providers/going_to_camp/going_to_camp_provider/","title":"going_to_camp_provider","text":"<p>Going to Camp Web Searching Utilities</p>"},{"location":"reference/providers/going_to_camp/going_to_camp_provider/#camply.providers.going_to_camp.going_to_camp_provider.GoingToCamp","title":"<code>GoingToCamp</code>","text":"<p>         Bases: <code>BaseProvider</code></p> <p>Going To Camp API provider</p> Source code in <code>camply/providers/going_to_camp/going_to_camp_provider.py</code> <pre><code>class GoingToCamp(BaseProvider):\n\"\"\"\n    Going To Camp API provider\n    \"\"\"\n@classmethod\ndef find_recreation_areas(\ncls, search_string: Optional[str] = None, **kwargs\n) -&gt; List[RecreationArea]:\n\"\"\"\n        Find Matching Recreation Areas based on search string\n        Parameters\n        ----------\n        search_string: Optional[str]\n            Search Keyword(s)\n        Returns\n        -------\n        filtered_responses: List[RecreationArea]\n            Array of Matching Recreation Areas\n        \"\"\"\nif search_string is not None:\nlogger.info(f'Searching for Recreation Areas matching: \"{search_string}\"')\nif not search_string or search_string == \"\":\nrec_areas = RECREATION_AREAS.values()\nlog_sorted_response(rec_areas)\nreturn rec_areas\nrec_areas = []\nfor _, rec_area in RECREATION_AREAS.items():\nif (\nsearch_string.lower() in rec_area.recreation_area.lower()\nor search_string.lower() in rec_area.recreation_area_location.lower()\n):\nrec_areas.append(rec_area)\nlog_sorted_response(rec_areas)\nreturn rec_areas\ndef rec_area_lookup(self, rec_area_id: int) -&gt; Tuple[str, RecreationArea]:\n\"\"\"\n        Lookup a recreation area by ID\n        Parameters\n        ----------\n        rec_area_id: int\n            The recreation area ID to lookup\n        Returns\n        -------\n        domain_name, rec_ara: Tuple[str, RecreationArea]\n            The rec area's domain name and the recreation area object\n        \"\"\"\nfor domain_name, rec_area in RECREATION_AREAS.items():\nif str(rec_area.recreation_area_id) == str(rec_area_id):\nreturn domain_name, rec_area\ndef find_campgrounds(\nself,\nsearch_string: str = None,\nrec_area_id: Optional[List[int]] = None,\ncampground_id: Optional[List[int]] = None,\ncampsite_id: Optional[List[int]] = None,\n**kwargs,\n) -&gt; List[CampgroundFacility]:\n\"\"\"\n        Find Campgrounds Given a Set of Search Criteria\n        Parameters\n        ----------\n        search_string: str\n            Search Keyword(s)\n        rec_area_id: Optional[List[int]]\n            Recreation Area ID by which to filter\n        campground_id: Optional[List[int]]\n            ID of the Campground\n        Returns\n        -------\n        facilities: List[CampgroundFacility]\n            Array of Matching Campgrounds\n        \"\"\"\nif rec_area_id in (None, [], ()):\nlogger.error(\n\"This provider requires --rec-area to be specified when seaching for campsites\"\n)\nsys.exit(1)\nreturn self.find_facilities_per_recreation_area(\nrec_area_id=rec_area_id,\ncampground_id=campground_id,\nsearch_string=search_string,\n)\ndef _get_attr_val(self, attribute, attribute_detail) -&gt; any:\nfor attr_value in attribute.get(\"values\", []):\nfor attribute_enum_detail in attribute_detail.get(\"values\"):\nif attribute_enum_detail[\"enumValue\"] == attr_value:\nreturn _fetch_nested_key(\nattribute_enum_detail, \"localizedValues\", 0, \"displayName\"\n)\ndef get_site_details(self, rec_area_id: int, resource_id: int):\n\"\"\"\n        Get the details about a site in a recreation area\n        Parameters\n        ----------\n        rec_area_id: int\n            Recreation Area ID by which to filter\n        resource_id: int\n        Returns\n        -------\n        details: Dict[str, str]\n            The details about the site\n        \"\"\"\nif not hasattr(self, \"_attribute_details\"):\nself._attribute_details = self._api_request(\nrec_area_id, \"ATTRIBUTE_DETAILS\"\n)\nattribute_details = self._attribute_details\nsite_details = self._api_request(\nrec_area_id, \"SITE_DETAILS\", {\"resourceId\": resource_id}\n)\nsite_attributes = {}\nfor attribute in site_details[\"definedAttributes\"]:\nattribute_detail = attribute_details[\nf\"{attribute['attributeDefinitionId']}\"\n]\nattribute_name = _fetch_nested_key(\nattribute_detail, \"localizedValues\", 0, \"displayName\"\n)\nattribute_value = attribute.get(\"value\")\nattribute_values = []\n# Attribute a multi-value enum\nif not attribute_value:\nattr_value = self._get_attr_val(attribute, attribute_detail)\nif not attr_value:\ncontinue\nattribute_values.append(attr_value)\nelse:\nattribute_values.append(f\"{attribute_value}\")\nsite_attributes[attribute_name] = \",\".join(attribute_values)\nsite_details[\"site_attributes\"] = site_attributes\nreturn site_details\ndef get_reservation_link(\nself,\nrec_area_domain_name,\nresource_location_id,\nmap_id,\nequipment_id,\nsub_equipment_id,\nparty_size,\nstart_date,\nend_date,\n):\n\"\"\"\n        Generate a URL which a site can be booked\n        Returns\n        -------\n        url: str\n            The reservation link URL\n        \"\"\"\nif not sub_equipment_id:\nsub_equipment_id = \"\"\nreturn (\n\"https://%s/create-booking/results?mapId=%s\"\n\"&amp;bookingCategoryId=0\"\n\"&amp;startDate=%s\"\n\"&amp;endDate=%s\"\n\"&amp;isReserving=true\"\n\"&amp;equipmentId=%s\"\n\"&amp;subEquipmentId=%s\"\n\"&amp;partySize=%s\"\n\"&amp;resourceLocationId=%s\"\n% (\nrec_area_domain_name,\nmap_id,\nstart_date.isoformat(),\nend_date.isoformat(),\nequipment_id,\nsub_equipment_id,\nparty_size,\nresource_location_id,\n)\n)\ndef find_facilities_per_recreation_area(\nself,\nrec_area_id: Optional[Union[List[int], int]] = None,\ncampground_id: Optional[Union[List[int], int]] = None,\nsearch_string: Optional[str] = None,\n**kwargs,\n) -&gt; List[CampgroundFacility]:\n\"\"\"\n        Find Matching Campsites by Recreation Area\n        Parameters\n        ----------\n        rec_area_id: Optional[Union[List[int], int]]\n            Recreation Area ID\n        campground_id: Optional[Union[List[int], int]]\n            Campground IDs\n        search_string: Optional[str]\n            A string to search for in the facility name\n        Returns\n        -------\n        campgrounds: List[CampgroundFacility]\n            Array of Matching Campsites\n        \"\"\"\nrec_area_id = make_list(rec_area_id, coerce=int)[0]\nlogger.info(\nf\"Retrieving Facility Information for Recreation Area ID: `{rec_area_id}`.\"\n)\nrec_area = None\nfor _, ra in RECREATION_AREAS.items():\nif str(ra.recreation_area_id) == str(rec_area_id):\nrec_area = ra\nif not rec_area:\nlogger.error(f\"Recreation area '{rec_area_id}' does not exist.\")\nsys.exit(1)\nself.campground_details = {}\napi_response = self._api_request(rec_area_id, \"LIST_CAMPGROUNDS\")\nfiltered_facilities = self._filter_facilities_responses(\nrec_area_id, facilities=api_response\n)\ncampgrounds = []\n# Fetch campgrounds details for all facilities\nfor camp_details in self._api_request(rec_area_id, \"CAMP_DETAILS\"):\nself.campground_details[camp_details[\"resourceLocationId\"]] = camp_details\n# If a search string is provided, make sure every facility name contains\n# the search string\nif search_string and search_string not in [[], (), \"\"]:\nfiltered_facilities = [\nf\nfor f in filtered_facilities\nif search_string.lower() in f.resource_location_name.lower()\n]\nfor facility in filtered_facilities:\n_, campground_facility = self._process_facilities_responses(\nrec_area, facility=facility\n)\nif not campground_facility:\ncontinue\nif not campground_id:\ncampgrounds.append(campground_facility)\ncampground_strings = make_list(campground_id, coerce=str)\nif (\ncampground_id\nand str(campground_facility.facility_id) in campground_strings\n):\ncampgrounds.append(campground_facility)\nlogger.info(f\"{len(campgrounds)} Matching Campgrounds Found\")\nlog_sorted_response(response_array=campgrounds)\nreturn campgrounds\ndef _hostname_for(self, recreation_area_id: int) -&gt; str:\nfor hostname, recreation_area in RECREATION_AREAS.items():\nif str(recreation_area.recreation_area_id) == str(recreation_area_id):\nreturn hostname\nreturn None\ndef _api_request(\nself,\nrec_area_id: int,\nendpoint_name: str,\nparams: Optional[Dict[str, str]] = None,\n) -&gt; str:\nif params is None:\nparams = {}\nhostname = self._hostname_for(rec_area_id)\nendpoint = ENDPOINTS.get(endpoint_name)\nurl = None\nif endpoint:\nurl = endpoint.format(hostname)\nuser_agent = {\n\"User-Agent\": UserAgent(use_external_data=False, browsers=[\"chrome\"]).chrome\n}\nresponse = requests.get(url=url, headers=user_agent, params=params, timeout=30)\nif response.ok is False:\nerror_message = \"Receiving bad data from GoingToCamp API: status_code: \"\nf\"{response.status_code}: {response.text}\"\nlogger.error(error_message)\nraise ConnectionError(error_message)\nreturn json.loads(response.content)\ndef _filter_facilities_responses(\nself, rec_area_id: int, facilities=List[Dict[str, Any]]\n) -&gt; List[ResourceLocation]:\n\"\"\"\n        Filter Facilities to Actual Reservable Campsites\n        Parameters\n        ----------\n        rec_area_id: int\n            Recreation Area ID\n        facilities: List[Dict[str, Any]]\n            List of facilities\n        Returns\n        -------\n        List[ResourceLocation]\n        \"\"\"\nfiltered_facilities = []\nfor facil in facilities:\ntry:\nlocation_name = _fetch_nested_key(\nfacil, \"localizedValues\", 0, \"fullName\"\n)\npark_alerts = _fetch_nested_key(\nfacil, \"park_alerts\", \"en-US\", 0, \"messageTitle\"\n)\nif not park_alerts:\npark_alerts = _fetch_nested_key(\nfacil, \"park_alerts\", \"en-CA\", 0, \"messageTitle\"\n)\nregion_name = _fetch_nested_key(facil, \"region\")\nfacility = ResourceLocation(\nid=None,\nregion_name=region_name if region_name else \"\",\npark_alerts=park_alerts,\nrec_area_id=rec_area_id,\nresource_categories=facil.get(\"resourceCategoryIds\"),\nresource_location_id=facil.get(\"resourceLocationId\"),\nresource_location_name=location_name,\n)\nexcept ValidationError as ve:\nlogger.error(\"That doesn't look like a valid Campground Facility\")\nlogger.error(facil)\nraise ProviderSearchError(\n\"Invalid Campground Facility Returned\"\n) from ve\nif not facility.resource_categories:\ncontinue\n# Resource categories from: /api/resourcecategory\nif any(\n[\nCAMP_SITE in facility.resource_categories,\nGROUP_SITE in facility.resource_categories,\nOVERFLOW_SITE in facility.resource_categories,\n]\n):\nfiltered_facilities.append(facility)\nreturn filtered_facilities\ndef _process_facilities_responses(\nself, rec_area: RecreationArea, facility: ResourceLocation\n) -&gt; Tuple[dict, Optional[CampgroundFacility]]:\n\"\"\"\n        Process Facilities Responses to be More Usable\n        Parameters\n        ----------\n        facility: dict\n        Returns\n        -------\n        Tuple[dict, CampgroundFacility]\n        \"\"\"\nself.campground_details[facility.resource_location_id]\nfacility.id = _fetch_nested_key(\nself.campground_details, facility.resource_location_id, \"mapId\"\n)\nif facility.region_name:\nformatted_recreation_area = (\nf\"{rec_area.recreation_area}, {facility.region_name}\"\n)\nelse:\nformatted_recreation_area = f\"{rec_area.recreation_area}\"\ncampground_facility = CampgroundFacility(\nfacility_name=facility.resource_location_name,\nrecreation_area=formatted_recreation_area,\nfacility_id=facility.resource_location_id,\nrecreation_area_id=facility.rec_area_id,\nmap_id=facility.id,\n)\nreturn facility, campground_facility\ndef _find_matching_resources(self, rec_area_id: int, search_filter: Dict[str, any]):\nresults = self._api_request(rec_area_id, \"MAPDATA\", search_filter)\navailability_details = {\nsearch_filter[\"mapId\"]: results[\"resourceAvailabilities\"]\n}\nreturn availability_details, list(results[\"mapLinkAvailabilities\"].keys())\ndef list_equipment_types(self, rec_area_id: int) -&gt; Dict[str, int]:\n\"\"\"\n        List equipment types available for a recreation area\n        Params\n        ------\n        rec_area_id: int\n            The ID of the recreation area\n        Returns\n        -------\n        types: List[GoingToCampEquipment]\n            A list of equipment types available to this rec area\n        \"\"\"\nresults = self._api_request(rec_area_id, \"LIST_EQUIPMENT\")\nequipment_types = []\n# Only allow equipment from non-group equipment category (the 0th\n# element in results)\nfor sub_category in results[0][\"subEquipmentCategories\"]:\nequipment_name = _fetch_nested_key(\nsub_category, \"localizedValues\", 0, \"name\"\n)\nequipment_id = sub_category[\"subEquipmentCategoryId\"]\nequipment_types.append(\nGoingToCampEquipment(\nequipment_name=equipment_name, equipment_type_id=equipment_id\n)\n)\nlog_sorted_response(response_array=equipment_types)\nreturn equipment_types\ndef list_site_availability(\nself,\ncampground: CampgroundFacility,\nstart_date: datetime.date,\nend_date: datetime.date,\nequipment_type_id: Optional[str],\n) -&gt; List[AvailableResource]:\n\"\"\"\n        Retrieve the Availability for all Sites in a Camp Area\n        Sites are filtered on the provided date range and compatible\n        equipment.\n        Returns\n        -------\n        available_sites: List[AvailableResource]\n            The list of available sites\n        \"\"\"\nsearch_filter = {\n\"mapId\": campground.map_id,\n\"resourceLocationId\": campground.facility_id,\n\"bookingCategoryId\": 0,\n\"startDate\": start_date.isoformat(),\n\"endDate\": end_date.isoformat(),\n\"isReserving\": True,\n\"getDailyAvailability\": False,\n\"partySize\": 1,\n\"numEquipment\": 1,\n\"equipmentCategoryId\": NON_GROUP_EQUIPMENT,\n\"filterData\": [],\n}\nif equipment_type_id:\nsearch_filter[\"subEquipmentCategoryId\"] = equipment_type_id\nresources, additional_resources = self._find_matching_resources(\ncampground.recreation_area_id, search_filter\n)\n# Resources are often deeply nested; fetch nested resources\nfor map_id in additional_resources:\nsearch_filter[\"mapId\"] = map_id\navail, _ = self._find_matching_resources(\ncampground.recreation_area_id, search_filter\n)\nresources.update(avail)\navailabilities = []\nfor map_id, resource_details in resources.items():\nfor resource_id, availability_details in resource_details.items():\nif availability_details[0][\"availability\"] == 0:\nar = AvailableResource(resource_id=resource_id, map_id=map_id)\navailabilities.append(ar)\nreturn availabilities\n</code></pre>"},{"location":"reference/providers/going_to_camp/going_to_camp_provider/#camply.providers.going_to_camp.going_to_camp_provider.GoingToCamp.find_campgrounds","title":"<code>find_campgrounds(search_string=None, rec_area_id=None, campground_id=None, campsite_id=None, **kwargs)</code>","text":"<p>Find Campgrounds Given a Set of Search Criteria</p> <p>Parameters:</p> Name Type Description Default <code>search_string</code> <code>str</code> <p>Search Keyword(s)</p> <code>None</code> <code>rec_area_id</code> <code>Optional[List[int]]</code> <p>Recreation Area ID by which to filter</p> <code>None</code> <code>campground_id</code> <code>Optional[List[int]]</code> <p>ID of the Campground</p> <code>None</code> <p>Returns:</p> Name Type Description <code>facilities</code> <code>List[CampgroundFacility]</code> <p>Array of Matching Campgrounds</p> Source code in <code>camply/providers/going_to_camp/going_to_camp_provider.py</code> <pre><code>def find_campgrounds(\nself,\nsearch_string: str = None,\nrec_area_id: Optional[List[int]] = None,\ncampground_id: Optional[List[int]] = None,\ncampsite_id: Optional[List[int]] = None,\n**kwargs,\n) -&gt; List[CampgroundFacility]:\n\"\"\"\n    Find Campgrounds Given a Set of Search Criteria\n    Parameters\n    ----------\n    search_string: str\n        Search Keyword(s)\n    rec_area_id: Optional[List[int]]\n        Recreation Area ID by which to filter\n    campground_id: Optional[List[int]]\n        ID of the Campground\n    Returns\n    -------\n    facilities: List[CampgroundFacility]\n        Array of Matching Campgrounds\n    \"\"\"\nif rec_area_id in (None, [], ()):\nlogger.error(\n\"This provider requires --rec-area to be specified when seaching for campsites\"\n)\nsys.exit(1)\nreturn self.find_facilities_per_recreation_area(\nrec_area_id=rec_area_id,\ncampground_id=campground_id,\nsearch_string=search_string,\n)\n</code></pre>"},{"location":"reference/providers/going_to_camp/going_to_camp_provider/#camply.providers.going_to_camp.going_to_camp_provider.GoingToCamp.find_facilities_per_recreation_area","title":"<code>find_facilities_per_recreation_area(rec_area_id=None, campground_id=None, search_string=None, **kwargs)</code>","text":"<p>Find Matching Campsites by Recreation Area</p> <p>Parameters:</p> Name Type Description Default <code>rec_area_id</code> <code>Optional[Union[List[int], int]]</code> <p>Recreation Area ID</p> <code>None</code> <code>campground_id</code> <code>Optional[Union[List[int], int]]</code> <p>Campground IDs</p> <code>None</code> <code>search_string</code> <code>Optional[str]</code> <p>A string to search for in the facility name</p> <code>None</code> <p>Returns:</p> Name Type Description <code>campgrounds</code> <code>List[CampgroundFacility]</code> <p>Array of Matching Campsites</p> Source code in <code>camply/providers/going_to_camp/going_to_camp_provider.py</code> <pre><code>def find_facilities_per_recreation_area(\nself,\nrec_area_id: Optional[Union[List[int], int]] = None,\ncampground_id: Optional[Union[List[int], int]] = None,\nsearch_string: Optional[str] = None,\n**kwargs,\n) -&gt; List[CampgroundFacility]:\n\"\"\"\n    Find Matching Campsites by Recreation Area\n    Parameters\n    ----------\n    rec_area_id: Optional[Union[List[int], int]]\n        Recreation Area ID\n    campground_id: Optional[Union[List[int], int]]\n        Campground IDs\n    search_string: Optional[str]\n        A string to search for in the facility name\n    Returns\n    -------\n    campgrounds: List[CampgroundFacility]\n        Array of Matching Campsites\n    \"\"\"\nrec_area_id = make_list(rec_area_id, coerce=int)[0]\nlogger.info(\nf\"Retrieving Facility Information for Recreation Area ID: `{rec_area_id}`.\"\n)\nrec_area = None\nfor _, ra in RECREATION_AREAS.items():\nif str(ra.recreation_area_id) == str(rec_area_id):\nrec_area = ra\nif not rec_area:\nlogger.error(f\"Recreation area '{rec_area_id}' does not exist.\")\nsys.exit(1)\nself.campground_details = {}\napi_response = self._api_request(rec_area_id, \"LIST_CAMPGROUNDS\")\nfiltered_facilities = self._filter_facilities_responses(\nrec_area_id, facilities=api_response\n)\ncampgrounds = []\n# Fetch campgrounds details for all facilities\nfor camp_details in self._api_request(rec_area_id, \"CAMP_DETAILS\"):\nself.campground_details[camp_details[\"resourceLocationId\"]] = camp_details\n# If a search string is provided, make sure every facility name contains\n# the search string\nif search_string and search_string not in [[], (), \"\"]:\nfiltered_facilities = [\nf\nfor f in filtered_facilities\nif search_string.lower() in f.resource_location_name.lower()\n]\nfor facility in filtered_facilities:\n_, campground_facility = self._process_facilities_responses(\nrec_area, facility=facility\n)\nif not campground_facility:\ncontinue\nif not campground_id:\ncampgrounds.append(campground_facility)\ncampground_strings = make_list(campground_id, coerce=str)\nif (\ncampground_id\nand str(campground_facility.facility_id) in campground_strings\n):\ncampgrounds.append(campground_facility)\nlogger.info(f\"{len(campgrounds)} Matching Campgrounds Found\")\nlog_sorted_response(response_array=campgrounds)\nreturn campgrounds\n</code></pre>"},{"location":"reference/providers/going_to_camp/going_to_camp_provider/#camply.providers.going_to_camp.going_to_camp_provider.GoingToCamp.find_recreation_areas","title":"<code>find_recreation_areas(search_string=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Find Matching Recreation Areas based on search string</p> <p>Parameters:</p> Name Type Description Default <code>search_string</code> <code>Optional[str]</code> <p>Search Keyword(s)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>filtered_responses</code> <code>List[RecreationArea]</code> <p>Array of Matching Recreation Areas</p> Source code in <code>camply/providers/going_to_camp/going_to_camp_provider.py</code> <pre><code>@classmethod\ndef find_recreation_areas(\ncls, search_string: Optional[str] = None, **kwargs\n) -&gt; List[RecreationArea]:\n\"\"\"\n    Find Matching Recreation Areas based on search string\n    Parameters\n    ----------\n    search_string: Optional[str]\n        Search Keyword(s)\n    Returns\n    -------\n    filtered_responses: List[RecreationArea]\n        Array of Matching Recreation Areas\n    \"\"\"\nif search_string is not None:\nlogger.info(f'Searching for Recreation Areas matching: \"{search_string}\"')\nif not search_string or search_string == \"\":\nrec_areas = RECREATION_AREAS.values()\nlog_sorted_response(rec_areas)\nreturn rec_areas\nrec_areas = []\nfor _, rec_area in RECREATION_AREAS.items():\nif (\nsearch_string.lower() in rec_area.recreation_area.lower()\nor search_string.lower() in rec_area.recreation_area_location.lower()\n):\nrec_areas.append(rec_area)\nlog_sorted_response(rec_areas)\nreturn rec_areas\n</code></pre>"},{"location":"reference/providers/going_to_camp/going_to_camp_provider/#camply.providers.going_to_camp.going_to_camp_provider.GoingToCamp.get_reservation_link","title":"<code>get_reservation_link(rec_area_domain_name, resource_location_id, map_id, equipment_id, sub_equipment_id, party_size, start_date, end_date)</code>","text":"<p>Generate a URL which a site can be booked</p> <p>Returns:</p> Name Type Description <code>url</code> <code>str</code> <p>The reservation link URL</p> Source code in <code>camply/providers/going_to_camp/going_to_camp_provider.py</code> <pre><code>def get_reservation_link(\nself,\nrec_area_domain_name,\nresource_location_id,\nmap_id,\nequipment_id,\nsub_equipment_id,\nparty_size,\nstart_date,\nend_date,\n):\n\"\"\"\n    Generate a URL which a site can be booked\n    Returns\n    -------\n    url: str\n        The reservation link URL\n    \"\"\"\nif not sub_equipment_id:\nsub_equipment_id = \"\"\nreturn (\n\"https://%s/create-booking/results?mapId=%s\"\n\"&amp;bookingCategoryId=0\"\n\"&amp;startDate=%s\"\n\"&amp;endDate=%s\"\n\"&amp;isReserving=true\"\n\"&amp;equipmentId=%s\"\n\"&amp;subEquipmentId=%s\"\n\"&amp;partySize=%s\"\n\"&amp;resourceLocationId=%s\"\n% (\nrec_area_domain_name,\nmap_id,\nstart_date.isoformat(),\nend_date.isoformat(),\nequipment_id,\nsub_equipment_id,\nparty_size,\nresource_location_id,\n)\n)\n</code></pre>"},{"location":"reference/providers/going_to_camp/going_to_camp_provider/#camply.providers.going_to_camp.going_to_camp_provider.GoingToCamp.get_site_details","title":"<code>get_site_details(rec_area_id, resource_id)</code>","text":"<p>Get the details about a site in a recreation area</p> <p>Parameters:</p> Name Type Description Default <code>rec_area_id</code> <code>int</code> <p>Recreation Area ID by which to filter</p> required <code>resource_id</code> <code>int</code> required <p>Returns:</p> Name Type Description <code>details</code> <code>Dict[str, str]</code> <p>The details about the site</p> Source code in <code>camply/providers/going_to_camp/going_to_camp_provider.py</code> <pre><code>def get_site_details(self, rec_area_id: int, resource_id: int):\n\"\"\"\n    Get the details about a site in a recreation area\n    Parameters\n    ----------\n    rec_area_id: int\n        Recreation Area ID by which to filter\n    resource_id: int\n    Returns\n    -------\n    details: Dict[str, str]\n        The details about the site\n    \"\"\"\nif not hasattr(self, \"_attribute_details\"):\nself._attribute_details = self._api_request(\nrec_area_id, \"ATTRIBUTE_DETAILS\"\n)\nattribute_details = self._attribute_details\nsite_details = self._api_request(\nrec_area_id, \"SITE_DETAILS\", {\"resourceId\": resource_id}\n)\nsite_attributes = {}\nfor attribute in site_details[\"definedAttributes\"]:\nattribute_detail = attribute_details[\nf\"{attribute['attributeDefinitionId']}\"\n]\nattribute_name = _fetch_nested_key(\nattribute_detail, \"localizedValues\", 0, \"displayName\"\n)\nattribute_value = attribute.get(\"value\")\nattribute_values = []\n# Attribute a multi-value enum\nif not attribute_value:\nattr_value = self._get_attr_val(attribute, attribute_detail)\nif not attr_value:\ncontinue\nattribute_values.append(attr_value)\nelse:\nattribute_values.append(f\"{attribute_value}\")\nsite_attributes[attribute_name] = \",\".join(attribute_values)\nsite_details[\"site_attributes\"] = site_attributes\nreturn site_details\n</code></pre>"},{"location":"reference/providers/going_to_camp/going_to_camp_provider/#camply.providers.going_to_camp.going_to_camp_provider.GoingToCamp.list_equipment_types","title":"<code>list_equipment_types(rec_area_id)</code>","text":"<p>List equipment types available for a recreation area</p>"},{"location":"reference/providers/going_to_camp/going_to_camp_provider/#camply.providers.going_to_camp.going_to_camp_provider.GoingToCamp.list_equipment_types--params","title":"Params","text":"<p>rec_area_id: int     The ID of the recreation area</p> <p>Returns:</p> Name Type Description <code>types</code> <code>List[GoingToCampEquipment]</code> <p>A list of equipment types available to this rec area</p> Source code in <code>camply/providers/going_to_camp/going_to_camp_provider.py</code> <pre><code>def list_equipment_types(self, rec_area_id: int) -&gt; Dict[str, int]:\n\"\"\"\n    List equipment types available for a recreation area\n    Params\n    ------\n    rec_area_id: int\n        The ID of the recreation area\n    Returns\n    -------\n    types: List[GoingToCampEquipment]\n        A list of equipment types available to this rec area\n    \"\"\"\nresults = self._api_request(rec_area_id, \"LIST_EQUIPMENT\")\nequipment_types = []\n# Only allow equipment from non-group equipment category (the 0th\n# element in results)\nfor sub_category in results[0][\"subEquipmentCategories\"]:\nequipment_name = _fetch_nested_key(\nsub_category, \"localizedValues\", 0, \"name\"\n)\nequipment_id = sub_category[\"subEquipmentCategoryId\"]\nequipment_types.append(\nGoingToCampEquipment(\nequipment_name=equipment_name, equipment_type_id=equipment_id\n)\n)\nlog_sorted_response(response_array=equipment_types)\nreturn equipment_types\n</code></pre>"},{"location":"reference/providers/going_to_camp/going_to_camp_provider/#camply.providers.going_to_camp.going_to_camp_provider.GoingToCamp.list_site_availability","title":"<code>list_site_availability(campground, start_date, end_date, equipment_type_id)</code>","text":"<p>Retrieve the Availability for all Sites in a Camp Area</p> <p>Sites are filtered on the provided date range and compatible equipment.</p> <p>Returns:</p> Name Type Description <code>available_sites</code> <code>List[AvailableResource]</code> <p>The list of available sites</p> Source code in <code>camply/providers/going_to_camp/going_to_camp_provider.py</code> <pre><code>def list_site_availability(\nself,\ncampground: CampgroundFacility,\nstart_date: datetime.date,\nend_date: datetime.date,\nequipment_type_id: Optional[str],\n) -&gt; List[AvailableResource]:\n\"\"\"\n    Retrieve the Availability for all Sites in a Camp Area\n    Sites are filtered on the provided date range and compatible\n    equipment.\n    Returns\n    -------\n    available_sites: List[AvailableResource]\n        The list of available sites\n    \"\"\"\nsearch_filter = {\n\"mapId\": campground.map_id,\n\"resourceLocationId\": campground.facility_id,\n\"bookingCategoryId\": 0,\n\"startDate\": start_date.isoformat(),\n\"endDate\": end_date.isoformat(),\n\"isReserving\": True,\n\"getDailyAvailability\": False,\n\"partySize\": 1,\n\"numEquipment\": 1,\n\"equipmentCategoryId\": NON_GROUP_EQUIPMENT,\n\"filterData\": [],\n}\nif equipment_type_id:\nsearch_filter[\"subEquipmentCategoryId\"] = equipment_type_id\nresources, additional_resources = self._find_matching_resources(\ncampground.recreation_area_id, search_filter\n)\n# Resources are often deeply nested; fetch nested resources\nfor map_id in additional_resources:\nsearch_filter[\"mapId\"] = map_id\navail, _ = self._find_matching_resources(\ncampground.recreation_area_id, search_filter\n)\nresources.update(avail)\navailabilities = []\nfor map_id, resource_details in resources.items():\nfor resource_id, availability_details in resource_details.items():\nif availability_details[0][\"availability\"] == 0:\nar = AvailableResource(resource_id=resource_id, map_id=map_id)\navailabilities.append(ar)\nreturn availabilities\n</code></pre>"},{"location":"reference/providers/going_to_camp/going_to_camp_provider/#camply.providers.going_to_camp.going_to_camp_provider.GoingToCamp.rec_area_lookup","title":"<code>rec_area_lookup(rec_area_id)</code>","text":"<p>Lookup a recreation area by ID</p> <p>Parameters:</p> Name Type Description Default <code>rec_area_id</code> <code>int</code> <p>The recreation area ID to lookup</p> required <p>Returns:</p> Type Description <code>domain_name, rec_ara</code> <p>The rec area's domain name and the recreation area object</p> Source code in <code>camply/providers/going_to_camp/going_to_camp_provider.py</code> <pre><code>def rec_area_lookup(self, rec_area_id: int) -&gt; Tuple[str, RecreationArea]:\n\"\"\"\n    Lookup a recreation area by ID\n    Parameters\n    ----------\n    rec_area_id: int\n        The recreation area ID to lookup\n    Returns\n    -------\n    domain_name, rec_ara: Tuple[str, RecreationArea]\n        The rec area's domain name and the recreation area object\n    \"\"\"\nfor domain_name, rec_area in RECREATION_AREAS.items():\nif str(rec_area.recreation_area_id) == str(rec_area_id):\nreturn domain_name, rec_area\n</code></pre>"},{"location":"reference/providers/recreation_dot_gov/","title":"recreation_dot_gov","text":"<p>RecreationDotGov init</p>"},{"location":"reference/providers/recreation_dot_gov/recdotgov_camps/","title":"recdotgov_camps","text":"<p>Campsite Searching: Recreation.gov</p>"},{"location":"reference/providers/recreation_dot_gov/recdotgov_camps/#camply.providers.recreation_dot_gov.recdotgov_camps.RecreationDotGov","title":"<code>RecreationDotGov</code>","text":"<p>         Bases: <code>RecreationDotGovBase</code></p> <p>Recreation.gov: Campsite Searcher</p> Source code in <code>camply/providers/recreation_dot_gov/recdotgov_camps.py</code> <pre><code>class RecreationDotGov(RecreationDotGovBase):\n\"\"\"\n    Recreation.gov: Campsite Searcher\n    \"\"\"\nfacility_type = RIDBConfig.CAMPGROUND_FACILITY_FIELD_QUALIFIER\nresource_api_path = RIDBConfig.CAMPSITE_API_PATH\nactivity_name = \"CAMPING\"\napi_response_class = CampsiteResponse\napi_base_path = RecreationBookingConfig.API_BASE_PATH\napi_search_result_class = RecDotGovCampsite\napi_search_result_key = \"campsite_id\"\ndef paginate_recdotgov_campsites(\nself, facility_id: int, equipment: Optional[List[str]] = None\n) -&gt; List[RecDotGovCampsite]:\n\"\"\"\n        Paginate through the RecDotGov Campsite Metadata\n        \"\"\"\nresults = 0\ncontinue_paginate = True\nendpoint_url = api_utils.generate_url(\nscheme=RecreationBookingConfig.API_SCHEME,\nnetloc=RecreationBookingConfig.API_NET_LOC,\npath=\"api/search/campsites\",\n)\nfq_list = [f\"asset_id:{facility_id}\"]\nif isinstance(equipment, list) and len(equipment) &gt; 0:\nfor item in equipment:\nfq_list.append(f\"campsite_equipment_name:{item}\")\nparams = {\n\"start\": 0,\n\"size\": 1000,\n\"fq\": fq_list,\n\"include_non_site_specific_campsites\": True,\n}\ncampsites: List[RecDotGovCampsite] = []\nwhile continue_paginate is True:\nresponse = self.make_recdotgov_request_retry(\nmethod=\"GET\",\nurl=endpoint_url,\nparams=params,\n)\nreturned_data = json.loads(response.content)\ncampsite_response = RecDotGovCampsiteResponse(**returned_data)\ncampsites += campsite_response.campsites\nresults += campsite_response.size\nparams.update(start=results)\nif results == campsite_response.total:\ncontinue_paginate = False\nreturn campsites\ndef make_recdotgov_availability_request(\nself,\ncampground_id: int,\nmonth: datetime,\n) -&gt; requests.Response:\n\"\"\"\n        Make a request to the RecreationDotGov API\n        Parameters\n        ----------\n        campground_id\n        month\n        Returns\n        -------\n        requests.Response\n        \"\"\"\napi_endpoint = self._rec_availability_get_endpoint(\npath=f\"{campground_id}/{RecreationBookingConfig.API_MONTH_PATH}\"\n)\nformatted_month = month.strftime(\"%Y-%m-01T00:00:00.000Z\")\nquery_params = {\"start_date\": formatted_month}\nreturn self.make_recdotgov_request(\nmethod=\"GET\",\nurl=api_endpoint,\nparams=query_params,\n)\n@classmethod\ndef _items_to_unique_dicts(\ncls, item: Union[List[Dict[str, Any]], pd.Series]\n) -&gt; List[Dict[str, Any]]:\n\"\"\"\n        Ensure the proper items are parsed for equipment and attributes\n        \"\"\"\nif isinstance(item, pd.Series):\nlist_of_dicts = list(chain.from_iterable(item.tolist()))\nunique_list_of_dicts = [\ndict(s) for s in {frozenset(d.items()) for d in list_of_dicts}\n]\nreturn unique_list_of_dicts\nelse:\nreturn item\n@classmethod\ndef _get_equipment_and_attributes(\ncls,\ncampsite_id: int,\ncampsite_metadata: pd.DataFrame,\n) -&gt; Tuple[List[Dict[str, Any]], List[Dict[str, Any]]]:\n\"\"\"\n        Index a DataFrame in a Complicated Way\n        \"\"\"\ntry:\nequipment = campsite_metadata.at[campsite_id, \"permitted_equipment\"]\nexcept LookupError:\nequipment = None\ntry:\nattributes = campsite_metadata.at[campsite_id, \"attributes\"]\nexcept LookupError:\nattributes = None\nequipment = cls._items_to_unique_dicts(item=equipment)\nattributes = cls._items_to_unique_dicts(item=attributes)\nreturn equipment, attributes\n@classmethod\ndef process_campsite_availability(\ncls,\navailability: Dict[str, Any],\nrecreation_area: str,\nrecreation_area_id: int,\nfacility_name: str,\nfacility_id: int,\nmonth: datetime,\ncampsite_metadata: pd.DataFrame,\n) -&gt; List[Optional[AvailableCampsite]]:\n\"\"\"\n        Parse the JSON Response and return availabilities\n        Parameters\n        ----------\n        availability: Dict[str, Any]\n            API Response\n        recreation_area: str\n            Name of Recreation Area\n        recreation_area_id: int\n            ID of Recreation Area\n        facility_name: str\n            Campground Facility Name\n        facility_id: int\n            Campground Facility ID\n        month: datetime\n            Month to Process\n        campsite_metadata: pd.DataFrame\n            Metadata Fetched from the Recreation.gov API about the Campsites\n        Returns\n        -------\n        total_campsite_availability: List[Optional[AvailableCampsite]]\n            Any monthly availabilities\n        \"\"\"\ntotal_campsite_availability: List[Optional[AvailableCampsite]] = []\ncampsite_data = CampsiteAvailabilityResponse(**availability)\nfor campsite_id, site_related_data in campsite_data.campsites.items():\nfor (\nmatching_date,\navailability_status,\n) in site_related_data.availabilities.items():\nif (\navailability_status\nnot in RecreationBookingConfig.CAMPSITE_UNAVAILABLE_STRINGS\n):\nbooking_url = (\nf\"{RecreationBookingConfig.CAMPSITE_BOOKING_URL}/{campsite_id}\"\n)\nequipment, attributes = cls._get_equipment_and_attributes(\ncampsite_id=campsite_id, campsite_metadata=campsite_metadata\n)\navailable_campsite = AvailableCampsite(\ncampsite_id=campsite_id,\nbooking_date=matching_date,\nbooking_end_date=matching_date + timedelta(days=1),\nbooking_nights=1,\ncampsite_site_name=site_related_data.site,\ncampsite_loop_name=site_related_data.loop,\ncampsite_type=site_related_data.campsite_type,\ncampsite_occupancy=(\nsite_related_data.min_num_people,\nsite_related_data.max_num_people,\n),\ncampsite_use_type=site_related_data.type_of_use,\navailability_status=availability_status,\nrecreation_area=recreation_area,\nrecreation_area_id=recreation_area_id,\nfacility_name=facility_name,\nfacility_id=facility_id,\nbooking_url=booking_url,\npermitted_equipment=equipment,\ncampsite_attributes=attributes,\n)\ntotal_campsite_availability.append(available_campsite)\nreturn total_campsite_availability\n</code></pre>"},{"location":"reference/providers/recreation_dot_gov/recdotgov_camps/#camply.providers.recreation_dot_gov.recdotgov_camps.RecreationDotGov.make_recdotgov_availability_request","title":"<code>make_recdotgov_availability_request(campground_id, month)</code>","text":"<p>Make a request to the RecreationDotGov API</p> <p>Parameters:</p> Name Type Description Default <code>campground_id</code> <code>int</code> required <code>month</code> <code>datetime</code> required <p>Returns:</p> Type Description <code>requests.Response</code> Source code in <code>camply/providers/recreation_dot_gov/recdotgov_camps.py</code> <pre><code>def make_recdotgov_availability_request(\nself,\ncampground_id: int,\nmonth: datetime,\n) -&gt; requests.Response:\n\"\"\"\n    Make a request to the RecreationDotGov API\n    Parameters\n    ----------\n    campground_id\n    month\n    Returns\n    -------\n    requests.Response\n    \"\"\"\napi_endpoint = self._rec_availability_get_endpoint(\npath=f\"{campground_id}/{RecreationBookingConfig.API_MONTH_PATH}\"\n)\nformatted_month = month.strftime(\"%Y-%m-01T00:00:00.000Z\")\nquery_params = {\"start_date\": formatted_month}\nreturn self.make_recdotgov_request(\nmethod=\"GET\",\nurl=api_endpoint,\nparams=query_params,\n)\n</code></pre>"},{"location":"reference/providers/recreation_dot_gov/recdotgov_camps/#camply.providers.recreation_dot_gov.recdotgov_camps.RecreationDotGov.paginate_recdotgov_campsites","title":"<code>paginate_recdotgov_campsites(facility_id, equipment=None)</code>","text":"<p>Paginate through the RecDotGov Campsite Metadata</p> Source code in <code>camply/providers/recreation_dot_gov/recdotgov_camps.py</code> <pre><code>def paginate_recdotgov_campsites(\nself, facility_id: int, equipment: Optional[List[str]] = None\n) -&gt; List[RecDotGovCampsite]:\n\"\"\"\n    Paginate through the RecDotGov Campsite Metadata\n    \"\"\"\nresults = 0\ncontinue_paginate = True\nendpoint_url = api_utils.generate_url(\nscheme=RecreationBookingConfig.API_SCHEME,\nnetloc=RecreationBookingConfig.API_NET_LOC,\npath=\"api/search/campsites\",\n)\nfq_list = [f\"asset_id:{facility_id}\"]\nif isinstance(equipment, list) and len(equipment) &gt; 0:\nfor item in equipment:\nfq_list.append(f\"campsite_equipment_name:{item}\")\nparams = {\n\"start\": 0,\n\"size\": 1000,\n\"fq\": fq_list,\n\"include_non_site_specific_campsites\": True,\n}\ncampsites: List[RecDotGovCampsite] = []\nwhile continue_paginate is True:\nresponse = self.make_recdotgov_request_retry(\nmethod=\"GET\",\nurl=endpoint_url,\nparams=params,\n)\nreturned_data = json.loads(response.content)\ncampsite_response = RecDotGovCampsiteResponse(**returned_data)\ncampsites += campsite_response.campsites\nresults += campsite_response.size\nparams.update(start=results)\nif results == campsite_response.total:\ncontinue_paginate = False\nreturn campsites\n</code></pre>"},{"location":"reference/providers/recreation_dot_gov/recdotgov_camps/#camply.providers.recreation_dot_gov.recdotgov_camps.RecreationDotGov.process_campsite_availability","title":"<code>process_campsite_availability(availability, recreation_area, recreation_area_id, facility_name, facility_id, month, campsite_metadata)</code>  <code>classmethod</code>","text":"<p>Parse the JSON Response and return availabilities</p> <p>Parameters:</p> Name Type Description Default <code>availability</code> <code>Dict[str, Any]</code> <p>API Response</p> required <code>recreation_area</code> <code>str</code> <p>Name of Recreation Area</p> required <code>recreation_area_id</code> <code>int</code> <p>ID of Recreation Area</p> required <code>facility_name</code> <code>str</code> <p>Campground Facility Name</p> required <code>facility_id</code> <code>int</code> <p>Campground Facility ID</p> required <code>month</code> <code>datetime</code> <p>Month to Process</p> required <code>campsite_metadata</code> <code>pd.DataFrame</code> <p>Metadata Fetched from the Recreation.gov API about the Campsites</p> required <p>Returns:</p> Name Type Description <code>total_campsite_availability</code> <code>List[Optional[AvailableCampsite]]</code> <p>Any monthly availabilities</p> Source code in <code>camply/providers/recreation_dot_gov/recdotgov_camps.py</code> <pre><code>@classmethod\ndef process_campsite_availability(\ncls,\navailability: Dict[str, Any],\nrecreation_area: str,\nrecreation_area_id: int,\nfacility_name: str,\nfacility_id: int,\nmonth: datetime,\ncampsite_metadata: pd.DataFrame,\n) -&gt; List[Optional[AvailableCampsite]]:\n\"\"\"\n    Parse the JSON Response and return availabilities\n    Parameters\n    ----------\n    availability: Dict[str, Any]\n        API Response\n    recreation_area: str\n        Name of Recreation Area\n    recreation_area_id: int\n        ID of Recreation Area\n    facility_name: str\n        Campground Facility Name\n    facility_id: int\n        Campground Facility ID\n    month: datetime\n        Month to Process\n    campsite_metadata: pd.DataFrame\n        Metadata Fetched from the Recreation.gov API about the Campsites\n    Returns\n    -------\n    total_campsite_availability: List[Optional[AvailableCampsite]]\n        Any monthly availabilities\n    \"\"\"\ntotal_campsite_availability: List[Optional[AvailableCampsite]] = []\ncampsite_data = CampsiteAvailabilityResponse(**availability)\nfor campsite_id, site_related_data in campsite_data.campsites.items():\nfor (\nmatching_date,\navailability_status,\n) in site_related_data.availabilities.items():\nif (\navailability_status\nnot in RecreationBookingConfig.CAMPSITE_UNAVAILABLE_STRINGS\n):\nbooking_url = (\nf\"{RecreationBookingConfig.CAMPSITE_BOOKING_URL}/{campsite_id}\"\n)\nequipment, attributes = cls._get_equipment_and_attributes(\ncampsite_id=campsite_id, campsite_metadata=campsite_metadata\n)\navailable_campsite = AvailableCampsite(\ncampsite_id=campsite_id,\nbooking_date=matching_date,\nbooking_end_date=matching_date + timedelta(days=1),\nbooking_nights=1,\ncampsite_site_name=site_related_data.site,\ncampsite_loop_name=site_related_data.loop,\ncampsite_type=site_related_data.campsite_type,\ncampsite_occupancy=(\nsite_related_data.min_num_people,\nsite_related_data.max_num_people,\n),\ncampsite_use_type=site_related_data.type_of_use,\navailability_status=availability_status,\nrecreation_area=recreation_area,\nrecreation_area_id=recreation_area_id,\nfacility_name=facility_name,\nfacility_id=facility_id,\nbooking_url=booking_url,\npermitted_equipment=equipment,\ncampsite_attributes=attributes,\n)\ntotal_campsite_availability.append(available_campsite)\nreturn total_campsite_availability\n</code></pre>"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/","title":"recdotgov_provider","text":"<p>Recreation.gov Web Searching Utilities</p>"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGovBase","title":"<code>RecreationDotGovBase</code>","text":"<p>         Bases: <code>BaseProvider</code>, <code>ABC</code></p> <p>Python Class for Working with Recreation.gov API / NPS APIs</p> Source code in <code>camply/providers/recreation_dot_gov/recdotgov_provider.py</code> <pre><code>class RecreationDotGovBase(BaseProvider, ABC):\n\"\"\"\n    Python Class for Working with Recreation.gov API / NPS APIs\n    \"\"\"\ndef __init__(self, api_key: str = None):\n\"\"\"\n        Initialize with Search Dates\n        \"\"\"\nsuper().__init__()\nif api_key is None:\n_api_key = RIDBConfig.API_KEY\nif isinstance(_api_key, bytes):\n_api_key: str = b64decode(RIDBConfig.API_KEY).decode(\"utf-8\")\nelse:\n_api_key: str = api_key\nself._ridb_api_headers: dict = {\n\"accept\": \"application/json\",\n\"apikey\": _api_key,\n}\n_user_agent = UserAgent(use_external_data=False, browsers=[\"chrome\"]).chrome\nself._user_agent = {\"User-Agent\": _user_agent}\n@property\n@abstractmethod\ndef api_search_result_key(self) -&gt; str:\n\"\"\"\n        Entity ID: Related to Searches\n        \"\"\"\npass\n@property\n@abstractmethod\ndef activity_name(self) -&gt; str:\n\"\"\"\n        Activity Name Used In API Query Params\n        \"\"\"\npass\n@property\n@abstractmethod\ndef api_search_result_class(self) -&gt; Type[CamplyModel]:\n\"\"\"\n        Pydantic Object for the Search Results API Response\n        \"\"\"\npass\n@property\n@abstractmethod\ndef facility_type(self) -&gt; str:\n\"\"\"\n        Facility Type: Used for Filtering Campgrounds\n        \"\"\"\npass\n@property\n@abstractmethod\ndef resource_api_path(self) -&gt; str:\n\"\"\"\n        API Endpoint Path\n        \"\"\"\npass\n@property\n@abstractmethod\ndef api_base_path(self) -&gt; str:\n\"\"\"\n        API Base Path - Used in Downstream API Calls.\n        \"\"\"\npass\n@property\n@abstractmethod\ndef api_response_class(self) -&gt; Type[CoreRecDotGovResponse]:\n\"\"\"\n        Pydantic Object Representing the API Response.\n        \"\"\"\npass\ndef find_recreation_areas(self, search_string: str = None, **kwargs) -&gt; List[dict]:\n\"\"\"\n        Find Matching Campsites Based on Search String\n        Parameters\n        ----------\n        search_string: str\n            Search Keyword(s)\n        Returns\n        -------\n        filtered_responses: List[dict]\n            Array of Matching Campsites\n        \"\"\"\ntry:\nassert any(\n[\nkwargs.get(\"state\", None) is not None,\nsearch_string is not None and search_string != \"\",\n]\n)\nexcept AssertionError as ae:\nraise RuntimeError(\n\"You must provide a search query or state(s) \"\n\"to find Recreation Areas\"\n) from ae\nif search_string is not None:\nlogger.info(f'Searching for Recreation Areas: \"{search_string}\"')\nstate_arg = kwargs.get(\"state\", None)\nif state_arg is not None:\nkwargs.update({\"state\": state_arg.upper()})\nparams = dict(query=search_string, sort=\"Name\", full=\"true\", **kwargs)\nif search_string is None:\nparams.pop(\"query\")\napi_response = self._ridb_get_paginate(\npath=RIDBConfig.REC_AREA_API_PATH, params=params\n)\nlogger.info(f\"{len(api_response)} recreation areas found.\")\nlogging_messages = []\nfor recreation_area_object in api_response:\n_, recreation_area = self._process_rec_area_response(\nrecreation_area=recreation_area_object\n)\nif recreation_area is not None:\nlogging_messages.append(recreation_area)\nlog_sorted_response(response_array=logging_messages)\nreturn api_response\ndef find_campgrounds(\nself,\nsearch_string: str = None,\nrec_area_id: Optional[List[int]] = None,\ncampground_id: Optional[List[int]] = None,\ncampsite_id: Optional[List[int]] = None,\n**kwargs,\n) -&gt; List[CampgroundFacility]:\n\"\"\"\n        Find Bookable Campgrounds Given a Set of Search Criteria\n        Parameters\n        ----------\n        search_string: str\n            Search Keyword(s)\n        rec_area_id: Optional[List[int]]\n            Recreation Area ID to filter with\n        campground_id: Optional[List[int]]\n            ID of the Campground\n        campsite_id: Optional[List[int]]\n            ID of the Campsite\n        Returns\n        -------\n        facilities: List[CampgroundFacility]\n            Array of Matching Campsites\n        \"\"\"\nif campsite_id not in (None, [], ()):\nfacilities = self._process_specific_campsites_provided(\ncampsite_id=campsite_id\n)\nelif campground_id not in (None, [], ()):\nfacilities = self._find_facilities_from_campgrounds(\ncampground_id=campground_id\n)\nelif rec_area_id not in (None, [], ()):\nfacilities = []\nfor recreation_area in rec_area_id:\nfacilities += self.find_facilities_per_recreation_area(\nrec_area_id=recreation_area\n)\nelse:\nstate_arg = kwargs.get(\"state\", None)\nif state_arg is not None:\nkwargs.update({\"state\": state_arg.upper()})\nif search_string in [\"\", None] and state_arg is None:\nraise RuntimeError(\n\"You must provide a search query or state to find campsites\"\n)\nif self.activity_name:\nkwargs[\"activity\"] = self.activity_name\nfacilities = self._find_facilities_from_search(\nsearch=search_string, **kwargs\n)\nreturn facilities\ndef find_facilities_per_recreation_area(\nself, rec_area_id: int = None, **kwargs\n) -&gt; List[CampgroundFacility]:\n\"\"\"\n        Find Matching Campsites Based from Recreation Area\n        Parameters\n        ----------\n        rec_area_id: int\n            Recreation Area ID\n        Returns\n        -------\n        campgrounds: List[CampgroundFacility]\n            Array of Matching Campsites\n        \"\"\"\nlogger.info(\nf\"Retrieving Facility Information for Recreation Area ID: `{rec_area_id}`.\"\n)\napi_path = f\"{RIDBConfig.REC_AREA_API_PATH}/{rec_area_id}/{RIDBConfig.FACILITIES_API_PATH}\"\napi_response = self._ridb_get_paginate(\npath=api_path, params=dict(full=\"true\", **kwargs)\n)\nfiltered_facilities = self._filter_facilities_responses(responses=api_response)\ncampgrounds = []\nlogger.info(f\"{len(filtered_facilities)} Matching Campgrounds Found\")\nfor facility in filtered_facilities:\n_, campground_facility = self.process_facilities_responses(\nfacility=facility\n)\nif campground_facility is not None:\ncampgrounds.append(campground_facility)\nlog_sorted_response(response_array=campgrounds)\nreturn campgrounds\ndef _find_facilities_from_campgrounds(\nself, campground_id: Union[int, List[int]]\n) -&gt; List[CampgroundFacility]:\n\"\"\"\n        Find Matching Campsites from Campground ID\n        Parameters\n        ----------\n        campground_id: Union[int, List[int]]\n            ID of the Campsite\n        Returns\n        -------\n        filtered_responses: List[CampgroundFacility]\n            Array of Matching Campsites\n        \"\"\"\ncampgrounds = []\nfor campground_identifier in campground_id:\nfacility_data = self.get_ridb_data(\npath=f\"{RIDBConfig.FACILITIES_API_PATH}/{campground_identifier}\",\nparams={\"full\": True},\n)\nfiltered_facility = self._filter_facilities_responses(\nresponses=[facility_data]\n)\n_, campground_facility = self.process_facilities_responses(\nfacility=filtered_facility[0]\n)\nif campground_facility is not None:\ncampgrounds.append(campground_facility)\nlogger.info(f\"{len(campgrounds)} Matching Campgrounds Found\")\nlog_sorted_response(response_array=campgrounds)\nreturn campgrounds\ndef _find_facilities_from_search(self, search: str, **kwargs) -&gt; List[dict]:\n\"\"\"\n        Find Matching Campgrounds Based on Search String\n        Parameters\n        ----------\n        search: str\n            Search String\n        Returns\n        -------\n        campgrounds: List[dict]\n            Array of Matching Campsites\n        \"\"\"\nfacilities_response = self._ridb_get_paginate(\npath=RIDBConfig.FACILITIES_API_PATH,\nparams=dict(query=search, full=\"true\", **kwargs),\n)\nfiltered_responses = self._filter_facilities_responses(\nresponses=facilities_response\n)\nlogger.info(f\"{len(filtered_responses)} Matching Campgrounds Found\")\ncampgrounds = []\nfor facility in filtered_responses:\n_, campground_facility = self.process_facilities_responses(\nfacility=facility\n)\nif campground_facility is not None:\ncampgrounds.append(campground_facility)\nlog_sorted_response(response_array=campgrounds)\nreturn campgrounds\n@classmethod\ndef _ridb_get_endpoint(cls, path: str) -&gt; str:\n\"\"\"\n        Return an API Endpoint for the RIDP\n        Parameters\n        ----------\n        path: str\n            URL Endpoint, see https://ridb.recreation.gov/docs\n        Returns\n        -------\n        endpoint_url: str\n            URL for the API Endpoint\n        \"\"\"\nassert RIDBConfig.RIDB_BASE_PATH.endswith(\"/\")\nbase_url = api_utils.generate_url(\nscheme=RIDBConfig.RIDB_SCHEME,\nnetloc=RIDBConfig.RIDB_NET_LOC,\npath=RIDBConfig.RIDB_BASE_PATH,\n)\nendpoint_url = parse.urljoin(base_url, path)\nreturn endpoint_url\n@tenacity.retry(\nwait=tenacity.wait_random_exponential(multiplier=2, max=10),\nstop=tenacity.stop.stop_after_delay(15),\n)\ndef get_ridb_data(\nself, path: str, params: Optional[dict] = None\n) -&gt; Union[dict, list]:\n\"\"\"\n        Find Matching Campsites Based on Search String\n        Parameters\n        ----------\n        path: str\n            URL Endpoint, see https://ridb.recreation.gov/docs\n        params: Optional[dict]\n            API Call Parameters\n        Returns\n        -------\n        Union[dict, list]\n        \"\"\"\napi_endpoint = self._ridb_get_endpoint(path=path)\nheaders = self.headers.copy()\nheaders.update(self._ridb_api_headers)\nresponse = self.session.get(\nurl=api_endpoint, headers=headers, params=params, timeout=30\n)\nif response.ok is False:\nerror_message = (\nf\"Receiving bad data from Recreation.gov API: {response.text}\"\n)\nlogger.error(error_message)\nraise ConnectionError(error_message)\nreturn loads(response.content)\ndef _ridb_get_paginate(\nself,\npath: str,\nparams: Optional[dict] = None,\n) -&gt; List[dict]:\n\"\"\"\n        Return the Paginated Response from the RIDP\n        Parameters\n        ----------\n        path: str\n            URL Endpoint, see https://ridb.recreation.gov/docs\n        params: Optional[dict]\n            API Call Parameters\n        Returns\n        -------\n        paginated_response: list\n            Concatted Response\n        \"\"\"\nif params is None:\nparams = {}\npaginated_response = []\ndata_incomplete = True\noffset: int = 0\nmax_offset: int = 500\nhistorical_results = 0\nwhile data_incomplete is True:\nparams.update(offset=offset)\ndata_response = self.get_ridb_data(path=path, params=params)\nresponse_object = GenericResponse(**data_response)\npaginated_response += response_object.RECDATA\nresult_count = response_object.METADATA.RESULTS.CURRENT_COUNT\nhistorical_results += result_count\ntotal_count = response_object.METADATA.RESULTS.TOTAL_COUNT\nif offset &gt;= max_offset:\nlogger.info(\nf\"Too Many Results returned ({total_count}), \"\n\"try performing a more specific search\"\n)\ndata_incomplete = False\nelif historical_results &lt; total_count:\noffset = historical_results\nelse:\ndata_incomplete = False\nreturn paginated_response\n@classmethod\ndef _filter_facilities_responses(cls, responses=List[dict]) -&gt; List[dict]:\n\"\"\"\n        Filter Facilities to Actual Reservable Campsites\n        Parameters\n        ----------\n        responses\n        Returns\n        -------\n        List[dict]\n        \"\"\"\nfiltered_responses = []\nfor possible_match in responses:\ntry:\nfacility = FacilityResponse(**possible_match)\nexcept ValidationError as e:\nlogger.error(\"That doesn't look like a valid Campground Facility\")\nlogger.error(json.dumps(possible_match))\nlogger.exception(e)\nraise ProviderSearchError(\"Invalid Campground Facility Returned\") from e\nif all(\n[\nfacility.FacilityTypeDescription == cls.facility_type,\nfacility.Enabled is True,\nfacility.Reservable is True,\n]\n):\nfiltered_responses.append(possible_match)\nreturn filtered_responses\n@classmethod\ndef process_facilities_responses(\ncls, facility: dict\n) -&gt; Tuple[dict, Optional[CampgroundFacility]]:\n\"\"\"\n        Process Facilities Responses to be More Usable\n        Parameters\n        ----------\n        facility: dict\n        Returns\n        -------\n        Tuple[dict, CampgroundFacility]\n        \"\"\"\nfacility_object = FacilityResponse(**facility)\ntry:\nfacility_state = facility_object.FACILITYADDRESS[0].AddressStateCode.upper()\nexcept (KeyError, IndexError):\nfacility_state = \"USA\"\ntry:\nif len(facility_object.RECAREA) == 0:\nrecreation_area_id = facility_object.ParentRecAreaID\nformatted_recreation_area = (\nf\"{facility_object.ORGANIZATION[0].OrgName}, {facility_state}\"\n)\nelse:\nrecreation_area = facility_object.RECAREA[0].RecAreaName\nrecreation_area_id = facility_object.RECAREA[0].RecAreaID\nformatted_recreation_area = f\"{recreation_area}, {facility_state}\"\ncampground_facility = CampgroundFacility(\nfacility_name=facility_object.FacilityName.title(),\nrecreation_area=formatted_recreation_area,\nfacility_id=facility_object.FacilityID,\nrecreation_area_id=recreation_area_id,\n)\nreturn facility, campground_facility\nexcept (KeyError, IndexError):\nreturn facility, None\n@classmethod\ndef _process_rec_area_response(\ncls, recreation_area=dict\n) -&gt; Tuple[dict, Optional[RecreationArea]]:\n\"\"\"\n        Process Rec Area Responses to be More Usable\n        Parameters\n        ----------\n        recreation_area: dict\n        Returns\n        -------\n        Tuple[dict, RecreationArea]\n        \"\"\"\nrec_area_response = RecreationAreaResponse(**recreation_area)\ntry:\nrecreation_area_location = rec_area_response.RECAREAADDRESS[\n0\n].AddressStateCode\nrecreation_area_tuple = RecreationArea(\nrecreation_area=rec_area_response.RecAreaName,\nrecreation_area_id=rec_area_response.RecAreaID,\nrecreation_area_location=recreation_area_location,\n)\nreturn recreation_area, recreation_area_tuple\nexcept IndexError:\nreturn recreation_area, None\n@classmethod\ndef _rec_availability_get_endpoint(cls, path: str) -&gt; str:\n\"\"\"\n        Return an API Endpoint for the Recreation.gov Campground Availability API\n        Parameters\n        ----------\n        path: str\n            URL Endpoint Path\n        Returns\n        -------\n        endpoint_url: str\n            URL for the API Endpoint\n        \"\"\"\nbase_url = api_utils.generate_url(\nscheme=RecreationBookingConfig.API_SCHEME,\nnetloc=RecreationBookingConfig.API_NET_LOC,\npath=cls.api_base_path,\n)\nendpoint_url = parse.urljoin(base_url, path)\nreturn endpoint_url\n@classmethod\n@ratelimit.sleep_and_retry\n@ratelimit.limits(calls=3, period=1)\ndef make_recdotgov_request(\ncls,\nurl: str,\nmethod: str = \"GET\",\nparams: Optional[Dict[str, Any]] = None,\n**kwargs,\n) -&gt; requests.Response:\n\"\"\"\n        Make a Raw Request to RecreationDotGov\n        Parameters\n        ----------\n        url: str\n        method: str\n        params: Optional[Dict[str, Any]]\n        Returns\n        -------\n        requests.Response\n        \"\"\"\n# BUILD THE HEADERS EXPECTED FROM THE API\nuser_agent = {\n\"User-Agent\": UserAgent(use_external_data=False, browsers=[\"chrome\"]).chrome\n}\nheaders = STANDARD_HEADERS.copy()\nheaders.update(user_agent)\nheaders.update(RecreationBookingConfig.API_REFERRERS)\nresponse = requests.request(\nmethod=method, url=url, headers=headers, params=params, timeout=30, **kwargs\n)\nreturn response\n@classmethod\n@tenacity.retry(\nwait=tenacity.wait_random_exponential(multiplier=2, max=10),\nstop=tenacity.stop.stop_after_delay(15),\n)\ndef make_recdotgov_request_retry(\ncls,\nurl: str,\nmethod: str = \"GET\",\nparams: Optional[Dict[str, Any]] = None,\n**kwargs,\n) -&gt; requests.Response:\n\"\"\"\n        Make a Raw Request to RecreationDotGov - But Handle 404\n        Parameters\n        ----------\n        url: str\n        method: str\n        params: Optional[Dict[str, Any]]\n        Returns\n        -------\n        requests.Response\n        \"\"\"\nresponse = cls.make_recdotgov_request(\nurl=url, method=method, params=params, **kwargs\n)\nresponse.raise_for_status()\nreturn response\n@tenacity.retry(\nwait=tenacity.wait_random_exponential(multiplier=3, max=1800),\nstop=tenacity.stop.stop_after_delay(6000),\n)\ndef _make_recdotgov_availability_request(\nself,\ncampground_id: int,\nmonth: datetime,\n) -&gt; requests.Response:\n\"\"\"\n        Make a request to the RecreationDotGov API - Handle Exponential Backoff\n        Parameters\n        ----------\n        campground_id\n        month\n        Returns\n        -------\n        requests.Response\n        \"\"\"\nresponse = self.make_recdotgov_availability_request(campground_id, month)\nif response.ok is True:\nreturn response\nelse:\nresponse_error = response.text\nerror_message = \"Bad Data Returned from the RecreationDotGov API\"\nlogger.debug(f\"{error_message}, will continue to retry\")\nlogger.debug(f\"Error Details: {response_error}\")\nraise ConnectionError(f\"{error_message}: {response_error}\")\ndef get_recdotgov_data(\nself, campground_id: int, month: datetime\n) -&gt; Union[dict, list]:\n\"\"\"\n        Find Campsite Availability Data\n        Parameters\n        ----------\n        campground_id: int\n            Campground ID from the RIDB API. Can also be pulled of URLs on Recreation.gov\n        month: datetime\n            datetime object, results will be filtered to month\n        Returns\n        -------\n        Union[dict, list]\n        \"\"\"\ntry:\nresponse = self._make_recdotgov_availability_request(\ncampground_id=campground_id, month=month\n)\nexcept tenacity.RetryError as re:\nraise RuntimeError(\n\"Something went wrong in fetching data from the \"\n\"RecreationDotGov API.\"\n) from re\nreturn loads(response.content)\ndef get_campsite_by_id(\nself, campsite_id: int\n) -&gt; Union[CampsiteResponse, TourResponse]:\n\"\"\"\n        Get a Campsite's Details\n        Parameters\n        ----------\n        campsite_id: int\n        Returns\n        -------\n        CamplyModel\n        \"\"\"\ndata = self.get_ridb_data(path=f\"{self.resource_api_path}/{campsite_id}\")\ntry:\nresponse = self.api_response_class(**data[0])\nexcept IndexError as ie:\nraise ProviderSearchError(\nf\"Campsite with ID #{campsite_id} not found.\"\n) from ie\nreturn response\ndef get_campground_ids_by_campsites(\nself, campsite_ids: List[int]\n) -&gt; Tuple[List[int], List[CamplyModel]]:\n\"\"\"\n        Retrieve a list of FacilityIDs, and Facilities from a Campsite ID List\n        Parameters\n        ----------\n        campsite_ids: List[int]\n            List of Campsite IDs\n        Returns\n        -------\n        Tuple[List[int], List[CamplyModel]]\n        \"\"\"\ncampground_ids = []\ncampgrounds = []\nfor campsite_id in campsite_ids:\ncampsite = self.get_campsite_by_id(campsite_id=campsite_id)\ncampgrounds.append(campsite)\ncampground_ids.append(campsite.FacilityID)\nreturn list(set(campground_ids)), list(campgrounds)\ndef _process_specific_campsites_provided(\nself, campsite_id: List[int] = None\n) -&gt; List[CampgroundFacility]:\n\"\"\"\n        Process Requests for Campgrounds into Facilities\n        Parameters\n        ----------\n        campsite_id: Optional[List[int]]\n        Returns\n        -------\n        List[CampgroundFacility]\n        \"\"\"\nfacility_ids, campsites = self.get_campground_ids_by_campsites(\ncampsite_ids=campsite_id\n)\nfacilities = []\nfor campsite in campsites:\nfacility = self._find_facilities_from_campgrounds(\ncampground_id=[campsite.FacilityID]\n)[0]\nfacilities.append(facility)\n# TODO(@juftin): Why did we change this?\nlogger.info(\n\"Searching Specific Campsite: \u26fa\ufe0f \"\nf\"{campsite} - {facility.facility_name}, {facility.recreation_area}\"\n)\nreturn facilities\ndef get_internal_campsites(\nself, facility_ids: List[int]\n) -&gt; List[RecDotGovCampsite]:\n\"\"\"\n        Retrieve all of the underlying Campsites to Search\n        \"\"\"\nall_campsites: List[RecDotGovCampsite] = []\nfor facility_id in facility_ids:\nall_campsites += self.paginate_recdotgov_campsites(facility_id=facility_id)\nreturn all_campsites\ndef get_internal_campsite_metadata(self, facility_ids: List[int]) -&gt; pd.DataFrame:\n\"\"\"\n        Retrieve Metadata About all of the underlying Campsites to Search\n        \"\"\"\nall_campsites: List[RecDotGovCampsite] = self.get_internal_campsites(\nfacility_ids=facility_ids\n)\nall_campsite_df = pd.DataFrame(\n[item.dict() for item in all_campsites],\ncolumns=self.api_search_result_class.__fields__,\n)\nall_campsite_df.set_index(self.api_search_result_key, inplace=True)\nreturn all_campsite_df\ndef list_campsite_units(\nself,\nrecreation_area_ids: Optional[Sequence[int]] = None,\ncampground_ids: Optional[Sequence[int]] = None,\n) -&gt; List[ListedCampsite]:\n\"\"\"\n        List Campsite Units\n        Parameters\n        ----------\n        recreation_area_ids: Optional[List[int]]\n        campground_ids: Optional[List[int]]\n        Returns\n        -------\n        List[ListedCampsite]\n        \"\"\"\nsuper().list_campsite_units(\nrecreation_area_ids=recreation_area_ids, campground_ids=campground_ids\n)\n@abstractmethod\ndef paginate_recdotgov_campsites(self, facility_id) -&gt; List[RecDotGovCampsite]:\n\"\"\"\n        Paginate Campsites\n        Parameters\n        ----------\n        facility_id\n        Returns\n        -------\n        List[RecDotGovCampsite]\n        \"\"\"\n</code></pre>"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGovBase.activity_name","title":"<code>activity_name: str</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Activity Name Used In API Query Params</p>"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGovBase.api_base_path","title":"<code>api_base_path: str</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>API Base Path - Used in Downstream API Calls.</p>"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGovBase.api_response_class","title":"<code>api_response_class: Type[CoreRecDotGovResponse]</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Pydantic Object Representing the API Response.</p>"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGovBase.api_search_result_class","title":"<code>api_search_result_class: Type[CamplyModel]</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Pydantic Object for the Search Results API Response</p>"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGovBase.api_search_result_key","title":"<code>api_search_result_key: str</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Entity ID: Related to Searches</p>"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGovBase.facility_type","title":"<code>facility_type: str</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Facility Type: Used for Filtering Campgrounds</p>"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGovBase.resource_api_path","title":"<code>resource_api_path: str</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>API Endpoint Path</p>"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGovBase.__init__","title":"<code>__init__(api_key=None)</code>","text":"<p>Initialize with Search Dates</p> Source code in <code>camply/providers/recreation_dot_gov/recdotgov_provider.py</code> <pre><code>def __init__(self, api_key: str = None):\n\"\"\"\n    Initialize with Search Dates\n    \"\"\"\nsuper().__init__()\nif api_key is None:\n_api_key = RIDBConfig.API_KEY\nif isinstance(_api_key, bytes):\n_api_key: str = b64decode(RIDBConfig.API_KEY).decode(\"utf-8\")\nelse:\n_api_key: str = api_key\nself._ridb_api_headers: dict = {\n\"accept\": \"application/json\",\n\"apikey\": _api_key,\n}\n_user_agent = UserAgent(use_external_data=False, browsers=[\"chrome\"]).chrome\nself._user_agent = {\"User-Agent\": _user_agent}\n</code></pre>"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGovBase.find_campgrounds","title":"<code>find_campgrounds(search_string=None, rec_area_id=None, campground_id=None, campsite_id=None, **kwargs)</code>","text":"<p>Find Bookable Campgrounds Given a Set of Search Criteria</p> <p>Parameters:</p> Name Type Description Default <code>search_string</code> <code>str</code> <p>Search Keyword(s)</p> <code>None</code> <code>rec_area_id</code> <code>Optional[List[int]]</code> <p>Recreation Area ID to filter with</p> <code>None</code> <code>campground_id</code> <code>Optional[List[int]]</code> <p>ID of the Campground</p> <code>None</code> <code>campsite_id</code> <code>Optional[List[int]]</code> <p>ID of the Campsite</p> <code>None</code> <p>Returns:</p> Name Type Description <code>facilities</code> <code>List[CampgroundFacility]</code> <p>Array of Matching Campsites</p> Source code in <code>camply/providers/recreation_dot_gov/recdotgov_provider.py</code> <pre><code>def find_campgrounds(\nself,\nsearch_string: str = None,\nrec_area_id: Optional[List[int]] = None,\ncampground_id: Optional[List[int]] = None,\ncampsite_id: Optional[List[int]] = None,\n**kwargs,\n) -&gt; List[CampgroundFacility]:\n\"\"\"\n    Find Bookable Campgrounds Given a Set of Search Criteria\n    Parameters\n    ----------\n    search_string: str\n        Search Keyword(s)\n    rec_area_id: Optional[List[int]]\n        Recreation Area ID to filter with\n    campground_id: Optional[List[int]]\n        ID of the Campground\n    campsite_id: Optional[List[int]]\n        ID of the Campsite\n    Returns\n    -------\n    facilities: List[CampgroundFacility]\n        Array of Matching Campsites\n    \"\"\"\nif campsite_id not in (None, [], ()):\nfacilities = self._process_specific_campsites_provided(\ncampsite_id=campsite_id\n)\nelif campground_id not in (None, [], ()):\nfacilities = self._find_facilities_from_campgrounds(\ncampground_id=campground_id\n)\nelif rec_area_id not in (None, [], ()):\nfacilities = []\nfor recreation_area in rec_area_id:\nfacilities += self.find_facilities_per_recreation_area(\nrec_area_id=recreation_area\n)\nelse:\nstate_arg = kwargs.get(\"state\", None)\nif state_arg is not None:\nkwargs.update({\"state\": state_arg.upper()})\nif search_string in [\"\", None] and state_arg is None:\nraise RuntimeError(\n\"You must provide a search query or state to find campsites\"\n)\nif self.activity_name:\nkwargs[\"activity\"] = self.activity_name\nfacilities = self._find_facilities_from_search(\nsearch=search_string, **kwargs\n)\nreturn facilities\n</code></pre>"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGovBase.find_facilities_per_recreation_area","title":"<code>find_facilities_per_recreation_area(rec_area_id=None, **kwargs)</code>","text":"<p>Find Matching Campsites Based from Recreation Area</p> <p>Parameters:</p> Name Type Description Default <code>rec_area_id</code> <code>int</code> <p>Recreation Area ID</p> <code>None</code> <p>Returns:</p> Name Type Description <code>campgrounds</code> <code>List[CampgroundFacility]</code> <p>Array of Matching Campsites</p> Source code in <code>camply/providers/recreation_dot_gov/recdotgov_provider.py</code> <pre><code>def find_facilities_per_recreation_area(\nself, rec_area_id: int = None, **kwargs\n) -&gt; List[CampgroundFacility]:\n\"\"\"\n    Find Matching Campsites Based from Recreation Area\n    Parameters\n    ----------\n    rec_area_id: int\n        Recreation Area ID\n    Returns\n    -------\n    campgrounds: List[CampgroundFacility]\n        Array of Matching Campsites\n    \"\"\"\nlogger.info(\nf\"Retrieving Facility Information for Recreation Area ID: `{rec_area_id}`.\"\n)\napi_path = f\"{RIDBConfig.REC_AREA_API_PATH}/{rec_area_id}/{RIDBConfig.FACILITIES_API_PATH}\"\napi_response = self._ridb_get_paginate(\npath=api_path, params=dict(full=\"true\", **kwargs)\n)\nfiltered_facilities = self._filter_facilities_responses(responses=api_response)\ncampgrounds = []\nlogger.info(f\"{len(filtered_facilities)} Matching Campgrounds Found\")\nfor facility in filtered_facilities:\n_, campground_facility = self.process_facilities_responses(\nfacility=facility\n)\nif campground_facility is not None:\ncampgrounds.append(campground_facility)\nlog_sorted_response(response_array=campgrounds)\nreturn campgrounds\n</code></pre>"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGovBase.find_recreation_areas","title":"<code>find_recreation_areas(search_string=None, **kwargs)</code>","text":"<p>Find Matching Campsites Based on Search String</p> <p>Parameters:</p> Name Type Description Default <code>search_string</code> <code>str</code> <p>Search Keyword(s)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>filtered_responses</code> <code>List[dict]</code> <p>Array of Matching Campsites</p> Source code in <code>camply/providers/recreation_dot_gov/recdotgov_provider.py</code> <pre><code>def find_recreation_areas(self, search_string: str = None, **kwargs) -&gt; List[dict]:\n\"\"\"\n    Find Matching Campsites Based on Search String\n    Parameters\n    ----------\n    search_string: str\n        Search Keyword(s)\n    Returns\n    -------\n    filtered_responses: List[dict]\n        Array of Matching Campsites\n    \"\"\"\ntry:\nassert any(\n[\nkwargs.get(\"state\", None) is not None,\nsearch_string is not None and search_string != \"\",\n]\n)\nexcept AssertionError as ae:\nraise RuntimeError(\n\"You must provide a search query or state(s) \"\n\"to find Recreation Areas\"\n) from ae\nif search_string is not None:\nlogger.info(f'Searching for Recreation Areas: \"{search_string}\"')\nstate_arg = kwargs.get(\"state\", None)\nif state_arg is not None:\nkwargs.update({\"state\": state_arg.upper()})\nparams = dict(query=search_string, sort=\"Name\", full=\"true\", **kwargs)\nif search_string is None:\nparams.pop(\"query\")\napi_response = self._ridb_get_paginate(\npath=RIDBConfig.REC_AREA_API_PATH, params=params\n)\nlogger.info(f\"{len(api_response)} recreation areas found.\")\nlogging_messages = []\nfor recreation_area_object in api_response:\n_, recreation_area = self._process_rec_area_response(\nrecreation_area=recreation_area_object\n)\nif recreation_area is not None:\nlogging_messages.append(recreation_area)\nlog_sorted_response(response_array=logging_messages)\nreturn api_response\n</code></pre>"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGovBase.get_campground_ids_by_campsites","title":"<code>get_campground_ids_by_campsites(campsite_ids)</code>","text":"<p>Retrieve a list of FacilityIDs, and Facilities from a Campsite ID List</p> <p>Parameters:</p> Name Type Description Default <code>campsite_ids</code> <code>List[int]</code> <p>List of Campsite IDs</p> required <p>Returns:</p> Type Description <code>Tuple[List[int], List[CamplyModel]]</code> Source code in <code>camply/providers/recreation_dot_gov/recdotgov_provider.py</code> <pre><code>def get_campground_ids_by_campsites(\nself, campsite_ids: List[int]\n) -&gt; Tuple[List[int], List[CamplyModel]]:\n\"\"\"\n    Retrieve a list of FacilityIDs, and Facilities from a Campsite ID List\n    Parameters\n    ----------\n    campsite_ids: List[int]\n        List of Campsite IDs\n    Returns\n    -------\n    Tuple[List[int], List[CamplyModel]]\n    \"\"\"\ncampground_ids = []\ncampgrounds = []\nfor campsite_id in campsite_ids:\ncampsite = self.get_campsite_by_id(campsite_id=campsite_id)\ncampgrounds.append(campsite)\ncampground_ids.append(campsite.FacilityID)\nreturn list(set(campground_ids)), list(campgrounds)\n</code></pre>"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGovBase.get_campsite_by_id","title":"<code>get_campsite_by_id(campsite_id)</code>","text":"<p>Get a Campsite's Details</p> <p>Parameters:</p> Name Type Description Default <code>campsite_id</code> <code>int</code> required <p>Returns:</p> Type Description <code>CamplyModel</code> Source code in <code>camply/providers/recreation_dot_gov/recdotgov_provider.py</code> <pre><code>def get_campsite_by_id(\nself, campsite_id: int\n) -&gt; Union[CampsiteResponse, TourResponse]:\n\"\"\"\n    Get a Campsite's Details\n    Parameters\n    ----------\n    campsite_id: int\n    Returns\n    -------\n    CamplyModel\n    \"\"\"\ndata = self.get_ridb_data(path=f\"{self.resource_api_path}/{campsite_id}\")\ntry:\nresponse = self.api_response_class(**data[0])\nexcept IndexError as ie:\nraise ProviderSearchError(\nf\"Campsite with ID #{campsite_id} not found.\"\n) from ie\nreturn response\n</code></pre>"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGovBase.get_internal_campsite_metadata","title":"<code>get_internal_campsite_metadata(facility_ids)</code>","text":"<p>Retrieve Metadata About all of the underlying Campsites to Search</p> Source code in <code>camply/providers/recreation_dot_gov/recdotgov_provider.py</code> <pre><code>def get_internal_campsite_metadata(self, facility_ids: List[int]) -&gt; pd.DataFrame:\n\"\"\"\n    Retrieve Metadata About all of the underlying Campsites to Search\n    \"\"\"\nall_campsites: List[RecDotGovCampsite] = self.get_internal_campsites(\nfacility_ids=facility_ids\n)\nall_campsite_df = pd.DataFrame(\n[item.dict() for item in all_campsites],\ncolumns=self.api_search_result_class.__fields__,\n)\nall_campsite_df.set_index(self.api_search_result_key, inplace=True)\nreturn all_campsite_df\n</code></pre>"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGovBase.get_internal_campsites","title":"<code>get_internal_campsites(facility_ids)</code>","text":"<p>Retrieve all of the underlying Campsites to Search</p> Source code in <code>camply/providers/recreation_dot_gov/recdotgov_provider.py</code> <pre><code>def get_internal_campsites(\nself, facility_ids: List[int]\n) -&gt; List[RecDotGovCampsite]:\n\"\"\"\n    Retrieve all of the underlying Campsites to Search\n    \"\"\"\nall_campsites: List[RecDotGovCampsite] = []\nfor facility_id in facility_ids:\nall_campsites += self.paginate_recdotgov_campsites(facility_id=facility_id)\nreturn all_campsites\n</code></pre>"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGovBase.get_recdotgov_data","title":"<code>get_recdotgov_data(campground_id, month)</code>","text":"<p>Find Campsite Availability Data</p> <p>Parameters:</p> Name Type Description Default <code>campground_id</code> <code>int</code> <p>Campground ID from the RIDB API. Can also be pulled of URLs on Recreation.gov</p> required <code>month</code> <code>datetime</code> <p>datetime object, results will be filtered to month</p> required <p>Returns:</p> Type Description <code>Union[dict, list]</code> Source code in <code>camply/providers/recreation_dot_gov/recdotgov_provider.py</code> <pre><code>def get_recdotgov_data(\nself, campground_id: int, month: datetime\n) -&gt; Union[dict, list]:\n\"\"\"\n    Find Campsite Availability Data\n    Parameters\n    ----------\n    campground_id: int\n        Campground ID from the RIDB API. Can also be pulled of URLs on Recreation.gov\n    month: datetime\n        datetime object, results will be filtered to month\n    Returns\n    -------\n    Union[dict, list]\n    \"\"\"\ntry:\nresponse = self._make_recdotgov_availability_request(\ncampground_id=campground_id, month=month\n)\nexcept tenacity.RetryError as re:\nraise RuntimeError(\n\"Something went wrong in fetching data from the \"\n\"RecreationDotGov API.\"\n) from re\nreturn loads(response.content)\n</code></pre>"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGovBase.get_ridb_data","title":"<code>get_ridb_data(path, params=None)</code>","text":"<p>Find Matching Campsites Based on Search String</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>URL Endpoint, see https://ridb.recreation.gov/docs</p> required <code>params</code> <code>Optional[dict]</code> <p>API Call Parameters</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[dict, list]</code> Source code in <code>camply/providers/recreation_dot_gov/recdotgov_provider.py</code> <pre><code>@tenacity.retry(\nwait=tenacity.wait_random_exponential(multiplier=2, max=10),\nstop=tenacity.stop.stop_after_delay(15),\n)\ndef get_ridb_data(\nself, path: str, params: Optional[dict] = None\n) -&gt; Union[dict, list]:\n\"\"\"\n    Find Matching Campsites Based on Search String\n    Parameters\n    ----------\n    path: str\n        URL Endpoint, see https://ridb.recreation.gov/docs\n    params: Optional[dict]\n        API Call Parameters\n    Returns\n    -------\n    Union[dict, list]\n    \"\"\"\napi_endpoint = self._ridb_get_endpoint(path=path)\nheaders = self.headers.copy()\nheaders.update(self._ridb_api_headers)\nresponse = self.session.get(\nurl=api_endpoint, headers=headers, params=params, timeout=30\n)\nif response.ok is False:\nerror_message = (\nf\"Receiving bad data from Recreation.gov API: {response.text}\"\n)\nlogger.error(error_message)\nraise ConnectionError(error_message)\nreturn loads(response.content)\n</code></pre>"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGovBase.list_campsite_units","title":"<code>list_campsite_units(recreation_area_ids=None, campground_ids=None)</code>","text":"<p>List Campsite Units</p> <p>Parameters:</p> Name Type Description Default <code>recreation_area_ids</code> <code>Optional[Sequence[int]]</code> <code>None</code> <code>campground_ids</code> <code>Optional[Sequence[int]]</code> <code>None</code> <p>Returns:</p> Type Description <code>List[ListedCampsite]</code> Source code in <code>camply/providers/recreation_dot_gov/recdotgov_provider.py</code> <pre><code>def list_campsite_units(\nself,\nrecreation_area_ids: Optional[Sequence[int]] = None,\ncampground_ids: Optional[Sequence[int]] = None,\n) -&gt; List[ListedCampsite]:\n\"\"\"\n    List Campsite Units\n    Parameters\n    ----------\n    recreation_area_ids: Optional[List[int]]\n    campground_ids: Optional[List[int]]\n    Returns\n    -------\n    List[ListedCampsite]\n    \"\"\"\nsuper().list_campsite_units(\nrecreation_area_ids=recreation_area_ids, campground_ids=campground_ids\n)\n</code></pre>"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGovBase.make_recdotgov_request","title":"<code>make_recdotgov_request(url, method='GET', params=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Make a Raw Request to RecreationDotGov</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> required <code>method</code> <code>str</code> <code>'GET'</code> <code>params</code> <code>Optional[Dict[str, Any]]</code> <code>None</code> <p>Returns:</p> Type Description <code>requests.Response</code> Source code in <code>camply/providers/recreation_dot_gov/recdotgov_provider.py</code> <pre><code>@classmethod\n@ratelimit.sleep_and_retry\n@ratelimit.limits(calls=3, period=1)\ndef make_recdotgov_request(\ncls,\nurl: str,\nmethod: str = \"GET\",\nparams: Optional[Dict[str, Any]] = None,\n**kwargs,\n) -&gt; requests.Response:\n\"\"\"\n    Make a Raw Request to RecreationDotGov\n    Parameters\n    ----------\n    url: str\n    method: str\n    params: Optional[Dict[str, Any]]\n    Returns\n    -------\n    requests.Response\n    \"\"\"\n# BUILD THE HEADERS EXPECTED FROM THE API\nuser_agent = {\n\"User-Agent\": UserAgent(use_external_data=False, browsers=[\"chrome\"]).chrome\n}\nheaders = STANDARD_HEADERS.copy()\nheaders.update(user_agent)\nheaders.update(RecreationBookingConfig.API_REFERRERS)\nresponse = requests.request(\nmethod=method, url=url, headers=headers, params=params, timeout=30, **kwargs\n)\nreturn response\n</code></pre>"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGovBase.make_recdotgov_request_retry","title":"<code>make_recdotgov_request_retry(url, method='GET', params=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Make a Raw Request to RecreationDotGov - But Handle 404</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> required <code>method</code> <code>str</code> <code>'GET'</code> <code>params</code> <code>Optional[Dict[str, Any]]</code> <code>None</code> <p>Returns:</p> Type Description <code>requests.Response</code> Source code in <code>camply/providers/recreation_dot_gov/recdotgov_provider.py</code> <pre><code>@classmethod\n@tenacity.retry(\nwait=tenacity.wait_random_exponential(multiplier=2, max=10),\nstop=tenacity.stop.stop_after_delay(15),\n)\ndef make_recdotgov_request_retry(\ncls,\nurl: str,\nmethod: str = \"GET\",\nparams: Optional[Dict[str, Any]] = None,\n**kwargs,\n) -&gt; requests.Response:\n\"\"\"\n    Make a Raw Request to RecreationDotGov - But Handle 404\n    Parameters\n    ----------\n    url: str\n    method: str\n    params: Optional[Dict[str, Any]]\n    Returns\n    -------\n    requests.Response\n    \"\"\"\nresponse = cls.make_recdotgov_request(\nurl=url, method=method, params=params, **kwargs\n)\nresponse.raise_for_status()\nreturn response\n</code></pre>"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGovBase.paginate_recdotgov_campsites","title":"<code>paginate_recdotgov_campsites(facility_id)</code>  <code>abstractmethod</code>","text":"<p>Paginate Campsites</p> <p>Parameters:</p> Name Type Description Default <code>facility_id</code> required <p>Returns:</p> Type Description <code>List[RecDotGovCampsite]</code> Source code in <code>camply/providers/recreation_dot_gov/recdotgov_provider.py</code> <pre><code>@abstractmethod\ndef paginate_recdotgov_campsites(self, facility_id) -&gt; List[RecDotGovCampsite]:\n\"\"\"\n    Paginate Campsites\n    Parameters\n    ----------\n    facility_id\n    Returns\n    -------\n    List[RecDotGovCampsite]\n    \"\"\"\n</code></pre>"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGovBase.process_facilities_responses","title":"<code>process_facilities_responses(facility)</code>  <code>classmethod</code>","text":"<p>Process Facilities Responses to be More Usable</p> <p>Parameters:</p> Name Type Description Default <code>facility</code> <code>dict</code> required <p>Returns:</p> Type Description <code>Tuple[dict, CampgroundFacility]</code> Source code in <code>camply/providers/recreation_dot_gov/recdotgov_provider.py</code> <pre><code>@classmethod\ndef process_facilities_responses(\ncls, facility: dict\n) -&gt; Tuple[dict, Optional[CampgroundFacility]]:\n\"\"\"\n    Process Facilities Responses to be More Usable\n    Parameters\n    ----------\n    facility: dict\n    Returns\n    -------\n    Tuple[dict, CampgroundFacility]\n    \"\"\"\nfacility_object = FacilityResponse(**facility)\ntry:\nfacility_state = facility_object.FACILITYADDRESS[0].AddressStateCode.upper()\nexcept (KeyError, IndexError):\nfacility_state = \"USA\"\ntry:\nif len(facility_object.RECAREA) == 0:\nrecreation_area_id = facility_object.ParentRecAreaID\nformatted_recreation_area = (\nf\"{facility_object.ORGANIZATION[0].OrgName}, {facility_state}\"\n)\nelse:\nrecreation_area = facility_object.RECAREA[0].RecAreaName\nrecreation_area_id = facility_object.RECAREA[0].RecAreaID\nformatted_recreation_area = f\"{recreation_area}, {facility_state}\"\ncampground_facility = CampgroundFacility(\nfacility_name=facility_object.FacilityName.title(),\nrecreation_area=formatted_recreation_area,\nfacility_id=facility_object.FacilityID,\nrecreation_area_id=recreation_area_id,\n)\nreturn facility, campground_facility\nexcept (KeyError, IndexError):\nreturn facility, None\n</code></pre>"},{"location":"reference/providers/recreation_dot_gov/recdotgov_tours/","title":"recdotgov_tours","text":"<p>Recreation.gov Implementation for Tours.</p>"},{"location":"reference/providers/recreation_dot_gov/recdotgov_tours/#camply.providers.recreation_dot_gov.recdotgov_tours.RecreationDotGovDailyMixin","title":"<code>RecreationDotGovDailyMixin</code>","text":"<p>         Bases: <code>RecreationDotGovTours</code>, <code>ABC</code></p> <p>MixIn Class to Support Daily Searches in Recreation.gov Searches</p> Source code in <code>camply/providers/recreation_dot_gov/recdotgov_tours.py</code> <pre><code>class RecreationDotGovDailyMixin(RecreationDotGovTours, ABC):\n\"\"\"\n    MixIn Class to Support Daily Searches in Recreation.gov Searches\n    \"\"\"\n@classmethod\ndef get_search_months(cls, search_days: List[datetime]) -&gt; List[datetime]:\n\"\"\"\n        Get the Unique Months that need to be Searched\n        Returns\n        -------\n        search_months: List[datetime]\n            Datetime Months to search for reservations\n        \"\"\"\nreturn search_days\ndef make_recdotgov_availability_request(\nself,\ncampground_id: int,\nmonth: datetime,\n) -&gt; requests.Response:\n\"\"\"\n        Make a request to the RecreationDotGov API\n        Parameters\n        ----------\n        campground_id\n        month\n        Returns\n        -------\n        requests.Response\n        \"\"\"\napi_endpoint = self._rec_availability_get_endpoint(path=str(campground_id))\nquery_params = {\n\"date\": month.strftime(\"%Y-%m-%d\"),\n}\nreturn self.make_recdotgov_request(\nmethod=\"GET\",\nurl=api_endpoint,\nparams=query_params,\n)\n@classmethod\ndef process_campsite_availability(\ncls,\navailability: Dict[str, Any],\nrecreation_area: str,\nrecreation_area_id: int,\nfacility_name: str,\nfacility_id: int,\nmonth: datetime,\ncampsite_metadata: pd.DataFrame,\n) -&gt; List[Optional[AvailableCampsite]]:\n\"\"\"\n        Parse the JSON Response and return availabilities\n        Parameters\n        ----------\n        availability: dict\n            API Response\n        recreation_area: str\n            Name of Recreation Area\n        recreation_area_id: int\n            ID of Recreation Area\n        facility_name: str\n            Campground Facility Name\n        facility_id: int\n            Campground Facility ID\n        month: datetime\n            Month to Process\n        campsite_metadata: pd.DataFrame\n            Metadata Fetched from the Recreation.gov API about the Campsites\n        Returns\n        -------\n        total_campsite_availability: List[Optional[AvailableCampsite]]\n            Any monthly availabilities\n        \"\"\"\ntotal_campsite_availability: List[AvailableCampsite] = []\nnow = datetime.now(timezone.utc)\navailabilities: Dict[str, Any] = {}\nfor slot in availability:\nslot_data = TourDailyAvailabilityResponse(**slot)\ntour_key = (slot_data.tour_date, slot_data.tour_id)\ncount_keys = set(slot_data.inventory_count.keys()) &amp; set(\nslot_data.reservation_count.keys()\n)\nfor count_key in count_keys:\nwindow = None\nif \"_SECONDARY\" in count_key:\nwindow = slot_data.booking_windows.SECONDARY\nelse:\nwindow = slot_data.booking_windows.PRIMARY\nif (\nnot window\nor now &lt; window.open_timestamp\nor now &gt;= window.close_timestamp\n):\ncontinue\ninventory_count = slot_data.inventory_count[count_key]\nreservation_count = slot_data.reservation_count[count_key]\nif inventory_count &lt;= reservation_count:\ncontinue\ntour_data = availabilities.setdefault(tour_key, {\"\": slot_data})\ntour_data[slot_data.tour_time] = (\ntour_data.get(slot_data.tour_time, 0)\n+ inventory_count\n- reservation_count\n)\nfor tour_date, tour_id in availabilities:\ntour_data = availabilities[tour_date, tour_id]\nslot_data = tour_data.pop(\"\")\nfields = cls.make_campsite_availability_fields(\ntour_id,\nvars(slot_data),\ntour_date,\ncampsite_metadata,\n)\navailable_campsite = AvailableCampsite(\ncampsite_occupancy=(1, sum(tour_data.values())),\navailability_status=slot_data.status,\nrecreation_area=recreation_area,\nrecreation_area_id=recreation_area_id,\nfacility_name=facility_name,\nfacility_id=facility_id,\npermitted_equipment=[\nRecDotGovEquipment(\nequipment_name=tour_time,\nmax_length=available_count,\n)\nfor tour_time, available_count in tour_data.items()\n],\ncampsite_attributes=[],\n**fields,\n)\ntotal_campsite_availability.append(available_campsite)\nreturn total_campsite_availability\n</code></pre>"},{"location":"reference/providers/recreation_dot_gov/recdotgov_tours/#camply.providers.recreation_dot_gov.recdotgov_tours.RecreationDotGovDailyMixin.get_search_months","title":"<code>get_search_months(search_days)</code>  <code>classmethod</code>","text":"<p>Get the Unique Months that need to be Searched</p> <p>Returns:</p> Name Type Description <code>search_months</code> <code>List[datetime]</code> <p>Datetime Months to search for reservations</p> Source code in <code>camply/providers/recreation_dot_gov/recdotgov_tours.py</code> <pre><code>@classmethod\ndef get_search_months(cls, search_days: List[datetime]) -&gt; List[datetime]:\n\"\"\"\n    Get the Unique Months that need to be Searched\n    Returns\n    -------\n    search_months: List[datetime]\n        Datetime Months to search for reservations\n    \"\"\"\nreturn search_days\n</code></pre>"},{"location":"reference/providers/recreation_dot_gov/recdotgov_tours/#camply.providers.recreation_dot_gov.recdotgov_tours.RecreationDotGovDailyMixin.make_recdotgov_availability_request","title":"<code>make_recdotgov_availability_request(campground_id, month)</code>","text":"<p>Make a request to the RecreationDotGov API</p> <p>Parameters:</p> Name Type Description Default <code>campground_id</code> <code>int</code> required <code>month</code> <code>datetime</code> required <p>Returns:</p> Type Description <code>requests.Response</code> Source code in <code>camply/providers/recreation_dot_gov/recdotgov_tours.py</code> <pre><code>def make_recdotgov_availability_request(\nself,\ncampground_id: int,\nmonth: datetime,\n) -&gt; requests.Response:\n\"\"\"\n    Make a request to the RecreationDotGov API\n    Parameters\n    ----------\n    campground_id\n    month\n    Returns\n    -------\n    requests.Response\n    \"\"\"\napi_endpoint = self._rec_availability_get_endpoint(path=str(campground_id))\nquery_params = {\n\"date\": month.strftime(\"%Y-%m-%d\"),\n}\nreturn self.make_recdotgov_request(\nmethod=\"GET\",\nurl=api_endpoint,\nparams=query_params,\n)\n</code></pre>"},{"location":"reference/providers/recreation_dot_gov/recdotgov_tours/#camply.providers.recreation_dot_gov.recdotgov_tours.RecreationDotGovDailyMixin.process_campsite_availability","title":"<code>process_campsite_availability(availability, recreation_area, recreation_area_id, facility_name, facility_id, month, campsite_metadata)</code>  <code>classmethod</code>","text":"<p>Parse the JSON Response and return availabilities</p> <p>Parameters:</p> Name Type Description Default <code>availability</code> <code>Dict[str, Any]</code> <p>API Response</p> required <code>recreation_area</code> <code>str</code> <p>Name of Recreation Area</p> required <code>recreation_area_id</code> <code>int</code> <p>ID of Recreation Area</p> required <code>facility_name</code> <code>str</code> <p>Campground Facility Name</p> required <code>facility_id</code> <code>int</code> <p>Campground Facility ID</p> required <code>month</code> <code>datetime</code> <p>Month to Process</p> required <code>campsite_metadata</code> <code>pd.DataFrame</code> <p>Metadata Fetched from the Recreation.gov API about the Campsites</p> required <p>Returns:</p> Name Type Description <code>total_campsite_availability</code> <code>List[Optional[AvailableCampsite]]</code> <p>Any monthly availabilities</p> Source code in <code>camply/providers/recreation_dot_gov/recdotgov_tours.py</code> <pre><code>@classmethod\ndef process_campsite_availability(\ncls,\navailability: Dict[str, Any],\nrecreation_area: str,\nrecreation_area_id: int,\nfacility_name: str,\nfacility_id: int,\nmonth: datetime,\ncampsite_metadata: pd.DataFrame,\n) -&gt; List[Optional[AvailableCampsite]]:\n\"\"\"\n    Parse the JSON Response and return availabilities\n    Parameters\n    ----------\n    availability: dict\n        API Response\n    recreation_area: str\n        Name of Recreation Area\n    recreation_area_id: int\n        ID of Recreation Area\n    facility_name: str\n        Campground Facility Name\n    facility_id: int\n        Campground Facility ID\n    month: datetime\n        Month to Process\n    campsite_metadata: pd.DataFrame\n        Metadata Fetched from the Recreation.gov API about the Campsites\n    Returns\n    -------\n    total_campsite_availability: List[Optional[AvailableCampsite]]\n        Any monthly availabilities\n    \"\"\"\ntotal_campsite_availability: List[AvailableCampsite] = []\nnow = datetime.now(timezone.utc)\navailabilities: Dict[str, Any] = {}\nfor slot in availability:\nslot_data = TourDailyAvailabilityResponse(**slot)\ntour_key = (slot_data.tour_date, slot_data.tour_id)\ncount_keys = set(slot_data.inventory_count.keys()) &amp; set(\nslot_data.reservation_count.keys()\n)\nfor count_key in count_keys:\nwindow = None\nif \"_SECONDARY\" in count_key:\nwindow = slot_data.booking_windows.SECONDARY\nelse:\nwindow = slot_data.booking_windows.PRIMARY\nif (\nnot window\nor now &lt; window.open_timestamp\nor now &gt;= window.close_timestamp\n):\ncontinue\ninventory_count = slot_data.inventory_count[count_key]\nreservation_count = slot_data.reservation_count[count_key]\nif inventory_count &lt;= reservation_count:\ncontinue\ntour_data = availabilities.setdefault(tour_key, {\"\": slot_data})\ntour_data[slot_data.tour_time] = (\ntour_data.get(slot_data.tour_time, 0)\n+ inventory_count\n- reservation_count\n)\nfor tour_date, tour_id in availabilities:\ntour_data = availabilities[tour_date, tour_id]\nslot_data = tour_data.pop(\"\")\nfields = cls.make_campsite_availability_fields(\ntour_id,\nvars(slot_data),\ntour_date,\ncampsite_metadata,\n)\navailable_campsite = AvailableCampsite(\ncampsite_occupancy=(1, sum(tour_data.values())),\navailability_status=slot_data.status,\nrecreation_area=recreation_area,\nrecreation_area_id=recreation_area_id,\nfacility_name=facility_name,\nfacility_id=facility_id,\npermitted_equipment=[\nRecDotGovEquipment(\nequipment_name=tour_time,\nmax_length=available_count,\n)\nfor tour_time, available_count in tour_data.items()\n],\ncampsite_attributes=[],\n**fields,\n)\ntotal_campsite_availability.append(available_campsite)\nreturn total_campsite_availability\n</code></pre>"},{"location":"reference/providers/recreation_dot_gov/recdotgov_tours/#camply.providers.recreation_dot_gov.recdotgov_tours.RecreationDotGovDailyTicket","title":"<code>RecreationDotGovDailyTicket</code>","text":"<p>         Bases: <code>RecreationDotGovDailyMixin</code>, <code>RecreationDotGovTicket</code></p> <p>RecreationDotGovTicket: Daily</p> <p>Daily MixIn for Tickets</p> Source code in <code>camply/providers/recreation_dot_gov/recdotgov_tours.py</code> <pre><code>class RecreationDotGovDailyTicket(RecreationDotGovDailyMixin, RecreationDotGovTicket):\n\"\"\"\n    RecreationDotGovTicket: Daily\n    Daily MixIn for Tickets\n    \"\"\"\n</code></pre>"},{"location":"reference/providers/recreation_dot_gov/recdotgov_tours/#camply.providers.recreation_dot_gov.recdotgov_tours.RecreationDotGovDailyTimedEntry","title":"<code>RecreationDotGovDailyTimedEntry</code>","text":"<p>         Bases: <code>RecreationDotGovDailyMixin</code>, <code>RecreationDotGovTimedEntry</code></p> <p>RecreationDotGovTimedEntry: Daily</p> <p>Daily MixIn for Tours</p> Source code in <code>camply/providers/recreation_dot_gov/recdotgov_tours.py</code> <pre><code>class RecreationDotGovDailyTimedEntry(\nRecreationDotGovDailyMixin, RecreationDotGovTimedEntry\n):\n\"\"\"\n    RecreationDotGovTimedEntry: Daily\n    Daily MixIn for Tours\n    \"\"\"\n</code></pre>"},{"location":"reference/providers/recreation_dot_gov/recdotgov_tours/#camply.providers.recreation_dot_gov.recdotgov_tours.RecreationDotGovTicket","title":"<code>RecreationDotGovTicket</code>","text":"<p>         Bases: <code>RecreationDotGovTours</code></p> <p>RecreationDotGovTicket</p> <p>Tickets for Tours</p> Source code in <code>camply/providers/recreation_dot_gov/recdotgov_tours.py</code> <pre><code>class RecreationDotGovTicket(RecreationDotGovTours):\n\"\"\"\n    RecreationDotGovTicket\n    Tickets for Tours\n    \"\"\"\nfacility_type = RIDBConfig.TICKET_FACILITY_FIELD_QUALIFIER\napi_search_fq = \"entity_type:tour\"\napi_base_path = \"api/ticket/availability/facility/\"\nbooking_url = \"https://www.recreation.gov/ticket/{facility_id}/ticket/{tour_id}\"\n</code></pre>"},{"location":"reference/providers/recreation_dot_gov/recdotgov_tours/#camply.providers.recreation_dot_gov.recdotgov_tours.RecreationDotGovTimedEntry","title":"<code>RecreationDotGovTimedEntry</code>","text":"<p>         Bases: <code>RecreationDotGovTours</code></p> <p>RecreationDotGovTimedEntry</p> <p>Timed Entries</p> Source code in <code>camply/providers/recreation_dot_gov/recdotgov_tours.py</code> <pre><code>class RecreationDotGovTimedEntry(RecreationDotGovTours):\n\"\"\"\n    RecreationDotGovTimedEntry\n    Timed Entries\n    \"\"\"\nfacility_type = RIDBConfig.TIMED_ENTRY_FACILITY_FIELD_QUALIFIER\napi_search_fq = \"entity_type:timedentry_tour\"\napi_base_path = \"api/timedentry/availability/facility/\"\nbooking_url = (\n\"https://www.recreation.gov/timed-entry/{facility_id}/ticket/{tour_id}\"\n)\n</code></pre>"},{"location":"reference/providers/recreation_dot_gov/recdotgov_tours/#camply.providers.recreation_dot_gov.recdotgov_tours.RecreationDotGovTours","title":"<code>RecreationDotGovTours</code>","text":"<p>         Bases: <code>RecreationDotGovBase</code>, <code>ABC</code></p> <p>Recreation.gov Implementation for Tours</p> Source code in <code>camply/providers/recreation_dot_gov/recdotgov_tours.py</code> <pre><code>class RecreationDotGovTours(RecreationDotGovBase, ABC):\n\"\"\"\n    Recreation.gov Implementation for Tours\n    \"\"\"\nresource_api_path = RIDBConfig.TOUR_API_PATH\napi_response_class = TourResponse\napi_search_result_class = RecDotGovSearchResult\napi_search_result_key = \"entity_id\"\nactivity_name = None  # Activity Name Should't Be Propogated to Query Parameters\n@property\n@abstractmethod\ndef api_search_fq(self) -&gt; str:\n\"\"\"\n        API Query Parameters\n        \"\"\"\npass\n@property\n@abstractmethod\ndef booking_url(self) -&gt; str:\n\"\"\"\n        API Endpoint\n        \"\"\"\npass\ndef paginate_recdotgov_campsites(\nself, facility_id: int, equipment: Optional[List[str]] = None\n) -&gt; List[RecDotGovSearchResult]:\n\"\"\"\n        Paginate through the RecDotGov Campsite Metadata\n        \"\"\"\nresults = 0\ncontinue_paginate = True\nendpoint_url = api_utils.generate_url(\nscheme=RecreationBookingConfig.API_SCHEME,\nnetloc=RecreationBookingConfig.API_NET_LOC,\npath=\"api/search\",\n)\nfq_list = [\nf\"asset_id:{facility_id}\",\n# Currently, entity_type:tour (parent is entity_type:ticketfacility)\n# or entity_type:timedentry_tour (parent is entity_type:timedentry).\nself.api_search_fq,\n]\nparams = {\n\"start\": 0,\n\"size\": 1000,\n\"fq\": fq_list,\n}\ncampsites: List[RecDotGovSearchResult] = []\nwhile continue_paginate is True:\nresponse = self.make_recdotgov_request_retry(\nmethod=\"GET\",\nurl=endpoint_url,\nparams=params,\n)\nreturned_data = json.loads(response.content)\ncampsite_response = RecDotGovSearchResponse(**returned_data)\ncampsites += campsite_response.results\nresults += campsite_response.size\nparams.update(start=results)\nif results == campsite_response.total:\ncontinue_paginate = False\nreturn campsites\ndef make_recdotgov_availability_request(\nself,\ncampground_id: int,\nmonth: datetime,\n) -&gt; requests.Response:\n\"\"\"\n        Make a request to the RecreationDotGov API\n        Parameters\n        ----------\n        campground_id\n        month\n        Returns\n        -------\n        requests.Response\n        \"\"\"\napi_endpoint = self._rec_availability_get_endpoint(\npath=f\"{campground_id}/monthlyAvailabilitySummaryView\"\n)\nquery_params = {\n\"year\": month.strftime(\"%Y\"),\n\"month\": month.strftime(\"%m\"),\n\"inventoryBucket\": \"FIT\",\n}\nreturn self.make_recdotgov_request(\nmethod=\"GET\",\nurl=api_endpoint,\nparams=query_params,\n)\n@classmethod\ndef make_campsite_availability_fields(\ncls,\ntour_id: int,\nbooking_url_vars: Dict[str, str],\nbooking_date: datetime.date,\ncampsite_metadata: pd.DataFrame,\n) -&gt; Dict[str, Any]:\n\"\"\"\n        Generate a dictionary of fields to be used in a campsite container.\n        Parameters\n        ----------\n        tour_id: int\n        booking_url_vars: Dict[str, str]\n        booking_date: datetime.date\n        campsite_metadata: pd.DataFrame\n        Returns\n        -------\n        Dict[str, Any]\n        \"\"\"\nbooking_date = datetime.combine(booking_date, time.min)\ntry:\nsite_name = campsite_metadata.at[tour_id, \"name\"]\nexcept LookupError:\nsite_name = f\"Tour #{tour_id}\"\ntry:\nloop_name = campsite_metadata.at[tour_id, \"description\"]\nexcept LookupError:\nloop_name = \"Description not available\"\ntry:\nuse_type = campsite_metadata.at[tour_id, \"time_zone\"]\nexcept LookupError:\nuse_type = \"Time zone not available\"\nreturn {\n\"booking_url\": cls.booking_url.format(**booking_url_vars),  # type: ignore\n\"booking_date\": booking_date,\n\"booking_end_date\": booking_date + timedelta(days=1),\n\"booking_nights\": 1,\n\"campsite_id\": tour_id,\n\"campsite_site_name\": site_name,\n\"campsite_loop_name\": loop_name,\n\"campsite_type\": cls.facility_type,\n\"campsite_use_type\": use_type,\n}\n@classmethod\ndef process_campsite_availability(\ncls,\navailability: Dict[str, Any],\nrecreation_area: str,\nrecreation_area_id: int,\nfacility_name: str,\nfacility_id: int,\nmonth: datetime,\ncampsite_metadata: pd.DataFrame,\n) -&gt; List[Optional[AvailableCampsite]]:\n\"\"\"\n        Parse the JSON Response and return availabilities\n        Parameters\n        ----------\n        availability: dict\n            API Response\n        recreation_area: str\n            Name of Recreation Area\n        recreation_area_id: int\n            ID of Recreation Area\n        facility_name: str\n            Campground Facility Name\n        facility_id: int\n            Campground Facility ID\n        month: datetime\n            Month to Process\n        campsite_metadata: pd.DataFrame\n            Metadata Fetched from the Recreation.gov API about the Campsites\n        Returns\n        -------\n        total_campsite_availability: List[Optional[AvailableCampsite]]\n            Any monthly availabilities\n        \"\"\"\ntotal_campsite_availability: List[Optional[AvailableCampsite]] = []\ncampsite_data = TourMonthlyAvailabilityResponse(**availability)\nfor (\nmatching_date,\ndate_related_data,\n) in campsite_data.facility_availability_summary_view_by_local_date.items():\nfor (\ntour_id,\navailability_status,\n) in date_related_data.tour_availability_summary_view_by_tour_id.items():\nif availability_status.reservable &gt; 0:\nfields = cls.make_campsite_availability_fields(\ntour_id,\nvars(availability_status),\nmatching_date,\ncampsite_metadata,\n)\navailable_campsite = AvailableCampsite(\ncampsite_occupancy=(1, availability_status.reservable),\navailability_status=availability_status.availability_level,\nrecreation_area=recreation_area,\nrecreation_area_id=recreation_area_id,\nfacility_name=facility_name,\nfacility_id=facility_id,\npermitted_equipment=[],\ncampsite_attributes=[],\n**fields,\n)\ntotal_campsite_availability.append(available_campsite)\nreturn total_campsite_availability\ndef get_campground_ids_by_campsites(\nself, campsite_ids: List[int]\n) -&gt; Tuple[List[int], List[CamplyModel]]:\n\"\"\"\n        Retrieve a list of FacilityIDs, and Facilities from a Campsite ID List\n        This implementation for tours tolerates unknown campsite_ids and mock them using known ones.\n        Parameters\n        ----------\n        campsite_ids: List[int]\n            List of Campsite IDs\n        Returns\n        -------\n        Tuple[List[int], List[CamplyModel]]\n        \"\"\"\ncampground_ids = []\ncampgrounds = []\nunknown_ids = []\nfor campsite_id in campsite_ids:\ntry:\ncampsite = self.get_campsite_by_id(campsite_id=campsite_id)\nexcept ProviderSearchError as e:\nwarning_message = (\n\"Ignoring ProviderSearchError; \"\nf\"be sure that this is covered by another one in the same facility: {e}\"\n)\nlogging.warning(warning_message)\nunknown_ids.append(campsite_id)\ncontinue\ncampgrounds.append(campsite)\ncampground_ids.append(campsite.FacilityID)\ncampground_ids_unique = list(set(campground_ids))\nif unknown_ids:\nif not campground_ids_unique:\nraise ProviderSearchError(\n\"No facility can be determined from specified tours.\"\n)\nfor unknown_id in unknown_ids:\ncampsite = TourResponse(\nTourID=unknown_id,\nFacilityID=campground_ids_unique[0],\nTourName=f\"Tour #{unknown_id} (facility may be wrong)\",\nTourType=\"Unknown Tour\",\nTourDuration=0,\nTourDescription=f\"Unknown Tour #{unknown_id}\",\nTourAccessible=False,\nCreatedDate=date.min,\nLastUpdatedDate=date.min,\nATTRIBUTES=[],\n)\ncampgrounds.append(campsite)\nreturn campground_ids_unique, list(campgrounds)\n</code></pre>"},{"location":"reference/providers/recreation_dot_gov/recdotgov_tours/#camply.providers.recreation_dot_gov.recdotgov_tours.RecreationDotGovTours.api_search_fq","title":"<code>api_search_fq: str</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>API Query Parameters</p>"},{"location":"reference/providers/recreation_dot_gov/recdotgov_tours/#camply.providers.recreation_dot_gov.recdotgov_tours.RecreationDotGovTours.booking_url","title":"<code>booking_url: str</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>API Endpoint</p>"},{"location":"reference/providers/recreation_dot_gov/recdotgov_tours/#camply.providers.recreation_dot_gov.recdotgov_tours.RecreationDotGovTours.get_campground_ids_by_campsites","title":"<code>get_campground_ids_by_campsites(campsite_ids)</code>","text":"<p>Retrieve a list of FacilityIDs, and Facilities from a Campsite ID List</p> <p>This implementation for tours tolerates unknown campsite_ids and mock them using known ones.</p> <p>Parameters:</p> Name Type Description Default <code>campsite_ids</code> <code>List[int]</code> <p>List of Campsite IDs</p> required <p>Returns:</p> Type Description <code>Tuple[List[int], List[CamplyModel]]</code> Source code in <code>camply/providers/recreation_dot_gov/recdotgov_tours.py</code> <pre><code>def get_campground_ids_by_campsites(\nself, campsite_ids: List[int]\n) -&gt; Tuple[List[int], List[CamplyModel]]:\n\"\"\"\n    Retrieve a list of FacilityIDs, and Facilities from a Campsite ID List\n    This implementation for tours tolerates unknown campsite_ids and mock them using known ones.\n    Parameters\n    ----------\n    campsite_ids: List[int]\n        List of Campsite IDs\n    Returns\n    -------\n    Tuple[List[int], List[CamplyModel]]\n    \"\"\"\ncampground_ids = []\ncampgrounds = []\nunknown_ids = []\nfor campsite_id in campsite_ids:\ntry:\ncampsite = self.get_campsite_by_id(campsite_id=campsite_id)\nexcept ProviderSearchError as e:\nwarning_message = (\n\"Ignoring ProviderSearchError; \"\nf\"be sure that this is covered by another one in the same facility: {e}\"\n)\nlogging.warning(warning_message)\nunknown_ids.append(campsite_id)\ncontinue\ncampgrounds.append(campsite)\ncampground_ids.append(campsite.FacilityID)\ncampground_ids_unique = list(set(campground_ids))\nif unknown_ids:\nif not campground_ids_unique:\nraise ProviderSearchError(\n\"No facility can be determined from specified tours.\"\n)\nfor unknown_id in unknown_ids:\ncampsite = TourResponse(\nTourID=unknown_id,\nFacilityID=campground_ids_unique[0],\nTourName=f\"Tour #{unknown_id} (facility may be wrong)\",\nTourType=\"Unknown Tour\",\nTourDuration=0,\nTourDescription=f\"Unknown Tour #{unknown_id}\",\nTourAccessible=False,\nCreatedDate=date.min,\nLastUpdatedDate=date.min,\nATTRIBUTES=[],\n)\ncampgrounds.append(campsite)\nreturn campground_ids_unique, list(campgrounds)\n</code></pre>"},{"location":"reference/providers/recreation_dot_gov/recdotgov_tours/#camply.providers.recreation_dot_gov.recdotgov_tours.RecreationDotGovTours.make_campsite_availability_fields","title":"<code>make_campsite_availability_fields(tour_id, booking_url_vars, booking_date, campsite_metadata)</code>  <code>classmethod</code>","text":"<p>Generate a dictionary of fields to be used in a campsite container.</p> <p>Parameters:</p> Name Type Description Default <code>tour_id</code> <code>int</code> required <code>booking_url_vars</code> <code>Dict[str, str]</code> required <code>booking_date</code> <code>datetime.date</code> required <code>campsite_metadata</code> <code>pd.DataFrame</code> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> Source code in <code>camply/providers/recreation_dot_gov/recdotgov_tours.py</code> <pre><code>@classmethod\ndef make_campsite_availability_fields(\ncls,\ntour_id: int,\nbooking_url_vars: Dict[str, str],\nbooking_date: datetime.date,\ncampsite_metadata: pd.DataFrame,\n) -&gt; Dict[str, Any]:\n\"\"\"\n    Generate a dictionary of fields to be used in a campsite container.\n    Parameters\n    ----------\n    tour_id: int\n    booking_url_vars: Dict[str, str]\n    booking_date: datetime.date\n    campsite_metadata: pd.DataFrame\n    Returns\n    -------\n    Dict[str, Any]\n    \"\"\"\nbooking_date = datetime.combine(booking_date, time.min)\ntry:\nsite_name = campsite_metadata.at[tour_id, \"name\"]\nexcept LookupError:\nsite_name = f\"Tour #{tour_id}\"\ntry:\nloop_name = campsite_metadata.at[tour_id, \"description\"]\nexcept LookupError:\nloop_name = \"Description not available\"\ntry:\nuse_type = campsite_metadata.at[tour_id, \"time_zone\"]\nexcept LookupError:\nuse_type = \"Time zone not available\"\nreturn {\n\"booking_url\": cls.booking_url.format(**booking_url_vars),  # type: ignore\n\"booking_date\": booking_date,\n\"booking_end_date\": booking_date + timedelta(days=1),\n\"booking_nights\": 1,\n\"campsite_id\": tour_id,\n\"campsite_site_name\": site_name,\n\"campsite_loop_name\": loop_name,\n\"campsite_type\": cls.facility_type,\n\"campsite_use_type\": use_type,\n}\n</code></pre>"},{"location":"reference/providers/recreation_dot_gov/recdotgov_tours/#camply.providers.recreation_dot_gov.recdotgov_tours.RecreationDotGovTours.make_recdotgov_availability_request","title":"<code>make_recdotgov_availability_request(campground_id, month)</code>","text":"<p>Make a request to the RecreationDotGov API</p> <p>Parameters:</p> Name Type Description Default <code>campground_id</code> <code>int</code> required <code>month</code> <code>datetime</code> required <p>Returns:</p> Type Description <code>requests.Response</code> Source code in <code>camply/providers/recreation_dot_gov/recdotgov_tours.py</code> <pre><code>def make_recdotgov_availability_request(\nself,\ncampground_id: int,\nmonth: datetime,\n) -&gt; requests.Response:\n\"\"\"\n    Make a request to the RecreationDotGov API\n    Parameters\n    ----------\n    campground_id\n    month\n    Returns\n    -------\n    requests.Response\n    \"\"\"\napi_endpoint = self._rec_availability_get_endpoint(\npath=f\"{campground_id}/monthlyAvailabilitySummaryView\"\n)\nquery_params = {\n\"year\": month.strftime(\"%Y\"),\n\"month\": month.strftime(\"%m\"),\n\"inventoryBucket\": \"FIT\",\n}\nreturn self.make_recdotgov_request(\nmethod=\"GET\",\nurl=api_endpoint,\nparams=query_params,\n)\n</code></pre>"},{"location":"reference/providers/recreation_dot_gov/recdotgov_tours/#camply.providers.recreation_dot_gov.recdotgov_tours.RecreationDotGovTours.paginate_recdotgov_campsites","title":"<code>paginate_recdotgov_campsites(facility_id, equipment=None)</code>","text":"<p>Paginate through the RecDotGov Campsite Metadata</p> Source code in <code>camply/providers/recreation_dot_gov/recdotgov_tours.py</code> <pre><code>def paginate_recdotgov_campsites(\nself, facility_id: int, equipment: Optional[List[str]] = None\n) -&gt; List[RecDotGovSearchResult]:\n\"\"\"\n    Paginate through the RecDotGov Campsite Metadata\n    \"\"\"\nresults = 0\ncontinue_paginate = True\nendpoint_url = api_utils.generate_url(\nscheme=RecreationBookingConfig.API_SCHEME,\nnetloc=RecreationBookingConfig.API_NET_LOC,\npath=\"api/search\",\n)\nfq_list = [\nf\"asset_id:{facility_id}\",\n# Currently, entity_type:tour (parent is entity_type:ticketfacility)\n# or entity_type:timedentry_tour (parent is entity_type:timedentry).\nself.api_search_fq,\n]\nparams = {\n\"start\": 0,\n\"size\": 1000,\n\"fq\": fq_list,\n}\ncampsites: List[RecDotGovSearchResult] = []\nwhile continue_paginate is True:\nresponse = self.make_recdotgov_request_retry(\nmethod=\"GET\",\nurl=endpoint_url,\nparams=params,\n)\nreturned_data = json.loads(response.content)\ncampsite_response = RecDotGovSearchResponse(**returned_data)\ncampsites += campsite_response.results\nresults += campsite_response.size\nparams.update(start=results)\nif results == campsite_response.total:\ncontinue_paginate = False\nreturn campsites\n</code></pre>"},{"location":"reference/providers/recreation_dot_gov/recdotgov_tours/#camply.providers.recreation_dot_gov.recdotgov_tours.RecreationDotGovTours.process_campsite_availability","title":"<code>process_campsite_availability(availability, recreation_area, recreation_area_id, facility_name, facility_id, month, campsite_metadata)</code>  <code>classmethod</code>","text":"<p>Parse the JSON Response and return availabilities</p> <p>Parameters:</p> Name Type Description Default <code>availability</code> <code>Dict[str, Any]</code> <p>API Response</p> required <code>recreation_area</code> <code>str</code> <p>Name of Recreation Area</p> required <code>recreation_area_id</code> <code>int</code> <p>ID of Recreation Area</p> required <code>facility_name</code> <code>str</code> <p>Campground Facility Name</p> required <code>facility_id</code> <code>int</code> <p>Campground Facility ID</p> required <code>month</code> <code>datetime</code> <p>Month to Process</p> required <code>campsite_metadata</code> <code>pd.DataFrame</code> <p>Metadata Fetched from the Recreation.gov API about the Campsites</p> required <p>Returns:</p> Name Type Description <code>total_campsite_availability</code> <code>List[Optional[AvailableCampsite]]</code> <p>Any monthly availabilities</p> Source code in <code>camply/providers/recreation_dot_gov/recdotgov_tours.py</code> <pre><code>@classmethod\ndef process_campsite_availability(\ncls,\navailability: Dict[str, Any],\nrecreation_area: str,\nrecreation_area_id: int,\nfacility_name: str,\nfacility_id: int,\nmonth: datetime,\ncampsite_metadata: pd.DataFrame,\n) -&gt; List[Optional[AvailableCampsite]]:\n\"\"\"\n    Parse the JSON Response and return availabilities\n    Parameters\n    ----------\n    availability: dict\n        API Response\n    recreation_area: str\n        Name of Recreation Area\n    recreation_area_id: int\n        ID of Recreation Area\n    facility_name: str\n        Campground Facility Name\n    facility_id: int\n        Campground Facility ID\n    month: datetime\n        Month to Process\n    campsite_metadata: pd.DataFrame\n        Metadata Fetched from the Recreation.gov API about the Campsites\n    Returns\n    -------\n    total_campsite_availability: List[Optional[AvailableCampsite]]\n        Any monthly availabilities\n    \"\"\"\ntotal_campsite_availability: List[Optional[AvailableCampsite]] = []\ncampsite_data = TourMonthlyAvailabilityResponse(**availability)\nfor (\nmatching_date,\ndate_related_data,\n) in campsite_data.facility_availability_summary_view_by_local_date.items():\nfor (\ntour_id,\navailability_status,\n) in date_related_data.tour_availability_summary_view_by_tour_id.items():\nif availability_status.reservable &gt; 0:\nfields = cls.make_campsite_availability_fields(\ntour_id,\nvars(availability_status),\nmatching_date,\ncampsite_metadata,\n)\navailable_campsite = AvailableCampsite(\ncampsite_occupancy=(1, availability_status.reservable),\navailability_status=availability_status.availability_level,\nrecreation_area=recreation_area,\nrecreation_area_id=recreation_area_id,\nfacility_name=facility_name,\nfacility_id=facility_id,\npermitted_equipment=[],\ncampsite_attributes=[],\n**fields,\n)\ntotal_campsite_availability.append(available_campsite)\nreturn total_campsite_availability\n</code></pre>"},{"location":"reference/providers/usedirect/","title":"usedirect","text":"<p>ReserveCalifornia</p>"},{"location":"reference/providers/usedirect/#camply.providers.usedirect.UseDirectProvider","title":"<code>UseDirectProvider</code>","text":"<p>         Bases: <code>BaseProvider</code>, <code>ABC</code></p> <p>Camply Provider for UseDirect RDR Campgrounds</p> Source code in <code>camply/providers/usedirect/usedirect.py</code> <pre><code>class UseDirectProvider(BaseProvider, ABC):\n\"\"\"\n    Camply Provider for UseDirect RDR Campgrounds\n    \"\"\"\nusedirect_city_parks: Dict[int, UseDirectCityPark] = {}\nusedirect_rec_areas: Dict[int, RecreationArea] = {}\nusedirect_campgrounds: Dict[int, CampgroundFacility] = {}\nusedirect_unit_categories: Dict[int, str] = {}\nusedirect_unit_type_groups: Dict[int, str] = {}\nusedirect_campsites: Dict[int, UseDirectAvailabilityUnit] = {}\ncampsite_ids: List[int] = []\nmetadata_refreshed: bool = False\nactive_search: bool = False\n__offline_cache_dir__: Optional[pathlib.Path] = None\nrdr_path: str = \"rdr\"\nbooking_path_params: bool = True\nbooking_path: str = \"Web/Default.aspx\"\n@property\n@abstractmethod\ndef base_url(self) -&gt; str:\n\"\"\"\n        Base URL for the Provider\n        \"\"\"\npass\n@property\n@abstractmethod\ndef campground_url(self) -&gt; str:\n\"\"\"\n        Campground URL for the Provider\n        \"\"\"\npass\n@property\n@abstractmethod\ndef state_code(self) -&gt; str:\n\"\"\"\n        State Code for the Provider\n        \"\"\"\npass\n@property\ndef offline_cache_dir(self) -&gt; pathlib.Path:\n\"\"\"\n        Offline Cache Directory\n        \"\"\"\nif self.__offline_cache_dir__ is None:\nreturn FileConfig.USEDIRECT_PROVIDER / self.__class__.__name__\nelse:\nreturn self.__offline_cache_dir__\ndef refresh_metadata(self) -&gt; None:\n\"\"\"\n        Refresh All the Campground Metadata\n        This is the way that this provider caches all of its metadata\n        offline. It makes a number of GET requests and saves the entire output\n        as JSON alongside the provider code itself (&lt;subdomain&gt;.usedirect.com):\n        - /rdr/rdr/search/filters\n        - /rdr/rdr/search/citypark\n        - /rdr/rdr/search/places\n        - /rdr/rdr/search/facilities\n        Returns\n        -------\n        None\n        \"\"\"\nif self.metadata_refreshed is False:\nself._get_campground_metadata()\nself._get_city_parks()\nself._get_places()\nself._get_facilities()\nself.metadata_refreshed = True\ndef search_for_recreation_areas(\nself,\nquery: Optional[str] = None,\nstate: Optional[str] = None,\n) -&gt; List[RecreationArea]:\n\"\"\"\n        Retrieve Recreation Areas\n        Parameters\n        ----------\n        state: str\n        query: str\n        Returns\n        -------\n        List[RecreationArea]\n        \"\"\"\nif state is not None and state.upper() != self.state_code.upper():\nraise CamplyError(\nf\"{self.__class__.__name__} doesn't support states outside {self.state_code}\"\n)\nif query is None:\nlogger.error(\n\"You must provide a search string to search `UseDirect` Recreation Areas\"\n)\nsys.exit(1)\nlogger.info(f'Searching for Recreation Areas: \"{query}\"')\nself.refresh_metadata()\nfound_recareas = [\nrec_area\nfor rec_area in self.usedirect_rec_areas.values()\nif self._search_camply_model(query=query, model=rec_area) is True\n]\nreturn found_recareas\ndef find_campgrounds(\nself,\nsearch_string: Optional[str] = None,\nrec_area_id: Optional[List[int]] = None,\nstate: Optional[str] = None,\nverbose: bool = True,\ncampground_id: Optional[List[int]] = None,\n**kwargs: Any,\n) -&gt; List[CampgroundFacility]:\n\"\"\"\n        Search A Facility via Offline Metadata\n        Parameters\n        ----------\n        rec_area_id: Optional[int]\n        state: Optional[str]\n        search_string: Optional[str]\n        campground_id: Optional[List[int]]\n        Returns\n        -------\n        List[CampgroundFacility]\n        \"\"\"\nself.active_search = True\nif state is not None and state.upper() != self.state_code:\nraise CamplyError(\nf\"{self.__class__.__name__} doesn't support states outside {self.state_code}\"\n)\nif campground_id is None:\ncampground_id = []\nif rec_area_id is None:\nrec_area_id = []\nif all([rec_area_id == [], search_string is None, campground_id == []]):\nlogger.error(\n\"You must provide a search string, campground ID, or recreation area ID \"\n\"to search on UseDirect\"\n)\nsys.exit(1)\nif search_string is not None:\nlogger.info(f'Searching for Campgrounds: \"{search_string}\"')\nself.refresh_metadata()\nfound_campgrounds = self._search_for_campgrounds(\ncampground_id=campground_id,\nrec_area_id=rec_area_id,\nsearch_string=search_string,\n)\nif verbose is True:\nlogger.info(f\"{len(found_campgrounds)} Matching Campgrounds Found\")\nlog_sorted_response(found_campgrounds)\nself.active_search = False\nreturn found_campgrounds\ndef _search_for_campgrounds(\nself,\ncampground_id: List[int],\nrec_area_id: List[int],\nsearch_string: Optional[str],\n) -&gt; List[CampgroundFacility]:\n\"\"\"\n        Filter a campground array\n        Parameters\n        ----------\n        campground_id: List[int]\n        rec_area_id: List[int]\n        search_string: Optional[str]\n        Returns\n        -------\n        List[CampgroundFacility]\n        \"\"\"\nfound_campgrounds: List[CampgroundFacility] = []\nif len(campground_id) &gt;= 1:\nfor camp_id in campground_id:\nfound_campgrounds += [\ncampground\nfor campground in self.usedirect_campgrounds.values()\nif campground.facility_id == int(camp_id)\n]\nelif len(rec_area_id) &gt;= 1:\nfor rec_area in rec_area_id:\nfound_campgrounds += [\ncampground\nfor campground in self.usedirect_campgrounds.values()\nif campground.recreation_area_id == int(rec_area)\n]\nelse:\nassert isinstance(search_string, str)\nfound_campgrounds = [\ncampground\nfor campground in self.usedirect_campgrounds.values()\nif self._search_camply_model(query=search_string, model=campground)\nis True\n]\nreturn found_campgrounds\n@ratelimit.sleep_and_retry\n@ratelimit.limits(calls=1, period=1)\ndef get_campsites_response(\nself,\ncampground_id: int,\nstart_date: Union[datetime, date],\nend_date: Union[datetime, date],\nis_ada: Optional[bool] = None,\nmin_vehicle_length: Optional[int] = None,\nunit_category_id: Optional[int] = None,\nweb_only: Optional[bool] = True,\nunit_type_group_ids: Optional[List[int]] = None,\nsleeping_unit_id: Optional[int] = None,\nunit_sort: Optional[str] = \"orderby\",\nin_season_only: Optional[bool] = True,\n) -&gt; UseDirectAvailabilityResponse:\n\"\"\"\n        Get Campsites from UseDirect\n        Parameters\n        ----------\n        campground_id: int\n            Facility ID of the campground\n        start_date: Union[datetime, date]\n            Search Start Date\n        end_date: Union[datetime, date]\n            Search End Date\n        is_ada: Optional[bool]\n            Search for ADA sites\n        min_vehicle_length: Optional[int]\n            Minimum Vehicle Length - defaults to 0 which doesn't filter\n        unit_category_id: Optional[int]\n            Unit Category ID (typically 0)\n        web_only: Optional[bool]\n            Search for sights bookable online\n        unit_type_group_ids: Optional[List[int]]\n            UnitTypeGroupIds - Search Param\n        sleeping_unit_id: Optional[int]\n            SleepingUnitId - search param\n        unit_sort: Optional[str]\n            Sort Order\n        in_season_only: Optional[bool]\n            Searching for in-season only campgrounds\n        Returns\n        -------\n        UseDirectAvailabilityResponse\n        \"\"\"\ndata = {\n\"IsADA\": is_ada,\n\"MinVehicleLength\": min_vehicle_length,\n\"UnitCategoryId\": unit_category_id,\n\"StartDate\": start_date.strftime(UseDirectConfig.DATE_FORMAT),\n\"WebOnly\": web_only,\n\"UnitTypesGroupIds\": []\nif unit_type_group_ids is None\nelse unit_type_group_ids,\n\"SleepingUnitId\": sleeping_unit_id,\n\"EndDate\": end_date.strftime(UseDirectConfig.DATE_FORMAT),\n\"UnitSort\": unit_sort,\n\"InSeasonOnly\": in_season_only,\n\"FacilityId\": campground_id,\n}\nnon_null_data = {\nkey: value for key, value in data.items() if value not in [None, [], \"\"]\n}\nurl = f\"{self.base_url}/{self.rdr_path}/{UseDirectConfig.AVAILABILITY_ENDPOINT}\"\nresponse = self.session.post(\nurl=url, data=json.dumps(non_null_data), headers=self.json_headers\n)\nresponse.raise_for_status()\nresponse_json = response.json()\ntry:\nreturn UseDirectAvailabilityResponse(**response.json())\nexcept ValidationError as e:\nraise\nerror_message = (\n\"Error Parsing UseDirect Availability Response \"\nf\"- Facility ID # {campground_id}.\"\n)\nif \"Message\" in response_json:\nerror_message += \" \" + response_json[\"Message\"]\nraise UseDirectError(error_message) from e\ndef get_campsites(\nself,\ncampground_id: int,\nstart_date: Union[datetime, date],\nend_date: Union[datetime, date],\nis_ada: Optional[bool] = None,\nmin_vehicle_length: Optional[int] = None,\nunit_category_id: Optional[int] = None,\nweb_only: Optional[bool] = True,\nunit_type_group_ids: Optional[List[int]] = None,\nsleeping_unit_id: Optional[int] = None,\nunit_sort: Optional[str] = \"orderby\",\nin_season_only: Optional[bool] = True,\n) -&gt; List[AvailableCampsite]:\n\"\"\"\n        Get Campsites from UseDirect\n        Parameters\n        ----------\n        campground_id: int\n            Facility ID of the campground\n        start_date: Union[datetime, date]\n            Search Start Date\n        end_date: Union[datetime, date]\n            Search End Date\n        is_ada: Optional[bool]\n            Search for ADA sites\n        min_vehicle_length: Optional[int]\n            Minimum Vehicle Length - defaults to 0 which doesn't filter\n        unit_category_id: Optional[int]\n            Unit Category ID (typically 0)\n        web_only: Optional[bool]\n            Search for sights bookable online\n        unit_type_group_ids: Optional[List[int]]\n            UnitTypeGroupIds - Search Param\n        sleeping_unit_id: Optional[int]\n            SleepingUnitId - search param\n        unit_sort: Optional[str]\n            Sort Order\n        in_season_only: Optional[bool]\n            Searching for in-season only campgrounds\n        Returns\n        -------\n        List[AvailableCampsite]\n        \"\"\"\nself.refresh_metadata()\navailability_response = self.get_campsites_response(\ncampground_id=campground_id,\nstart_date=start_date,\nend_date=end_date,\nis_ada=is_ada,\nmin_vehicle_length=min_vehicle_length,\nunit_category_id=unit_category_id,\nweb_only=web_only,\nunit_type_group_ids=unit_type_group_ids,\nsleeping_unit_id=sleeping_unit_id,\nunit_sort=unit_sort,\nin_season_only=in_season_only,\n)\ncampsites: List[AvailableCampsite] = []\nif availability_response.Facility.Units is None:\nreturn campsites\nfor _campground_unit_id, unit in availability_response.Facility.Units.items():\nfor _slice_date, availability_slice in unit.Slices.items():\ncampsite = self._get_available_campsite(\navailability_slice=availability_slice,\navailability_response=availability_response,\nunit=unit,\n)\ncampsite_available = campsite.availability_status == \"Available\"\nif campsite_available is True:\nif (\nlen(self.campsite_ids) == 0\nor campsite.campsite_id in self.campsite_ids\n):\ncampsites.append(campsite)\nreturn campsites\ndef _get_available_campsite(\nself,\navailability_slice: UseDirectAvailabilitySlice,\navailability_response: UseDirectAvailabilityResponse,\nunit: UseDirectAvailabilityUnit,\n) -&gt; AvailableCampsite:\n\"\"\"\n        Create an AvailableCampsite Object from the Availability Grid Response\n        Parameters\n        ----------\n        availability_slice: UseDirectAvailabilitySlice\n        availability_response: UseDirectAvailabilityResponse\n        unit: UseDirectAvailabilityUnit\n        Returns\n        -------\n        AvailableCampsite\n        \"\"\"\nstart_date = datetime.fromordinal(availability_slice.Date.toordinal())\nfacility_id = availability_response.Facility.FacilityId\nfacility = self.usedirect_campgrounds[facility_id]\nrecreation_area = self.usedirect_rec_areas[facility.recreation_area_id]\nbooking_url = f\"{self.campground_url}/{self.booking_path}\"\nif self.booking_path_params is True:\nbooking_url = f\"{booking_url}#!park/{recreation_area.recreation_area_id}/{facility_id}\"\nif unit.UnitCategoryId is None:\nunit.UnitCategoryId = -1\nif unit.UnitTypeGroupId is None:\nunit.UnitTypeGroupId = -1\ncampsite_type = self.usedirect_unit_categories.get(unit.UnitCategoryId, None)\ncampsite_use_type = self.usedirect_unit_type_groups.get(\nunit.UnitTypeGroupId, None\n)\ncampsite = AvailableCampsite(\ncampsite_id=unit.UnitId,\nbooking_date=start_date,\nbooking_end_date=start_date + timedelta(days=1),\nbooking_nights=1,\ncampsite_site_name=unit.Name,\navailability_status=(\n\"Available\" if availability_slice.IsFree is True else \"Unavailable\"\n),\nrecreation_area=recreation_area.recreation_area,\nrecreation_area_id=facility.recreation_area_id,\nfacility_name=facility.facility_name,\nfacility_id=facility.facility_id,\nbooking_url=booking_url,\ncampsite_occupancy=(0, 1),\ncampsite_type=campsite_type,\ncampsite_use_type=campsite_use_type,\n)\nreturn campsite\ndef _fetch_metadata_from_disk(\nself, file_path: pathlib.Path\n) -&gt; Optional[Union[Dict[Any, Any], List[Dict[Any, Any]]]]:\n\"\"\"\n        Cache Metadata Locally and Invalidate after a day\n        Parameters\n        ----------\n        file_path: pathlib.Path\n        Returns\n        -------\n        Optional[Dict[Any, Any]]\n        \"\"\"\nif file_path.exists() is False:\ndata = None\nelse:\nmodified_time = datetime.utcfromtimestamp(file_path.stat().st_mtime)\ncurrent_time = datetime.utcnow()\nif (\ncurrent_time - modified_time &gt; timedelta(days=1)\nand self.active_search is False\n):\ndata = None\nelse:\njson_body: Dict[Any, Any] = json.loads(\nfile_path.read_text(encoding=\"utf-8\")\n)\ndata = json_body\nif data is None:\nlogger.debug(\"Refreshing UseDirect Metadata: %s\", file_path.name)\nreturn data\ndef _get_campground_metadata(self) -&gt; UseDirectMetadata:\n\"\"\"\n        Return Metadata for Campgrounds\n        Returns\n        -------\n        UseDirectMetadata\n        \"\"\"\nmetadata_file = self.offline_cache_dir.joinpath(\"filters.json\")\ncampground_metadata = self._fetch_metadata_from_disk(file_path=metadata_file)\nif campground_metadata is None:\nself.offline_cache_dir.mkdir(parents=True, exist_ok=True)\nurl = f\"{self.base_url}/{self.rdr_path}/{UseDirectConfig.METADATA_PREFIX}\"\nresp = self.session.get(url=url)\nresp.raise_for_status()\ncampground_metadata = resp.json()\nmetadata_file.write_text(json.dumps(campground_metadata, indent=2))\ndata = UseDirectMetadata(**campground_metadata)\nself.usedirect_unit_categories = {\nitem.UnitCategoryId: item.UnitCategoryName for item in data.UnitCategories\n}\nself.usedirect_unit_type_groups = {\nitem.UnitTypesGroupId: item.UnitTypesGroupName\nfor item in data.UnitTypesGroups\n}\nreturn data\ndef _get_city_parks(self) -&gt; Dict[int, UseDirectCityPark]:\n\"\"\"\n        Fetch Metadata On Every CityPark\n        Returns\n        -------\n        Dict[int, UseDirectCityPark]\n        \"\"\"\nmetadata_file = self.offline_cache_dir.joinpath(\"cityparks.json\")\ncity_park_data = self._fetch_metadata_from_disk(file_path=metadata_file)\nif city_park_data is None:\nurl = f\"{self.base_url}/{self.rdr_path}/{UseDirectConfig.CITYPARK_ENDPOINT}\"\nresp = self.session.get(url=url)\nresp.raise_for_status()\ncity_park_data: Dict[str, Dict[str, Any]] = resp.json()\nmetadata_file.write_text(json.dumps(city_park_data, indent=2))\nself.usedirect_city_parks: Dict[int, UseDirectCityPark] = {\nint(city_park_id): UseDirectCityPark(**city_park_json)\nfor city_park_id, city_park_json in city_park_data.items()\nif city_park_json[\"Name\"] is not None\n}\nreturn self.usedirect_city_parks\ndef _get_places(self) -&gt; Dict[int, UseDirectDetailedPlace]:\n\"\"\"\n        Fetch Metadata On Every Place\n        Returns\n        -------\n        Dict[int, UseDirectDetailedPlace]\n        \"\"\"\nmetadata_file = self.offline_cache_dir.joinpath(\"places.json\")\nplaces_data = self._fetch_metadata_from_disk(file_path=metadata_file)\nif places_data is None:\nurl = f\"{self.base_url}/{self.rdr_path}/{UseDirectConfig.LIST_PLACES_ENDPOINT}\"\nresp = self.session.get(url=url)\nresp.raise_for_status()\nplaces_data: List[Dict[str, Any]] = resp.json()\nmetadata_file.write_text(json.dumps(places_data, indent=2))\nplaces_validated = [\nUseDirectDetailedPlace(**place_json) for place_json in places_data\n]\nplaces_data_validated: Dict[int, UseDirectDetailedPlace] = {\nitem.PlaceId: item for item in places_validated\n}\nself.usedirect_rec_areas: Dict[int, RecreationArea] = {\nplace.PlaceId: RecreationArea(\nrecreation_area=place.Name,\nrecreation_area_id=place.PlaceId,\nrecreation_area_location=f\"{place.City.title()}, {place.State}\",\ndescription=place.Description,\n)\nfor place in places_data_validated.values()\n}\nreturn places_data_validated\ndef _get_facilities(self) -&gt; Dict[int, UseDirectFacilityMetadata]:\n\"\"\"\n        Fetch Metadata On Every Facility\n        Returns\n        -------\n        Dict[int, UseDirectFacilityMetadata]\n        \"\"\"\nmetadata_file = self.offline_cache_dir.joinpath(\"facilities.json\")\nfacilities_data = self._fetch_metadata_from_disk(file_path=metadata_file)\nif facilities_data is None:\nurl = f\"{self.base_url}/{self.rdr_path}/{UseDirectConfig.LIST_FACILITIES_ENDPOINT}\"\nresp = self.session.get(url=url)\nresp.raise_for_status()\nfacilities_data: List[Dict[str, Any]] = resp.json()\nmetadata_file.write_text(json.dumps(facilities_data, indent=2))\nif not isinstance(facilities_data, list):\nraise CamplyError(\"Unexpected data from %s\", metadata_file)\nfacilities_validated = [\nUseDirectFacilityMetadata(**facility_json)\nfor facility_json in facilities_data\n]\nfacilities_data_validated: Dict[int, UseDirectFacilityMetadata] = {\nitem.FacilityId: item for item in facilities_validated\n}\nself.usedirect_campgrounds: Dict[int, CampgroundFacility] = {}\nfor facility in facilities_data_validated.values():\nrec_area = self.usedirect_rec_areas.get(facility.PlaceId, None)\nif rec_area is not None:\nself.usedirect_campgrounds[facility.FacilityId] = CampgroundFacility(\nfacility_name=facility.Name,\nfacility_id=facility.FacilityId,\nrecreation_area_id=facility.PlaceId,\nrecreation_area=rec_area.recreation_area,\n)\nreturn facilities_data_validated\n@classmethod\ndef _search_camply_model(cls, query: str, model: CamplyModel) -&gt; bool:\n\"\"\"\n        Search a Camply Model\n        Parameters\n        ----------\n        query: str\n        model: CamplyModel\n        Returns\n        -------\n        bool\n        \"\"\"\nreturn any(\nquery.lower() in str(value).lower() for value in model.dict().values()\n)\ndef get_campsites_per_facility(\nself, facility_id: int\n) -&gt; List[UseDirectAvailabilityUnit]:\n\"\"\"\n        Get Campsites Per Facility\n        Parameters\n        ----------\n        facility_id: int\n        Returns\n        -------\n        List[UseDirectAvailabilityUnit]\n        \"\"\"\nresp = self.get_campsites_response(\ncampground_id=facility_id, start_date=date.today(), end_date=date.today()\n)\ncampsites: List[UseDirectAvailabilityUnit] = list(resp.Facility.Units.values())\nfor campsite in campsites:\ncampsite.FacilityId = facility_id\nreturn campsites\ndef get_campsite_metadata(\nself, facility_ids: List[int]\n) -&gt; Dict[int, UseDirectAvailabilityUnit]:\n\"\"\"\n        Get the Campsite Metadata\n        Parameters\n        ----------\n        facility_ids: List[int]\n            List of facility ids to fetch metadata for\n        Returns\n        -------\n        Dict[int, UseDirectAvailabilityUnit]\n        \"\"\"\ncampsites: Dict[int, UseDirectAvailabilityUnit] = {}\nfor facility_id in facility_ids:\nfound_campsites = self.get_campsites_per_facility(facility_id=facility_id)\ncampsite_dict = {item.UnitId: item for item in found_campsites}\ncampsites.update(campsite_dict)\nself.usedirect_campsites.update(campsites)\nreturn campsites\ndef _prepare_facility_ids(\nself,\nrecreation_area_ids: Optional[List[int]] = None,\ncampground_ids: Optional[List[int]] = None,\n) -&gt; List[int]:\n\"\"\"\n        Prepare Facility Ids\n        Parameters\n        ----------\n        recreation_area_ids: Optional[List[int]]\n        campground_ids: Optional[List[int]]\n        Returns\n        -------\n        List[int]\n        \"\"\"\nif not self.usedirect_campgrounds:\nself.refresh_metadata()\nrecreation_area_ids = recreation_area_ids or []\ncampground_ids = campground_ids or []\nfacility_ids = []\nif len(recreation_area_ids) == 0 and len(campground_ids) == 0:\nraise CamplyError(\"Must specify either a recreation area or campground id\")\nelif len(recreation_area_ids) &gt; 0:\nlogger.info(\n\"Searching %s Recreation Areas for campgrounds\",\nlen(recreation_area_ids),\n)\nfor recreation_area_id in recreation_area_ids:\nfacility_ids += [\nfacility_id\nfor facility_id, facility in self.usedirect_campgrounds.items()\nif facility.recreation_area_id == int(recreation_area_id)\n]\nelse:\nfacility_ids = campground_ids\nfacility_ids = [int(x) for x in facility_ids]\nreturn facility_ids\ndef validate_campsites(self, campsites: List[int], facility_ids: List[int]) -&gt; None:\n\"\"\"\n        Validate Campsites\n        Parameters\n        ----------\n        campsites: List[int]\n        Returns\n        -------\n        None\n        \"\"\"\nself.get_campsite_metadata(facility_ids=facility_ids)\nfor campsite_id in campsites:\nif campsite_id not in self.usedirect_campsites:\nraise CamplyError(f\"Campsite {campsite_id} not found\")\nelse:\ncampsite = self.usedirect_campsites[campsite_id]\nlogger.info(\"Searching Specific campsite: %s\", campsite.Name)\nself.campsite_ids = list(campsites)\n</code></pre>"},{"location":"reference/providers/usedirect/#camply.providers.usedirect.usedirect.UseDirectProvider.base_url","title":"<code>base_url: str</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Base URL for the Provider</p>"},{"location":"reference/providers/usedirect/#camply.providers.usedirect.usedirect.UseDirectProvider.campground_url","title":"<code>campground_url: str</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Campground URL for the Provider</p>"},{"location":"reference/providers/usedirect/#camply.providers.usedirect.usedirect.UseDirectProvider.offline_cache_dir","title":"<code>offline_cache_dir: pathlib.Path</code>  <code>property</code>","text":"<p>Offline Cache Directory</p>"},{"location":"reference/providers/usedirect/#camply.providers.usedirect.usedirect.UseDirectProvider.state_code","title":"<code>state_code: str</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>State Code for the Provider</p>"},{"location":"reference/providers/usedirect/#camply.providers.usedirect.usedirect.UseDirectProvider.find_campgrounds","title":"<code>find_campgrounds(search_string=None, rec_area_id=None, state=None, verbose=True, campground_id=None, **kwargs)</code>","text":"<p>Search A Facility via Offline Metadata</p> <p>Parameters:</p> Name Type Description Default <code>rec_area_id</code> <code>Optional[List[int]]</code> <code>None</code> <code>state</code> <code>Optional[str]</code> <code>None</code> <code>search_string</code> <code>Optional[str]</code> <code>None</code> <code>campground_id</code> <code>Optional[List[int]]</code> <code>None</code> <p>Returns:</p> Type Description <code>List[CampgroundFacility]</code> Source code in <code>camply/providers/usedirect/usedirect.py</code> <pre><code>def find_campgrounds(\nself,\nsearch_string: Optional[str] = None,\nrec_area_id: Optional[List[int]] = None,\nstate: Optional[str] = None,\nverbose: bool = True,\ncampground_id: Optional[List[int]] = None,\n**kwargs: Any,\n) -&gt; List[CampgroundFacility]:\n\"\"\"\n    Search A Facility via Offline Metadata\n    Parameters\n    ----------\n    rec_area_id: Optional[int]\n    state: Optional[str]\n    search_string: Optional[str]\n    campground_id: Optional[List[int]]\n    Returns\n    -------\n    List[CampgroundFacility]\n    \"\"\"\nself.active_search = True\nif state is not None and state.upper() != self.state_code:\nraise CamplyError(\nf\"{self.__class__.__name__} doesn't support states outside {self.state_code}\"\n)\nif campground_id is None:\ncampground_id = []\nif rec_area_id is None:\nrec_area_id = []\nif all([rec_area_id == [], search_string is None, campground_id == []]):\nlogger.error(\n\"You must provide a search string, campground ID, or recreation area ID \"\n\"to search on UseDirect\"\n)\nsys.exit(1)\nif search_string is not None:\nlogger.info(f'Searching for Campgrounds: \"{search_string}\"')\nself.refresh_metadata()\nfound_campgrounds = self._search_for_campgrounds(\ncampground_id=campground_id,\nrec_area_id=rec_area_id,\nsearch_string=search_string,\n)\nif verbose is True:\nlogger.info(f\"{len(found_campgrounds)} Matching Campgrounds Found\")\nlog_sorted_response(found_campgrounds)\nself.active_search = False\nreturn found_campgrounds\n</code></pre>"},{"location":"reference/providers/usedirect/#camply.providers.usedirect.usedirect.UseDirectProvider.get_campsite_metadata","title":"<code>get_campsite_metadata(facility_ids)</code>","text":"<p>Get the Campsite Metadata</p> <p>Parameters:</p> Name Type Description Default <code>facility_ids</code> <code>List[int]</code> <p>List of facility ids to fetch metadata for</p> required <p>Returns:</p> Type Description <code>Dict[int, UseDirectAvailabilityUnit]</code> Source code in <code>camply/providers/usedirect/usedirect.py</code> <pre><code>def get_campsite_metadata(\nself, facility_ids: List[int]\n) -&gt; Dict[int, UseDirectAvailabilityUnit]:\n\"\"\"\n    Get the Campsite Metadata\n    Parameters\n    ----------\n    facility_ids: List[int]\n        List of facility ids to fetch metadata for\n    Returns\n    -------\n    Dict[int, UseDirectAvailabilityUnit]\n    \"\"\"\ncampsites: Dict[int, UseDirectAvailabilityUnit] = {}\nfor facility_id in facility_ids:\nfound_campsites = self.get_campsites_per_facility(facility_id=facility_id)\ncampsite_dict = {item.UnitId: item for item in found_campsites}\ncampsites.update(campsite_dict)\nself.usedirect_campsites.update(campsites)\nreturn campsites\n</code></pre>"},{"location":"reference/providers/usedirect/#camply.providers.usedirect.usedirect.UseDirectProvider.get_campsites","title":"<code>get_campsites(campground_id, start_date, end_date, is_ada=None, min_vehicle_length=None, unit_category_id=None, web_only=True, unit_type_group_ids=None, sleeping_unit_id=None, unit_sort='orderby', in_season_only=True)</code>","text":"<p>Get Campsites from UseDirect</p> <p>Parameters:</p> Name Type Description Default <code>campground_id</code> <code>int</code> <p>Facility ID of the campground</p> required <code>start_date</code> <code>Union[datetime, date]</code> <p>Search Start Date</p> required <code>end_date</code> <code>Union[datetime, date]</code> <p>Search End Date</p> required <code>is_ada</code> <code>Optional[bool]</code> <p>Search for ADA sites</p> <code>None</code> <code>min_vehicle_length</code> <code>Optional[int]</code> <p>Minimum Vehicle Length - defaults to 0 which doesn't filter</p> <code>None</code> <code>unit_category_id</code> <code>Optional[int]</code> <p>Unit Category ID (typically 0)</p> <code>None</code> <code>web_only</code> <code>Optional[bool]</code> <p>Search for sights bookable online</p> <code>True</code> <code>unit_type_group_ids</code> <code>Optional[List[int]]</code> <p>UnitTypeGroupIds - Search Param</p> <code>None</code> <code>sleeping_unit_id</code> <code>Optional[int]</code> <p>SleepingUnitId - search param</p> <code>None</code> <code>unit_sort</code> <code>Optional[str]</code> <p>Sort Order</p> <code>'orderby'</code> <code>in_season_only</code> <code>Optional[bool]</code> <p>Searching for in-season only campgrounds</p> <code>True</code> <p>Returns:</p> Type Description <code>List[AvailableCampsite]</code> Source code in <code>camply/providers/usedirect/usedirect.py</code> <pre><code>def get_campsites(\nself,\ncampground_id: int,\nstart_date: Union[datetime, date],\nend_date: Union[datetime, date],\nis_ada: Optional[bool] = None,\nmin_vehicle_length: Optional[int] = None,\nunit_category_id: Optional[int] = None,\nweb_only: Optional[bool] = True,\nunit_type_group_ids: Optional[List[int]] = None,\nsleeping_unit_id: Optional[int] = None,\nunit_sort: Optional[str] = \"orderby\",\nin_season_only: Optional[bool] = True,\n) -&gt; List[AvailableCampsite]:\n\"\"\"\n    Get Campsites from UseDirect\n    Parameters\n    ----------\n    campground_id: int\n        Facility ID of the campground\n    start_date: Union[datetime, date]\n        Search Start Date\n    end_date: Union[datetime, date]\n        Search End Date\n    is_ada: Optional[bool]\n        Search for ADA sites\n    min_vehicle_length: Optional[int]\n        Minimum Vehicle Length - defaults to 0 which doesn't filter\n    unit_category_id: Optional[int]\n        Unit Category ID (typically 0)\n    web_only: Optional[bool]\n        Search for sights bookable online\n    unit_type_group_ids: Optional[List[int]]\n        UnitTypeGroupIds - Search Param\n    sleeping_unit_id: Optional[int]\n        SleepingUnitId - search param\n    unit_sort: Optional[str]\n        Sort Order\n    in_season_only: Optional[bool]\n        Searching for in-season only campgrounds\n    Returns\n    -------\n    List[AvailableCampsite]\n    \"\"\"\nself.refresh_metadata()\navailability_response = self.get_campsites_response(\ncampground_id=campground_id,\nstart_date=start_date,\nend_date=end_date,\nis_ada=is_ada,\nmin_vehicle_length=min_vehicle_length,\nunit_category_id=unit_category_id,\nweb_only=web_only,\nunit_type_group_ids=unit_type_group_ids,\nsleeping_unit_id=sleeping_unit_id,\nunit_sort=unit_sort,\nin_season_only=in_season_only,\n)\ncampsites: List[AvailableCampsite] = []\nif availability_response.Facility.Units is None:\nreturn campsites\nfor _campground_unit_id, unit in availability_response.Facility.Units.items():\nfor _slice_date, availability_slice in unit.Slices.items():\ncampsite = self._get_available_campsite(\navailability_slice=availability_slice,\navailability_response=availability_response,\nunit=unit,\n)\ncampsite_available = campsite.availability_status == \"Available\"\nif campsite_available is True:\nif (\nlen(self.campsite_ids) == 0\nor campsite.campsite_id in self.campsite_ids\n):\ncampsites.append(campsite)\nreturn campsites\n</code></pre>"},{"location":"reference/providers/usedirect/#camply.providers.usedirect.usedirect.UseDirectProvider.get_campsites_per_facility","title":"<code>get_campsites_per_facility(facility_id)</code>","text":"<p>Get Campsites Per Facility</p> <p>Parameters:</p> Name Type Description Default <code>facility_id</code> <code>int</code> required <p>Returns:</p> Type Description <code>List[UseDirectAvailabilityUnit]</code> Source code in <code>camply/providers/usedirect/usedirect.py</code> <pre><code>def get_campsites_per_facility(\nself, facility_id: int\n) -&gt; List[UseDirectAvailabilityUnit]:\n\"\"\"\n    Get Campsites Per Facility\n    Parameters\n    ----------\n    facility_id: int\n    Returns\n    -------\n    List[UseDirectAvailabilityUnit]\n    \"\"\"\nresp = self.get_campsites_response(\ncampground_id=facility_id, start_date=date.today(), end_date=date.today()\n)\ncampsites: List[UseDirectAvailabilityUnit] = list(resp.Facility.Units.values())\nfor campsite in campsites:\ncampsite.FacilityId = facility_id\nreturn campsites\n</code></pre>"},{"location":"reference/providers/usedirect/#camply.providers.usedirect.usedirect.UseDirectProvider.get_campsites_response","title":"<code>get_campsites_response(campground_id, start_date, end_date, is_ada=None, min_vehicle_length=None, unit_category_id=None, web_only=True, unit_type_group_ids=None, sleeping_unit_id=None, unit_sort='orderby', in_season_only=True)</code>","text":"<p>Get Campsites from UseDirect</p> <p>Parameters:</p> Name Type Description Default <code>campground_id</code> <code>int</code> <p>Facility ID of the campground</p> required <code>start_date</code> <code>Union[datetime, date]</code> <p>Search Start Date</p> required <code>end_date</code> <code>Union[datetime, date]</code> <p>Search End Date</p> required <code>is_ada</code> <code>Optional[bool]</code> <p>Search for ADA sites</p> <code>None</code> <code>min_vehicle_length</code> <code>Optional[int]</code> <p>Minimum Vehicle Length - defaults to 0 which doesn't filter</p> <code>None</code> <code>unit_category_id</code> <code>Optional[int]</code> <p>Unit Category ID (typically 0)</p> <code>None</code> <code>web_only</code> <code>Optional[bool]</code> <p>Search for sights bookable online</p> <code>True</code> <code>unit_type_group_ids</code> <code>Optional[List[int]]</code> <p>UnitTypeGroupIds - Search Param</p> <code>None</code> <code>sleeping_unit_id</code> <code>Optional[int]</code> <p>SleepingUnitId - search param</p> <code>None</code> <code>unit_sort</code> <code>Optional[str]</code> <p>Sort Order</p> <code>'orderby'</code> <code>in_season_only</code> <code>Optional[bool]</code> <p>Searching for in-season only campgrounds</p> <code>True</code> <p>Returns:</p> Type Description <code>UseDirectAvailabilityResponse</code> Source code in <code>camply/providers/usedirect/usedirect.py</code> <pre><code>@ratelimit.sleep_and_retry\n@ratelimit.limits(calls=1, period=1)\ndef get_campsites_response(\nself,\ncampground_id: int,\nstart_date: Union[datetime, date],\nend_date: Union[datetime, date],\nis_ada: Optional[bool] = None,\nmin_vehicle_length: Optional[int] = None,\nunit_category_id: Optional[int] = None,\nweb_only: Optional[bool] = True,\nunit_type_group_ids: Optional[List[int]] = None,\nsleeping_unit_id: Optional[int] = None,\nunit_sort: Optional[str] = \"orderby\",\nin_season_only: Optional[bool] = True,\n) -&gt; UseDirectAvailabilityResponse:\n\"\"\"\n    Get Campsites from UseDirect\n    Parameters\n    ----------\n    campground_id: int\n        Facility ID of the campground\n    start_date: Union[datetime, date]\n        Search Start Date\n    end_date: Union[datetime, date]\n        Search End Date\n    is_ada: Optional[bool]\n        Search for ADA sites\n    min_vehicle_length: Optional[int]\n        Minimum Vehicle Length - defaults to 0 which doesn't filter\n    unit_category_id: Optional[int]\n        Unit Category ID (typically 0)\n    web_only: Optional[bool]\n        Search for sights bookable online\n    unit_type_group_ids: Optional[List[int]]\n        UnitTypeGroupIds - Search Param\n    sleeping_unit_id: Optional[int]\n        SleepingUnitId - search param\n    unit_sort: Optional[str]\n        Sort Order\n    in_season_only: Optional[bool]\n        Searching for in-season only campgrounds\n    Returns\n    -------\n    UseDirectAvailabilityResponse\n    \"\"\"\ndata = {\n\"IsADA\": is_ada,\n\"MinVehicleLength\": min_vehicle_length,\n\"UnitCategoryId\": unit_category_id,\n\"StartDate\": start_date.strftime(UseDirectConfig.DATE_FORMAT),\n\"WebOnly\": web_only,\n\"UnitTypesGroupIds\": []\nif unit_type_group_ids is None\nelse unit_type_group_ids,\n\"SleepingUnitId\": sleeping_unit_id,\n\"EndDate\": end_date.strftime(UseDirectConfig.DATE_FORMAT),\n\"UnitSort\": unit_sort,\n\"InSeasonOnly\": in_season_only,\n\"FacilityId\": campground_id,\n}\nnon_null_data = {\nkey: value for key, value in data.items() if value not in [None, [], \"\"]\n}\nurl = f\"{self.base_url}/{self.rdr_path}/{UseDirectConfig.AVAILABILITY_ENDPOINT}\"\nresponse = self.session.post(\nurl=url, data=json.dumps(non_null_data), headers=self.json_headers\n)\nresponse.raise_for_status()\nresponse_json = response.json()\ntry:\nreturn UseDirectAvailabilityResponse(**response.json())\nexcept ValidationError as e:\nraise\nerror_message = (\n\"Error Parsing UseDirect Availability Response \"\nf\"- Facility ID # {campground_id}.\"\n)\nif \"Message\" in response_json:\nerror_message += \" \" + response_json[\"Message\"]\nraise UseDirectError(error_message) from e\n</code></pre>"},{"location":"reference/providers/usedirect/#camply.providers.usedirect.usedirect.UseDirectProvider.refresh_metadata","title":"<code>refresh_metadata()</code>","text":"<p>Refresh All the Campground Metadata</p> <p>This is the way that this provider caches all of its metadata offline. It makes a number of GET requests and saves the entire output as JSON alongside the provider code itself (.usedirect.com): <ul> <li>/rdr/rdr/search/filters</li> <li>/rdr/rdr/search/citypark</li> <li>/rdr/rdr/search/places</li> <li>/rdr/rdr/search/facilities</li> </ul> <p>Returns:</p> Type Description <code>None</code> Source code in <code>camply/providers/usedirect/usedirect.py</code> <pre><code>def refresh_metadata(self) -&gt; None:\n\"\"\"\n    Refresh All the Campground Metadata\n    This is the way that this provider caches all of its metadata\n    offline. It makes a number of GET requests and saves the entire output\n    as JSON alongside the provider code itself (&lt;subdomain&gt;.usedirect.com):\n    - /rdr/rdr/search/filters\n    - /rdr/rdr/search/citypark\n    - /rdr/rdr/search/places\n    - /rdr/rdr/search/facilities\n    Returns\n    -------\n    None\n    \"\"\"\nif self.metadata_refreshed is False:\nself._get_campground_metadata()\nself._get_city_parks()\nself._get_places()\nself._get_facilities()\nself.metadata_refreshed = True\n</code></pre>"},{"location":"reference/providers/usedirect/#camply.providers.usedirect.usedirect.UseDirectProvider.search_for_recreation_areas","title":"<code>search_for_recreation_areas(query=None, state=None)</code>","text":"<p>Retrieve Recreation Areas</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>Optional[str]</code> <code>None</code> <code>query</code> <code>Optional[str]</code> <code>None</code> <p>Returns:</p> Type Description <code>List[RecreationArea]</code> Source code in <code>camply/providers/usedirect/usedirect.py</code> <pre><code>def search_for_recreation_areas(\nself,\nquery: Optional[str] = None,\nstate: Optional[str] = None,\n) -&gt; List[RecreationArea]:\n\"\"\"\n    Retrieve Recreation Areas\n    Parameters\n    ----------\n    state: str\n    query: str\n    Returns\n    -------\n    List[RecreationArea]\n    \"\"\"\nif state is not None and state.upper() != self.state_code.upper():\nraise CamplyError(\nf\"{self.__class__.__name__} doesn't support states outside {self.state_code}\"\n)\nif query is None:\nlogger.error(\n\"You must provide a search string to search `UseDirect` Recreation Areas\"\n)\nsys.exit(1)\nlogger.info(f'Searching for Recreation Areas: \"{query}\"')\nself.refresh_metadata()\nfound_recareas = [\nrec_area\nfor rec_area in self.usedirect_rec_areas.values()\nif self._search_camply_model(query=query, model=rec_area) is True\n]\nreturn found_recareas\n</code></pre>"},{"location":"reference/providers/usedirect/#camply.providers.usedirect.usedirect.UseDirectProvider.validate_campsites","title":"<code>validate_campsites(campsites, facility_ids)</code>","text":"<p>Validate Campsites</p> <p>Parameters:</p> Name Type Description Default <code>campsites</code> <code>List[int]</code> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>camply/providers/usedirect/usedirect.py</code> <pre><code>def validate_campsites(self, campsites: List[int], facility_ids: List[int]) -&gt; None:\n\"\"\"\n    Validate Campsites\n    Parameters\n    ----------\n    campsites: List[int]\n    Returns\n    -------\n    None\n    \"\"\"\nself.get_campsite_metadata(facility_ids=facility_ids)\nfor campsite_id in campsites:\nif campsite_id not in self.usedirect_campsites:\nraise CamplyError(f\"Campsite {campsite_id} not found\")\nelse:\ncampsite = self.usedirect_campsites[campsite_id]\nlogger.info(\"Searching Specific campsite: %s\", campsite.Name)\nself.campsite_ids = list(campsites)\n</code></pre>"},{"location":"reference/providers/usedirect/usedirect/","title":"usedirect","text":"<p>UseDirect Provider</p>"},{"location":"reference/providers/usedirect/usedirect/#camply.providers.usedirect.usedirect.UseDirectError","title":"<code>UseDirectError</code>","text":"<p>         Bases: <code>CamplyError</code></p> <p>UseDirect Provider Error</p> Source code in <code>camply/providers/usedirect/usedirect.py</code> <pre><code>class UseDirectError(CamplyError):\n\"\"\"\n    UseDirect Provider Error\n    \"\"\"\n</code></pre>"},{"location":"reference/providers/usedirect/usedirect/#camply.providers.usedirect.usedirect.UseDirectProvider","title":"<code>UseDirectProvider</code>","text":"<p>         Bases: <code>BaseProvider</code>, <code>ABC</code></p> <p>Camply Provider for UseDirect RDR Campgrounds</p> Source code in <code>camply/providers/usedirect/usedirect.py</code> <pre><code>class UseDirectProvider(BaseProvider, ABC):\n\"\"\"\n    Camply Provider for UseDirect RDR Campgrounds\n    \"\"\"\nusedirect_city_parks: Dict[int, UseDirectCityPark] = {}\nusedirect_rec_areas: Dict[int, RecreationArea] = {}\nusedirect_campgrounds: Dict[int, CampgroundFacility] = {}\nusedirect_unit_categories: Dict[int, str] = {}\nusedirect_unit_type_groups: Dict[int, str] = {}\nusedirect_campsites: Dict[int, UseDirectAvailabilityUnit] = {}\ncampsite_ids: List[int] = []\nmetadata_refreshed: bool = False\nactive_search: bool = False\n__offline_cache_dir__: Optional[pathlib.Path] = None\nrdr_path: str = \"rdr\"\nbooking_path_params: bool = True\nbooking_path: str = \"Web/Default.aspx\"\n@property\n@abstractmethod\ndef base_url(self) -&gt; str:\n\"\"\"\n        Base URL for the Provider\n        \"\"\"\npass\n@property\n@abstractmethod\ndef campground_url(self) -&gt; str:\n\"\"\"\n        Campground URL for the Provider\n        \"\"\"\npass\n@property\n@abstractmethod\ndef state_code(self) -&gt; str:\n\"\"\"\n        State Code for the Provider\n        \"\"\"\npass\n@property\ndef offline_cache_dir(self) -&gt; pathlib.Path:\n\"\"\"\n        Offline Cache Directory\n        \"\"\"\nif self.__offline_cache_dir__ is None:\nreturn FileConfig.USEDIRECT_PROVIDER / self.__class__.__name__\nelse:\nreturn self.__offline_cache_dir__\ndef refresh_metadata(self) -&gt; None:\n\"\"\"\n        Refresh All the Campground Metadata\n        This is the way that this provider caches all of its metadata\n        offline. It makes a number of GET requests and saves the entire output\n        as JSON alongside the provider code itself (&lt;subdomain&gt;.usedirect.com):\n        - /rdr/rdr/search/filters\n        - /rdr/rdr/search/citypark\n        - /rdr/rdr/search/places\n        - /rdr/rdr/search/facilities\n        Returns\n        -------\n        None\n        \"\"\"\nif self.metadata_refreshed is False:\nself._get_campground_metadata()\nself._get_city_parks()\nself._get_places()\nself._get_facilities()\nself.metadata_refreshed = True\ndef search_for_recreation_areas(\nself,\nquery: Optional[str] = None,\nstate: Optional[str] = None,\n) -&gt; List[RecreationArea]:\n\"\"\"\n        Retrieve Recreation Areas\n        Parameters\n        ----------\n        state: str\n        query: str\n        Returns\n        -------\n        List[RecreationArea]\n        \"\"\"\nif state is not None and state.upper() != self.state_code.upper():\nraise CamplyError(\nf\"{self.__class__.__name__} doesn't support states outside {self.state_code}\"\n)\nif query is None:\nlogger.error(\n\"You must provide a search string to search `UseDirect` Recreation Areas\"\n)\nsys.exit(1)\nlogger.info(f'Searching for Recreation Areas: \"{query}\"')\nself.refresh_metadata()\nfound_recareas = [\nrec_area\nfor rec_area in self.usedirect_rec_areas.values()\nif self._search_camply_model(query=query, model=rec_area) is True\n]\nreturn found_recareas\ndef find_campgrounds(\nself,\nsearch_string: Optional[str] = None,\nrec_area_id: Optional[List[int]] = None,\nstate: Optional[str] = None,\nverbose: bool = True,\ncampground_id: Optional[List[int]] = None,\n**kwargs: Any,\n) -&gt; List[CampgroundFacility]:\n\"\"\"\n        Search A Facility via Offline Metadata\n        Parameters\n        ----------\n        rec_area_id: Optional[int]\n        state: Optional[str]\n        search_string: Optional[str]\n        campground_id: Optional[List[int]]\n        Returns\n        -------\n        List[CampgroundFacility]\n        \"\"\"\nself.active_search = True\nif state is not None and state.upper() != self.state_code:\nraise CamplyError(\nf\"{self.__class__.__name__} doesn't support states outside {self.state_code}\"\n)\nif campground_id is None:\ncampground_id = []\nif rec_area_id is None:\nrec_area_id = []\nif all([rec_area_id == [], search_string is None, campground_id == []]):\nlogger.error(\n\"You must provide a search string, campground ID, or recreation area ID \"\n\"to search on UseDirect\"\n)\nsys.exit(1)\nif search_string is not None:\nlogger.info(f'Searching for Campgrounds: \"{search_string}\"')\nself.refresh_metadata()\nfound_campgrounds = self._search_for_campgrounds(\ncampground_id=campground_id,\nrec_area_id=rec_area_id,\nsearch_string=search_string,\n)\nif verbose is True:\nlogger.info(f\"{len(found_campgrounds)} Matching Campgrounds Found\")\nlog_sorted_response(found_campgrounds)\nself.active_search = False\nreturn found_campgrounds\ndef _search_for_campgrounds(\nself,\ncampground_id: List[int],\nrec_area_id: List[int],\nsearch_string: Optional[str],\n) -&gt; List[CampgroundFacility]:\n\"\"\"\n        Filter a campground array\n        Parameters\n        ----------\n        campground_id: List[int]\n        rec_area_id: List[int]\n        search_string: Optional[str]\n        Returns\n        -------\n        List[CampgroundFacility]\n        \"\"\"\nfound_campgrounds: List[CampgroundFacility] = []\nif len(campground_id) &gt;= 1:\nfor camp_id in campground_id:\nfound_campgrounds += [\ncampground\nfor campground in self.usedirect_campgrounds.values()\nif campground.facility_id == int(camp_id)\n]\nelif len(rec_area_id) &gt;= 1:\nfor rec_area in rec_area_id:\nfound_campgrounds += [\ncampground\nfor campground in self.usedirect_campgrounds.values()\nif campground.recreation_area_id == int(rec_area)\n]\nelse:\nassert isinstance(search_string, str)\nfound_campgrounds = [\ncampground\nfor campground in self.usedirect_campgrounds.values()\nif self._search_camply_model(query=search_string, model=campground)\nis True\n]\nreturn found_campgrounds\n@ratelimit.sleep_and_retry\n@ratelimit.limits(calls=1, period=1)\ndef get_campsites_response(\nself,\ncampground_id: int,\nstart_date: Union[datetime, date],\nend_date: Union[datetime, date],\nis_ada: Optional[bool] = None,\nmin_vehicle_length: Optional[int] = None,\nunit_category_id: Optional[int] = None,\nweb_only: Optional[bool] = True,\nunit_type_group_ids: Optional[List[int]] = None,\nsleeping_unit_id: Optional[int] = None,\nunit_sort: Optional[str] = \"orderby\",\nin_season_only: Optional[bool] = True,\n) -&gt; UseDirectAvailabilityResponse:\n\"\"\"\n        Get Campsites from UseDirect\n        Parameters\n        ----------\n        campground_id: int\n            Facility ID of the campground\n        start_date: Union[datetime, date]\n            Search Start Date\n        end_date: Union[datetime, date]\n            Search End Date\n        is_ada: Optional[bool]\n            Search for ADA sites\n        min_vehicle_length: Optional[int]\n            Minimum Vehicle Length - defaults to 0 which doesn't filter\n        unit_category_id: Optional[int]\n            Unit Category ID (typically 0)\n        web_only: Optional[bool]\n            Search for sights bookable online\n        unit_type_group_ids: Optional[List[int]]\n            UnitTypeGroupIds - Search Param\n        sleeping_unit_id: Optional[int]\n            SleepingUnitId - search param\n        unit_sort: Optional[str]\n            Sort Order\n        in_season_only: Optional[bool]\n            Searching for in-season only campgrounds\n        Returns\n        -------\n        UseDirectAvailabilityResponse\n        \"\"\"\ndata = {\n\"IsADA\": is_ada,\n\"MinVehicleLength\": min_vehicle_length,\n\"UnitCategoryId\": unit_category_id,\n\"StartDate\": start_date.strftime(UseDirectConfig.DATE_FORMAT),\n\"WebOnly\": web_only,\n\"UnitTypesGroupIds\": []\nif unit_type_group_ids is None\nelse unit_type_group_ids,\n\"SleepingUnitId\": sleeping_unit_id,\n\"EndDate\": end_date.strftime(UseDirectConfig.DATE_FORMAT),\n\"UnitSort\": unit_sort,\n\"InSeasonOnly\": in_season_only,\n\"FacilityId\": campground_id,\n}\nnon_null_data = {\nkey: value for key, value in data.items() if value not in [None, [], \"\"]\n}\nurl = f\"{self.base_url}/{self.rdr_path}/{UseDirectConfig.AVAILABILITY_ENDPOINT}\"\nresponse = self.session.post(\nurl=url, data=json.dumps(non_null_data), headers=self.json_headers\n)\nresponse.raise_for_status()\nresponse_json = response.json()\ntry:\nreturn UseDirectAvailabilityResponse(**response.json())\nexcept ValidationError as e:\nraise\nerror_message = (\n\"Error Parsing UseDirect Availability Response \"\nf\"- Facility ID # {campground_id}.\"\n)\nif \"Message\" in response_json:\nerror_message += \" \" + response_json[\"Message\"]\nraise UseDirectError(error_message) from e\ndef get_campsites(\nself,\ncampground_id: int,\nstart_date: Union[datetime, date],\nend_date: Union[datetime, date],\nis_ada: Optional[bool] = None,\nmin_vehicle_length: Optional[int] = None,\nunit_category_id: Optional[int] = None,\nweb_only: Optional[bool] = True,\nunit_type_group_ids: Optional[List[int]] = None,\nsleeping_unit_id: Optional[int] = None,\nunit_sort: Optional[str] = \"orderby\",\nin_season_only: Optional[bool] = True,\n) -&gt; List[AvailableCampsite]:\n\"\"\"\n        Get Campsites from UseDirect\n        Parameters\n        ----------\n        campground_id: int\n            Facility ID of the campground\n        start_date: Union[datetime, date]\n            Search Start Date\n        end_date: Union[datetime, date]\n            Search End Date\n        is_ada: Optional[bool]\n            Search for ADA sites\n        min_vehicle_length: Optional[int]\n            Minimum Vehicle Length - defaults to 0 which doesn't filter\n        unit_category_id: Optional[int]\n            Unit Category ID (typically 0)\n        web_only: Optional[bool]\n            Search for sights bookable online\n        unit_type_group_ids: Optional[List[int]]\n            UnitTypeGroupIds - Search Param\n        sleeping_unit_id: Optional[int]\n            SleepingUnitId - search param\n        unit_sort: Optional[str]\n            Sort Order\n        in_season_only: Optional[bool]\n            Searching for in-season only campgrounds\n        Returns\n        -------\n        List[AvailableCampsite]\n        \"\"\"\nself.refresh_metadata()\navailability_response = self.get_campsites_response(\ncampground_id=campground_id,\nstart_date=start_date,\nend_date=end_date,\nis_ada=is_ada,\nmin_vehicle_length=min_vehicle_length,\nunit_category_id=unit_category_id,\nweb_only=web_only,\nunit_type_group_ids=unit_type_group_ids,\nsleeping_unit_id=sleeping_unit_id,\nunit_sort=unit_sort,\nin_season_only=in_season_only,\n)\ncampsites: List[AvailableCampsite] = []\nif availability_response.Facility.Units is None:\nreturn campsites\nfor _campground_unit_id, unit in availability_response.Facility.Units.items():\nfor _slice_date, availability_slice in unit.Slices.items():\ncampsite = self._get_available_campsite(\navailability_slice=availability_slice,\navailability_response=availability_response,\nunit=unit,\n)\ncampsite_available = campsite.availability_status == \"Available\"\nif campsite_available is True:\nif (\nlen(self.campsite_ids) == 0\nor campsite.campsite_id in self.campsite_ids\n):\ncampsites.append(campsite)\nreturn campsites\ndef _get_available_campsite(\nself,\navailability_slice: UseDirectAvailabilitySlice,\navailability_response: UseDirectAvailabilityResponse,\nunit: UseDirectAvailabilityUnit,\n) -&gt; AvailableCampsite:\n\"\"\"\n        Create an AvailableCampsite Object from the Availability Grid Response\n        Parameters\n        ----------\n        availability_slice: UseDirectAvailabilitySlice\n        availability_response: UseDirectAvailabilityResponse\n        unit: UseDirectAvailabilityUnit\n        Returns\n        -------\n        AvailableCampsite\n        \"\"\"\nstart_date = datetime.fromordinal(availability_slice.Date.toordinal())\nfacility_id = availability_response.Facility.FacilityId\nfacility = self.usedirect_campgrounds[facility_id]\nrecreation_area = self.usedirect_rec_areas[facility.recreation_area_id]\nbooking_url = f\"{self.campground_url}/{self.booking_path}\"\nif self.booking_path_params is True:\nbooking_url = f\"{booking_url}#!park/{recreation_area.recreation_area_id}/{facility_id}\"\nif unit.UnitCategoryId is None:\nunit.UnitCategoryId = -1\nif unit.UnitTypeGroupId is None:\nunit.UnitTypeGroupId = -1\ncampsite_type = self.usedirect_unit_categories.get(unit.UnitCategoryId, None)\ncampsite_use_type = self.usedirect_unit_type_groups.get(\nunit.UnitTypeGroupId, None\n)\ncampsite = AvailableCampsite(\ncampsite_id=unit.UnitId,\nbooking_date=start_date,\nbooking_end_date=start_date + timedelta(days=1),\nbooking_nights=1,\ncampsite_site_name=unit.Name,\navailability_status=(\n\"Available\" if availability_slice.IsFree is True else \"Unavailable\"\n),\nrecreation_area=recreation_area.recreation_area,\nrecreation_area_id=facility.recreation_area_id,\nfacility_name=facility.facility_name,\nfacility_id=facility.facility_id,\nbooking_url=booking_url,\ncampsite_occupancy=(0, 1),\ncampsite_type=campsite_type,\ncampsite_use_type=campsite_use_type,\n)\nreturn campsite\ndef _fetch_metadata_from_disk(\nself, file_path: pathlib.Path\n) -&gt; Optional[Union[Dict[Any, Any], List[Dict[Any, Any]]]]:\n\"\"\"\n        Cache Metadata Locally and Invalidate after a day\n        Parameters\n        ----------\n        file_path: pathlib.Path\n        Returns\n        -------\n        Optional[Dict[Any, Any]]\n        \"\"\"\nif file_path.exists() is False:\ndata = None\nelse:\nmodified_time = datetime.utcfromtimestamp(file_path.stat().st_mtime)\ncurrent_time = datetime.utcnow()\nif (\ncurrent_time - modified_time &gt; timedelta(days=1)\nand self.active_search is False\n):\ndata = None\nelse:\njson_body: Dict[Any, Any] = json.loads(\nfile_path.read_text(encoding=\"utf-8\")\n)\ndata = json_body\nif data is None:\nlogger.debug(\"Refreshing UseDirect Metadata: %s\", file_path.name)\nreturn data\ndef _get_campground_metadata(self) -&gt; UseDirectMetadata:\n\"\"\"\n        Return Metadata for Campgrounds\n        Returns\n        -------\n        UseDirectMetadata\n        \"\"\"\nmetadata_file = self.offline_cache_dir.joinpath(\"filters.json\")\ncampground_metadata = self._fetch_metadata_from_disk(file_path=metadata_file)\nif campground_metadata is None:\nself.offline_cache_dir.mkdir(parents=True, exist_ok=True)\nurl = f\"{self.base_url}/{self.rdr_path}/{UseDirectConfig.METADATA_PREFIX}\"\nresp = self.session.get(url=url)\nresp.raise_for_status()\ncampground_metadata = resp.json()\nmetadata_file.write_text(json.dumps(campground_metadata, indent=2))\ndata = UseDirectMetadata(**campground_metadata)\nself.usedirect_unit_categories = {\nitem.UnitCategoryId: item.UnitCategoryName for item in data.UnitCategories\n}\nself.usedirect_unit_type_groups = {\nitem.UnitTypesGroupId: item.UnitTypesGroupName\nfor item in data.UnitTypesGroups\n}\nreturn data\ndef _get_city_parks(self) -&gt; Dict[int, UseDirectCityPark]:\n\"\"\"\n        Fetch Metadata On Every CityPark\n        Returns\n        -------\n        Dict[int, UseDirectCityPark]\n        \"\"\"\nmetadata_file = self.offline_cache_dir.joinpath(\"cityparks.json\")\ncity_park_data = self._fetch_metadata_from_disk(file_path=metadata_file)\nif city_park_data is None:\nurl = f\"{self.base_url}/{self.rdr_path}/{UseDirectConfig.CITYPARK_ENDPOINT}\"\nresp = self.session.get(url=url)\nresp.raise_for_status()\ncity_park_data: Dict[str, Dict[str, Any]] = resp.json()\nmetadata_file.write_text(json.dumps(city_park_data, indent=2))\nself.usedirect_city_parks: Dict[int, UseDirectCityPark] = {\nint(city_park_id): UseDirectCityPark(**city_park_json)\nfor city_park_id, city_park_json in city_park_data.items()\nif city_park_json[\"Name\"] is not None\n}\nreturn self.usedirect_city_parks\ndef _get_places(self) -&gt; Dict[int, UseDirectDetailedPlace]:\n\"\"\"\n        Fetch Metadata On Every Place\n        Returns\n        -------\n        Dict[int, UseDirectDetailedPlace]\n        \"\"\"\nmetadata_file = self.offline_cache_dir.joinpath(\"places.json\")\nplaces_data = self._fetch_metadata_from_disk(file_path=metadata_file)\nif places_data is None:\nurl = f\"{self.base_url}/{self.rdr_path}/{UseDirectConfig.LIST_PLACES_ENDPOINT}\"\nresp = self.session.get(url=url)\nresp.raise_for_status()\nplaces_data: List[Dict[str, Any]] = resp.json()\nmetadata_file.write_text(json.dumps(places_data, indent=2))\nplaces_validated = [\nUseDirectDetailedPlace(**place_json) for place_json in places_data\n]\nplaces_data_validated: Dict[int, UseDirectDetailedPlace] = {\nitem.PlaceId: item for item in places_validated\n}\nself.usedirect_rec_areas: Dict[int, RecreationArea] = {\nplace.PlaceId: RecreationArea(\nrecreation_area=place.Name,\nrecreation_area_id=place.PlaceId,\nrecreation_area_location=f\"{place.City.title()}, {place.State}\",\ndescription=place.Description,\n)\nfor place in places_data_validated.values()\n}\nreturn places_data_validated\ndef _get_facilities(self) -&gt; Dict[int, UseDirectFacilityMetadata]:\n\"\"\"\n        Fetch Metadata On Every Facility\n        Returns\n        -------\n        Dict[int, UseDirectFacilityMetadata]\n        \"\"\"\nmetadata_file = self.offline_cache_dir.joinpath(\"facilities.json\")\nfacilities_data = self._fetch_metadata_from_disk(file_path=metadata_file)\nif facilities_data is None:\nurl = f\"{self.base_url}/{self.rdr_path}/{UseDirectConfig.LIST_FACILITIES_ENDPOINT}\"\nresp = self.session.get(url=url)\nresp.raise_for_status()\nfacilities_data: List[Dict[str, Any]] = resp.json()\nmetadata_file.write_text(json.dumps(facilities_data, indent=2))\nif not isinstance(facilities_data, list):\nraise CamplyError(\"Unexpected data from %s\", metadata_file)\nfacilities_validated = [\nUseDirectFacilityMetadata(**facility_json)\nfor facility_json in facilities_data\n]\nfacilities_data_validated: Dict[int, UseDirectFacilityMetadata] = {\nitem.FacilityId: item for item in facilities_validated\n}\nself.usedirect_campgrounds: Dict[int, CampgroundFacility] = {}\nfor facility in facilities_data_validated.values():\nrec_area = self.usedirect_rec_areas.get(facility.PlaceId, None)\nif rec_area is not None:\nself.usedirect_campgrounds[facility.FacilityId] = CampgroundFacility(\nfacility_name=facility.Name,\nfacility_id=facility.FacilityId,\nrecreation_area_id=facility.PlaceId,\nrecreation_area=rec_area.recreation_area,\n)\nreturn facilities_data_validated\n@classmethod\ndef _search_camply_model(cls, query: str, model: CamplyModel) -&gt; bool:\n\"\"\"\n        Search a Camply Model\n        Parameters\n        ----------\n        query: str\n        model: CamplyModel\n        Returns\n        -------\n        bool\n        \"\"\"\nreturn any(\nquery.lower() in str(value).lower() for value in model.dict().values()\n)\ndef get_campsites_per_facility(\nself, facility_id: int\n) -&gt; List[UseDirectAvailabilityUnit]:\n\"\"\"\n        Get Campsites Per Facility\n        Parameters\n        ----------\n        facility_id: int\n        Returns\n        -------\n        List[UseDirectAvailabilityUnit]\n        \"\"\"\nresp = self.get_campsites_response(\ncampground_id=facility_id, start_date=date.today(), end_date=date.today()\n)\ncampsites: List[UseDirectAvailabilityUnit] = list(resp.Facility.Units.values())\nfor campsite in campsites:\ncampsite.FacilityId = facility_id\nreturn campsites\ndef get_campsite_metadata(\nself, facility_ids: List[int]\n) -&gt; Dict[int, UseDirectAvailabilityUnit]:\n\"\"\"\n        Get the Campsite Metadata\n        Parameters\n        ----------\n        facility_ids: List[int]\n            List of facility ids to fetch metadata for\n        Returns\n        -------\n        Dict[int, UseDirectAvailabilityUnit]\n        \"\"\"\ncampsites: Dict[int, UseDirectAvailabilityUnit] = {}\nfor facility_id in facility_ids:\nfound_campsites = self.get_campsites_per_facility(facility_id=facility_id)\ncampsite_dict = {item.UnitId: item for item in found_campsites}\ncampsites.update(campsite_dict)\nself.usedirect_campsites.update(campsites)\nreturn campsites\ndef _prepare_facility_ids(\nself,\nrecreation_area_ids: Optional[List[int]] = None,\ncampground_ids: Optional[List[int]] = None,\n) -&gt; List[int]:\n\"\"\"\n        Prepare Facility Ids\n        Parameters\n        ----------\n        recreation_area_ids: Optional[List[int]]\n        campground_ids: Optional[List[int]]\n        Returns\n        -------\n        List[int]\n        \"\"\"\nif not self.usedirect_campgrounds:\nself.refresh_metadata()\nrecreation_area_ids = recreation_area_ids or []\ncampground_ids = campground_ids or []\nfacility_ids = []\nif len(recreation_area_ids) == 0 and len(campground_ids) == 0:\nraise CamplyError(\"Must specify either a recreation area or campground id\")\nelif len(recreation_area_ids) &gt; 0:\nlogger.info(\n\"Searching %s Recreation Areas for campgrounds\",\nlen(recreation_area_ids),\n)\nfor recreation_area_id in recreation_area_ids:\nfacility_ids += [\nfacility_id\nfor facility_id, facility in self.usedirect_campgrounds.items()\nif facility.recreation_area_id == int(recreation_area_id)\n]\nelse:\nfacility_ids = campground_ids\nfacility_ids = [int(x) for x in facility_ids]\nreturn facility_ids\ndef validate_campsites(self, campsites: List[int], facility_ids: List[int]) -&gt; None:\n\"\"\"\n        Validate Campsites\n        Parameters\n        ----------\n        campsites: List[int]\n        Returns\n        -------\n        None\n        \"\"\"\nself.get_campsite_metadata(facility_ids=facility_ids)\nfor campsite_id in campsites:\nif campsite_id not in self.usedirect_campsites:\nraise CamplyError(f\"Campsite {campsite_id} not found\")\nelse:\ncampsite = self.usedirect_campsites[campsite_id]\nlogger.info(\"Searching Specific campsite: %s\", campsite.Name)\nself.campsite_ids = list(campsites)\n</code></pre>"},{"location":"reference/providers/usedirect/usedirect/#camply.providers.usedirect.usedirect.UseDirectProvider.base_url","title":"<code>base_url: str</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Base URL for the Provider</p>"},{"location":"reference/providers/usedirect/usedirect/#camply.providers.usedirect.usedirect.UseDirectProvider.campground_url","title":"<code>campground_url: str</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Campground URL for the Provider</p>"},{"location":"reference/providers/usedirect/usedirect/#camply.providers.usedirect.usedirect.UseDirectProvider.offline_cache_dir","title":"<code>offline_cache_dir: pathlib.Path</code>  <code>property</code>","text":"<p>Offline Cache Directory</p>"},{"location":"reference/providers/usedirect/usedirect/#camply.providers.usedirect.usedirect.UseDirectProvider.state_code","title":"<code>state_code: str</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>State Code for the Provider</p>"},{"location":"reference/providers/usedirect/usedirect/#camply.providers.usedirect.usedirect.UseDirectProvider.find_campgrounds","title":"<code>find_campgrounds(search_string=None, rec_area_id=None, state=None, verbose=True, campground_id=None, **kwargs)</code>","text":"<p>Search A Facility via Offline Metadata</p> <p>Parameters:</p> Name Type Description Default <code>rec_area_id</code> <code>Optional[List[int]]</code> <code>None</code> <code>state</code> <code>Optional[str]</code> <code>None</code> <code>search_string</code> <code>Optional[str]</code> <code>None</code> <code>campground_id</code> <code>Optional[List[int]]</code> <code>None</code> <p>Returns:</p> Type Description <code>List[CampgroundFacility]</code> Source code in <code>camply/providers/usedirect/usedirect.py</code> <pre><code>def find_campgrounds(\nself,\nsearch_string: Optional[str] = None,\nrec_area_id: Optional[List[int]] = None,\nstate: Optional[str] = None,\nverbose: bool = True,\ncampground_id: Optional[List[int]] = None,\n**kwargs: Any,\n) -&gt; List[CampgroundFacility]:\n\"\"\"\n    Search A Facility via Offline Metadata\n    Parameters\n    ----------\n    rec_area_id: Optional[int]\n    state: Optional[str]\n    search_string: Optional[str]\n    campground_id: Optional[List[int]]\n    Returns\n    -------\n    List[CampgroundFacility]\n    \"\"\"\nself.active_search = True\nif state is not None and state.upper() != self.state_code:\nraise CamplyError(\nf\"{self.__class__.__name__} doesn't support states outside {self.state_code}\"\n)\nif campground_id is None:\ncampground_id = []\nif rec_area_id is None:\nrec_area_id = []\nif all([rec_area_id == [], search_string is None, campground_id == []]):\nlogger.error(\n\"You must provide a search string, campground ID, or recreation area ID \"\n\"to search on UseDirect\"\n)\nsys.exit(1)\nif search_string is not None:\nlogger.info(f'Searching for Campgrounds: \"{search_string}\"')\nself.refresh_metadata()\nfound_campgrounds = self._search_for_campgrounds(\ncampground_id=campground_id,\nrec_area_id=rec_area_id,\nsearch_string=search_string,\n)\nif verbose is True:\nlogger.info(f\"{len(found_campgrounds)} Matching Campgrounds Found\")\nlog_sorted_response(found_campgrounds)\nself.active_search = False\nreturn found_campgrounds\n</code></pre>"},{"location":"reference/providers/usedirect/usedirect/#camply.providers.usedirect.usedirect.UseDirectProvider.get_campsite_metadata","title":"<code>get_campsite_metadata(facility_ids)</code>","text":"<p>Get the Campsite Metadata</p> <p>Parameters:</p> Name Type Description Default <code>facility_ids</code> <code>List[int]</code> <p>List of facility ids to fetch metadata for</p> required <p>Returns:</p> Type Description <code>Dict[int, UseDirectAvailabilityUnit]</code> Source code in <code>camply/providers/usedirect/usedirect.py</code> <pre><code>def get_campsite_metadata(\nself, facility_ids: List[int]\n) -&gt; Dict[int, UseDirectAvailabilityUnit]:\n\"\"\"\n    Get the Campsite Metadata\n    Parameters\n    ----------\n    facility_ids: List[int]\n        List of facility ids to fetch metadata for\n    Returns\n    -------\n    Dict[int, UseDirectAvailabilityUnit]\n    \"\"\"\ncampsites: Dict[int, UseDirectAvailabilityUnit] = {}\nfor facility_id in facility_ids:\nfound_campsites = self.get_campsites_per_facility(facility_id=facility_id)\ncampsite_dict = {item.UnitId: item for item in found_campsites}\ncampsites.update(campsite_dict)\nself.usedirect_campsites.update(campsites)\nreturn campsites\n</code></pre>"},{"location":"reference/providers/usedirect/usedirect/#camply.providers.usedirect.usedirect.UseDirectProvider.get_campsites","title":"<code>get_campsites(campground_id, start_date, end_date, is_ada=None, min_vehicle_length=None, unit_category_id=None, web_only=True, unit_type_group_ids=None, sleeping_unit_id=None, unit_sort='orderby', in_season_only=True)</code>","text":"<p>Get Campsites from UseDirect</p> <p>Parameters:</p> Name Type Description Default <code>campground_id</code> <code>int</code> <p>Facility ID of the campground</p> required <code>start_date</code> <code>Union[datetime, date]</code> <p>Search Start Date</p> required <code>end_date</code> <code>Union[datetime, date]</code> <p>Search End Date</p> required <code>is_ada</code> <code>Optional[bool]</code> <p>Search for ADA sites</p> <code>None</code> <code>min_vehicle_length</code> <code>Optional[int]</code> <p>Minimum Vehicle Length - defaults to 0 which doesn't filter</p> <code>None</code> <code>unit_category_id</code> <code>Optional[int]</code> <p>Unit Category ID (typically 0)</p> <code>None</code> <code>web_only</code> <code>Optional[bool]</code> <p>Search for sights bookable online</p> <code>True</code> <code>unit_type_group_ids</code> <code>Optional[List[int]]</code> <p>UnitTypeGroupIds - Search Param</p> <code>None</code> <code>sleeping_unit_id</code> <code>Optional[int]</code> <p>SleepingUnitId - search param</p> <code>None</code> <code>unit_sort</code> <code>Optional[str]</code> <p>Sort Order</p> <code>'orderby'</code> <code>in_season_only</code> <code>Optional[bool]</code> <p>Searching for in-season only campgrounds</p> <code>True</code> <p>Returns:</p> Type Description <code>List[AvailableCampsite]</code> Source code in <code>camply/providers/usedirect/usedirect.py</code> <pre><code>def get_campsites(\nself,\ncampground_id: int,\nstart_date: Union[datetime, date],\nend_date: Union[datetime, date],\nis_ada: Optional[bool] = None,\nmin_vehicle_length: Optional[int] = None,\nunit_category_id: Optional[int] = None,\nweb_only: Optional[bool] = True,\nunit_type_group_ids: Optional[List[int]] = None,\nsleeping_unit_id: Optional[int] = None,\nunit_sort: Optional[str] = \"orderby\",\nin_season_only: Optional[bool] = True,\n) -&gt; List[AvailableCampsite]:\n\"\"\"\n    Get Campsites from UseDirect\n    Parameters\n    ----------\n    campground_id: int\n        Facility ID of the campground\n    start_date: Union[datetime, date]\n        Search Start Date\n    end_date: Union[datetime, date]\n        Search End Date\n    is_ada: Optional[bool]\n        Search for ADA sites\n    min_vehicle_length: Optional[int]\n        Minimum Vehicle Length - defaults to 0 which doesn't filter\n    unit_category_id: Optional[int]\n        Unit Category ID (typically 0)\n    web_only: Optional[bool]\n        Search for sights bookable online\n    unit_type_group_ids: Optional[List[int]]\n        UnitTypeGroupIds - Search Param\n    sleeping_unit_id: Optional[int]\n        SleepingUnitId - search param\n    unit_sort: Optional[str]\n        Sort Order\n    in_season_only: Optional[bool]\n        Searching for in-season only campgrounds\n    Returns\n    -------\n    List[AvailableCampsite]\n    \"\"\"\nself.refresh_metadata()\navailability_response = self.get_campsites_response(\ncampground_id=campground_id,\nstart_date=start_date,\nend_date=end_date,\nis_ada=is_ada,\nmin_vehicle_length=min_vehicle_length,\nunit_category_id=unit_category_id,\nweb_only=web_only,\nunit_type_group_ids=unit_type_group_ids,\nsleeping_unit_id=sleeping_unit_id,\nunit_sort=unit_sort,\nin_season_only=in_season_only,\n)\ncampsites: List[AvailableCampsite] = []\nif availability_response.Facility.Units is None:\nreturn campsites\nfor _campground_unit_id, unit in availability_response.Facility.Units.items():\nfor _slice_date, availability_slice in unit.Slices.items():\ncampsite = self._get_available_campsite(\navailability_slice=availability_slice,\navailability_response=availability_response,\nunit=unit,\n)\ncampsite_available = campsite.availability_status == \"Available\"\nif campsite_available is True:\nif (\nlen(self.campsite_ids) == 0\nor campsite.campsite_id in self.campsite_ids\n):\ncampsites.append(campsite)\nreturn campsites\n</code></pre>"},{"location":"reference/providers/usedirect/usedirect/#camply.providers.usedirect.usedirect.UseDirectProvider.get_campsites_per_facility","title":"<code>get_campsites_per_facility(facility_id)</code>","text":"<p>Get Campsites Per Facility</p> <p>Parameters:</p> Name Type Description Default <code>facility_id</code> <code>int</code> required <p>Returns:</p> Type Description <code>List[UseDirectAvailabilityUnit]</code> Source code in <code>camply/providers/usedirect/usedirect.py</code> <pre><code>def get_campsites_per_facility(\nself, facility_id: int\n) -&gt; List[UseDirectAvailabilityUnit]:\n\"\"\"\n    Get Campsites Per Facility\n    Parameters\n    ----------\n    facility_id: int\n    Returns\n    -------\n    List[UseDirectAvailabilityUnit]\n    \"\"\"\nresp = self.get_campsites_response(\ncampground_id=facility_id, start_date=date.today(), end_date=date.today()\n)\ncampsites: List[UseDirectAvailabilityUnit] = list(resp.Facility.Units.values())\nfor campsite in campsites:\ncampsite.FacilityId = facility_id\nreturn campsites\n</code></pre>"},{"location":"reference/providers/usedirect/usedirect/#camply.providers.usedirect.usedirect.UseDirectProvider.get_campsites_response","title":"<code>get_campsites_response(campground_id, start_date, end_date, is_ada=None, min_vehicle_length=None, unit_category_id=None, web_only=True, unit_type_group_ids=None, sleeping_unit_id=None, unit_sort='orderby', in_season_only=True)</code>","text":"<p>Get Campsites from UseDirect</p> <p>Parameters:</p> Name Type Description Default <code>campground_id</code> <code>int</code> <p>Facility ID of the campground</p> required <code>start_date</code> <code>Union[datetime, date]</code> <p>Search Start Date</p> required <code>end_date</code> <code>Union[datetime, date]</code> <p>Search End Date</p> required <code>is_ada</code> <code>Optional[bool]</code> <p>Search for ADA sites</p> <code>None</code> <code>min_vehicle_length</code> <code>Optional[int]</code> <p>Minimum Vehicle Length - defaults to 0 which doesn't filter</p> <code>None</code> <code>unit_category_id</code> <code>Optional[int]</code> <p>Unit Category ID (typically 0)</p> <code>None</code> <code>web_only</code> <code>Optional[bool]</code> <p>Search for sights bookable online</p> <code>True</code> <code>unit_type_group_ids</code> <code>Optional[List[int]]</code> <p>UnitTypeGroupIds - Search Param</p> <code>None</code> <code>sleeping_unit_id</code> <code>Optional[int]</code> <p>SleepingUnitId - search param</p> <code>None</code> <code>unit_sort</code> <code>Optional[str]</code> <p>Sort Order</p> <code>'orderby'</code> <code>in_season_only</code> <code>Optional[bool]</code> <p>Searching for in-season only campgrounds</p> <code>True</code> <p>Returns:</p> Type Description <code>UseDirectAvailabilityResponse</code> Source code in <code>camply/providers/usedirect/usedirect.py</code> <pre><code>@ratelimit.sleep_and_retry\n@ratelimit.limits(calls=1, period=1)\ndef get_campsites_response(\nself,\ncampground_id: int,\nstart_date: Union[datetime, date],\nend_date: Union[datetime, date],\nis_ada: Optional[bool] = None,\nmin_vehicle_length: Optional[int] = None,\nunit_category_id: Optional[int] = None,\nweb_only: Optional[bool] = True,\nunit_type_group_ids: Optional[List[int]] = None,\nsleeping_unit_id: Optional[int] = None,\nunit_sort: Optional[str] = \"orderby\",\nin_season_only: Optional[bool] = True,\n) -&gt; UseDirectAvailabilityResponse:\n\"\"\"\n    Get Campsites from UseDirect\n    Parameters\n    ----------\n    campground_id: int\n        Facility ID of the campground\n    start_date: Union[datetime, date]\n        Search Start Date\n    end_date: Union[datetime, date]\n        Search End Date\n    is_ada: Optional[bool]\n        Search for ADA sites\n    min_vehicle_length: Optional[int]\n        Minimum Vehicle Length - defaults to 0 which doesn't filter\n    unit_category_id: Optional[int]\n        Unit Category ID (typically 0)\n    web_only: Optional[bool]\n        Search for sights bookable online\n    unit_type_group_ids: Optional[List[int]]\n        UnitTypeGroupIds - Search Param\n    sleeping_unit_id: Optional[int]\n        SleepingUnitId - search param\n    unit_sort: Optional[str]\n        Sort Order\n    in_season_only: Optional[bool]\n        Searching for in-season only campgrounds\n    Returns\n    -------\n    UseDirectAvailabilityResponse\n    \"\"\"\ndata = {\n\"IsADA\": is_ada,\n\"MinVehicleLength\": min_vehicle_length,\n\"UnitCategoryId\": unit_category_id,\n\"StartDate\": start_date.strftime(UseDirectConfig.DATE_FORMAT),\n\"WebOnly\": web_only,\n\"UnitTypesGroupIds\": []\nif unit_type_group_ids is None\nelse unit_type_group_ids,\n\"SleepingUnitId\": sleeping_unit_id,\n\"EndDate\": end_date.strftime(UseDirectConfig.DATE_FORMAT),\n\"UnitSort\": unit_sort,\n\"InSeasonOnly\": in_season_only,\n\"FacilityId\": campground_id,\n}\nnon_null_data = {\nkey: value for key, value in data.items() if value not in [None, [], \"\"]\n}\nurl = f\"{self.base_url}/{self.rdr_path}/{UseDirectConfig.AVAILABILITY_ENDPOINT}\"\nresponse = self.session.post(\nurl=url, data=json.dumps(non_null_data), headers=self.json_headers\n)\nresponse.raise_for_status()\nresponse_json = response.json()\ntry:\nreturn UseDirectAvailabilityResponse(**response.json())\nexcept ValidationError as e:\nraise\nerror_message = (\n\"Error Parsing UseDirect Availability Response \"\nf\"- Facility ID # {campground_id}.\"\n)\nif \"Message\" in response_json:\nerror_message += \" \" + response_json[\"Message\"]\nraise UseDirectError(error_message) from e\n</code></pre>"},{"location":"reference/providers/usedirect/usedirect/#camply.providers.usedirect.usedirect.UseDirectProvider.refresh_metadata","title":"<code>refresh_metadata()</code>","text":"<p>Refresh All the Campground Metadata</p> <p>This is the way that this provider caches all of its metadata offline. It makes a number of GET requests and saves the entire output as JSON alongside the provider code itself (.usedirect.com): <ul> <li>/rdr/rdr/search/filters</li> <li>/rdr/rdr/search/citypark</li> <li>/rdr/rdr/search/places</li> <li>/rdr/rdr/search/facilities</li> </ul> <p>Returns:</p> Type Description <code>None</code> Source code in <code>camply/providers/usedirect/usedirect.py</code> <pre><code>def refresh_metadata(self) -&gt; None:\n\"\"\"\n    Refresh All the Campground Metadata\n    This is the way that this provider caches all of its metadata\n    offline. It makes a number of GET requests and saves the entire output\n    as JSON alongside the provider code itself (&lt;subdomain&gt;.usedirect.com):\n    - /rdr/rdr/search/filters\n    - /rdr/rdr/search/citypark\n    - /rdr/rdr/search/places\n    - /rdr/rdr/search/facilities\n    Returns\n    -------\n    None\n    \"\"\"\nif self.metadata_refreshed is False:\nself._get_campground_metadata()\nself._get_city_parks()\nself._get_places()\nself._get_facilities()\nself.metadata_refreshed = True\n</code></pre>"},{"location":"reference/providers/usedirect/usedirect/#camply.providers.usedirect.usedirect.UseDirectProvider.search_for_recreation_areas","title":"<code>search_for_recreation_areas(query=None, state=None)</code>","text":"<p>Retrieve Recreation Areas</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>Optional[str]</code> <code>None</code> <code>query</code> <code>Optional[str]</code> <code>None</code> <p>Returns:</p> Type Description <code>List[RecreationArea]</code> Source code in <code>camply/providers/usedirect/usedirect.py</code> <pre><code>def search_for_recreation_areas(\nself,\nquery: Optional[str] = None,\nstate: Optional[str] = None,\n) -&gt; List[RecreationArea]:\n\"\"\"\n    Retrieve Recreation Areas\n    Parameters\n    ----------\n    state: str\n    query: str\n    Returns\n    -------\n    List[RecreationArea]\n    \"\"\"\nif state is not None and state.upper() != self.state_code.upper():\nraise CamplyError(\nf\"{self.__class__.__name__} doesn't support states outside {self.state_code}\"\n)\nif query is None:\nlogger.error(\n\"You must provide a search string to search `UseDirect` Recreation Areas\"\n)\nsys.exit(1)\nlogger.info(f'Searching for Recreation Areas: \"{query}\"')\nself.refresh_metadata()\nfound_recareas = [\nrec_area\nfor rec_area in self.usedirect_rec_areas.values()\nif self._search_camply_model(query=query, model=rec_area) is True\n]\nreturn found_recareas\n</code></pre>"},{"location":"reference/providers/usedirect/usedirect/#camply.providers.usedirect.usedirect.UseDirectProvider.validate_campsites","title":"<code>validate_campsites(campsites, facility_ids)</code>","text":"<p>Validate Campsites</p> <p>Parameters:</p> Name Type Description Default <code>campsites</code> <code>List[int]</code> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>camply/providers/usedirect/usedirect.py</code> <pre><code>def validate_campsites(self, campsites: List[int], facility_ids: List[int]) -&gt; None:\n\"\"\"\n    Validate Campsites\n    Parameters\n    ----------\n    campsites: List[int]\n    Returns\n    -------\n    None\n    \"\"\"\nself.get_campsite_metadata(facility_ids=facility_ids)\nfor campsite_id in campsites:\nif campsite_id not in self.usedirect_campsites:\nraise CamplyError(f\"Campsite {campsite_id} not found\")\nelse:\ncampsite = self.usedirect_campsites[campsite_id]\nlogger.info(\"Searching Specific campsite: %s\", campsite.Name)\nself.campsite_ids = list(campsites)\n</code></pre>"},{"location":"reference/providers/usedirect/variations/","title":"variations","text":"<p>Usedirect specific variations</p>"},{"location":"reference/providers/usedirect/variations/#camply.providers.usedirect.variations.AlabamaStateParks","title":"<code>AlabamaStateParks</code>","text":"<p>         Bases: <code>UseDirectProvider</code></p> <p>Alabama State Parks</p> Source code in <code>camply/providers/usedirect/variations.py</code> <pre><code>class AlabamaStateParks(UseDirectProvider):\n\"\"\"\n    Alabama State Parks\n    \"\"\"\nbase_url = \"https://alabamardr.usedirect.com\"\ncampground_url = \"https://www.reservealapark.com\"\nrdr_path = \"alabamardr\"\nbooking_path = \"AlabamaWebHome/Facilities/SearchViewUnitAvailabity.aspx\"\nbooking_path_params = False\nstate_code = \"AL\"\n</code></pre>"},{"location":"reference/providers/usedirect/variations/#camply.providers.usedirect.variations.ArizonaStateParks","title":"<code>ArizonaStateParks</code>","text":"<p>         Bases: <code>UseDirectProvider</code></p> <p>Arizona State Parks</p> Source code in <code>camply/providers/usedirect/variations.py</code> <pre><code>class ArizonaStateParks(UseDirectProvider):\n\"\"\"\n    Arizona State Parks\n    \"\"\"\nbase_url = \"https://azrdr.usedirect.com\"\ncampground_url = \"https://ArizonaStateParks.com\"\nrdr_path = \"azrdr\"\nbooking_path = \"reserve\"\nstate_code = \"AZ\"\n</code></pre>"},{"location":"reference/providers/usedirect/variations/#camply.providers.usedirect.variations.FairfaxCountyParks","title":"<code>FairfaxCountyParks</code>","text":"<p>         Bases: <code>UseDirectProvider</code></p> <p>Fairfax County Parks</p> Source code in <code>camply/providers/usedirect/variations.py</code> <pre><code>class FairfaxCountyParks(UseDirectProvider):\n\"\"\"\n    Fairfax County Parks\n    \"\"\"\nbase_url = \"https://fairfaxrdr.usedirect.com\"\ncampground_url = \"https://fairfax.usedirect.com\"\nrdr_path = \"FCPARDR\"\nbooking_path = \"FairfaxFCPAWeb/Facilities/SearchViewUnitAvailabity.aspx\"\nbooking_path_params = False\nstate_code = \"VA\"\n</code></pre>"},{"location":"reference/providers/usedirect/variations/#camply.providers.usedirect.variations.FloridaStateParks","title":"<code>FloridaStateParks</code>","text":"<p>         Bases: <code>UseDirectProvider</code></p> <p>Florida State Parks</p> Source code in <code>camply/providers/usedirect/variations.py</code> <pre><code>class FloridaStateParks(UseDirectProvider):\n\"\"\"\n    Florida State Parks\n    \"\"\"\nbase_url = \"https://floridardr.usedirect.com\"\ncampground_url = \"https://www.reserve.floridastateparks.org\"\nrdr_path = \"FloridaRDR\"\nbooking_path = \"Web\"\nstate_code = \"FL\"\n</code></pre>"},{"location":"reference/providers/usedirect/variations/#camply.providers.usedirect.variations.MaricopaCountyParks","title":"<code>MaricopaCountyParks</code>","text":"<p>         Bases: <code>UseDirectProvider</code></p> <p>Maricopa County Parks</p> Source code in <code>camply/providers/usedirect/variations.py</code> <pre><code>class MaricopaCountyParks(UseDirectProvider):\n\"\"\"\n    Maricopa County Parks\n    \"\"\"\nbase_url = \"https://maricopardr.usedirect.com\"\ncampground_url = \"https://www.maricopacountyparks.org\"\nrdr_path = \"maricopardr\"\nbooking_path = \"MaricopaWeb/Facilities/SearchViewUnitAvailabity.aspx\"\nbooking_path_params = False\nstate_code = \"AZ\"\n</code></pre>"},{"location":"reference/providers/usedirect/variations/#camply.providers.usedirect.variations.MinnesotaStateParks","title":"<code>MinnesotaStateParks</code>","text":"<p>         Bases: <code>UseDirectProvider</code></p> <p>Minnesota State Parks</p> Source code in <code>camply/providers/usedirect/variations.py</code> <pre><code>class MinnesotaStateParks(UseDirectProvider):\n\"\"\"\n    Minnesota State Parks\n    \"\"\"\nbase_url = \"https://mnrdr.usedirect.com\"\ncampground_url = \"https://reservemn.usedirect.com\"\nrdr_path = \"minnesotardr\"\nbooking_path = \"MinnesotaWeb\"\nstate_code = \"MN\"\n</code></pre>"},{"location":"reference/providers/usedirect/variations/#camply.providers.usedirect.variations.MissouriStateParks","title":"<code>MissouriStateParks</code>","text":"<p>         Bases: <code>UseDirectProvider</code></p> <p>Missouri State Parks</p> Source code in <code>camply/providers/usedirect/variations.py</code> <pre><code>class MissouriStateParks(UseDirectProvider):\n\"\"\"\n    Missouri State Parks\n    \"\"\"\nbase_url = \"https://msprdr.usedirect.com\"\ncampground_url = \"https://icampmo1.usedirect.com\"\nrdr_path = \"msprdr\"\nbooking_path = \"MSPWeb\"\nstate_code = \"MO\"\n</code></pre>"},{"location":"reference/providers/usedirect/variations/#camply.providers.usedirect.variations.NorthernTerritory","title":"<code>NorthernTerritory</code>","text":"<p>         Bases: <code>UseDirectProvider</code></p> <p>Australian NorthernTerritory</p> Source code in <code>camply/providers/usedirect/variations.py</code> <pre><code>class NorthernTerritory(UseDirectProvider):\n\"\"\"\n    Australian NorthernTerritory\n    \"\"\"\nbase_url = \"https://northernterritoryrdr.usedirect.com\"\ncampground_url = \"https://parkbookings.nt.gov.au\"\nrdr_path = \"NorthernTerritoryRDR\"\nbooking_path = \"Web/Facilities/SearchViewUnitAvailabity.aspx\"\nbooking_path_params = False\nstate_code = \"NT\"\n</code></pre>"},{"location":"reference/providers/usedirect/variations/#camply.providers.usedirect.variations.OhioStateParks","title":"<code>OhioStateParks</code>","text":"<p>         Bases: <code>UseDirectProvider</code></p> <p>Ohio State Parks</p> Source code in <code>camply/providers/usedirect/variations.py</code> <pre><code>class OhioStateParks(UseDirectProvider):\n\"\"\"\n    Ohio State Parks\n    \"\"\"\nbase_url = \"https://ohiordr.usedirect.com\"\ncampground_url = \"https://www.OhioStateParks.com\"\nrdr_path = \"ohiordr\"\nbooking_path = \"OhioCampWeb\"\nstate_code = \"OH\"\n</code></pre>"},{"location":"reference/providers/usedirect/variations/#camply.providers.usedirect.variations.OregonMetro","title":"<code>OregonMetro</code>","text":"<p>         Bases: <code>UseDirectProvider</code></p> <p>Oregon Metro Parks</p> Source code in <code>camply/providers/usedirect/variations.py</code> <pre><code>class OregonMetro(UseDirectProvider):\n\"\"\"\n    Oregon Metro Parks\n    \"\"\"\nbase_url = \"https://oregonrdr.usedirect.com\"\ncampground_url = \"https://reservemetro.usedirect.com\"\nrdr_path = \"oregonmetrordr\"\nbooking_path = \"MetroWeb/Facilities/SearchViewUnitAvailabity.aspx\"\nbooking_path_params = False\nstate_code = \"OR\"\n</code></pre>"},{"location":"reference/providers/usedirect/variations/#camply.providers.usedirect.variations.ReserveCalifornia","title":"<code>ReserveCalifornia</code>","text":"<p>         Bases: <code>UseDirectProvider</code></p> <p>ReserveCalifornia</p> Source code in <code>camply/providers/usedirect/variations.py</code> <pre><code>class ReserveCalifornia(UseDirectProvider):\n\"\"\"\n    ReserveCalifornia\n    \"\"\"\nbase_url = \"https://calirdr.usedirect.com\"\ncampground_url = \"https://www.reservecalifornia.com\"\nstate_code = \"CA\"\n</code></pre>"},{"location":"reference/providers/usedirect/variations/#camply.providers.usedirect.variations.VirginiaStateParks","title":"<code>VirginiaStateParks</code>","text":"<p>         Bases: <code>UseDirectProvider</code></p> <p>Virginia State Parks</p> Source code in <code>camply/providers/usedirect/variations.py</code> <pre><code>class VirginiaStateParks(UseDirectProvider):\n\"\"\"\n    Virginia State Parks\n    \"\"\"\nbase_url = \"https://virginiardr.usedirect.com\"\ncampground_url = \"https://VirginiaStateParks.com\"\nrdr_path = \"virginiardr\"\nbooking_path = \"Web\"\nstate_code = \"VA\"\n</code></pre>"},{"location":"reference/providers/xanterra/","title":"xanterra","text":"<p>Xanterra init</p>"},{"location":"reference/providers/xanterra/yellowstone_lodging/","title":"yellowstone_lodging","text":"<p>Python Class Check Yellowstone Campground Booking API for Availability</p>"},{"location":"reference/providers/xanterra/yellowstone_lodging/#camply.providers.xanterra.yellowstone_lodging.Yellowstone","title":"<code>Yellowstone</code>","text":"<p>         Bases: <code>BaseProvider</code></p> <p>Scanner for Lodging in Yellowstone</p> Source code in <code>camply/providers/xanterra/yellowstone_lodging.py</code> <pre><code>class Yellowstone(BaseProvider):\n\"\"\"\n    Scanner for Lodging in Yellowstone\n    \"\"\"\nrecreation_area = RecreationArea(\nrecreation_area=YellowstoneConfig.YELLOWSTONE_RECREATION_AREA_FULL_NAME,\nrecreation_area_id=YellowstoneConfig.YELLOWSTONE_RECREATION_AREA_ID,\nrecreation_area_location=\"USA\",\n)\ndef _get_monthly_availability(self, month: datetime, nights: int = None) -&gt; dict:\n\"\"\"\n        Check All Lodging in Yellowstone for Campground Data\n        Returns\n        -------\n        data_availability: dict\n            Data Availability Dictionary\n        \"\"\"\nquery_dict = {\n\"date\": self._ensure_current_month(month=month),\n\"limit\": 31,\n\"rate_code\": YellowstoneConfig.RATE_CODE,\n}\nif nights is not None:\nquery_dict.update({\"nights\": nights})\napi_endpoint = self._get_api_endpoint(\nurl_path=YellowstoneConfig.YELLOWSTONE_LODGING_PATH, query=None\n)\nlogger.info(\nf\"Searching for Yellowstone Lodging Availability: {month.strftime('%B, %Y')}\"\n)\nall_resort_availability_data = self.make_yellowstone_request(\nendpoint=api_endpoint, params=query_dict\n)\nreturn all_resort_availability_data\n@staticmethod\n@tenacity.retry(\nwait=tenacity.wait_random_exponential(multiplier=3, max=1800),\nstop=tenacity.stop.stop_after_delay(6000),\n)\ndef _try_retry_get_data(endpoint: str, params: Optional[dict] = None) -&gt; dict:\n\"\"\"\n        Try and Retry Fetching Data from the Yellowstone API.\n        Unfortunately this is a required method to request the data since the\n        Yellowstone API doesn't always return data.\n        Parameters\n        ----------\n        endpoint: str\n            API Endpoint\n        params\n        Returns\n        -------\n        dict\n        \"\"\"\nyellowstone_headers = {}\nuser_agent = {\n\"User-Agent\": UserAgent(use_external_data=False, browsers=[\"chrome\"]).chrome\n}\nyellowstone_headers.update(user_agent)\nyellowstone_headers.update(STANDARD_HEADERS)\nyellowstone_headers.update(YellowstoneConfig.API_REFERRERS)\nresponse = requests.get(\nurl=endpoint, headers=yellowstone_headers, params=params, timeout=30\n)\nif response.ok is True and response.text.strip() != \"\":\nreturn loads(response.content)\nelse:\nerror_message = (\n\"Something went wrong with checking the \"\n\"Yellowstone Booking API. Will continue retrying.\"\n)\nlogger.warning(error_message)\nraise RuntimeError(error_message)\n@staticmethod\ndef make_yellowstone_request(endpoint: str, params: Optional[dict] = None) -&gt; dict:\n\"\"\"\n        Try and Retry Fetching Data from the Yellowstone API.\n        Unfortunately this is a required method to request the data since the\n        Yellowstone API doesn't always return data.\n        Parameters\n        ----------\n        endpoint: str\n            API Endpoint\n        params\n        Returns\n        -------\n        dict\n        \"\"\"\ntry:\ncontent = Yellowstone._try_retry_get_data(endpoint=endpoint, params=params)\nexcept RuntimeError as re:\nraise RuntimeError(f\"error_message: {re}\") from re\nreturn content\n@classmethod\ndef _get_api_endpoint(cls, url_path: str, query: Optional[dict] = None) -&gt; str:\n\"\"\"\n        Build the API Endpoint for All Yellowstone Lodging\n        \"\"\"\nif query is not None:\nquery_string = parse.urlencode(query=query)\nelse:\nquery_string = \"\"\nurl_components = {\n\"scheme\": YellowstoneConfig.API_SCHEME,\n\"netloc\": YellowstoneConfig.API_BASE_ENDPOINT,\n\"url\": url_path,\n\"params\": \"\",\n\"query\": query_string,\n\"fragment\": \"\",\n}\napi_endpoint = parse.urlunparse(tuple(url_components.values()))\nreturn api_endpoint\n@classmethod\ndef _return_lodging_url(\ncls, lodging_code: str, month: datetime, params: Optional[dict] = \"\"\n) -&gt; str:\n\"\"\"\n        Return a Browser Loadable URL to book from\n        Parameters\n        ----------\n        lodging_code: str\n            Lodging Code from API\n        month: datetime\n            Month to return bookings filtered to\n        params: Optional[dict]\n            Optional URL Parameters\n        Returns\n        -------\n        str\n            URL String\n        \"\"\"\nquery = {\n\"dateFrom\": month.strftime(\"%m-%d-%Y\"),\n\"adults\": 1,\n\"destination\": lodging_code,\n\"children\": 0,\n}\nif params is not None:\nquery.update(params)\nquery_string = parse.urlencode(query=query)\nurl_components = {\n\"scheme\": YellowstoneConfig.API_SCHEME,\n\"netloc\": YellowstoneConfig.WEBUI_BASE_ENDPOINT,\n\"url\": YellowstoneConfig.WEBUI_BOOKING_PATH,\n\"params\": \"\",\n\"query\": query_string,\n\"fragment\": \"\",\n}\nwebui_endpoint = parse.urlunparse(tuple(url_components.values()))\nreturn webui_endpoint\n@classmethod\ndef _compile_campground_availabilities(\ncls, availability: XantResortData\n) -&gt; List[dict]:\n\"\"\"\n        Gather Data about campground availabilities within a JSON Availability Objet\n        Parameters\n        ----------\n        availability: ResortData\n            JSON Availability Object\n        Returns\n        -------\n        available_campsites:  List[dict]\n            List of Availabilities as JSON\n        \"\"\"\navailable_campsites = []\nfor booking_date, daily_data in availability.availability.items():\ncamping_keys = [\nkey\nfor key in daily_data.keys()\nif YellowstoneConfig.LODGING_CAMPGROUND_QUALIFIER in key\n]\nfor hotel_code in camping_keys:\nhotel_data = daily_data[hotel_code]\ntry:\nhotel_title = hotel_data.rates[YellowstoneConfig.RATE_CODE].title\nhotel_rate_mins = hotel_data.rates[YellowstoneConfig.RATE_CODE].mins\nif hotel_rate_mins != {1: 0}:\nmin_capacity = min(hotel_rate_mins.keys())\nmax_capacity = max(hotel_rate_mins.keys())\ncapacity = (min_capacity, max_capacity)\ncampsite = {\n\"campsite_id\": None,\n\"booking_date\": booking_date,\n\"campsite_occupancy\": capacity,\n\"recreation_area\": YellowstoneConfig.YELLOWSTONE_RECREATION_AREA_NAME,\n\"recreation_area_id\": YellowstoneConfig.YELLOWSTONE_RECREATION_AREA_ID,\n\"facility_name\": hotel_title.replace(\n*YellowstoneConfig.YELLOWSTONE_CAMPGROUND_NAME_REPLACE\n),\n\"facility_id\": hotel_code,\n}\navailable_campsites.append(campsite)\nexcept KeyError:\npass\nlogger.info(\nf\"\\t{logging_utils.get_emoji(available_campsites)}\\t\"\nf\"{len(available_campsites)} sites found.\"\n)\nreturn available_campsites\ndef _gather_campsite_specific_availability(\nself,\navailable_campsites: List[dict],\nmonth: datetime,\nnights: Optional[int] = None,\n) -&gt; List[dict]:\n\"\"\"\n        Get campsite extra information\n        Given a DataFrame of campsite availability, return updated Data with details\n        about the actual campsites that are available (i.e Tent Size, RV Length, Etc)\n        Parameters\n        ----------\n        available_campsites: List[dict]\n            List of Available Campsites as JSON objects\n        month: datetime\n            Month object\n        Returns\n        -------\n        List[dict]\n        \"\"\"\navailable_room_array = []\navailability_df = DataFrame(data=available_campsites)\nif availability_df.empty is True:\nreturn available_room_array\nfor facility_id, _facility_df in availability_df.groupby(\nYellowstoneConfig.FACILITY_ID\n):\napi_endpoint = self._get_api_endpoint(\nurl_path=YellowstoneConfig.YELLOWSTONE_CAMPSITE_AVAILABILITY, query=None\n)\nparams = {\"date\": self._ensure_current_month(month=month), \"limit\": 31}\nif nights is not None:\nparams.update({\"nights\": nights})\ncampsite_data = self.make_yellowstone_request(\nendpoint=f\"{api_endpoint}/{facility_id}\", params=params\n)\ncampsite_availability = campsite_data[\nYellowstoneConfig.BOOKING_AVAILABILITY\n]\nbooking_dates = campsite_availability.keys()\navailabilities = self._process_daily_availability(\nbooking_dates=booking_dates,\ncampsite_availability=campsite_availability,\nfacility_id=facility_id,\n)\navailable_room_array += availabilities\nreturn available_room_array\n@classmethod\ndef _process_daily_availability(\ncls, booking_dates: List[str], campsite_availability: dict, facility_id: str\n) -&gt; List[dict]:\n\"\"\"\n        Process Monthly Availability\n        Parameters\n        ----------\n        booking_dates: List[str]\n            List of booking dates to process\n        campsite_availability: dict\n            Campsite availability dict\n        facility_id: str\n            Identification of the Facility\n        Returns\n        -------\n        List[dict]\n        \"\"\"\ndaily_availabilities = []\nfor booking_date_str in booking_dates:\ndaily_availability = campsite_availability[booking_date_str]\nif (\ndaily_availability[YellowstoneConfig.FACILITY_STATUS]\n== YellowstoneConfig.FACILITY_STATUS_QUALIFIER\n):\navailable_rooms = daily_availability[YellowstoneConfig.FACILITY_ROOMS]\nfor room in available_rooms:\nif room[YellowstoneConfig.FACILITY_AVAILABLE_QUALIFIER] &gt; 0:\ndaily_availabilities.append(\n{\n\"booking_date\": booking_date_str,\n\"facility_id\": facility_id,\n\"campsite_code\": room[\nYellowstoneConfig.FACILITY_ROOM_CODE\n],\n\"available\": room[\nYellowstoneConfig.FACILITY_AVAILABLE_QUALIFIER\n],\n\"price\": room[YellowstoneConfig.FACILITY_PRICE],\n}\n)\nreturn daily_availabilities\ndef _get_property_information(self, available_rooms: List[dict]) -&gt; List[dict]:\n\"\"\"\n        Gather Information About All Campgrounds / Hotels within Yellowstone\n        Parameters\n        ----------\n        available_rooms: List[dict]\n        Returns\n        -------\n        List[dict]\n        \"\"\"\nproperty_info_array = []\navailability_df = DataFrame(data=available_rooms)\nif availability_df.empty is True:\nreturn property_info_array\nfacility_identifiers = availability_df[YellowstoneConfig.FACILITY_ID].unique()\nfor facility_id in facility_identifiers:\napi_endpoint = self._get_api_endpoint(\nurl_path=YellowstoneConfig.YELLOWSTONE_PROPERTY_INFO, query=None\n)\ncampsite_info = self.make_yellowstone_request(\nendpoint=f\"{api_endpoint}/{facility_id}\"\n)\ncampsite_codes = campsite_info.keys()\nfor campsite_code in campsite_codes:\ncampsite_data = campsite_info[campsite_code]\nproperty_info_array.append(\n{\n\"facility_id\": facility_id,\n\"campsite_code\": campsite_code,\n\"campsite_title\": campsite_data[\nYellowstoneConfig.LODGING_TITLE\n],\n\"campsite_type\": campsite_data[\nYellowstoneConfig.FACILITY_TYPE\n].upper(),\n\"capacity\": (\ncampsite_data[YellowstoneConfig.LODGING_OCCUPANCY_BASE],\ncampsite_data[YellowstoneConfig.LODGING_OCCUPANCY_MAX],\n),\n}\n)\nreturn property_info_array\ndef get_monthly_campsites(\nself, month: datetime, nights: Optional[int] = None\n) -&gt; List[AvailableCampsite]:\n\"\"\"\n        Return All Campsites Available in a Given Month\n        Parameters\n        ----------\n        month: datetime\n            Month to Search\n        nights: Optional[int]\n            Search for consecutive nights\n        Returns\n        -------\n        List[AvailableCampsite]\n        \"\"\"\nnow = datetime.now().date()\nsearch_date = month.replace(day=1)\nif month &lt;= now:\nlogger.info(\n\"Cannot input search dates before today, adjusting search parameters.\"\n)\nsearch_date = search_date.replace(\nyear=now.year, month=now.month, day=now.day\n)\navailability_found = self._get_monthly_availability(\nmonth=search_date, nights=nights\n)\navailability = XantResortData(**availability_found)\nmonthly_campsites = self._compile_campground_availabilities(\navailability=availability\n)\ncampsite_data = DataFrame(\nmonthly_campsites, columns=YellowstoneConfig.CAMPSITE_DATA_COLUMNS\n).drop_duplicates()\nif campsite_data.empty is True:\nreturn []\navailable_room_array = self._gather_campsite_specific_availability(\navailable_campsites=monthly_campsites, month=month, nights=nights\n)\navailable_rooms = DataFrame(available_room_array)\nproperty_info = self._get_property_information(\navailable_rooms=available_room_array\n)\nproperties = DataFrame(property_info)\nmerged_campsites = available_rooms.merge(\nproperties,\non=[\nYellowstoneConfig.FACILITY_ID_COLUMN,\nYellowstoneConfig.CAMPSITE_ID_COLUMN,\n],\n)\nmerged_campsites[YellowstoneConfig.BOOKING_DATE_COLUMN] = to_datetime(\nmerged_campsites[YellowstoneConfig.BOOKING_DATE_COLUMN]\n)\nif nights is not None:\nnights_param = {\"nights\": nights}\nelse:\nnights_param = {\"nights\": 1}\nbooking_nights = nights_param.get(\"nights\")\nmerged_campsites[YellowstoneConfig.BOOKING_END_DATE_COLUMN] = merged_campsites[\nYellowstoneConfig.BOOKING_DATE_COLUMN\n] + timedelta(days=booking_nights)\nmerged_campsites[YellowstoneConfig.BOOKING_NIGHTS_COLUMN] = booking_nights\nfinal_campsites = merged_campsites.merge(\ncampsite_data, on=YellowstoneConfig.FACILITY_ID_COLUMN\n).sort_values(by=YellowstoneConfig.BOOKING_DATE_COLUMN)\nfinal_campsites[YellowstoneConfig.BOOKING_URL_COLUMN] = final_campsites.apply(\nlambda x: self._return_lodging_url(\nlodging_code=x.facility_id, month=x.booking_date, params=nights_param\n),\naxis=1,\n)\nall_monthly_campsite_array = self._df_to_campsites(campsite_df=final_campsites)\nreturn all_monthly_campsite_array\n@classmethod\ndef _df_to_campsites(cls, campsite_df: DataFrame) -&gt; List[AvailableCampsite]:\n\"\"\"\n        Transform a DataFrame into an array of AvailableCampsites\n        Parameters\n        ----------\n        campsite_df: DataFrame\n        Returns\n        -------\n        List[AvailableCampsite]\n        \"\"\"\nall_monthly_campsite_array = []\nfor _, row in campsite_df.iterrows():\ncampsite = AvailableCampsite(\ncampsite_id=row[YellowstoneConfig.CAMPSITE_ID_COLUMN],\nbooking_date=row[YellowstoneConfig.BOOKING_DATE_COLUMN],\nbooking_end_date=row[YellowstoneConfig.BOOKING_END_DATE_COLUMN],\nbooking_nights=row[YellowstoneConfig.BOOKING_NIGHTS_COLUMN],\ncampsite_site_name=row[YellowstoneConfig.CAMPSITE_SITE_NAME_COLUMN],\ncampsite_loop_name=YellowstoneConfig.YELLOWSTONE_LOOP_NAME,\ncampsite_type=row[YellowstoneConfig.CAMPSITE_TYPE_COLUMN],\ncampsite_occupancy=row[YellowstoneConfig.CAMPSITE_OCCUPANCY_COLUMN],\ncampsite_use_type=row[YellowstoneConfig.CAMPSITE_USE_TYPE_COLUMN],\navailability_status=YellowstoneConfig.CAMPSITE_AVAILABILITY_STATUS,\nrecreation_area=YellowstoneConfig.YELLOWSTONE_RECREATION_AREA_NAME,\nrecreation_area_id=YellowstoneConfig.YELLOWSTONE_RECREATION_AREA_ID,\nfacility_name=row[YellowstoneConfig.FACILITY_NAME_COLUMN],\nfacility_id=row[YellowstoneConfig.FACILITY_ID_COLUMN],\nbooking_url=row[YellowstoneConfig.BOOKING_URL_COLUMN],\n)\nall_monthly_campsite_array.append(campsite)\nreturn all_monthly_campsite_array\n@classmethod\ndef _ensure_current_month(cls, month: datetime) -&gt; datetime:\n\"\"\"\n        Ensure That We Never Give the Yellowstone API Dates in the past.\n        Parameters\n        ----------\n        month: datetime\n        Returns\n        -------\n        datetime\n        \"\"\"\nyellowstone_timezone = timezone(YellowstoneConfig.YELLOWSTONE_TIMEZONE)\nyellowstone_current_time = datetime.now(yellowstone_timezone).date()\ntoday = datetime(\nyear=yellowstone_current_time.year,\nmonth=yellowstone_current_time.month,\nday=yellowstone_current_time.day,\n).date()\nif today &gt; month:\nmonth = today\nreturn month\ndef find_campgrounds(self, **kwargs) -&gt; List[CampgroundFacility]:\n\"\"\"\n        Print the Campgrounds inside of Yellowstone\n        \"\"\"\nlog_sorted_response(YellowstoneConfig.YELLOWSTONE_CAMPGROUND_OBJECTS)\nreturn YellowstoneConfig.YELLOWSTONE_CAMPGROUND_OBJECTS\n</code></pre>"},{"location":"reference/providers/xanterra/yellowstone_lodging/#camply.providers.xanterra.yellowstone_lodging.Yellowstone.find_campgrounds","title":"<code>find_campgrounds(**kwargs)</code>","text":"<p>Print the Campgrounds inside of Yellowstone</p> Source code in <code>camply/providers/xanterra/yellowstone_lodging.py</code> <pre><code>def find_campgrounds(self, **kwargs) -&gt; List[CampgroundFacility]:\n\"\"\"\n    Print the Campgrounds inside of Yellowstone\n    \"\"\"\nlog_sorted_response(YellowstoneConfig.YELLOWSTONE_CAMPGROUND_OBJECTS)\nreturn YellowstoneConfig.YELLOWSTONE_CAMPGROUND_OBJECTS\n</code></pre>"},{"location":"reference/providers/xanterra/yellowstone_lodging/#camply.providers.xanterra.yellowstone_lodging.Yellowstone.get_monthly_campsites","title":"<code>get_monthly_campsites(month, nights=None)</code>","text":"<p>Return All Campsites Available in a Given Month</p> <p>Parameters:</p> Name Type Description Default <code>month</code> <code>datetime</code> <p>Month to Search</p> required <code>nights</code> <code>Optional[int]</code> <p>Search for consecutive nights</p> <code>None</code> <p>Returns:</p> Type Description <code>List[AvailableCampsite]</code> Source code in <code>camply/providers/xanterra/yellowstone_lodging.py</code> <pre><code>def get_monthly_campsites(\nself, month: datetime, nights: Optional[int] = None\n) -&gt; List[AvailableCampsite]:\n\"\"\"\n    Return All Campsites Available in a Given Month\n    Parameters\n    ----------\n    month: datetime\n        Month to Search\n    nights: Optional[int]\n        Search for consecutive nights\n    Returns\n    -------\n    List[AvailableCampsite]\n    \"\"\"\nnow = datetime.now().date()\nsearch_date = month.replace(day=1)\nif month &lt;= now:\nlogger.info(\n\"Cannot input search dates before today, adjusting search parameters.\"\n)\nsearch_date = search_date.replace(\nyear=now.year, month=now.month, day=now.day\n)\navailability_found = self._get_monthly_availability(\nmonth=search_date, nights=nights\n)\navailability = XantResortData(**availability_found)\nmonthly_campsites = self._compile_campground_availabilities(\navailability=availability\n)\ncampsite_data = DataFrame(\nmonthly_campsites, columns=YellowstoneConfig.CAMPSITE_DATA_COLUMNS\n).drop_duplicates()\nif campsite_data.empty is True:\nreturn []\navailable_room_array = self._gather_campsite_specific_availability(\navailable_campsites=monthly_campsites, month=month, nights=nights\n)\navailable_rooms = DataFrame(available_room_array)\nproperty_info = self._get_property_information(\navailable_rooms=available_room_array\n)\nproperties = DataFrame(property_info)\nmerged_campsites = available_rooms.merge(\nproperties,\non=[\nYellowstoneConfig.FACILITY_ID_COLUMN,\nYellowstoneConfig.CAMPSITE_ID_COLUMN,\n],\n)\nmerged_campsites[YellowstoneConfig.BOOKING_DATE_COLUMN] = to_datetime(\nmerged_campsites[YellowstoneConfig.BOOKING_DATE_COLUMN]\n)\nif nights is not None:\nnights_param = {\"nights\": nights}\nelse:\nnights_param = {\"nights\": 1}\nbooking_nights = nights_param.get(\"nights\")\nmerged_campsites[YellowstoneConfig.BOOKING_END_DATE_COLUMN] = merged_campsites[\nYellowstoneConfig.BOOKING_DATE_COLUMN\n] + timedelta(days=booking_nights)\nmerged_campsites[YellowstoneConfig.BOOKING_NIGHTS_COLUMN] = booking_nights\nfinal_campsites = merged_campsites.merge(\ncampsite_data, on=YellowstoneConfig.FACILITY_ID_COLUMN\n).sort_values(by=YellowstoneConfig.BOOKING_DATE_COLUMN)\nfinal_campsites[YellowstoneConfig.BOOKING_URL_COLUMN] = final_campsites.apply(\nlambda x: self._return_lodging_url(\nlodging_code=x.facility_id, month=x.booking_date, params=nights_param\n),\naxis=1,\n)\nall_monthly_campsite_array = self._df_to_campsites(campsite_df=final_campsites)\nreturn all_monthly_campsite_array\n</code></pre>"},{"location":"reference/providers/xanterra/yellowstone_lodging/#camply.providers.xanterra.yellowstone_lodging.Yellowstone.make_yellowstone_request","title":"<code>make_yellowstone_request(endpoint, params=None)</code>  <code>staticmethod</code>","text":"<p>Try and Retry Fetching Data from the Yellowstone API.</p> <p>Unfortunately this is a required method to request the data since the Yellowstone API doesn't always return data.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>API Endpoint</p> required <code>params</code> <code>Optional[dict]</code> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> Source code in <code>camply/providers/xanterra/yellowstone_lodging.py</code> <pre><code>@staticmethod\ndef make_yellowstone_request(endpoint: str, params: Optional[dict] = None) -&gt; dict:\n\"\"\"\n    Try and Retry Fetching Data from the Yellowstone API.\n    Unfortunately this is a required method to request the data since the\n    Yellowstone API doesn't always return data.\n    Parameters\n    ----------\n    endpoint: str\n        API Endpoint\n    params\n    Returns\n    -------\n    dict\n    \"\"\"\ntry:\ncontent = Yellowstone._try_retry_get_data(endpoint=endpoint, params=params)\nexcept RuntimeError as re:\nraise RuntimeError(f\"error_message: {re}\") from re\nreturn content\n</code></pre>"},{"location":"reference/search/","title":"search","text":"<p>camply search init file</p>"},{"location":"reference/search/base_search/","title":"base_search","text":"<p>Recreation.gov Web Searching Utilities</p>"},{"location":"reference/search/base_search/#camply.search.base_search.BaseCampingSearch","title":"<code>BaseCampingSearch</code>","text":"<p>         Bases: <code>ABC</code></p> <p>Camping Search Object</p> Source code in <code>camply/search/base_search.py</code> <pre><code>class BaseCampingSearch(ABC):\n\"\"\"\n    Camping Search Object\n    \"\"\"\ncampgrounds: List[CampgroundFacility] = []\nlist_campsites_supported: bool = True\nnotifier: Optional[MultiNotifierProvider] = None\ndef __init__(\nself,\nsearch_window: Union[SearchWindow, List[SearchWindow]],\nweekends_only: bool = False,\nnights: int = 1,\noffline_search: bool = False,\noffline_search_path: Optional[str] = None,\ndays_of_the_week: Optional[Sequence[int]] = None,\n**kwargs,\n) -&gt; None:\n\"\"\"\n        Initialize with Search Parameters\n        Parameters\n        ----------\n        search_window: Union[SearchWindow, List[SearchWindow]]\n            Search Window tuple containing start date and End Date\n        weekends_only: bool\n            Whether to only search for Camping availabilities on the weekends (Friday /\n            Saturday nights)\n        nights: int\n            minimum number of consecutive nights to search per campsite,defaults to 1\n        offline_search: bool\n            When set to True, the campsite search will both save the results of the\n            campsites it's found, but also load those campsites before beginning a\n            search for other campsites.\n        offline_search_path: Optional[str]\n            When offline search is set to True, this is the name of the file to be saved/loaded.\n            When not specified, the filename will default to `camply_campsites.json`\n        days_of_the_week: Optional[Sequence[int]]\n            Days of the week (by weekday integer) to search for.\n        \"\"\"\nself._verbose = kwargs.get(\"verbose\", True)\nself.campsite_finder: ProviderType = self.provider_class()\nself.search_window: List[SearchWindow] = make_list(search_window)\nself.days_of_the_week = set(\ndays_of_the_week if days_of_the_week is not None else ()\n)\nself.weekends_only: bool = weekends_only\nif self.weekends_only is True:\nself.days_of_the_week.add(4)\nself.days_of_the_week.add(5)\nif len(self.days_of_the_week) == 0:\nself.days_of_the_week = {0, 1, 2, 3, 4, 5, 6}\nself._original_search_days: List[datetime] = self._get_search_days()\nself._original_search_months: List[\ndatetime\n] = self.campsite_finder.get_search_months(self._original_search_days)\nself.nights = self._validate_consecutive_nights(nights=nights)\nif offline_search_path is not None:\nself.offline_search = True\nelse:\nself.offline_search = offline_search\nself.offline_search_path = self._set_offline_search_path(\nfile_path=offline_search_path\n)\nself.campsites_found: Set[AvailableCampsite] = set()\nself.loaded_campsites: Set[AvailableCampsite] = set()\nif self.offline_search_path.suffixes[-1] == \".json\":\nself.offline_mode: str = \"json\"\nelif self.offline_search_path.suffixes[-1] in [\".pkl\", \".pickle\"]:\nself.offline_mode: str = \"pickle\"\nelse:\nraise CamplyError(\n\"You must provide a `.json` or a `.pickle` / `.pkl` file name for offline searches\"\n)\nif self.offline_search is True:\nlogger.info(\n\"Campsite search is configured to save offline: %s\",\nself.offline_search_path,\n)\nself.campsites_found: Set[\nAvailableCampsite\n] = self.load_campsites_from_file()\nself.loaded_campsites: Set[AvailableCampsite] = self.campsites_found.copy()\n@property\ndef search_days(self) -&gt; List[datetime]:\n\"\"\"\n        Get the Unique Days that need to be Searched\n        \"\"\"\ncurrent_date = datetime.now().date()\nreturn [day for day in self._original_search_days if day &gt;= current_date]\n@property\ndef search_months(self) -&gt; List[datetime]:\n\"\"\"\n        Get the Unique Months that need to be Searched\n        \"\"\"\ncurrent_month = datetime.now().date().replace(day=1)\nreturn [day for day in self._original_search_months if day &gt;= current_month]\n@abstractmethod\ndef get_all_campsites(self) -&gt; List[AvailableCampsite]:\n\"\"\"\n        Perform the Search and Return Matching Availabilities.\n        This method must be implemented\n        on all sub-classes.\n        Returns\n        -------\n        List[AvailableCampsite]\n        \"\"\"\n@property\n@abstractmethod\ndef provider_class(self) -&gt; ProviderType:\n\"\"\"\n        Provider Class Dependency Injection\n        \"\"\"\ndef _get_intersection_date_overlap(\nself,\ndate: datetime,\nperiods: int,\nsearch_days: List[datetime],\n) -&gt; bool:\n\"\"\"\n        Find Date Overlap\n        Parameters\n        ----------\n        date: datetime\n        periods: int\n        search_days: List[datetime]\n        Returns\n        -------\n        bool\n        \"\"\"\ntimestamp_range = date_range(start=date, periods=periods)\ncampsite_date_range = {item.date() for item in timestamp_range}\nintersection = campsite_date_range.intersection(search_days)\nif intersection:\nreturn True\nelse:\nreturn False\ndef _compare_date_overlap(self, campsite: AvailableCampsite) -&gt; bool:\n\"\"\"\n        See whether a campsite should be returned as found\n        Parameters\n        ----------\n        campsite: AvailableCampsite\n        Returns\n        -------\n        bool\n        \"\"\"\nintersection = self._get_intersection_date_overlap(\ndate=campsite.booking_date,\nperiods=campsite.booking_nights,\nsearch_days=self.search_days,\n)\nreturn intersection\ndef _filter_date_overlap(self, campsites: DataFrame) -&gt; pd.DataFrame:\n\"\"\"\n        See whether a campsite should be returned as found\n        Parameters\n        ----------\n        campsites: pd.DataFrame\n        Returns\n        -------\n        pd.DataFrame\n        \"\"\"\nmatches = campsites.apply(\nlambda x: self._get_intersection_date_overlap(\ndate=x.booking_date.to_pydatetime(),\nperiods=x.booking_nights,\nsearch_days=self.search_days,\n),\naxis=1,\n)\nfiltered_campsites = campsites[matches].copy().reset_index(drop=True)\nreturn filtered_campsites\ndef _search_matching_campsites_available(\nself, log: bool = False, verbose: bool = False, raise_error: bool = False\n) -&gt; List[AvailableCampsite]:\n\"\"\"\n        Perform the Search and Return Matching Availabilities\n        Parameters\n        ----------\n        log: bool\n            Whether to log found campsites\n        verbose: bool\n            Used with `log` to enhance the amount of info logged to the console\n        raise_error: bool\n            Whether to raise an error if nothing is found. Defaults to False.\n        Returns\n        -------\n        List[AvailableCampsite]\n        \"\"\"\nmatching_campgrounds = []\nfor camp in self.get_all_campsites():\nif all(\n[\nself._compare_date_overlap(campsite=camp) is True,\ncamp.booking_nights &gt;= self.nights,\n]\n):\nmatching_campgrounds.append(camp)\nlogger.info(\nf\"{(get_emoji(matching_campgrounds) + ' ') * 4}{len(matching_campgrounds)} \"\n\"Reservable Campsites Matching Search Preferences\"\n)\nself.assemble_availabilities(\nmatching_data=matching_campgrounds, log=log, verbose=verbose\n)\nif (\nself.offline_search is True\nand self.loaded_campsites.issuperset(matching_campgrounds)\nand raise_error is True\n):\ncampsite_availability_message = (\n\"No New Campsites were found, we'll continue checking\"\n)\nlogger.info(campsite_availability_message)\nraise CampsiteNotFoundError(campsite_availability_message)\nelif len(matching_campgrounds) == 0 and raise_error is True:\ncampsite_availability_message = (\n\"No Campsites were found, we'll continue checking\"\n)\nlogger.info(campsite_availability_message)\nraise CampsiteNotFoundError(campsite_availability_message)\nreturn matching_campgrounds\n@classmethod\ndef _get_polling_minutes(cls, polling_interval: Optional[int]) -&gt; int:\n\"\"\"\n        Return the Number of Minutes to Search\n        Parameters\n        ----------\n        polling_interval: Optional[int]\n            Used with `continuous=True`, the amount of time to wait between searches.\n            Defaults to 10 if not provided, cannot be less than 5\n        Returns\n        -------\n        int\n        \"\"\"\nif polling_interval is None:\npolling_interval = getenv(\n\"POLLING_INTERVAL\", SearchConfig.RECOMMENDED_POLLING_INTERVAL\n)\nif int(polling_interval) &lt; SearchConfig.POLLING_INTERVAL_MINIMUM:\npolling_interval = SearchConfig.POLLING_INTERVAL_MINIMUM\npolling_interval_minutes = int(round(float(polling_interval), 2))\nreturn polling_interval_minutes\ndef _continuous_search_retry(\nself,\nlog: bool,\nverbose: bool,\npolling_interval: int,\ncontinuous_search_attempts: int,\nnotification_provider: Union[str, List[str], BaseNotifications, None],\nnotify_first_try: bool,\nsearch_once: bool = False,\n) -&gt; List[AvailableCampsite]:\n\"\"\"\n        Search for Campsites until at least one is found\n        Parameters\n        ----------\n        log: bool\n            Whether to log found campsites\n        verbose: bool\n            Used with `log` to enhance the amount of info logged to the console\n        polling_interval: Optional[int]\n            Used with `continuous=True`, the amount of time to wait between searches.\n            Defaults to 10 if not provided, cannot be less than 5\n        continuous_search_attempts: int\n            Number of preexisting search attempts\n        notification_provider: provider: Union[str, List[str]]\n            Used with `continuous=True`, Name of notification provider to use. Accepts\n            \"email\", \"pushover\", and defaults to \"silent\". Also accepts a list or commma\n            separated string of these options or even a notification provider object itself\n        notify_first_try: bool\n            Used with `continuous=True`, whether to send all non-silent notifications if more\n            than 5 matching campsites are found on the first try. Defaults to false which\n            only sends the first 5.\n        search_once: bool\n            Whether to only search once (and not actually continuously)\n        Returns\n        -------\n        List[AvailableCampsite]\n        \"\"\"\npolling_interval_minutes = self._get_polling_minutes(\npolling_interval=polling_interval\n)\nself.notifier = MultiNotifierProvider(provider=notification_provider)\nlogger.info(\nf\"Searching for campsites every {polling_interval_minutes} minutes. \"\n)\nself.notifier.log_providers()\nretryer = tenacity.Retrying(\nretry=tenacity.retry_if_exception_type(CampsiteNotFoundError),\nwait=tenacity.wait.wait_fixed(int(polling_interval_minutes) * 60),\n)\nmatching_campsites = retryer.__call__(\nfn=self._search_matching_campsites_available,\nlog=False,\nverbose=False,\nraise_error=not search_once,\n)\nfound_campsites = set(matching_campsites)\nnew_campsites = found_campsites.difference(self.campsites_found)\nself.assemble_availabilities(\nmatching_data=list(new_campsites), log=log, verbose=verbose\n)\nlogger.info(f\"{len(new_campsites)} New Campsites Found.\")\nself.campsites_found.update(new_campsites)\nlogged_campsites = list(new_campsites)\nself._handle_notifications(\nretryer=retryer,\nnotifier=self.notifier,\nlogged_campsites=logged_campsites,\ncontinuous_search_attempts=continuous_search_attempts,\nnotify_first_try=notify_first_try,\n)\nreturn list(self.campsites_found)\n@classmethod\ndef _handle_notifications(\ncls,\nretryer: tenacity.Retrying,\nnotifier: MultiNotifierProvider,\nlogged_campsites: List[AvailableCampsite],\ncontinuous_search_attempts: int,\nnotify_first_try: bool,\n) -&gt; None:\n\"\"\"\n        Handle sending notifications\n        Parameters\n        ----------\n        retryer: tenacity.Retrying\n        notifier: MultiNotifierProvider\n        logged_campsites: List[AvailableCampsite]\n        continuous_search_attempts: int\n        notify_first_try: bool\n        Returns\n        -------\n        None\n        \"\"\"\nattempt_number = retryer.statistics.get(\"attempt_number\", 1)\nminimum_first_notify = SearchConfig.MINIMUM_CAMPSITES_FIRST_NOTIFY\nif max([attempt_number, continuous_search_attempts]) &gt; 1:\nlogged_campsites = cls._handle_too_many_campsites_found(\nnotifier=notifier, logged_campsites=logged_campsites\n)\nnotifier.send_campsites(campsites=logged_campsites)\nelif attempt_number == 1 and notify_first_try is True:\nlogged_campsites = cls._handle_too_many_campsites_found(\nnotifier=notifier, logged_campsites=logged_campsites\n)\nnotifier.send_campsites(campsites=logged_campsites)\nelse:\nif (\nlen(notifier.providers) &gt; 1\nand len(logged_campsites) &gt; minimum_first_notify\n):\nerror_message = (\nf\"Found more than {minimum_first_notify} \"\nf\"matching campsites ({len(logged_campsites)}) on the \"\n\"first try. Try searching online instead. \"\nf\"camply is only sending the first \"\nf\"{minimum_first_notify} notifications. \"\n\"Go Get your campsite! \ud83c\udfd5\"\n)\nlogger.warning(error_message)\nnotifier.send_message(message=error_message)\nlogged_campsites = logged_campsites[:minimum_first_notify]\nnotifier.send_campsites(campsites=logged_campsites)\n@classmethod\ndef _handle_too_many_campsites_found(\ncls, notifier: MultiNotifierProvider, logged_campsites: List[AvailableCampsite]\n) -&gt; List[AvailableCampsite]:\n\"\"\"\n        Handle Scenarios Where Too Many Campsites are Found\n        Parameters\n        ----------\n        notifier: MultiNotifierProvider\n        logged_campsites: List[AvailableCampsite]\n        Returns\n        -------\n        List[AvailableCampsite]\n        \"\"\"\nlimit = SearchConfig.MAXIMUM_NOTIFICATION_BATCH_SIZE\nnumber_campsites = len(logged_campsites)\nif number_campsites &gt; limit:\nwarning_message = (\nf\"Too many campsites were found during the search ({number_campsites} \"\nf\"total). camply will only send you the first {limit} notifications.\"\n)\nlogger.warning(warning_message)\nrestricted_campsites = logged_campsites[:limit]\nnotifier.send_message(warning_message)\nelse:\nrestricted_campsites = logged_campsites\nreturn restricted_campsites\ndef _search_campsites_continuous(\nself,\nlog: bool = True,\nverbose: bool = False,\npolling_interval: Optional[int] = None,\nnotification_provider: str = \"silent\",\nnotify_first_try: bool = False,\nsearch_forever: bool = False,\nsearch_once: bool = False,\n):\n\"\"\"\n        Continuously Search For Campsites\n        Parameters\n        ----------\n        log: bool\n            Whether to log found campsites\n        verbose: bool\n            Used with `log` to enhance the amount of info logged to the console\n        polling_interval: Optional[int]\n            Used with `continuous=True`, the amount of time to wait between searches.\n            Defaults to 10 if not provided, cannot be less than 5\n        notification_provider: str\n            Used with `continuous=True`, Name of notification provider to use. Accepts\n            \"email\", \"pushover\", and defaults to \"silent\". Also accepts a list or commma\n            separated string of these options or even a notification provider object itself\n        notify_first_try: bool\n            Used with `continuous=True`, whether to send all non-silent notifications if more\n            than 5 matching campsites are found on the first try. Defaults to false which\n            only sends the first 5.\n        search_forever: bool\n            Used with `continuous=True`, This option searches for new campsites forever, with\n            the caveat being that it will never notify about the same campsite.\n        search_once: bool\n            Whether to only search once (and not actually continuously)\n        Returns\n        -------\n        List[AvailableCampsite]\n        \"\"\"\npolling_interval_minutes = self._get_polling_minutes(\npolling_interval=polling_interval\n)\ncontinuous_search = True\ncontinuous_search_attempts = 1\nwhile continuous_search is True:\nstarting_count = len(self.campsites_found)\nself._continuous_search_retry(\nlog=log,\nverbose=verbose,\npolling_interval=polling_interval,\nnotification_provider=notification_provider,\nnotify_first_try=notify_first_try,\ncontinuous_search_attempts=continuous_search_attempts,\nsearch_once=search_once,\n)\nending_count = len(self.campsites_found)\ncontinuous_search_attempts += 1\nif self.offline_search is True and ending_count &gt; starting_count:\nself.unload_campsites_to_file()\nif search_once is True:\ncontinuous_search = False\nelif search_forever is True:\nsleep(int(polling_interval_minutes) * 60)\nelse:\ncontinuous_search = False\nreturn list(self.campsites_found)\ndef get_matching_campsites(\nself,\nlog: bool = True,\nverbose: bool = False,\ncontinuous: bool = False,\npolling_interval: Optional[int] = None,\nnotification_provider: str = \"silent\",\nnotify_first_try: bool = False,\nsearch_forever: bool = False,\nsearch_once: bool = False,\n) -&gt; List[AvailableCampsite]:\n\"\"\"\n        Perform the Search and Return Matching Availabilities\n        Parameters\n        ----------\n        log: bool\n            Whether to log found campsites\n        verbose: bool\n            Used with `log` to enhance the amount of info logged to the console\n        continuous: bool\n            Whether to continue searching beyond just the first time\n        polling_interval: Optional[int]\n            Used with `continuous=True`, the amount of time to wait between searches.\n            Defaults to 10 if not provided, cannot be less than 5\n        notification_provider: str\n            Used with `continuous=True`, Name of notification provider to use. Accepts\n            \"email\", \"pushover\", and defaults to \"silent\". Also accepts a list or commma\n            separated string of these options or even a notification provider object itself\n        notify_first_try: bool\n            Used with `continuous=True`, whether to send all non-silent notifications if more\n            than 5 matching campsites are found on the first try. Defaults to false which\n            only sends the first 5.\n        search_forever: bool\n            Used with `continuous=True`, This option searches for new campsites forever, with\n            the caveat being that it will never notify about the same campsite.\n        search_once: bool\n            Whether to only search once (and not actually continuously)\n        Returns\n        -------\n        List[AvailableCampsite]\n        \"\"\"\nif continuous is True or search_once is True:\ntry:\nself._search_campsites_continuous(\nlog=log,\nverbose=verbose,\npolling_interval=polling_interval,\nnotification_provider=notification_provider,\nnotify_first_try=notify_first_try,\nsearch_forever=search_forever,\nsearch_once=search_once,\n)\nexcept Exception as e:\nself.notifier.last_gasp(error=e)\nraise e\nelse:\nstarting_count = len(self.campsites_found)\nmatching_campsites = self._search_matching_campsites_available(\nlog=log, verbose=True\n)\nself.campsites_found.update(set(matching_campsites))\nending_count = len(self.campsites_found)\nif self.offline_search is True and ending_count &gt; starting_count:\nself.unload_campsites_to_file()\nreturn list(self.campsites_found)\ndef _get_search_days(self) -&gt; List[datetime]:\n\"\"\"\n        Retrieve Specific Days to Search For\n        Returns\n        -------\n        search_days: List[datetime]\n            Datetime days to search for reservations\n        \"\"\"\ncurrent_date = datetime.now().date()\nsearch_nights = set()\nfor window in self.search_window:\ngenerated_dates = {\ndate for date in window.get_date_range() if date &gt;= current_date\n}\nsearch_nights.update(generated_dates)\nsearch_nights: Set[datetime] = {\nx for x in search_nights if x.weekday() in self.days_of_the_week\n}\nmax_nights_to_list = 2\nall_nights = 7\nif len(search_nights) &gt; 0 and self._verbose is True:\nlogger.info(\nf\"{len(search_nights)} booking nights selected for search, \"\nf\"ranging from {min(search_nights)} to {max(search_nights)}\"\n)\nif 0 &lt; len(self.days_of_the_week) &lt;= max_nights_to_list:\nday_mapping = {value: key for key, value in days_of_the_week_base.items()}\nweek_nights = [day_mapping[item] for item in sorted(self.days_of_the_week)]\nlogger.info(\n\"Searching for booking nights on %s\",\n\" and \".join(week_nights),\n)\nelif len(self.days_of_the_week) &lt; all_nights:\nlogger.info(\n\"Searching across %s specific days of the week\",\nlen(self.days_of_the_week),\n)\nelif len(self.days_of_the_week) == all_nights:\npass\nelse:\nlogger.error(SearchConfig.ERROR_MESSAGE)\nraise RuntimeError(SearchConfig.ERROR_MESSAGE)\nreturn sorted(search_nights)\n@classmethod\ndef _consolidate_campsites(\ncls, campsite_df: DataFrame, nights: int\n) -&gt; pd.DataFrame:\n\"\"\"\n        Consolidate Single Night Campsites into Multiple Night Campsites\n        Parameters\n        ----------\n        campsite_df: DataFrame\n            DataFrame of AvailableCampsites\n        Returns\n        -------\n        pd.DataFrame\n        \"\"\"\ncomposed_groupings = []\nfor _, campsite_slice in campsite_df.groupby(\n[CampsiteContainerFields.CAMPSITE_ID, CampsiteContainerFields.CAMPGROUND_ID]\n):\n# SORT THE VALUES AND CREATE A COPIED SLICE\ncampsite_grouping = campsite_slice.sort_values(\nby=CampsiteContainerFields.BOOKING_DATE, ascending=True\n).copy()\n# ASSEMBLE THE CAMPSITES AVAILABILITIES INTO GROUPS THAT ARE CONSECUTIVE\nbooking_date = campsite_grouping[CampsiteContainerFields.BOOKING_DATE]\ndate = Timedelta(\"1d\")\nconsecutive_nights = booking_date.diff() != date\ngroup_identifier = consecutive_nights.cumsum()\ncampsite_grouping[CampsiteContainerFields.CAMPSITE_GROUP] = group_identifier\n# USE THE ASSEMBLED GROUPS TO CREATE UPDATED CAMPSITES AND REMOVE DUPLICATES\nfor _campsite_group, campsite_group_slice in campsite_grouping.groupby(\nCampsiteContainerFields.CAMPSITE_GROUP\n):\ncomposed_grouping = campsite_group_slice.sort_values(\nby=CampsiteContainerFields.BOOKING_DATE, ascending=True\n).copy()\ncomposed_grouping.drop(\ncolumns=[CampsiteContainerFields.CAMPSITE_GROUP], inplace=True\n)\nnightly_breakouts = cls._find_consecutive_nights(\ndataframe=composed_grouping, nights=nights\n)\ncomposed_groupings.append(nightly_breakouts)\nif len(composed_groupings) == 0:\ncomposed_groupings = [DataFrame()]\nreturn concat(composed_groupings, ignore_index=True)\n@classmethod\ndef _consecutive_subseq(cls, iterable: Iterable, length: int) -&gt; Generator:\n\"\"\"\n        Find All Sub Sequences by length Given a List\n        See https://tinyurl.com/5av5unjd\n        Parameters\n        ----------\n        iterable: Iterable\n        length: int\n        Returns\n        -------\n        Generator\n        \"\"\"\nfor _, consec_run in groupby(enumerate(iterable), lambda x: x[0] - x[1]):\nk_wise = tee(map(itemgetter(1), consec_run), length)\nfor n, it in enumerate(k_wise):\nnext(islice(it, n, n), None)\nyield from zip(*k_wise)\n@classmethod\ndef _find_consecutive_nights(cls, dataframe: DataFrame, nights: int) -&gt; DataFrame:\n\"\"\"\n        Explode a DataFrame of Consecutive Nightly Campsite Availabilities,\n        Expand to all unique possibilities given the length of the stay.\n        Parameters\n        ----------\n        dataframe: DataFrame\n        nights: int\n        Returns\n        -------\n        DataFrame\n        \"\"\"\nduplicate_subset = set(dataframe.columns) - AvailableCampsite.__unhashable__\ndataframe_slice = dataframe.copy().reset_index(drop=True)\nnights_indexes = dataframe_slice.booking_date.index\nconsecutive_generator = cls._consecutive_subseq(\niterable=nights_indexes, length=nights\n)\nsequences = list(consecutive_generator)\nconcatted_data = []\nfor sequence in sequences:\nindex_list = list(sequence)\ndata_copy = dataframe_slice.iloc[index_list].copy()\ndata_copy.booking_date = data_copy.booking_date.min()\ndata_copy.booking_end_date = data_copy.booking_end_date.max()\ndata_copy.booking_url = data_copy.booking_url.loc[index_list[0]]\ndata_copy.booking_nights = (\ndata_copy.booking_end_date - data_copy.booking_date\n).dt.days\ndata_copy.drop_duplicates(inplace=True, subset=duplicate_subset)\nconcatted_data.append(data_copy)\nif len(concatted_data) == 0:\nconcatted_data = [DataFrame()]\nreturn concat(concatted_data, ignore_index=True)\ndef _validate_consecutive_nights(self, nights: int) -&gt; int:\n\"\"\"\n        Validate the number of consecutive nights to search\n        Parameters\n        ----------\n        nights : int\n            Number of nights to check\n        Returns\n        -------\n        int\n            The proper number of nights to search\n        \"\"\"\nsearch_days = Series(self.search_days)\nconsecutive_nights = search_days.diff() != Timedelta(\"1d\")\nlargest_grouping = consecutive_nights.cumsum().value_counts().max()\nif nights &gt; 1:\nlogger.info(\nf\"Searching for availabilities with {nights} consecutive night stays.\"\n)\nif nights &gt; largest_grouping:\nlogger.warning(\n\"Too many consecutive nights selected. \"\n\"The consecutive night parameter will be set to \"\nf\"the max possible, {largest_grouping}.\"\n)\nreturn largest_grouping\nelse:\nreturn nights\n@staticmethod\ndef campsites_to_df(campsites: List[AvailableCampsite]) -&gt; DataFrame:\n\"\"\"\n        Convert Campsite Array to\n        Parameters\n        ----------\n        campsites: List[AvailableCampsite]\n        Returns\n        -------\n        DataFrame\n        \"\"\"\ncampsite_df = DataFrame(\ndata=[campsite.dict() for campsite in campsites],\ncolumns=AvailableCampsite.__fields__,\n)\nreturn campsite_df\n@staticmethod\ndef df_to_campsites(campsite_df: DataFrame) -&gt; List[AvailableCampsite]:\n\"\"\"\n        Convert Campsite DataFrame to array of AvailableCampsite objects\n        Parameters\n        ----------\n        campsite_df: DataFrame\n        Returns\n        -------\n        List[AvailableCampsite]\n        \"\"\"\ncomposed_campsite_array = []\ncomposed_campsite_data_array = campsite_df.to_dict(orient=\"records\")\nfor campsite_record in composed_campsite_data_array:\ncampsite_record[\"booking_date\"] = campsite_record[\n\"booking_date\"\n].to_pydatetime()\ncampsite_record[\"booking_end_date\"] = campsite_record[\n\"booking_end_date\"\n].to_pydatetime()\ncomposed_campsite_array.append(AvailableCampsite(**campsite_record))\nreturn composed_campsite_array\n@classmethod\ndef assemble_availabilities(\ncls,\nmatching_data: List[AvailableCampsite],\nlog: bool = True,\nverbose: bool = False,\n) -&gt; DataFrame:\n\"\"\"\n        Prepare a Pandas DataFrame from Array of AvailableCampsite objects\n        Parameters\n        ----------\n        matching_data: List[AvailableCampsite]\n            List of campsites to assemble\n        log: bool\n            Whether to log found campsites\n        verbose: bool\n            Used with `log` to enhance the amount of info logged to the console\n        Returns\n        -------\n        availability_df: DataFrame\n        \"\"\"\navailability_df = cls.campsites_to_df(campsites=matching_data)\nif log is True:\ncls._log_availabilities(availability_df=availability_df, verbose=verbose)\nreturn availability_df\n@classmethod\ndef _log_availabilities(\ncls, availability_df: DataFrame, verbose: bool\n) -&gt; DataFrame:\n\"\"\"\n        Log the Availabilities\n        Parameters\n        ----------\n        availability_df: DataFrame\n        verbose: bool\n        Returns\n        -------\n        DataFrame\n        \"\"\"\nbooking_date: datetime\nfor booking_date, available_sites in availability_df.groupby(\"booking_date\"):\nlogger.info(\nf\"\ud83d\udcc5 {booking_date.strftime('%a, %B %d')} \"\nf\"\ud83c\udfd5  {len(available_sites)} sites\"\n)\nlocation_tuple: tuple\nfor location_tuple, campground_availability in available_sites.groupby(\n[DataColumns.RECREATION_AREA_COLUMN, DataColumns.FACILITY_NAME_COLUMN]\n):\nlogger.info(\nf\"\\t\u26f0\ufe0f  {'  \ud83c\udfd5  '.join(location_tuple)}: \u26fa \"\nf\"{len(campground_availability)} sites\"\n)\nif verbose is True:\nfor (\nbooking_nights,\nnightly_availability,\n) in campground_availability.groupby(\nDataColumns.BOOKING_NIGHTS_COLUMN\n):\nunique_urls = nightly_availability[\nDataColumns.BOOKING_URL_COLUMN\n].unique()\nfor booking_url in sorted(unique_urls):\nlogger.info(\nf\"\\t\\t\ud83d\udd17 {booking_url} \"\nf\"({booking_nights} night\"\nf\"{'s' if booking_nights &gt; 1 else ''})\"\n)\nreturn availability_df\ndef unload_campsites_to_file(self) -&gt; pathlib.Path:\n\"\"\"\n        Unload a BaseSearch Object's campsites to a serialized Pickle file.\n        Returns\n        -------\n        pathlib.Path\n        \"\"\"\nif self.offline_mode == \"pickle\":\nwith open(self.offline_search_path, mode=\"wb\") as file_stream:\npickle.dump(\nobj=self.campsites_found,\nfile=file_stream,\nprotocol=4,\nfix_imports=True,\n)\nfile_stream.seek(0)\nelif self.offline_mode == \"json\":\nwith open(self.offline_search_path, mode=\"w\") as file_stream:\njson.dump(\nobj=self.campsites_found,\nfp=file_stream,\nsort_keys=True,\ndefault=pydantic_encoder,\nindent=4,\n)\nfile_stream.seek(0)\nlogger.debug(\n\"%s campsites saved to file: %s\",\nlen(self.campsites_found),\nself.offline_search_path,\n)\nreturn self.offline_search_path\ndef load_campsites_from_file(self) -&gt; Set[AvailableCampsite]:\n\"\"\"\n        Load a BaseSearch Object's campsites from a serialized Pickle file.\n        Returns\n        -------\n        Set[AvailableCampsite]\n        \"\"\"\nif self.offline_search_path.exists():\nif self.offline_mode == \"pickle\":\nwith open(self.offline_search_path, mode=\"rb\") as file_stream:\ncampsites: Set[AvailableCampsite] = pickle.load(\nfile=file_stream, fix_imports=True\n)\nelif self.offline_mode == \"json\":\nwith open(self.offline_search_path, mode=\"r\") as file_stream:\ncampsites_dicts: List[Dict[str, Any]] = json.load(file_stream)\ncampsites: Set[AvailableCampsite] = {\nAvailableCampsite(**json_dict) for json_dict in campsites_dicts\n}\nif len(campsites) &gt; 0:\nlogger.info(\n\"%s campsites loaded from file: %s\",\nlen(campsites),\nself.offline_search_path,\n)\nelse:\ncampsites = set()\nreturn campsites\n@staticmethod\ndef _set_offline_search_path(file_path: Optional[str]) -&gt; pathlib.Path:\ndefault_file_path = \"camply_campsites.json\"\nif file_path is None:\nfile_path = default_file_path\nreturned_path = pathlib.Path(file_path).resolve()\nparent_dir = pathlib.Path.cwd()\nif all(\n[\nreturned_path.exists(),\nreturned_path.is_file(),\nset(returned_path.suffixes).issubset({\".pkl\", \".pickle\", \".json\"}),\n]\n):\npath_obj = returned_path\nelif all(\n[\nreturned_path.exists(),\nreturned_path.is_dir(),\n]\n):\npath_obj = returned_path.joinpath(default_file_path)\nelif all(\n[\nreturned_path.parent.exists(),\nreturned_path.parent.is_dir(),\n]\n):\npath_obj = returned_path\nelse:\npath_obj = parent_dir.joinpath(file_path)\nif not path_obj.parent.exists():\nraise FileNotFoundError(f\"That directory doesn't exist: {path_obj.parent}\")\nreturn path_obj\n@abstractmethod\ndef list_campsite_units(self) -&gt; Any:\n\"\"\"\n        List Campsite Units\n        Returns\n        -------\n        Any\n        \"\"\"\n@classmethod\ndef log_listed_campsites(\ncls,\ncampsites: Sequence[ListedCampsite],\nfacilities: Sequence[CampgroundFacility],\n) -&gt; None:\n\"\"\"\n        Print the campsites to the console\n        Parameters\n        ----------\n        facilities: List[CampgroundFacility]\n        campsites: List[ListedCampsite]\n        Returns\n        -------\n        None\n        \"\"\"\nlogger.info(\"Found %s campgrounds to search\", len(facilities))\nlogger.info(\"Found %s Campsites\", len(campsites))\nfor facility in sorted(facilities, key=lambda x: x.facility_id):\nlogger.info(\"\ud83c\udfd5  %s - (#%s)\", facility.facility_name, facility.facility_id)\nfor item in campsites:\nif item.facility_id == facility.facility_id:\nlogger.info(\"    \u26fa\ufe0f %s - (#%s)\", item.name, item.id)\n</code></pre>"},{"location":"reference/search/base_search/#camply.search.base_search.BaseCampingSearch.provider_class","title":"<code>provider_class: ProviderType</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Provider Class Dependency Injection</p>"},{"location":"reference/search/base_search/#camply.search.base_search.BaseCampingSearch.search_days","title":"<code>search_days: List[datetime]</code>  <code>property</code>","text":"<p>Get the Unique Days that need to be Searched</p>"},{"location":"reference/search/base_search/#camply.search.base_search.BaseCampingSearch.search_months","title":"<code>search_months: List[datetime]</code>  <code>property</code>","text":"<p>Get the Unique Months that need to be Searched</p>"},{"location":"reference/search/base_search/#camply.search.base_search.BaseCampingSearch.__init__","title":"<code>__init__(search_window, weekends_only=False, nights=1, offline_search=False, offline_search_path=None, days_of_the_week=None, **kwargs)</code>","text":"<p>Initialize with Search Parameters</p> <p>Parameters:</p> Name Type Description Default <code>search_window</code> <code>Union[SearchWindow, List[SearchWindow]]</code> <p>Search Window tuple containing start date and End Date</p> required <code>weekends_only</code> <code>bool</code> <p>Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights)</p> <code>False</code> <code>nights</code> <code>int</code> <p>minimum number of consecutive nights to search per campsite,defaults to 1</p> <code>1</code> <code>offline_search</code> <code>bool</code> <p>When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites.</p> <code>False</code> <code>offline_search_path</code> <code>Optional[str]</code> <p>When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to <code>camply_campsites.json</code></p> <code>None</code> <code>days_of_the_week</code> <code>Optional[Sequence[int]]</code> <p>Days of the week (by weekday integer) to search for.</p> <code>None</code> Source code in <code>camply/search/base_search.py</code> <pre><code>def __init__(\nself,\nsearch_window: Union[SearchWindow, List[SearchWindow]],\nweekends_only: bool = False,\nnights: int = 1,\noffline_search: bool = False,\noffline_search_path: Optional[str] = None,\ndays_of_the_week: Optional[Sequence[int]] = None,\n**kwargs,\n) -&gt; None:\n\"\"\"\n    Initialize with Search Parameters\n    Parameters\n    ----------\n    search_window: Union[SearchWindow, List[SearchWindow]]\n        Search Window tuple containing start date and End Date\n    weekends_only: bool\n        Whether to only search for Camping availabilities on the weekends (Friday /\n        Saturday nights)\n    nights: int\n        minimum number of consecutive nights to search per campsite,defaults to 1\n    offline_search: bool\n        When set to True, the campsite search will both save the results of the\n        campsites it's found, but also load those campsites before beginning a\n        search for other campsites.\n    offline_search_path: Optional[str]\n        When offline search is set to True, this is the name of the file to be saved/loaded.\n        When not specified, the filename will default to `camply_campsites.json`\n    days_of_the_week: Optional[Sequence[int]]\n        Days of the week (by weekday integer) to search for.\n    \"\"\"\nself._verbose = kwargs.get(\"verbose\", True)\nself.campsite_finder: ProviderType = self.provider_class()\nself.search_window: List[SearchWindow] = make_list(search_window)\nself.days_of_the_week = set(\ndays_of_the_week if days_of_the_week is not None else ()\n)\nself.weekends_only: bool = weekends_only\nif self.weekends_only is True:\nself.days_of_the_week.add(4)\nself.days_of_the_week.add(5)\nif len(self.days_of_the_week) == 0:\nself.days_of_the_week = {0, 1, 2, 3, 4, 5, 6}\nself._original_search_days: List[datetime] = self._get_search_days()\nself._original_search_months: List[\ndatetime\n] = self.campsite_finder.get_search_months(self._original_search_days)\nself.nights = self._validate_consecutive_nights(nights=nights)\nif offline_search_path is not None:\nself.offline_search = True\nelse:\nself.offline_search = offline_search\nself.offline_search_path = self._set_offline_search_path(\nfile_path=offline_search_path\n)\nself.campsites_found: Set[AvailableCampsite] = set()\nself.loaded_campsites: Set[AvailableCampsite] = set()\nif self.offline_search_path.suffixes[-1] == \".json\":\nself.offline_mode: str = \"json\"\nelif self.offline_search_path.suffixes[-1] in [\".pkl\", \".pickle\"]:\nself.offline_mode: str = \"pickle\"\nelse:\nraise CamplyError(\n\"You must provide a `.json` or a `.pickle` / `.pkl` file name for offline searches\"\n)\nif self.offline_search is True:\nlogger.info(\n\"Campsite search is configured to save offline: %s\",\nself.offline_search_path,\n)\nself.campsites_found: Set[\nAvailableCampsite\n] = self.load_campsites_from_file()\nself.loaded_campsites: Set[AvailableCampsite] = self.campsites_found.copy()\n</code></pre>"},{"location":"reference/search/base_search/#camply.search.base_search.BaseCampingSearch.assemble_availabilities","title":"<code>assemble_availabilities(matching_data, log=True, verbose=False)</code>  <code>classmethod</code>","text":"<p>Prepare a Pandas DataFrame from Array of AvailableCampsite objects</p> <p>Parameters:</p> Name Type Description Default <code>matching_data</code> <code>List[AvailableCampsite]</code> <p>List of campsites to assemble</p> required <code>log</code> <code>bool</code> <p>Whether to log found campsites</p> <code>True</code> <code>verbose</code> <code>bool</code> <p>Used with <code>log</code> to enhance the amount of info logged to the console</p> <code>False</code> <p>Returns:</p> Name Type Description <code>availability_df</code> <code>DataFrame</code> Source code in <code>camply/search/base_search.py</code> <pre><code>@classmethod\ndef assemble_availabilities(\ncls,\nmatching_data: List[AvailableCampsite],\nlog: bool = True,\nverbose: bool = False,\n) -&gt; DataFrame:\n\"\"\"\n    Prepare a Pandas DataFrame from Array of AvailableCampsite objects\n    Parameters\n    ----------\n    matching_data: List[AvailableCampsite]\n        List of campsites to assemble\n    log: bool\n        Whether to log found campsites\n    verbose: bool\n        Used with `log` to enhance the amount of info logged to the console\n    Returns\n    -------\n    availability_df: DataFrame\n    \"\"\"\navailability_df = cls.campsites_to_df(campsites=matching_data)\nif log is True:\ncls._log_availabilities(availability_df=availability_df, verbose=verbose)\nreturn availability_df\n</code></pre>"},{"location":"reference/search/base_search/#camply.search.base_search.BaseCampingSearch.campsites_to_df","title":"<code>campsites_to_df(campsites)</code>  <code>staticmethod</code>","text":"<p>Convert Campsite Array to</p> <p>Parameters:</p> Name Type Description Default <code>campsites</code> <code>List[AvailableCampsite]</code> required <p>Returns:</p> Type Description <code>DataFrame</code> Source code in <code>camply/search/base_search.py</code> <pre><code>@staticmethod\ndef campsites_to_df(campsites: List[AvailableCampsite]) -&gt; DataFrame:\n\"\"\"\n    Convert Campsite Array to\n    Parameters\n    ----------\n    campsites: List[AvailableCampsite]\n    Returns\n    -------\n    DataFrame\n    \"\"\"\ncampsite_df = DataFrame(\ndata=[campsite.dict() for campsite in campsites],\ncolumns=AvailableCampsite.__fields__,\n)\nreturn campsite_df\n</code></pre>"},{"location":"reference/search/base_search/#camply.search.base_search.BaseCampingSearch.df_to_campsites","title":"<code>df_to_campsites(campsite_df)</code>  <code>staticmethod</code>","text":"<p>Convert Campsite DataFrame to array of AvailableCampsite objects</p> <p>Parameters:</p> Name Type Description Default <code>campsite_df</code> <code>DataFrame</code> required <p>Returns:</p> Type Description <code>List[AvailableCampsite]</code> Source code in <code>camply/search/base_search.py</code> <pre><code>@staticmethod\ndef df_to_campsites(campsite_df: DataFrame) -&gt; List[AvailableCampsite]:\n\"\"\"\n    Convert Campsite DataFrame to array of AvailableCampsite objects\n    Parameters\n    ----------\n    campsite_df: DataFrame\n    Returns\n    -------\n    List[AvailableCampsite]\n    \"\"\"\ncomposed_campsite_array = []\ncomposed_campsite_data_array = campsite_df.to_dict(orient=\"records\")\nfor campsite_record in composed_campsite_data_array:\ncampsite_record[\"booking_date\"] = campsite_record[\n\"booking_date\"\n].to_pydatetime()\ncampsite_record[\"booking_end_date\"] = campsite_record[\n\"booking_end_date\"\n].to_pydatetime()\ncomposed_campsite_array.append(AvailableCampsite(**campsite_record))\nreturn composed_campsite_array\n</code></pre>"},{"location":"reference/search/base_search/#camply.search.base_search.BaseCampingSearch.get_all_campsites","title":"<code>get_all_campsites()</code>  <code>abstractmethod</code>","text":"<p>Perform the Search and Return Matching Availabilities.</p> <p>This method must be implemented on all sub-classes.</p> <p>Returns:</p> Type Description <code>List[AvailableCampsite]</code> Source code in <code>camply/search/base_search.py</code> <pre><code>@abstractmethod\ndef get_all_campsites(self) -&gt; List[AvailableCampsite]:\n\"\"\"\n    Perform the Search and Return Matching Availabilities.\n    This method must be implemented\n    on all sub-classes.\n    Returns\n    -------\n    List[AvailableCampsite]\n    \"\"\"\n</code></pre>"},{"location":"reference/search/base_search/#camply.search.base_search.BaseCampingSearch.get_matching_campsites","title":"<code>get_matching_campsites(log=True, verbose=False, continuous=False, polling_interval=None, notification_provider='silent', notify_first_try=False, search_forever=False, search_once=False)</code>","text":"<p>Perform the Search and Return Matching Availabilities</p> <p>Parameters:</p> Name Type Description Default <code>log</code> <code>bool</code> <p>Whether to log found campsites</p> <code>True</code> <code>verbose</code> <code>bool</code> <p>Used with <code>log</code> to enhance the amount of info logged to the console</p> <code>False</code> <code>continuous</code> <code>bool</code> <p>Whether to continue searching beyond just the first time</p> <code>False</code> <code>polling_interval</code> <code>Optional[int]</code> <p>Used with <code>continuous=True</code>, the amount of time to wait between searches. Defaults to 10 if not provided, cannot be less than 5</p> <code>None</code> <code>notification_provider</code> <code>str</code> <p>Used with <code>continuous=True</code>, Name of notification provider to use. Accepts \"email\", \"pushover\", and defaults to \"silent\". Also accepts a list or commma separated string of these options or even a notification provider object itself</p> <code>'silent'</code> <code>notify_first_try</code> <code>bool</code> <p>Used with <code>continuous=True</code>, whether to send all non-silent notifications if more than 5 matching campsites are found on the first try. Defaults to false which only sends the first 5.</p> <code>False</code> <code>search_forever</code> <code>bool</code> <p>Used with <code>continuous=True</code>, This option searches for new campsites forever, with the caveat being that it will never notify about the same campsite.</p> <code>False</code> <code>search_once</code> <code>bool</code> <p>Whether to only search once (and not actually continuously)</p> <code>False</code> <p>Returns:</p> Type Description <code>List[AvailableCampsite]</code> Source code in <code>camply/search/base_search.py</code> <pre><code>def get_matching_campsites(\nself,\nlog: bool = True,\nverbose: bool = False,\ncontinuous: bool = False,\npolling_interval: Optional[int] = None,\nnotification_provider: str = \"silent\",\nnotify_first_try: bool = False,\nsearch_forever: bool = False,\nsearch_once: bool = False,\n) -&gt; List[AvailableCampsite]:\n\"\"\"\n    Perform the Search and Return Matching Availabilities\n    Parameters\n    ----------\n    log: bool\n        Whether to log found campsites\n    verbose: bool\n        Used with `log` to enhance the amount of info logged to the console\n    continuous: bool\n        Whether to continue searching beyond just the first time\n    polling_interval: Optional[int]\n        Used with `continuous=True`, the amount of time to wait between searches.\n        Defaults to 10 if not provided, cannot be less than 5\n    notification_provider: str\n        Used with `continuous=True`, Name of notification provider to use. Accepts\n        \"email\", \"pushover\", and defaults to \"silent\". Also accepts a list or commma\n        separated string of these options or even a notification provider object itself\n    notify_first_try: bool\n        Used with `continuous=True`, whether to send all non-silent notifications if more\n        than 5 matching campsites are found on the first try. Defaults to false which\n        only sends the first 5.\n    search_forever: bool\n        Used with `continuous=True`, This option searches for new campsites forever, with\n        the caveat being that it will never notify about the same campsite.\n    search_once: bool\n        Whether to only search once (and not actually continuously)\n    Returns\n    -------\n    List[AvailableCampsite]\n    \"\"\"\nif continuous is True or search_once is True:\ntry:\nself._search_campsites_continuous(\nlog=log,\nverbose=verbose,\npolling_interval=polling_interval,\nnotification_provider=notification_provider,\nnotify_first_try=notify_first_try,\nsearch_forever=search_forever,\nsearch_once=search_once,\n)\nexcept Exception as e:\nself.notifier.last_gasp(error=e)\nraise e\nelse:\nstarting_count = len(self.campsites_found)\nmatching_campsites = self._search_matching_campsites_available(\nlog=log, verbose=True\n)\nself.campsites_found.update(set(matching_campsites))\nending_count = len(self.campsites_found)\nif self.offline_search is True and ending_count &gt; starting_count:\nself.unload_campsites_to_file()\nreturn list(self.campsites_found)\n</code></pre>"},{"location":"reference/search/base_search/#camply.search.base_search.BaseCampingSearch.list_campsite_units","title":"<code>list_campsite_units()</code>  <code>abstractmethod</code>","text":"<p>List Campsite Units</p> <p>Returns:</p> Type Description <code>Any</code> Source code in <code>camply/search/base_search.py</code> <pre><code>@abstractmethod\ndef list_campsite_units(self) -&gt; Any:\n\"\"\"\n    List Campsite Units\n    Returns\n    -------\n    Any\n    \"\"\"\n</code></pre>"},{"location":"reference/search/base_search/#camply.search.base_search.BaseCampingSearch.load_campsites_from_file","title":"<code>load_campsites_from_file()</code>","text":"<p>Load a BaseSearch Object's campsites from a serialized Pickle file.</p> <p>Returns:</p> Type Description <code>Set[AvailableCampsite]</code> Source code in <code>camply/search/base_search.py</code> <pre><code>def load_campsites_from_file(self) -&gt; Set[AvailableCampsite]:\n\"\"\"\n    Load a BaseSearch Object's campsites from a serialized Pickle file.\n    Returns\n    -------\n    Set[AvailableCampsite]\n    \"\"\"\nif self.offline_search_path.exists():\nif self.offline_mode == \"pickle\":\nwith open(self.offline_search_path, mode=\"rb\") as file_stream:\ncampsites: Set[AvailableCampsite] = pickle.load(\nfile=file_stream, fix_imports=True\n)\nelif self.offline_mode == \"json\":\nwith open(self.offline_search_path, mode=\"r\") as file_stream:\ncampsites_dicts: List[Dict[str, Any]] = json.load(file_stream)\ncampsites: Set[AvailableCampsite] = {\nAvailableCampsite(**json_dict) for json_dict in campsites_dicts\n}\nif len(campsites) &gt; 0:\nlogger.info(\n\"%s campsites loaded from file: %s\",\nlen(campsites),\nself.offline_search_path,\n)\nelse:\ncampsites = set()\nreturn campsites\n</code></pre>"},{"location":"reference/search/base_search/#camply.search.base_search.BaseCampingSearch.log_listed_campsites","title":"<code>log_listed_campsites(campsites, facilities)</code>  <code>classmethod</code>","text":"<p>Print the campsites to the console</p> <p>Parameters:</p> Name Type Description Default <code>facilities</code> <code>Sequence[CampgroundFacility]</code> required <code>campsites</code> <code>Sequence[ListedCampsite]</code> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>camply/search/base_search.py</code> <pre><code>@classmethod\ndef log_listed_campsites(\ncls,\ncampsites: Sequence[ListedCampsite],\nfacilities: Sequence[CampgroundFacility],\n) -&gt; None:\n\"\"\"\n    Print the campsites to the console\n    Parameters\n    ----------\n    facilities: List[CampgroundFacility]\n    campsites: List[ListedCampsite]\n    Returns\n    -------\n    None\n    \"\"\"\nlogger.info(\"Found %s campgrounds to search\", len(facilities))\nlogger.info(\"Found %s Campsites\", len(campsites))\nfor facility in sorted(facilities, key=lambda x: x.facility_id):\nlogger.info(\"\ud83c\udfd5  %s - (#%s)\", facility.facility_name, facility.facility_id)\nfor item in campsites:\nif item.facility_id == facility.facility_id:\nlogger.info(\"    \u26fa\ufe0f %s - (#%s)\", item.name, item.id)\n</code></pre>"},{"location":"reference/search/base_search/#camply.search.base_search.BaseCampingSearch.unload_campsites_to_file","title":"<code>unload_campsites_to_file()</code>","text":"<p>Unload a BaseSearch Object's campsites to a serialized Pickle file.</p> <p>Returns:</p> Type Description <code>pathlib.Path</code> Source code in <code>camply/search/base_search.py</code> <pre><code>def unload_campsites_to_file(self) -&gt; pathlib.Path:\n\"\"\"\n    Unload a BaseSearch Object's campsites to a serialized Pickle file.\n    Returns\n    -------\n    pathlib.Path\n    \"\"\"\nif self.offline_mode == \"pickle\":\nwith open(self.offline_search_path, mode=\"wb\") as file_stream:\npickle.dump(\nobj=self.campsites_found,\nfile=file_stream,\nprotocol=4,\nfix_imports=True,\n)\nfile_stream.seek(0)\nelif self.offline_mode == \"json\":\nwith open(self.offline_search_path, mode=\"w\") as file_stream:\njson.dump(\nobj=self.campsites_found,\nfp=file_stream,\nsort_keys=True,\ndefault=pydantic_encoder,\nindent=4,\n)\nfile_stream.seek(0)\nlogger.debug(\n\"%s campsites saved to file: %s\",\nlen(self.campsites_found),\nself.offline_search_path,\n)\nreturn self.offline_search_path\n</code></pre>"},{"location":"reference/search/search_going_to_camp/","title":"search_going_to_camp","text":"<p>Going To Camp API search utilities</p>"},{"location":"reference/search/search_going_to_camp/#camply.search.search_going_to_camp.SearchGoingToCamp","title":"<code>SearchGoingToCamp</code>","text":"<p>         Bases: <code>BaseCampingSearch</code></p> <p>Searches on GoingToCamp.com for Campsites</p> Source code in <code>camply/search/search_going_to_camp.py</code> <pre><code>class SearchGoingToCamp(BaseCampingSearch):\n\"\"\"\n    Searches on GoingToCamp.com for Campsites\n    \"\"\"\nprovider_class = GoingToCamp\nlist_campsites_supported: bool = False\n@classmethod\ndef find_recreation_areas(\ncls, search_string: str, **kwargs\n) -&gt; List[RecreationArea]:\n\"\"\"\n        Return the GoingToCamp Recreation Areas\n        \"\"\"\nreturn GoingToCamp.find_recreation_areas(search_string=search_string)\n# noinspection PyUnusedLocal\ndef __init__(\nself,\nsearch_window: Union[SearchWindow, List[SearchWindow]],\nrecreation_area: List[int],\ncampsites: Optional[Union[List[int], int]] = None,\nweekends_only: bool = False,\ncampgrounds: Optional[Union[List[str], str]] = None,\nequipment_id: Optional[int] = None,\nnights: int = 1,\n**kwargs,\n) -&gt; None:\n\"\"\"\n        Initialize with Search Parameters\n        Parameters\n        ----------\n        search_window: Union[SearchWindow, List[SearchWindow]]\n            Search Window tuple containing start date and End Date\n        recreation_area: List[int]\n            The ID of the recreation area to be searched. This type of this is a\n            List[int], but only for compatability with the BaseCampingSeach API.\n            This list is validated to contain a single recreation area.\n        weekends_only: bool\n            Whether to only search for Camping availabilities on the weekends (Friday /\n            Saturday nights)\n        campgrounds: Union[List[int], int]\n            Campground ID or List of Campground IDs\n        nights: int\n            minimum number of consecutive nights to search per campsite,defaults to 1\n        \"\"\"\nself.provider = GoingToCamp\nsuper().__init__(\nsearch_window=search_window,\nweekends_only=weekends_only,\nnights=nights,\n**kwargs,\n)\nself._recreation_area_id = self._validate_rec_area(recreation_area)\nself._campgrounds = campgrounds\nself.weekends_only = weekends_only\nassert (\nany(\n[\ncampsites not in [[], None],\ncampgrounds not in [[], None],\nrecreation_area is not None,\n]\n)\nis True\n)\nself.campsites = make_list(campsites)\nself.equipment_id = self._validate_equipment(\nequipment_id, self._recreation_area_id\n)\nself.campgrounds = self._get_searchable_campgrounds()\n@classmethod\ndef _validate_rec_area(cls, recreation_area: int) -&gt; int:\nif recreation_area in [(), [], None]:\nlogger.error(\"At least one --rec-area must be provided\")\nsys.exit(1)\nif is_list_like(recreation_area) is True and len(recreation_area) &gt; 1:\nlogger.error(\n\"Going To Camp only allows a single recreation area to be searched at a time\"\n)\nsys.exit(1)\nreturn int(make_list(recreation_area)[0])\n@classmethod\ndef _validate_equipment(cls, equipment_id: Optional[int], rec_area: int):\nif not equipment_id:\nreturn\ntry:\nreturn int(equipment_id)\nexcept ValueError:\nlogger.error(\n\"Invalid equipment ID. Use the follwoing to get list of \"\n\"equipment types: \"\nf\"`camply equipment-types --provider goingtocamp --rec-area {rec_area}`\"\n)\nsys.exit(1)\ndef get_all_campsites(self) -&gt; List[AvailableCampsite]:\n\"\"\"\n        Search for all campsites matching search criteria.\n        Because Going To Camp has no efficient way of filtering\n        campsites for multiple campgrounds, this function is limited to listening\n        all campsites _within_ a cammpground. Iterating through all sites for\n        all campgrounds would likely lead to abuse complaints.\n        Returns\n        -------\n        List[AvailableCampsite]\n        \"\"\"\navailable_sites = []\nfor search_window in self.search_window:\ncurrent_start_date = search_window.get_current_start_date()\nfor campground in self.campgrounds:\nsites = self.campsite_finder.list_site_availability(\ncampground=campground,\nstart_date=current_start_date,\nend_date=search_window.end_date,\nequipment_type_id=self.equipment_id,\n)\nfor site in sites:\nsite_details = self.campsite_finder.get_site_details(\nself._recreation_area_id, site.resource_id\n)\nnights = (search_window.end_date - current_start_date).days\nstart_dt = datetime.combine(current_start_date, time.min)\nend_dt = datetime.combine(search_window.end_date, time.min)\n(\nrec_area_domain_name,\nrec_area,\n) = self.campsite_finder.rec_area_lookup(\nrec_area_id=self._recreation_area_id\n)\nbooking_url = self.campsite_finder.get_reservation_link(\nrec_area_domain_name,\nresource_location_id=campground.facility_id,\nmap_id=site.map_id,\nequipment_id=NON_GROUP_EQUIPMENT,\nsub_equipment_id=self.equipment_id,\nparty_size=1,\nstart_date=current_start_date,\nend_date=search_window.end_date,\n)\n# Some rec areas have zero-capacity sites, which should not\n# be viable for camping. Skip all zero-capacity sites.\nif (\nnot site_details[\"minCapacity\"]\nor not site_details[\"maxCapacity\"]\n):\ncontinue\navailable_sites.append(\nAvailableCampsite(\ncampsite_id=site_details[\"resourceId\"],\ncampsite_site_name=site_details[\"localizedValues\"][0][\n\"name\"\n],\nbooking_date=start_dt,\nbooking_end_date=end_dt,\nbooking_nights=nights,\ncampsite_loop_name=\"Unknown\",\ncampsite_type=site_details[\"site_attributes\"].get(\n\"Service Type\", \"Unknown\"\n),\ncampsite_occupancy=(\nsite_details[\"minCapacity\"],\nsite_details[\"maxCapacity\"],\n),\ncampsite_use_type=\"N/A\",\navailability_status=\"Available\",\nrecreation_area=rec_area.recreation_area,\nrecreation_area_id=self._recreation_area_id,\nfacility_name=campground.facility_name,\nfacility_id=campground.facility_id,\nbooking_url=booking_url,\n)\n)\nreturn available_sites\ndef _get_searchable_campgrounds(self) -&gt; List[CampgroundFacility]:\n\"\"\"\n        Return a List of Campgrounds to search\n        Returns\n        -------\n        searchable_campgrounds: List[CampgroundFacility]\n            List of searchable campgrounds\n        \"\"\"\nif self._campgrounds in [(), [], None] or not self._recreation_area_id:\nlogger.error(\n\"You must provide a Campground and Recreation Area to\"\n\" search campsites with this provider\"\n)\nsys.exit(1)\nif self.campsites not in [(), [], None]:\nself.campsites = [int(campsite_id) for campsite_id in self.campsites]\nreturn self._get_campgrounds_by_campsite_id()\nreturn self._get_campgrounds_by_recreation_area_id()\ndef _get_campgrounds_by_recreation_area_id(self) -&gt; List[CampgroundFacility]:\n\"\"\"\n        Return a List of Campgrounds to search when provided with Recreation Area IDs\n        Returns\n        -------\n        campgrounds: List[CampgroundFacility]\n        \"\"\"\nif self._campgrounds not in [(), [], None]:\nreturn self.campsite_finder.find_campgrounds(\nrec_area_id=self._recreation_area_id, campground_id=self._campgrounds\n)\nreturn self.campsite_finder.find_campgrounds(\nrec_area_id=self._recreation_area_id,\n)\ndef list_campsite_units(self) -&gt; Any:\n\"\"\"\n        List Campsite Units\n        Returns\n        -------\n        Any\n        \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"reference/search/search_going_to_camp/#camply.search.search_going_to_camp.SearchGoingToCamp.__init__","title":"<code>__init__(search_window, recreation_area, campsites=None, weekends_only=False, campgrounds=None, equipment_id=None, nights=1, **kwargs)</code>","text":"<p>Initialize with Search Parameters</p> <p>Parameters:</p> Name Type Description Default <code>search_window</code> <code>Union[SearchWindow, List[SearchWindow]]</code> <p>Search Window tuple containing start date and End Date</p> required <code>recreation_area</code> <code>List[int]</code> <p>The ID of the recreation area to be searched. This type of this is a List[int], but only for compatability with the BaseCampingSeach API. This list is validated to contain a single recreation area.</p> required <code>weekends_only</code> <code>bool</code> <p>Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights)</p> <code>False</code> <code>campgrounds</code> <code>Optional[Union[List[str], str]]</code> <p>Campground ID or List of Campground IDs</p> <code>None</code> <code>nights</code> <code>int</code> <p>minimum number of consecutive nights to search per campsite,defaults to 1</p> <code>1</code> Source code in <code>camply/search/search_going_to_camp.py</code> <pre><code>def __init__(\nself,\nsearch_window: Union[SearchWindow, List[SearchWindow]],\nrecreation_area: List[int],\ncampsites: Optional[Union[List[int], int]] = None,\nweekends_only: bool = False,\ncampgrounds: Optional[Union[List[str], str]] = None,\nequipment_id: Optional[int] = None,\nnights: int = 1,\n**kwargs,\n) -&gt; None:\n\"\"\"\n    Initialize with Search Parameters\n    Parameters\n    ----------\n    search_window: Union[SearchWindow, List[SearchWindow]]\n        Search Window tuple containing start date and End Date\n    recreation_area: List[int]\n        The ID of the recreation area to be searched. This type of this is a\n        List[int], but only for compatability with the BaseCampingSeach API.\n        This list is validated to contain a single recreation area.\n    weekends_only: bool\n        Whether to only search for Camping availabilities on the weekends (Friday /\n        Saturday nights)\n    campgrounds: Union[List[int], int]\n        Campground ID or List of Campground IDs\n    nights: int\n        minimum number of consecutive nights to search per campsite,defaults to 1\n    \"\"\"\nself.provider = GoingToCamp\nsuper().__init__(\nsearch_window=search_window,\nweekends_only=weekends_only,\nnights=nights,\n**kwargs,\n)\nself._recreation_area_id = self._validate_rec_area(recreation_area)\nself._campgrounds = campgrounds\nself.weekends_only = weekends_only\nassert (\nany(\n[\ncampsites not in [[], None],\ncampgrounds not in [[], None],\nrecreation_area is not None,\n]\n)\nis True\n)\nself.campsites = make_list(campsites)\nself.equipment_id = self._validate_equipment(\nequipment_id, self._recreation_area_id\n)\nself.campgrounds = self._get_searchable_campgrounds()\n</code></pre>"},{"location":"reference/search/search_going_to_camp/#camply.search.search_going_to_camp.SearchGoingToCamp.find_recreation_areas","title":"<code>find_recreation_areas(search_string, **kwargs)</code>  <code>classmethod</code>","text":"<p>Return the GoingToCamp Recreation Areas</p> Source code in <code>camply/search/search_going_to_camp.py</code> <pre><code>@classmethod\ndef find_recreation_areas(\ncls, search_string: str, **kwargs\n) -&gt; List[RecreationArea]:\n\"\"\"\n    Return the GoingToCamp Recreation Areas\n    \"\"\"\nreturn GoingToCamp.find_recreation_areas(search_string=search_string)\n</code></pre>"},{"location":"reference/search/search_going_to_camp/#camply.search.search_going_to_camp.SearchGoingToCamp.get_all_campsites","title":"<code>get_all_campsites()</code>","text":"<p>Search for all campsites matching search criteria.</p> <p>Because Going To Camp has no efficient way of filtering campsites for multiple campgrounds, this function is limited to listening all campsites within a cammpground. Iterating through all sites for all campgrounds would likely lead to abuse complaints.</p> <p>Returns:</p> Type Description <code>List[AvailableCampsite]</code> Source code in <code>camply/search/search_going_to_camp.py</code> <pre><code>def get_all_campsites(self) -&gt; List[AvailableCampsite]:\n\"\"\"\n    Search for all campsites matching search criteria.\n    Because Going To Camp has no efficient way of filtering\n    campsites for multiple campgrounds, this function is limited to listening\n    all campsites _within_ a cammpground. Iterating through all sites for\n    all campgrounds would likely lead to abuse complaints.\n    Returns\n    -------\n    List[AvailableCampsite]\n    \"\"\"\navailable_sites = []\nfor search_window in self.search_window:\ncurrent_start_date = search_window.get_current_start_date()\nfor campground in self.campgrounds:\nsites = self.campsite_finder.list_site_availability(\ncampground=campground,\nstart_date=current_start_date,\nend_date=search_window.end_date,\nequipment_type_id=self.equipment_id,\n)\nfor site in sites:\nsite_details = self.campsite_finder.get_site_details(\nself._recreation_area_id, site.resource_id\n)\nnights = (search_window.end_date - current_start_date).days\nstart_dt = datetime.combine(current_start_date, time.min)\nend_dt = datetime.combine(search_window.end_date, time.min)\n(\nrec_area_domain_name,\nrec_area,\n) = self.campsite_finder.rec_area_lookup(\nrec_area_id=self._recreation_area_id\n)\nbooking_url = self.campsite_finder.get_reservation_link(\nrec_area_domain_name,\nresource_location_id=campground.facility_id,\nmap_id=site.map_id,\nequipment_id=NON_GROUP_EQUIPMENT,\nsub_equipment_id=self.equipment_id,\nparty_size=1,\nstart_date=current_start_date,\nend_date=search_window.end_date,\n)\n# Some rec areas have zero-capacity sites, which should not\n# be viable for camping. Skip all zero-capacity sites.\nif (\nnot site_details[\"minCapacity\"]\nor not site_details[\"maxCapacity\"]\n):\ncontinue\navailable_sites.append(\nAvailableCampsite(\ncampsite_id=site_details[\"resourceId\"],\ncampsite_site_name=site_details[\"localizedValues\"][0][\n\"name\"\n],\nbooking_date=start_dt,\nbooking_end_date=end_dt,\nbooking_nights=nights,\ncampsite_loop_name=\"Unknown\",\ncampsite_type=site_details[\"site_attributes\"].get(\n\"Service Type\", \"Unknown\"\n),\ncampsite_occupancy=(\nsite_details[\"minCapacity\"],\nsite_details[\"maxCapacity\"],\n),\ncampsite_use_type=\"N/A\",\navailability_status=\"Available\",\nrecreation_area=rec_area.recreation_area,\nrecreation_area_id=self._recreation_area_id,\nfacility_name=campground.facility_name,\nfacility_id=campground.facility_id,\nbooking_url=booking_url,\n)\n)\nreturn available_sites\n</code></pre>"},{"location":"reference/search/search_going_to_camp/#camply.search.search_going_to_camp.SearchGoingToCamp.list_campsite_units","title":"<code>list_campsite_units()</code>","text":"<p>List Campsite Units</p> <p>Returns:</p> Type Description <code>Any</code> Source code in <code>camply/search/search_going_to_camp.py</code> <pre><code>def list_campsite_units(self) -&gt; Any:\n\"\"\"\n    List Campsite Units\n    Returns\n    -------\n    Any\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"reference/search/search_recreationdotgov/","title":"search_recreationdotgov","text":"<p>Recreation.gov Web Searching Utilities</p>"},{"location":"reference/search/search_recreationdotgov/#camply.search.search_recreationdotgov.SearchRecreationDotGov","title":"<code>SearchRecreationDotGov</code>","text":"<p>         Bases: <code>SearchRecreationDotGovBase</code></p> <p>Searches on Recreation.gov for Campsites (default provider)</p> Source code in <code>camply/search/search_recreationdotgov.py</code> <pre><code>class SearchRecreationDotGov(SearchRecreationDotGovBase):\n\"\"\"\n    Searches on Recreation.gov for Campsites (default provider)\n    \"\"\"\nprovider_class = RecreationDotGov\n</code></pre>"},{"location":"reference/search/search_recreationdotgov/#camply.search.search_recreationdotgov.SearchRecreationDotGovBase","title":"<code>SearchRecreationDotGovBase</code>","text":"<p>         Bases: <code>BaseCampingSearch</code>, <code>ABC</code></p> <p>Camping Search Object</p> Source code in <code>camply/search/search_recreationdotgov.py</code> <pre><code>class SearchRecreationDotGovBase(BaseCampingSearch, ABC):\n\"\"\"\n    Camping Search Object\n    \"\"\"\naccepted_equipment: Optional[\nList[str]\n] = EquipmentOptions.__all_accepted_equipment__\ndef __init__(\nself,\nsearch_window: Union[SearchWindow, List[SearchWindow]],\nrecreation_area: Optional[Union[List[int], int]] = None,\ncampgrounds: Optional[Union[List[int], int]] = None,\ncampsites: Optional[Union[List[int], int]] = None,\nweekends_only: bool = False,\nnights: int = 1,\nequipment: Optional[List[Tuple[str, Optional[int]]]] = None,\noffline_search: bool = False,\noffline_search_path: Optional[str] = None,\n**kwargs,\n) -&gt; None:\n\"\"\"\n        Initialize with Search Parameters\n        Parameters\n        ----------\n        search_window: Union[SearchWindow, List[SearchWindow]]\n            Search Window tuple containing start date and End Date\n        recreation_area: Optional[Union[List[int], int]]\n            ID of Recreation Area (i.e. 2907 - Rocky Mountain National Park)\n        campgrounds: Optional[Union[List[int], int]]\n            Campground ID or List of Campground IDs\n        campsites: Optional[Union[List[int], int]]\n            Campsite ID or List of Campsite IDs\n        weekends_only: bool\n            Whether to only search for Camping availabilities on the weekends (Friday /\n            Saturday nights)\n        nights: int\n            minimum number of consecutive nights to search per campsite,defaults to 1\n        equipment: Optional[List[Tuple[str, Optional[int]]]]\n            List of Tuples of Equipment to Search for. An equipment tuple array looks\n            like this: `[(\"Tent\", None), (\"RV\", 20)]` - meaning the selected search\n            looks for sites to accommodate any tent size and RVs less than or equal\n            to 20 feet. Tuples contain the Equipment name and an optional equipment\n            length, otherwise provide None. Equipment names include `Tent`, `RV`,\n            `Trailer`, `Vehicle` and are not case-sensitive.\n        offline_search: bool\n            When set to True, the campsite search will both save the results of the\n            campsites it's found, but also load those campsites before beginning a\n            search for other campsites.\n        offline_search_path: Optional[str]\n            When offline search is set to True, this is the name of the file to be saved/loaded.\n            When not specified, the filename will default to `camply_campsites.json`\n        \"\"\"\nsuper(SearchRecreationDotGovBase, self).__init__(\nsearch_window=search_window,\nweekends_only=weekends_only,\nnights=nights,\noffline_search=offline_search,\noffline_search_path=offline_search_path,\n**kwargs,\n)\nself.campsite_finder: RecreationDotGov\nself._recreation_area_id = make_list(recreation_area)\nself._campground_object = campgrounds\nself.weekends_only = weekends_only\nassert (\nany(\n[\ncampsites not in [[], None],\ncampgrounds not in [[], None],\nrecreation_area is not None,\n]\n)\nis True\n)\nself.campsites = make_list(campsites)\nself.campgrounds = self._get_searchable_campgrounds()\nself.campsite_metadata: Optional[pd.DataFrame] = None\nself.equipment: List[Tuple[str, Optional[int]]] = []\nself.equipment = self._get_searchable_equipment(equipment=equipment)\ndef _get_searchable_campgrounds(self) -&gt; List[CampgroundFacility]:\n\"\"\"\n        Return a List of Campgrounds to search\n        This handles scenarios where a recreation area is provided instead\n        of a campground list\n        Returns\n        -------\n        searchable_campgrounds: List[int]\n            List of searchable campground IDs\n        \"\"\"\nif self.campsites not in [(), [], None]:\nself.campsites = [int(campsite_id) for campsite_id in self.campsites]\nsearchable_campgrounds = self._get_campgrounds_by_campsite_id()\nelif self._campground_object not in [(), [], None]:\nsearchable_campgrounds = self._get_campgrounds_by_campground_id()\nelif self._recreation_area_id not in [(), [], None]:\nsearchable_campgrounds = self._get_campgrounds_by_recreation_area_id()\nelse:\nraise RuntimeError(\"You must provide a Campground or Recreation Area ID\")\nreturn list(set(searchable_campgrounds))\n@classmethod\ndef _get_searchable_equipment(\ncls, equipment: Optional[List[Tuple[str, Optional[int]]]]\n) -&gt; Optional[List[Tuple[str, Optional[int]]]]:\n\"\"\"\n        Sort through and validate Equipment\n        Parameters\n        ----------\n        equipment: Optional[List[Tuple[str, Optional[int]]]]\n        Returns\n        -------\n        Optional[List[Tuple[str, Optional[int]]]]\n        \"\"\"\nequipment_names = []\nfinal_equipment = None\nif isinstance(equipment, (list, tuple)):\nfinal_equipment = []\nfor equipment_name, equipment_length in equipment:\nif (\ncls.accepted_equipment\n== EquipmentOptions.__all_accepted_equipment__\nand equipment_name.lower() not in cls.accepted_equipment\n):\nlogger.warning(\nf\"Equipment name not recognized: {equipment_name}. This won't \"\n\"be used for filtering. \"\n\"Acceptable options are: \"\nf\"{', '.join(cls.accepted_equipment)}\"\n)\nelif (\ncls.accepted_equipment == EquipmentConfig.TIMESTAMP_EQUIPMENT\nand equipment_name not in EquipmentConfig.TIMESTAMP_EQUIPMENT\n):\nlogger.warning(\n'Invalid Timestamp supplied, \"%s\". This won\\'t be used for filtering',\nequipment_name,\n)\nelse:\nfinal_equipment.append((equipment_name, equipment_length))\nequipment_names.append(equipment_name)\nif len(final_equipment) &gt; 0:\nlogger.info(\nf\"Filtering Campsites based on Equipment: {' | '.join(equipment_names)}\"\n)\nreturn final_equipment\ndef _get_campgrounds_by_campground_id(self) -&gt; List[CampgroundFacility]:\n\"\"\"\n        Return a List of Campgrounds to search when provided with campground IDs\n        Returns\n        -------\n        returned_sites: List[int]\n            List of searchable campground IDs\n        \"\"\"\ncampground_list = make_list(self._campground_object)\nfacilities = self.campsite_finder.find_campgrounds(\ncampground_id=campground_list\n)\nreturn facilities\ndef _get_campgrounds_by_campsite_id(self) -&gt; List[CampgroundFacility]:\n\"\"\"\n        Return a List of Campgrounds to search when provided with Campsite IDs\n        Returns\n        -------\n        returned_sites: List[int]\n            List of searchable campground IDs\n        \"\"\"\ncampsite_list = make_list(self.campsites)\nfacilities = self.campsite_finder.find_campgrounds(campsite_id=campsite_list)\nreturn facilities\ndef _get_campgrounds_by_recreation_area_id(self) -&gt; List[CampgroundFacility]:\n\"\"\"\n        Return a List of Campgrounds to search when provided with Recreation Area IDs\n        Returns\n        -------\n        campgrounds: List[CampgroundFacility]\n        \"\"\"\ncampgrounds = []\nfor rec_area in self._recreation_area_id:\ncampground_array = self.campsite_finder.find_facilities_per_recreation_area(\nrec_area_id=rec_area\n)\ncampgrounds += campground_array\nreturn campgrounds\ndef get_all_campsites(self) -&gt; List[AvailableCampsite]:\n\"\"\"\n        Perform the Search and Return All Monthly Availabilities\n        Returns\n        -------\n        List[AvailableCampsite]\n        \"\"\"\nfound_campsites = []\nif len(self.campgrounds) == 0:\nerror_message = \"No campgrounds found to search\"\nlogger.error(error_message)\nraise SearchError(error_message)\nlogger.info(f\"Searching across {len(self.campgrounds)} campgrounds\")\nif self.campsite_metadata is None:\nself.campsite_metadata = (\nself.campsite_finder.get_internal_campsite_metadata(\nfacility_ids=[facil.facility_id for facil in self.campgrounds]\n)\n)\nlogger.info(\n\"Metadata fetched for %s campsites\", len(self.campsite_metadata)\n)\nfor index, campground in enumerate(self.campgrounds):\nfor month in self.search_months:\nlogger.info(\nf\"Searching {campground.facility_name}, {campground.recreation_area} \"\nf\"({campground.facility_id}) for availability: \"\nf\"{month.strftime('%B, %Y')}\"\n)\navailabilities = self.campsite_finder.get_recdotgov_data(\ncampground_id=campground.facility_id, month=month\n)\ncampsites = self.campsite_finder.process_campsite_availability(\navailability=availabilities,\nrecreation_area=campground.recreation_area,\nrecreation_area_id=campground.recreation_area_id,\nfacility_name=campground.facility_name,\nfacility_id=campground.facility_id,\nmonth=month,\ncampsite_metadata=self.campsite_metadata,\n)\nlogger.info(\nf\"\\t{logging_utils.get_emoji(campsites)}\\t\"\nf\"{len(campsites)} total sites found in month of \"\nf\"{month.strftime('%B')}\"\n)\nif self.campsites not in [None, []]:\ncampsites = [\ncampsite_obj\nfor campsite_obj in campsites\nif int(campsite_obj.campsite_id) in self.campsites\n]\nfound_campsites += campsites\nif index + 1 &lt; len(self.campgrounds):\nsleep(round(uniform(*RecreationBookingConfig.RATE_LIMITING), 2))\ncampsite_df = self.campsites_to_df(campsites=found_campsites)\ncampsite_df_validated = self._filter_date_overlap(campsites=campsite_df)\ncompiled_campsite_df = self._consolidate_campsites(\ncampsite_df=campsite_df_validated, nights=self.nights\n)\nequipment_filtered_campsites = self.filter_campsites_to_equipment(\ncampsites=compiled_campsite_df\n)\ncompiled_campsites = self.df_to_campsites(\ncampsite_df=equipment_filtered_campsites\n)\nreturn compiled_campsites\ndef filter_campsites_to_equipment(self, campsites: pd.DataFrame) -&gt; pd.DataFrame:\n\"\"\"\n        Filter a Campsite DataFrame down to specified equipment\n        Parameters\n        ----------\n        campsites: pd.DataFrame\n        Returns\n        -------\n        pd.DataFrame\n        \"\"\"\nif self.equipment is None or len(self.equipment) == 0 or len(campsites) == 0:\nreturn campsites\ncolumn_names = [\"campsite_id\", \"permitted_equipment\"]\nexploded_data = campsites[column_names].explode(\"permitted_equipment\")\nexpanded_data = exploded_data[\"permitted_equipment\"].apply(pd.Series)\njoined_data = pd.DataFrame(\npd.concat([exploded_data, expanded_data], axis=1),\ncolumns=[*column_names, \"equipment_name\", \"max_length\"],\n)\nif self.accepted_equipment == EquipmentOptions.__all_accepted_equipment__:\njoined_data[\"equipment_name_normalized\"] = (\njoined_data[\"equipment_name\"]\n.fillna(\"\")\n.apply(lambda x: EquipmentConfig.EQUIPMENT_REVERSE_MAPPING[x])\n)\nelse:\njoined_data[\"equipment_name_normalized\"] = joined_data[\"equipment_name\"]\nequipment_types = [item[0].lower() for item in self.equipment]\nmatching_equipment = joined_data[\njoined_data[\"equipment_name_normalized\"].isin(equipment_types)\n]\nmatching_ids = []\nfor equipment_name, equipment_length in self.equipment:\nmatching_data = matching_equipment[\nmatching_equipment[\"equipment_name_normalized\"]\n== equipment_name.lower()\n].copy()\nif equipment_length is not None:\nmatching_data = matching_data[\nmatching_data[\"max_length\"] &gt;= float(equipment_length)\n]\nmatching_ids += list(matching_data[\"campsite_id\"].unique())\noriginal_campsites = campsites[\ncampsites[\"campsite_id\"].isin(matching_ids)\n].copy()\nreturn original_campsites\ndef _get_listable_campsites(\nself, campsites: Union[List[RecDotGovCampsite], List[RecDotGovSearchResult]]\n) -&gt; List[ListedCampsite]:\n\"\"\"\n        Get Listable Campsites\n        Returns\n        -------\n        List[ListedCampsite]\n        \"\"\"\nif isinstance(campsites[0], RecDotGovCampsite):\nreturn [\nListedCampsite(\nid=item.campsite_id,\nfacility_id=item.asset_id,\nname=item.name,\n)\nfor item in campsites\n]\nelif isinstance(campsites[0], RecDotGovSearchResult):\nreturn [\nListedCampsite(\nid=item.entity_id,\nfacility_id=item.parent_id,\nname=item.name,\n)\nfor item in campsites\n]\nelse:\nraise NotImplementedError(\nf\"Cannot get listable campsites from type {type(campsites[0])}\"\n)\ndef list_campsite_units(self) -&gt; List[ListedCampsite]:\n\"\"\"\n        List Campsite Units\n        Returns\n        -------\n        List[ListedCampsite]\n        \"\"\"\nrecdotgov_campsites = self.campsite_finder.get_internal_campsites(\nfacility_ids=[item.facility_id for item in self.campgrounds]\n)\nlistable_campsites = self._get_listable_campsites(campsites=recdotgov_campsites)\nself.log_listed_campsites(\ncampsites=listable_campsites,\nfacilities=self.campgrounds,\n)\nreturn listable_campsites\n</code></pre>"},{"location":"reference/search/search_recreationdotgov/#camply.search.search_recreationdotgov.SearchRecreationDotGovBase.__init__","title":"<code>__init__(search_window, recreation_area=None, campgrounds=None, campsites=None, weekends_only=False, nights=1, equipment=None, offline_search=False, offline_search_path=None, **kwargs)</code>","text":"<p>Initialize with Search Parameters</p> <p>Parameters:</p> Name Type Description Default <code>search_window</code> <code>Union[SearchWindow, List[SearchWindow]]</code> <p>Search Window tuple containing start date and End Date</p> required <code>recreation_area</code> <code>Optional[Union[List[int], int]]</code> <p>ID of Recreation Area (i.e. 2907 - Rocky Mountain National Park)</p> <code>None</code> <code>campgrounds</code> <code>Optional[Union[List[int], int]]</code> <p>Campground ID or List of Campground IDs</p> <code>None</code> <code>campsites</code> <code>Optional[Union[List[int], int]]</code> <p>Campsite ID or List of Campsite IDs</p> <code>None</code> <code>weekends_only</code> <code>bool</code> <p>Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights)</p> <code>False</code> <code>nights</code> <code>int</code> <p>minimum number of consecutive nights to search per campsite,defaults to 1</p> <code>1</code> <code>equipment</code> <code>Optional[List[Tuple[str, Optional[int]]]]</code> <p>List of Tuples of Equipment to Search for. An equipment tuple array looks like this: <code>[(\"Tent\", None), (\"RV\", 20)]</code> - meaning the selected search looks for sites to accommodate any tent size and RVs less than or equal to 20 feet. Tuples contain the Equipment name and an optional equipment length, otherwise provide None. Equipment names include <code>Tent</code>, <code>RV</code>, <code>Trailer</code>, <code>Vehicle</code> and are not case-sensitive.</p> <code>None</code> <code>offline_search</code> <code>bool</code> <p>When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites.</p> <code>False</code> <code>offline_search_path</code> <code>Optional[str]</code> <p>When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to <code>camply_campsites.json</code></p> <code>None</code> Source code in <code>camply/search/search_recreationdotgov.py</code> <pre><code>def __init__(\nself,\nsearch_window: Union[SearchWindow, List[SearchWindow]],\nrecreation_area: Optional[Union[List[int], int]] = None,\ncampgrounds: Optional[Union[List[int], int]] = None,\ncampsites: Optional[Union[List[int], int]] = None,\nweekends_only: bool = False,\nnights: int = 1,\nequipment: Optional[List[Tuple[str, Optional[int]]]] = None,\noffline_search: bool = False,\noffline_search_path: Optional[str] = None,\n**kwargs,\n) -&gt; None:\n\"\"\"\n    Initialize with Search Parameters\n    Parameters\n    ----------\n    search_window: Union[SearchWindow, List[SearchWindow]]\n        Search Window tuple containing start date and End Date\n    recreation_area: Optional[Union[List[int], int]]\n        ID of Recreation Area (i.e. 2907 - Rocky Mountain National Park)\n    campgrounds: Optional[Union[List[int], int]]\n        Campground ID or List of Campground IDs\n    campsites: Optional[Union[List[int], int]]\n        Campsite ID or List of Campsite IDs\n    weekends_only: bool\n        Whether to only search for Camping availabilities on the weekends (Friday /\n        Saturday nights)\n    nights: int\n        minimum number of consecutive nights to search per campsite,defaults to 1\n    equipment: Optional[List[Tuple[str, Optional[int]]]]\n        List of Tuples of Equipment to Search for. An equipment tuple array looks\n        like this: `[(\"Tent\", None), (\"RV\", 20)]` - meaning the selected search\n        looks for sites to accommodate any tent size and RVs less than or equal\n        to 20 feet. Tuples contain the Equipment name and an optional equipment\n        length, otherwise provide None. Equipment names include `Tent`, `RV`,\n        `Trailer`, `Vehicle` and are not case-sensitive.\n    offline_search: bool\n        When set to True, the campsite search will both save the results of the\n        campsites it's found, but also load those campsites before beginning a\n        search for other campsites.\n    offline_search_path: Optional[str]\n        When offline search is set to True, this is the name of the file to be saved/loaded.\n        When not specified, the filename will default to `camply_campsites.json`\n    \"\"\"\nsuper(SearchRecreationDotGovBase, self).__init__(\nsearch_window=search_window,\nweekends_only=weekends_only,\nnights=nights,\noffline_search=offline_search,\noffline_search_path=offline_search_path,\n**kwargs,\n)\nself.campsite_finder: RecreationDotGov\nself._recreation_area_id = make_list(recreation_area)\nself._campground_object = campgrounds\nself.weekends_only = weekends_only\nassert (\nany(\n[\ncampsites not in [[], None],\ncampgrounds not in [[], None],\nrecreation_area is not None,\n]\n)\nis True\n)\nself.campsites = make_list(campsites)\nself.campgrounds = self._get_searchable_campgrounds()\nself.campsite_metadata: Optional[pd.DataFrame] = None\nself.equipment: List[Tuple[str, Optional[int]]] = []\nself.equipment = self._get_searchable_equipment(equipment=equipment)\n</code></pre>"},{"location":"reference/search/search_recreationdotgov/#camply.search.search_recreationdotgov.SearchRecreationDotGovBase.filter_campsites_to_equipment","title":"<code>filter_campsites_to_equipment(campsites)</code>","text":"<p>Filter a Campsite DataFrame down to specified equipment</p> <p>Parameters:</p> Name Type Description Default <code>campsites</code> <code>pd.DataFrame</code> required <p>Returns:</p> Type Description <code>pd.DataFrame</code> Source code in <code>camply/search/search_recreationdotgov.py</code> <pre><code>def filter_campsites_to_equipment(self, campsites: pd.DataFrame) -&gt; pd.DataFrame:\n\"\"\"\n    Filter a Campsite DataFrame down to specified equipment\n    Parameters\n    ----------\n    campsites: pd.DataFrame\n    Returns\n    -------\n    pd.DataFrame\n    \"\"\"\nif self.equipment is None or len(self.equipment) == 0 or len(campsites) == 0:\nreturn campsites\ncolumn_names = [\"campsite_id\", \"permitted_equipment\"]\nexploded_data = campsites[column_names].explode(\"permitted_equipment\")\nexpanded_data = exploded_data[\"permitted_equipment\"].apply(pd.Series)\njoined_data = pd.DataFrame(\npd.concat([exploded_data, expanded_data], axis=1),\ncolumns=[*column_names, \"equipment_name\", \"max_length\"],\n)\nif self.accepted_equipment == EquipmentOptions.__all_accepted_equipment__:\njoined_data[\"equipment_name_normalized\"] = (\njoined_data[\"equipment_name\"]\n.fillna(\"\")\n.apply(lambda x: EquipmentConfig.EQUIPMENT_REVERSE_MAPPING[x])\n)\nelse:\njoined_data[\"equipment_name_normalized\"] = joined_data[\"equipment_name\"]\nequipment_types = [item[0].lower() for item in self.equipment]\nmatching_equipment = joined_data[\njoined_data[\"equipment_name_normalized\"].isin(equipment_types)\n]\nmatching_ids = []\nfor equipment_name, equipment_length in self.equipment:\nmatching_data = matching_equipment[\nmatching_equipment[\"equipment_name_normalized\"]\n== equipment_name.lower()\n].copy()\nif equipment_length is not None:\nmatching_data = matching_data[\nmatching_data[\"max_length\"] &gt;= float(equipment_length)\n]\nmatching_ids += list(matching_data[\"campsite_id\"].unique())\noriginal_campsites = campsites[\ncampsites[\"campsite_id\"].isin(matching_ids)\n].copy()\nreturn original_campsites\n</code></pre>"},{"location":"reference/search/search_recreationdotgov/#camply.search.search_recreationdotgov.SearchRecreationDotGovBase.get_all_campsites","title":"<code>get_all_campsites()</code>","text":"<p>Perform the Search and Return All Monthly Availabilities</p> <p>Returns:</p> Type Description <code>List[AvailableCampsite]</code> Source code in <code>camply/search/search_recreationdotgov.py</code> <pre><code>def get_all_campsites(self) -&gt; List[AvailableCampsite]:\n\"\"\"\n    Perform the Search and Return All Monthly Availabilities\n    Returns\n    -------\n    List[AvailableCampsite]\n    \"\"\"\nfound_campsites = []\nif len(self.campgrounds) == 0:\nerror_message = \"No campgrounds found to search\"\nlogger.error(error_message)\nraise SearchError(error_message)\nlogger.info(f\"Searching across {len(self.campgrounds)} campgrounds\")\nif self.campsite_metadata is None:\nself.campsite_metadata = (\nself.campsite_finder.get_internal_campsite_metadata(\nfacility_ids=[facil.facility_id for facil in self.campgrounds]\n)\n)\nlogger.info(\n\"Metadata fetched for %s campsites\", len(self.campsite_metadata)\n)\nfor index, campground in enumerate(self.campgrounds):\nfor month in self.search_months:\nlogger.info(\nf\"Searching {campground.facility_name}, {campground.recreation_area} \"\nf\"({campground.facility_id}) for availability: \"\nf\"{month.strftime('%B, %Y')}\"\n)\navailabilities = self.campsite_finder.get_recdotgov_data(\ncampground_id=campground.facility_id, month=month\n)\ncampsites = self.campsite_finder.process_campsite_availability(\navailability=availabilities,\nrecreation_area=campground.recreation_area,\nrecreation_area_id=campground.recreation_area_id,\nfacility_name=campground.facility_name,\nfacility_id=campground.facility_id,\nmonth=month,\ncampsite_metadata=self.campsite_metadata,\n)\nlogger.info(\nf\"\\t{logging_utils.get_emoji(campsites)}\\t\"\nf\"{len(campsites)} total sites found in month of \"\nf\"{month.strftime('%B')}\"\n)\nif self.campsites not in [None, []]:\ncampsites = [\ncampsite_obj\nfor campsite_obj in campsites\nif int(campsite_obj.campsite_id) in self.campsites\n]\nfound_campsites += campsites\nif index + 1 &lt; len(self.campgrounds):\nsleep(round(uniform(*RecreationBookingConfig.RATE_LIMITING), 2))\ncampsite_df = self.campsites_to_df(campsites=found_campsites)\ncampsite_df_validated = self._filter_date_overlap(campsites=campsite_df)\ncompiled_campsite_df = self._consolidate_campsites(\ncampsite_df=campsite_df_validated, nights=self.nights\n)\nequipment_filtered_campsites = self.filter_campsites_to_equipment(\ncampsites=compiled_campsite_df\n)\ncompiled_campsites = self.df_to_campsites(\ncampsite_df=equipment_filtered_campsites\n)\nreturn compiled_campsites\n</code></pre>"},{"location":"reference/search/search_recreationdotgov/#camply.search.search_recreationdotgov.SearchRecreationDotGovBase.list_campsite_units","title":"<code>list_campsite_units()</code>","text":"<p>List Campsite Units</p> <p>Returns:</p> Type Description <code>List[ListedCampsite]</code> Source code in <code>camply/search/search_recreationdotgov.py</code> <pre><code>def list_campsite_units(self) -&gt; List[ListedCampsite]:\n\"\"\"\n    List Campsite Units\n    Returns\n    -------\n    List[ListedCampsite]\n    \"\"\"\nrecdotgov_campsites = self.campsite_finder.get_internal_campsites(\nfacility_ids=[item.facility_id for item in self.campgrounds]\n)\nlistable_campsites = self._get_listable_campsites(campsites=recdotgov_campsites)\nself.log_listed_campsites(\ncampsites=listable_campsites,\nfacilities=self.campgrounds,\n)\nreturn listable_campsites\n</code></pre>"},{"location":"reference/search/search_recreationdotgov/#camply.search.search_recreationdotgov.SearchRecreationDotGovDailyTicket","title":"<code>SearchRecreationDotGovDailyTicket</code>","text":"<p>         Bases: <code>SearchRecreationDotGovBase</code></p> <p>Searches on Recreation.gov for Tickets and Tours (Daily)</p> Source code in <code>camply/search/search_recreationdotgov.py</code> <pre><code>class SearchRecreationDotGovDailyTicket(SearchRecreationDotGovBase):\n\"\"\"\n    Searches on Recreation.gov for Tickets and Tours (Daily)\n    \"\"\"\nprovider_class = RecreationDotGovDailyTicket\naccepted_equipment = EquipmentConfig.TIMESTAMP_EQUIPMENT\n</code></pre>"},{"location":"reference/search/search_recreationdotgov/#camply.search.search_recreationdotgov.SearchRecreationDotGovDailyTimedEntry","title":"<code>SearchRecreationDotGovDailyTimedEntry</code>","text":"<p>         Bases: <code>SearchRecreationDotGovBase</code></p> <p>Searches on Recreation.gov for Timed Entries (Daily)</p> Source code in <code>camply/search/search_recreationdotgov.py</code> <pre><code>class SearchRecreationDotGovDailyTimedEntry(SearchRecreationDotGovBase):\n\"\"\"\n    Searches on Recreation.gov for Timed Entries (Daily)\n    \"\"\"\nprovider_class = RecreationDotGovDailyTimedEntry\naccepted_equipment = EquipmentConfig.TIMESTAMP_EQUIPMENT\n</code></pre>"},{"location":"reference/search/search_recreationdotgov/#camply.search.search_recreationdotgov.SearchRecreationDotGovTicket","title":"<code>SearchRecreationDotGovTicket</code>","text":"<p>         Bases: <code>SearchRecreationDotGovBase</code></p> <p>Searches on Recreation.gov for Tickets and Tours</p> Source code in <code>camply/search/search_recreationdotgov.py</code> <pre><code>class SearchRecreationDotGovTicket(SearchRecreationDotGovBase):\n\"\"\"\n    Searches on Recreation.gov for Tickets and Tours\n    \"\"\"\nprovider_class = RecreationDotGovTicket\n</code></pre>"},{"location":"reference/search/search_recreationdotgov/#camply.search.search_recreationdotgov.SearchRecreationDotGovTimedEntry","title":"<code>SearchRecreationDotGovTimedEntry</code>","text":"<p>         Bases: <code>SearchRecreationDotGovBase</code></p> <p>Searches on Recreation.gov for Timed Entries</p> Source code in <code>camply/search/search_recreationdotgov.py</code> <pre><code>class SearchRecreationDotGovTimedEntry(SearchRecreationDotGovBase):\n\"\"\"\n    Searches on Recreation.gov for Timed Entries\n    \"\"\"\nprovider_class = RecreationDotGovTimedEntry\n</code></pre>"},{"location":"reference/search/search_usedirect/","title":"search_usedirect","text":"<p>Search Implementation: Reserve California</p>"},{"location":"reference/search/search_usedirect/#camply.search.search_usedirect.SearchAlabamaStateParks","title":"<code>SearchAlabamaStateParks</code>","text":"<p>         Bases: <code>SearchUseDirect</code></p> <p>Searches on ReserveAlaPark.com for Campsites</p> Source code in <code>camply/search/search_usedirect.py</code> <pre><code>class SearchAlabamaStateParks(SearchUseDirect):\n\"\"\"\n    Searches on ReserveAlaPark.com for Campsites\n    \"\"\"\nprovider_class = AlabamaStateParks\n</code></pre>"},{"location":"reference/search/search_usedirect/#camply.search.search_usedirect.SearchArizonaStateParks","title":"<code>SearchArizonaStateParks</code>","text":"<p>         Bases: <code>SearchUseDirect</code></p> <p>Searches on AZStateParks.com for Campsites</p> Source code in <code>camply/search/search_usedirect.py</code> <pre><code>class SearchArizonaStateParks(SearchUseDirect):\n\"\"\"\n    Searches on AZStateParks.com for Campsites\n    \"\"\"\nprovider_class = ArizonaStateParks\n</code></pre>"},{"location":"reference/search/search_usedirect/#camply.search.search_usedirect.SearchFairfaxCountyParks","title":"<code>SearchFairfaxCountyParks</code>","text":"<p>         Bases: <code>SearchUseDirect</code></p> <p>Searches on fairfax.usedirect.com for Campsites (Virginia)</p> Source code in <code>camply/search/search_usedirect.py</code> <pre><code>class SearchFairfaxCountyParks(SearchUseDirect):\n\"\"\"\n    Searches on fairfax.usedirect.com for Campsites (Virginia)\n    \"\"\"\nprovider_class = FairfaxCountyParks\n</code></pre>"},{"location":"reference/search/search_usedirect/#camply.search.search_usedirect.SearchFloridaStateParks","title":"<code>SearchFloridaStateParks</code>","text":"<p>         Bases: <code>SearchUseDirect</code></p> <p>Searches on FloridaStateParks.org for Campsites</p> Source code in <code>camply/search/search_usedirect.py</code> <pre><code>class SearchFloridaStateParks(SearchUseDirect):\n\"\"\"\n    Searches on FloridaStateParks.org for Campsites\n    \"\"\"\nprovider_class = FloridaStateParks\n</code></pre>"},{"location":"reference/search/search_usedirect/#camply.search.search_usedirect.SearchMaricopaCountyParks","title":"<code>SearchMaricopaCountyParks</code>","text":"<p>         Bases: <code>SearchUseDirect</code></p> <p>Searches on MaricopaCountyParks.org for Campsites (Arizona)</p> Source code in <code>camply/search/search_usedirect.py</code> <pre><code>class SearchMaricopaCountyParks(SearchUseDirect):\n\"\"\"\n    Searches on MaricopaCountyParks.org for Campsites (Arizona)\n    \"\"\"\nprovider_class = MaricopaCountyParks\n</code></pre>"},{"location":"reference/search/search_usedirect/#camply.search.search_usedirect.SearchMinnesotaStateParks","title":"<code>SearchMinnesotaStateParks</code>","text":"<p>         Bases: <code>SearchUseDirect</code></p> <p>Searches on ReserveMN.usedirect.com for Campsites</p> Source code in <code>camply/search/search_usedirect.py</code> <pre><code>class SearchMinnesotaStateParks(SearchUseDirect):\n\"\"\"\n    Searches on ReserveMN.usedirect.com for Campsites\n    \"\"\"\nprovider_class = MinnesotaStateParks\n</code></pre>"},{"location":"reference/search/search_usedirect/#camply.search.search_usedirect.SearchMissouriStateParks","title":"<code>SearchMissouriStateParks</code>","text":"<p>         Bases: <code>SearchUseDirect</code></p> <p>Searches on icampmo1.usedirect.com for Campsites</p> Source code in <code>camply/search/search_usedirect.py</code> <pre><code>class SearchMissouriStateParks(SearchUseDirect):\n\"\"\"\n    Searches on icampmo1.usedirect.com for Campsites\n    \"\"\"\nprovider_class = MissouriStateParks\n</code></pre>"},{"location":"reference/search/search_usedirect/#camply.search.search_usedirect.SearchNorthernTerritory","title":"<code>SearchNorthernTerritory</code>","text":"<p>         Bases: <code>SearchUseDirect</code></p> <p>Searches the Australian Northern Territory for Campsites</p> Source code in <code>camply/search/search_usedirect.py</code> <pre><code>class SearchNorthernTerritory(SearchUseDirect):\n\"\"\"\n    Searches the Australian Northern Territory for Campsites\n    \"\"\"\nprovider_class = NorthernTerritory\n</code></pre>"},{"location":"reference/search/search_usedirect/#camply.search.search_usedirect.SearchOhioStateParks","title":"<code>SearchOhioStateParks</code>","text":"<p>         Bases: <code>SearchUseDirect</code></p> <p>Searches on ReserveOhio.com for Campsites</p> Source code in <code>camply/search/search_usedirect.py</code> <pre><code>class SearchOhioStateParks(SearchUseDirect):\n\"\"\"\n    Searches on ReserveOhio.com for Campsites\n    \"\"\"\nprovider_class = OhioStateParks\n</code></pre>"},{"location":"reference/search/search_usedirect/#camply.search.search_usedirect.SearchOregonMetro","title":"<code>SearchOregonMetro</code>","text":"<p>         Bases: <code>SearchUseDirect</code></p> <p>Searches on OregonMetro.gov for Campsites (Portland Metro)</p> Source code in <code>camply/search/search_usedirect.py</code> <pre><code>class SearchOregonMetro(SearchUseDirect):\n\"\"\"\n    Searches on OregonMetro.gov for Campsites (Portland Metro)\n    \"\"\"\nprovider_class = OregonMetro\n</code></pre>"},{"location":"reference/search/search_usedirect/#camply.search.search_usedirect.SearchReserveCalifornia","title":"<code>SearchReserveCalifornia</code>","text":"<p>         Bases: <code>SearchUseDirect</code></p> <p>Search ReserveCalifornia</p> Source code in <code>camply/search/search_usedirect.py</code> <pre><code>class SearchReserveCalifornia(SearchUseDirect):\n\"\"\"\n    Search ReserveCalifornia\n    \"\"\"\nprovider_class = ReserveCalifornia\n</code></pre>"},{"location":"reference/search/search_usedirect/#camply.search.search_usedirect.SearchUseDirect","title":"<code>SearchUseDirect</code>","text":"<p>         Bases: <code>BaseCampingSearch</code>, <code>ABC</code></p> <p>Searches on UseDirect.com for Campsites</p> Source code in <code>camply/search/search_usedirect.py</code> <pre><code>class SearchUseDirect(BaseCampingSearch, ABC):\n\"\"\"\n    Searches on UseDirect.com for Campsites\n    \"\"\"\n@property\n@abstractmethod\ndef provider_class(self) -&gt; Type[BaseCampingSearch]:\n\"\"\"\n        Provider Class to be used for Search\n        \"\"\"\npass\ndef __init__(\nself,\nsearch_window: Union[SearchWindow, List[SearchWindow]],\nrecreation_area: List[int],\nweekends_only: bool = False,\ncampgrounds: Optional[Union[List[str], str]] = None,\nnights: int = 1,\n**kwargs,\n) -&gt; None:\n\"\"\"\n        Initialize with Search Parameters\n        Parameters\n        ----------\n        search_window: Union[SearchWindow, List[SearchWindow]]\n            Search Window tuple containing start date and End Date\n        recreation_area: List[int]\n            The IDs of the recreation area to be searched.\n        weekends_only: bool\n            Whether to only search for Camping availabilities on the weekends (Friday /\n            Saturday nights)\n        campgrounds: Union[List[int], int]\n            Campground ID or List of Campground IDs\n        nights: int\n            minimum number of consecutive nights to search per campsite,defaults to 1\n        \"\"\"\nsuper().__init__(\nsearch_window=search_window,\nweekends_only=weekends_only,\nnights=nights,\n**kwargs,\n)\nself._recreation_area_ids: List[int] = make_list(recreation_area, coerce=int)\nself._campground_ids: List[int] = make_list(campgrounds, coerce=int)\ncampsites = make_list(kwargs.get(\"campsites\", []), coerce=int) or []\nif len(campsites) &gt; 0:\nself.campsite_finder.validate_campsites(\ncampsites=campsites, facility_ids=self._campground_ids\n)\ntry:\nassert any(\n[\nself._campground_ids not in (None, []),\nself._recreation_area_ids not in (None, []),\n]\n)\nexcept AssertionError:\nlogger.error(\nf\"You must provide a Campground ID or a Recreation Area ID to {self.provider_class.__name__}\"\n)\nsys.exit(1)\nif self._campground_ids:\nself.campgrounds = self.campsite_finder.find_campgrounds(\ncampground_id=self._campground_ids,\nverbose=False,\n)\nelse:\nself.campgrounds = self.campsite_finder.find_campgrounds(\nrec_area_id=self._recreation_area_ids,\nverbose=False,\n)\nself.campground_ids = [item.facility_id for item in self.campgrounds]\nif len(self.campground_ids) == 0:\nlogger.error(\"No Campsites Found Matching Your Search Criteria\")\nsys.exit(1)\nif kwargs.get(\"equipment\", ()):\nlogger.warning(\n\"%s Doesn't Support Equipment, yet \ud83d\ude42\", self.provider_class.__name__\n)\ndef get_all_campsites(self, **kwargs: Dict[str, Any]) -&gt; List[AvailableCampsite]:\n\"\"\"\n        Retrieve All Campsites from the UseDirect API\n        Parameters\n        ----------\n        kwargs: Dict[str, Any]\n        Returns\n        -------\n        List[AvailableCampsite]\n        \"\"\"\nlogger.info(f\"Searching across {len(self.campgrounds)} campgrounds\")\nfor campground in self.campgrounds:\nlog_str = format_log_string(campground)\nlogger.info(\"    %s\", log_str)\ncampsites_found: List[AvailableCampsite] = []\nfor month in self.search_months:\nfor campground in self.campgrounds:\nlogger.info(\nf\"Searching {campground.facility_name}, {campground.recreation_area} \"\nf\"({campground.facility_id}) for availability: \"\nf\"{month.strftime('%B, %Y')}\"\n)\nend_date = month + relativedelta(months=1) - timedelta(days=1)\ncampsites = self.campsite_finder.get_campsites(\ncampground_id=campground.facility_id,\nstart_date=month,\nend_date=end_date,\n)\nlogger.info(\nf\"\\t{logging_utils.get_emoji(campsites)}\\t\"\nf\"{len(campsites)} total sites found in month of \"\nf\"{month.strftime('%B')}\"\n)\ncampsites_found += campsites\ncampsite_df = self.campsites_to_df(campsites=campsites_found)\ncampsite_df_validated = self._filter_date_overlap(campsites=campsite_df)\nconsolidated_campsites = self._consolidate_campsites(\ncampsite_df=campsite_df_validated, nights=self.nights\n)\ncompiled_campsites = self.df_to_campsites(campsite_df=consolidated_campsites)\nreturn compiled_campsites\n@classmethod\ndef find_recreation_areas(\ncls, search_string: str, **kwargs\n) -&gt; List[RecreationArea]:\n\"\"\"\n        Return the UseDirect Recreation Areas\n        \"\"\"\nrec_areas = cls.provider_class().search_for_recreation_areas(\nquery=search_string, state=kwargs.get(\"state\")\n)\nlogger.info(f\"{len(rec_areas)} Matching Recreation Areas Found\")\nlog_sorted_response(rec_areas)\nreturn rec_areas\ndef list_campsite_units(self) -&gt; List[ListedCampsite]:\n\"\"\"\n        List Campsite Units\n        Returns\n        -------\n        List[ListedCampsite]\n        \"\"\"\nif not self.campsite_finder.usedirect_campsites:\nself.campsite_finder.get_campsite_metadata(facility_ids=self.campground_ids)\nsorted_campsites = sorted(\nself.campsite_finder.usedirect_campsites.values(),\nkey=lambda x: x.OrderByRaw,\n)\nlogged_campsites = [\nListedCampsite(id=item.UnitId, name=item.Name, facility_id=item.FacilityId)\nfor item in sorted_campsites\n]\nself.log_listed_campsites(\ncampsites=logged_campsites,\nfacilities=self.campgrounds,\n)\nreturn logged_campsites\n</code></pre>"},{"location":"reference/search/search_usedirect/#camply.search.search_usedirect.SearchUseDirect.provider_class","title":"<code>provider_class: Type[BaseCampingSearch]</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Provider Class to be used for Search</p>"},{"location":"reference/search/search_usedirect/#camply.search.search_usedirect.SearchUseDirect.__init__","title":"<code>__init__(search_window, recreation_area, weekends_only=False, campgrounds=None, nights=1, **kwargs)</code>","text":"<p>Initialize with Search Parameters</p> <p>Parameters:</p> Name Type Description Default <code>search_window</code> <code>Union[SearchWindow, List[SearchWindow]]</code> <p>Search Window tuple containing start date and End Date</p> required <code>recreation_area</code> <code>List[int]</code> <p>The IDs of the recreation area to be searched.</p> required <code>weekends_only</code> <code>bool</code> <p>Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights)</p> <code>False</code> <code>campgrounds</code> <code>Optional[Union[List[str], str]]</code> <p>Campground ID or List of Campground IDs</p> <code>None</code> <code>nights</code> <code>int</code> <p>minimum number of consecutive nights to search per campsite,defaults to 1</p> <code>1</code> Source code in <code>camply/search/search_usedirect.py</code> <pre><code>def __init__(\nself,\nsearch_window: Union[SearchWindow, List[SearchWindow]],\nrecreation_area: List[int],\nweekends_only: bool = False,\ncampgrounds: Optional[Union[List[str], str]] = None,\nnights: int = 1,\n**kwargs,\n) -&gt; None:\n\"\"\"\n    Initialize with Search Parameters\n    Parameters\n    ----------\n    search_window: Union[SearchWindow, List[SearchWindow]]\n        Search Window tuple containing start date and End Date\n    recreation_area: List[int]\n        The IDs of the recreation area to be searched.\n    weekends_only: bool\n        Whether to only search for Camping availabilities on the weekends (Friday /\n        Saturday nights)\n    campgrounds: Union[List[int], int]\n        Campground ID or List of Campground IDs\n    nights: int\n        minimum number of consecutive nights to search per campsite,defaults to 1\n    \"\"\"\nsuper().__init__(\nsearch_window=search_window,\nweekends_only=weekends_only,\nnights=nights,\n**kwargs,\n)\nself._recreation_area_ids: List[int] = make_list(recreation_area, coerce=int)\nself._campground_ids: List[int] = make_list(campgrounds, coerce=int)\ncampsites = make_list(kwargs.get(\"campsites\", []), coerce=int) or []\nif len(campsites) &gt; 0:\nself.campsite_finder.validate_campsites(\ncampsites=campsites, facility_ids=self._campground_ids\n)\ntry:\nassert any(\n[\nself._campground_ids not in (None, []),\nself._recreation_area_ids not in (None, []),\n]\n)\nexcept AssertionError:\nlogger.error(\nf\"You must provide a Campground ID or a Recreation Area ID to {self.provider_class.__name__}\"\n)\nsys.exit(1)\nif self._campground_ids:\nself.campgrounds = self.campsite_finder.find_campgrounds(\ncampground_id=self._campground_ids,\nverbose=False,\n)\nelse:\nself.campgrounds = self.campsite_finder.find_campgrounds(\nrec_area_id=self._recreation_area_ids,\nverbose=False,\n)\nself.campground_ids = [item.facility_id for item in self.campgrounds]\nif len(self.campground_ids) == 0:\nlogger.error(\"No Campsites Found Matching Your Search Criteria\")\nsys.exit(1)\nif kwargs.get(\"equipment\", ()):\nlogger.warning(\n\"%s Doesn't Support Equipment, yet \ud83d\ude42\", self.provider_class.__name__\n)\n</code></pre>"},{"location":"reference/search/search_usedirect/#camply.search.search_usedirect.SearchUseDirect.find_recreation_areas","title":"<code>find_recreation_areas(search_string, **kwargs)</code>  <code>classmethod</code>","text":"<p>Return the UseDirect Recreation Areas</p> Source code in <code>camply/search/search_usedirect.py</code> <pre><code>@classmethod\ndef find_recreation_areas(\ncls, search_string: str, **kwargs\n) -&gt; List[RecreationArea]:\n\"\"\"\n    Return the UseDirect Recreation Areas\n    \"\"\"\nrec_areas = cls.provider_class().search_for_recreation_areas(\nquery=search_string, state=kwargs.get(\"state\")\n)\nlogger.info(f\"{len(rec_areas)} Matching Recreation Areas Found\")\nlog_sorted_response(rec_areas)\nreturn rec_areas\n</code></pre>"},{"location":"reference/search/search_usedirect/#camply.search.search_usedirect.SearchUseDirect.get_all_campsites","title":"<code>get_all_campsites(**kwargs)</code>","text":"<p>Retrieve All Campsites from the UseDirect API</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>Dict[str, Any]</code> <code>{}</code> <p>Returns:</p> Type Description <code>List[AvailableCampsite]</code> Source code in <code>camply/search/search_usedirect.py</code> <pre><code>def get_all_campsites(self, **kwargs: Dict[str, Any]) -&gt; List[AvailableCampsite]:\n\"\"\"\n    Retrieve All Campsites from the UseDirect API\n    Parameters\n    ----------\n    kwargs: Dict[str, Any]\n    Returns\n    -------\n    List[AvailableCampsite]\n    \"\"\"\nlogger.info(f\"Searching across {len(self.campgrounds)} campgrounds\")\nfor campground in self.campgrounds:\nlog_str = format_log_string(campground)\nlogger.info(\"    %s\", log_str)\ncampsites_found: List[AvailableCampsite] = []\nfor month in self.search_months:\nfor campground in self.campgrounds:\nlogger.info(\nf\"Searching {campground.facility_name}, {campground.recreation_area} \"\nf\"({campground.facility_id}) for availability: \"\nf\"{month.strftime('%B, %Y')}\"\n)\nend_date = month + relativedelta(months=1) - timedelta(days=1)\ncampsites = self.campsite_finder.get_campsites(\ncampground_id=campground.facility_id,\nstart_date=month,\nend_date=end_date,\n)\nlogger.info(\nf\"\\t{logging_utils.get_emoji(campsites)}\\t\"\nf\"{len(campsites)} total sites found in month of \"\nf\"{month.strftime('%B')}\"\n)\ncampsites_found += campsites\ncampsite_df = self.campsites_to_df(campsites=campsites_found)\ncampsite_df_validated = self._filter_date_overlap(campsites=campsite_df)\nconsolidated_campsites = self._consolidate_campsites(\ncampsite_df=campsite_df_validated, nights=self.nights\n)\ncompiled_campsites = self.df_to_campsites(campsite_df=consolidated_campsites)\nreturn compiled_campsites\n</code></pre>"},{"location":"reference/search/search_usedirect/#camply.search.search_usedirect.SearchUseDirect.list_campsite_units","title":"<code>list_campsite_units()</code>","text":"<p>List Campsite Units</p> <p>Returns:</p> Type Description <code>List[ListedCampsite]</code> Source code in <code>camply/search/search_usedirect.py</code> <pre><code>def list_campsite_units(self) -&gt; List[ListedCampsite]:\n\"\"\"\n    List Campsite Units\n    Returns\n    -------\n    List[ListedCampsite]\n    \"\"\"\nif not self.campsite_finder.usedirect_campsites:\nself.campsite_finder.get_campsite_metadata(facility_ids=self.campground_ids)\nsorted_campsites = sorted(\nself.campsite_finder.usedirect_campsites.values(),\nkey=lambda x: x.OrderByRaw,\n)\nlogged_campsites = [\nListedCampsite(id=item.UnitId, name=item.Name, facility_id=item.FacilityId)\nfor item in sorted_campsites\n]\nself.log_listed_campsites(\ncampsites=logged_campsites,\nfacilities=self.campgrounds,\n)\nreturn logged_campsites\n</code></pre>"},{"location":"reference/search/search_usedirect/#camply.search.search_usedirect.SearchVirginiaStateParks","title":"<code>SearchVirginiaStateParks</code>","text":"<p>         Bases: <code>SearchUseDirect</code></p> <p>Searches on ReserveVAParks.com for Campsites</p> Source code in <code>camply/search/search_usedirect.py</code> <pre><code>class SearchVirginiaStateParks(SearchUseDirect):\n\"\"\"\n    Searches on ReserveVAParks.com for Campsites\n    \"\"\"\nprovider_class = VirginiaStateParks\n</code></pre>"},{"location":"reference/search/search_yellowstone/","title":"search_yellowstone","text":"<p>Yellowstone Lodging Web Searching Utilities</p>"},{"location":"reference/search/search_yellowstone/#camply.search.search_yellowstone.SearchYellowstone","title":"<code>SearchYellowstone</code>","text":"<p>         Bases: <code>BaseCampingSearch</code></p> <p>Searches on YellowstoneNationalParkLodges.com for Campsites</p> Source code in <code>camply/search/search_yellowstone.py</code> <pre><code>class SearchYellowstone(BaseCampingSearch):\n\"\"\"\n    Searches on YellowstoneNationalParkLodges.com for Campsites\n    \"\"\"\nrecreation_area = Yellowstone.recreation_area\nprovider_class = Yellowstone\nlist_campsites_supported: bool = False\n# noinspection PyUnusedLocal\ndef __init__(\nself,\nsearch_window: Union[SearchWindow, List[SearchWindow]],\nweekends_only: bool = False,\ncampgrounds: Optional[Union[List[str], str]] = None,\nnights: int = 1,\noffline_search: bool = False,\noffline_search_path: Optional[str] = None,\n**kwargs,\n) -&gt; None:\n\"\"\"\n        Initialize with Search Parameters\n        Parameters\n        ----------\n        search_window: Union[SearchWindow, List[SearchWindow]]\n            Search Window tuple containing start date and End Date\n        weekends_only: bool\n            Whether to only search for Camping availabilities on the weekends (Friday /\n            Saturday nights)\n        campgrounds: Optional[Union[List[str], str]]\n            Campground ID or List of Campground IDs\n        nights: int\n            minimum number of consecutive nights to search per campsite,defaults to 1\n        offline_search: bool\n            When set to True, the campsite search will both save the results of the\n            campsites it's found, but also load those campsites before beginning a\n            search for other campsites.\n        offline_search_path: Optional[str]\n            When offline search is set to True, this is the name of the file to be saved/loaded.\n            When not specified, the filename will default to `camply_campsites.json`\n        \"\"\"\nsuper().__init__(\nsearch_window=search_window,\nweekends_only=weekends_only,\nnights=nights,\noffline_search=offline_search,\noffline_search_path=offline_search_path,\n**kwargs,\n)\nself.campgrounds = make_list(campgrounds)\ndef get_all_campsites(self) -&gt; List[AvailableCampsite]:\n\"\"\"\n        Search for all matching campsites in Yellowstone.\n        Returns\n        -------\n        List[AvailableCampsite]\n        \"\"\"\nall_campsites = []\nsearchable_campgrounds = self._get_searchable_campgrounds()\nthis_month = datetime.now().date().replace(day=1)\nfor month in self.search_months:\nif month &gt;= this_month:\nall_campsites += self.campsite_finder.get_monthly_campsites(\nmonth=month, nights=None if self.nights == 1 else self.nights\n)\nmatching_campsites = self._filter_campsites_to_campgrounds(\ncampsites=all_campsites, searchable_campgrounds=searchable_campgrounds\n)\ncampsite_df = self.campsites_to_df(campsites=matching_campsites)\ncampsite_df_validated = self._filter_date_overlap(campsites=campsite_df)\ntime_window_end = max(self.search_days) + timedelta(days=1)\ncompiled_campsite_df = campsite_df_validated[\ncampsite_df_validated.booking_end_date &lt;= pd.Timestamp(time_window_end)\n]\ncompiled_campsites = self.df_to_campsites(campsite_df=compiled_campsite_df)\nreturn compiled_campsites\ndef _get_searchable_campgrounds(self) -&gt; Optional[Set[str]]:\n\"\"\"\n        Return the Campgrounds for the Camping Search\n        Returns\n        -------\n        Optional[Set[str]]\n        \"\"\"\nif self.campgrounds in [None, []]:\nreturn None\nsupported_campsites = set(YellowstoneConfig.YELLOWSTONE_CAMPGROUNDS.keys())\nselected_campsites = set(self.campgrounds)\nsearchable_campgrounds = supported_campsites.intersection(selected_campsites)\nif len(searchable_campgrounds) == 0:\ncampground_ids = [\nf\"`{key}` ({value})\"\nfor key, value in YellowstoneConfig.YELLOWSTONE_CAMPGROUNDS.items()\n]\nerror_message = (\n\"You must supply a YellowstoneNationalParkLodges supported \"\n\"campground ID. Current supported Campground IDs: \"\nf\"{', '.join(campground_ids)}\"\n)\nlogger.error(error_message)\nraise SearchError(error_message)\nlogger.info(f\"{len(searchable_campgrounds)} Matching Campgrounds Found\")\nfor campground in searchable_campgrounds:\nlogger.info(\nf\"\u26f0  {YellowstoneConfig.YELLOWSTONE_RECREATION_AREA_FORMAL_NAME} \"\nf\"(#{YellowstoneConfig.YELLOWSTONE_RECREATION_AREA_ID}) - \ud83c\udfd5  \"\nf\"{YellowstoneConfig.YELLOWSTONE_CAMPGROUNDS[campground]} ({campground})\"\n)\nreturn searchable_campgrounds\ndef _filter_campsites_to_campgrounds(\nself, campsites: List[AvailableCampsite], searchable_campgrounds: Set[str]\n) -&gt; List[AvailableCampsite]:\n\"\"\"\n        Filter Campsites Down to Matching Campgrounds\n        Parameters\n        ----------\n        campsites: List[AvailableCampsite]\n        searchable_campgrounds: Set[str]\n        Returns\n        -------\n        List[AvailableCampsite]\n        \"\"\"\nif self.campgrounds in [None, []]:\nreturn campsites\nmatching_campsites = [\ncampsite\nfor campsite in campsites\nif campsite.facility_id in searchable_campgrounds\n]\nreturn matching_campsites\n@classmethod\ndef find_recreation_areas(cls, **kwargs) -&gt; List[RecreationArea]:\n\"\"\"\n        Return the Yellowstone Recreation Area Object\n        \"\"\"\nlog_sorted_response([cls.recreation_area])\nreturn [cls.recreation_area]\ndef list_campsite_units(self) -&gt; Any:\n\"\"\"\n        List Campsite Units\n        Returns\n        -------\n        Any\n        \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"reference/search/search_yellowstone/#camply.search.search_yellowstone.SearchYellowstone.__init__","title":"<code>__init__(search_window, weekends_only=False, campgrounds=None, nights=1, offline_search=False, offline_search_path=None, **kwargs)</code>","text":"<p>Initialize with Search Parameters</p> <p>Parameters:</p> Name Type Description Default <code>search_window</code> <code>Union[SearchWindow, List[SearchWindow]]</code> <p>Search Window tuple containing start date and End Date</p> required <code>weekends_only</code> <code>bool</code> <p>Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights)</p> <code>False</code> <code>campgrounds</code> <code>Optional[Union[List[str], str]]</code> <p>Campground ID or List of Campground IDs</p> <code>None</code> <code>nights</code> <code>int</code> <p>minimum number of consecutive nights to search per campsite,defaults to 1</p> <code>1</code> <code>offline_search</code> <code>bool</code> <p>When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites.</p> <code>False</code> <code>offline_search_path</code> <code>Optional[str]</code> <p>When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to <code>camply_campsites.json</code></p> <code>None</code> Source code in <code>camply/search/search_yellowstone.py</code> <pre><code>def __init__(\nself,\nsearch_window: Union[SearchWindow, List[SearchWindow]],\nweekends_only: bool = False,\ncampgrounds: Optional[Union[List[str], str]] = None,\nnights: int = 1,\noffline_search: bool = False,\noffline_search_path: Optional[str] = None,\n**kwargs,\n) -&gt; None:\n\"\"\"\n    Initialize with Search Parameters\n    Parameters\n    ----------\n    search_window: Union[SearchWindow, List[SearchWindow]]\n        Search Window tuple containing start date and End Date\n    weekends_only: bool\n        Whether to only search for Camping availabilities on the weekends (Friday /\n        Saturday nights)\n    campgrounds: Optional[Union[List[str], str]]\n        Campground ID or List of Campground IDs\n    nights: int\n        minimum number of consecutive nights to search per campsite,defaults to 1\n    offline_search: bool\n        When set to True, the campsite search will both save the results of the\n        campsites it's found, but also load those campsites before beginning a\n        search for other campsites.\n    offline_search_path: Optional[str]\n        When offline search is set to True, this is the name of the file to be saved/loaded.\n        When not specified, the filename will default to `camply_campsites.json`\n    \"\"\"\nsuper().__init__(\nsearch_window=search_window,\nweekends_only=weekends_only,\nnights=nights,\noffline_search=offline_search,\noffline_search_path=offline_search_path,\n**kwargs,\n)\nself.campgrounds = make_list(campgrounds)\n</code></pre>"},{"location":"reference/search/search_yellowstone/#camply.search.search_yellowstone.SearchYellowstone.find_recreation_areas","title":"<code>find_recreation_areas(**kwargs)</code>  <code>classmethod</code>","text":"<p>Return the Yellowstone Recreation Area Object</p> Source code in <code>camply/search/search_yellowstone.py</code> <pre><code>@classmethod\ndef find_recreation_areas(cls, **kwargs) -&gt; List[RecreationArea]:\n\"\"\"\n    Return the Yellowstone Recreation Area Object\n    \"\"\"\nlog_sorted_response([cls.recreation_area])\nreturn [cls.recreation_area]\n</code></pre>"},{"location":"reference/search/search_yellowstone/#camply.search.search_yellowstone.SearchYellowstone.get_all_campsites","title":"<code>get_all_campsites()</code>","text":"<p>Search for all matching campsites in Yellowstone.</p> <p>Returns:</p> Type Description <code>List[AvailableCampsite]</code> Source code in <code>camply/search/search_yellowstone.py</code> <pre><code>def get_all_campsites(self) -&gt; List[AvailableCampsite]:\n\"\"\"\n    Search for all matching campsites in Yellowstone.\n    Returns\n    -------\n    List[AvailableCampsite]\n    \"\"\"\nall_campsites = []\nsearchable_campgrounds = self._get_searchable_campgrounds()\nthis_month = datetime.now().date().replace(day=1)\nfor month in self.search_months:\nif month &gt;= this_month:\nall_campsites += self.campsite_finder.get_monthly_campsites(\nmonth=month, nights=None if self.nights == 1 else self.nights\n)\nmatching_campsites = self._filter_campsites_to_campgrounds(\ncampsites=all_campsites, searchable_campgrounds=searchable_campgrounds\n)\ncampsite_df = self.campsites_to_df(campsites=matching_campsites)\ncampsite_df_validated = self._filter_date_overlap(campsites=campsite_df)\ntime_window_end = max(self.search_days) + timedelta(days=1)\ncompiled_campsite_df = campsite_df_validated[\ncampsite_df_validated.booking_end_date &lt;= pd.Timestamp(time_window_end)\n]\ncompiled_campsites = self.df_to_campsites(campsite_df=compiled_campsite_df)\nreturn compiled_campsites\n</code></pre>"},{"location":"reference/search/search_yellowstone/#camply.search.search_yellowstone.SearchYellowstone.list_campsite_units","title":"<code>list_campsite_units()</code>","text":"<p>List Campsite Units</p> <p>Returns:</p> Type Description <code>Any</code> Source code in <code>camply/search/search_yellowstone.py</code> <pre><code>def list_campsite_units(self) -&gt; Any:\n\"\"\"\n    List Campsite Units\n    Returns\n    -------\n    Any\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"reference/utils/","title":"utils","text":"<p>Utils init file</p>"},{"location":"reference/utils/#camply.utils.filter_json","title":"<code>filter_json(json, filters)</code>","text":"<p>Extension Method to Dictionaries, allows easy filtering</p> <p>Parameters:</p> Name Type Description Default <code>json</code> <code>dict</code> required <code>filters</code> <code>Union[str, List[str]]</code> required <p>Returns:</p> Name Type Description <code>filtered_object</code> <code>object</code> <p>Resulting JSON Filtered Object</p> Source code in <code>camply/utils/api_utils.py</code> <pre><code>def filter_json(json: dict, filters: Union[str, List[str]]) -&gt; object:\n\"\"\"\n    Extension Method to Dictionaries, allows easy filtering\n    Parameters\n    ----------\n    json\n    filters\n    Returns\n    -------\n    filtered_object: object\n        Resulting JSON Filtered Object\n    \"\"\"\nif not isinstance(filters, list):\nfilters = [filters]\nobject_layers = {0: json}\ntry:\nfor index, filter_layer in enumerate(filters):\nlayer_index = index + 1\nobject_layers[layer_index] = object_layers[index][filter_layer]\ndel object_layers[index]\nexcept KeyError as key_error:\nerror_message = (\nf\"Unable to find matching JSON Filtering | {key_error} | {filters}\"\n)\nlogger.error(error_message)\nraise KeyError from key_error\nreturn object_layers[len(filters)]\n</code></pre>"},{"location":"reference/utils/#camply.utils.generate_url","title":"<code>generate_url(scheme, netloc, path='', params='', query='', fragment='')</code>","text":"<p>Build a URL</p> <p>Parameters:</p> Name Type Description Default <code>scheme</code> <code>str</code> <p>URL scheme specifier</p> required <code>netloc</code> <code>str</code> <p>Network location part</p> required <code>path</code> <code>str</code> <p>Hierarchical path</p> <code>''</code> <code>params</code> <code>str</code> <p>Parameters for last path element</p> <code>''</code> <code>query</code> <code>str</code> <p>Query component</p> <code>''</code> <code>fragment</code> <code>str</code> <p>Fragment identifier</p> <code>''</code> <p>Returns:</p> Name Type Description <code>url</code> <code>str</code> <p>Compiled URL</p> Source code in <code>camply/utils/api_utils.py</code> <pre><code>def generate_url(\nscheme: str,\nnetloc: str,\npath: str = \"\",\nparams: str = \"\",\nquery: str = \"\",\nfragment: str = \"\",\n):\n\"\"\"\n    Build a URL\n    Parameters\n    ----------\n    scheme: str\n        URL scheme specifier\n    netloc: str\n        Network location part\n    path: str\n        Hierarchical path\n    params: str\n        Parameters for last path element\n    query: str\n        Query component\n    fragment: str\n        Fragment identifier\n    Returns\n    -------\n    url: str\n        Compiled URL\n    \"\"\"\nurl_components = {\n\"scheme\": scheme,\n\"netloc\": netloc,\n\"path\": path,\n\"params\": params,\n\"query\": query,\n\"fragment\": fragment,\n}\nreturn parse.urlunparse(components=tuple(url_components.values()))\n</code></pre>"},{"location":"reference/utils/#camply.utils.log_camply","title":"<code>log_camply(self, message, *args, **kwargs)</code>","text":"<p>Custom Logging Notification Level for Pushover Logging</p> <p>Between logging.ERROR and logging.CRITICAL (45)</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <code>logging.Logger</code> required <code>message</code> <code>str</code> <p>Message String</p> required <code>args</code> <code>()</code> <code>kwargs</code> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> Source code in <code>camply/utils/logging_utils.py</code> <pre><code>def log_camply(self: logging.Logger, message: str, *args, **kwargs) -&gt; None:\n\"\"\"\n    Custom Logging Notification Level for Pushover Logging\n    Between logging.ERROR and logging.CRITICAL (45)\n    Parameters\n    ----------\n    self: logging.Logger\n    message: str\n        Message String\n    args\n    kwargs\n    Returns\n    -------\n    None\n    \"\"\"\nnotification_level = logging.INFO + 1\nlogging.addLevelName(level=notification_level, levelName=\"CAMPLY\")\nif self.isEnabledFor(level=notification_level):\nself._log(level=notification_level, msg=message, args=args, **kwargs)\n</code></pre>"},{"location":"reference/utils/#camply.utils.make_list","title":"<code>make_list(obj, coerce=None)</code>","text":"<p>Make Anything An Iterable Instance</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> required <code>coerce</code> <code>Optional[Callable]</code> <code>None</code> <p>Returns:</p> Type Description <code>List[object]</code> Source code in <code>camply/utils/general_utils.py</code> <pre><code>def make_list(obj, coerce: Optional[Callable] = None) -&gt; Optional[List[Any]]:\n\"\"\"\n    Make Anything An Iterable Instance\n    Parameters\n    ----------\n    obj: object\n    coerce: Callable\n    Returns\n    -------\n    List[object]\n    \"\"\"\nif obj is None:\nreturn None\nelif isinstance(obj, CamplyModel):\nreturn [coerce(obj) if coerce is not None else obj]\nelif is_list_like(obj) is True:\nif coerce is not None:\nreturn [coerce(item) for item in obj]\nelse:\nreturn list(obj)\nelse:\nreturn [coerce(obj) if coerce is not None else obj]\n</code></pre>"},{"location":"reference/utils/api_utils/","title":"api_utils","text":"<p>Recreation.gov Web Searching Utilities</p>"},{"location":"reference/utils/api_utils/#camply.utils.api_utils.filter_json","title":"<code>filter_json(json, filters)</code>","text":"<p>Extension Method to Dictionaries, allows easy filtering</p> <p>Parameters:</p> Name Type Description Default <code>json</code> <code>dict</code> required <code>filters</code> <code>Union[str, List[str]]</code> required <p>Returns:</p> Name Type Description <code>filtered_object</code> <code>object</code> <p>Resulting JSON Filtered Object</p> Source code in <code>camply/utils/api_utils.py</code> <pre><code>def filter_json(json: dict, filters: Union[str, List[str]]) -&gt; object:\n\"\"\"\n    Extension Method to Dictionaries, allows easy filtering\n    Parameters\n    ----------\n    json\n    filters\n    Returns\n    -------\n    filtered_object: object\n        Resulting JSON Filtered Object\n    \"\"\"\nif not isinstance(filters, list):\nfilters = [filters]\nobject_layers = {0: json}\ntry:\nfor index, filter_layer in enumerate(filters):\nlayer_index = index + 1\nobject_layers[layer_index] = object_layers[index][filter_layer]\ndel object_layers[index]\nexcept KeyError as key_error:\nerror_message = (\nf\"Unable to find matching JSON Filtering | {key_error} | {filters}\"\n)\nlogger.error(error_message)\nraise KeyError from key_error\nreturn object_layers[len(filters)]\n</code></pre>"},{"location":"reference/utils/api_utils/#camply.utils.api_utils.generate_url","title":"<code>generate_url(scheme, netloc, path='', params='', query='', fragment='')</code>","text":"<p>Build a URL</p> <p>Parameters:</p> Name Type Description Default <code>scheme</code> <code>str</code> <p>URL scheme specifier</p> required <code>netloc</code> <code>str</code> <p>Network location part</p> required <code>path</code> <code>str</code> <p>Hierarchical path</p> <code>''</code> <code>params</code> <code>str</code> <p>Parameters for last path element</p> <code>''</code> <code>query</code> <code>str</code> <p>Query component</p> <code>''</code> <code>fragment</code> <code>str</code> <p>Fragment identifier</p> <code>''</code> <p>Returns:</p> Name Type Description <code>url</code> <code>str</code> <p>Compiled URL</p> Source code in <code>camply/utils/api_utils.py</code> <pre><code>def generate_url(\nscheme: str,\nnetloc: str,\npath: str = \"\",\nparams: str = \"\",\nquery: str = \"\",\nfragment: str = \"\",\n):\n\"\"\"\n    Build a URL\n    Parameters\n    ----------\n    scheme: str\n        URL scheme specifier\n    netloc: str\n        Network location part\n    path: str\n        Hierarchical path\n    params: str\n        Parameters for last path element\n    query: str\n        Query component\n    fragment: str\n        Fragment identifier\n    Returns\n    -------\n    url: str\n        Compiled URL\n    \"\"\"\nurl_components = {\n\"scheme\": scheme,\n\"netloc\": netloc,\n\"path\": path,\n\"params\": params,\n\"query\": query,\n\"fragment\": fragment,\n}\nreturn parse.urlunparse(components=tuple(url_components.values()))\n</code></pre>"},{"location":"reference/utils/configure_camply/","title":"configure_camply","text":"<p>Camply Configuration Script</p>"},{"location":"reference/utils/configure_camply/#camply.utils.configure_camply.check_dot_camply_file","title":"<code>check_dot_camply_file()</code>","text":"<p>Check to see if the <code>.camply</code> file already exists</p> <p>Return the file existence status</p> <p>Returns:</p> Type Description <code>bool</code> Source code in <code>camply/utils/configure_camply.py</code> <pre><code>def check_dot_camply_file() -&gt; bool:\n\"\"\"\n    Check to see if the `.camply` file already exists\n    Return the file existence status\n    Returns\n    -------\n    bool\n    \"\"\"\nif isfile(FileConfig.DOT_CAMPLY_FILE) is True:\nlogger.info(\n\"Skipping configuration. `.camply` file already exists: \"\nf\"{FileConfig.DOT_CAMPLY_FILE}\"\n)\nreturn True\nelse:\nreturn False\n</code></pre>"},{"location":"reference/utils/configure_camply/#camply.utils.configure_camply.double_check","title":"<code>double_check(message)</code>","text":"<p>Double check if a step should be taken within CLI</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Message to log in interactive shell</p> required Source code in <code>camply/utils/configure_camply.py</code> <pre><code>def double_check(message: str) -&gt; bool:\n\"\"\"\n    Double check if a step should be taken within CLI\n    Parameters\n    ----------\n    message: str\n        Message to log in interactive shell\n    \"\"\"\nfirst_confirmation = Confirm.ask(prompt=message)\nif first_confirmation is True:\nsecond_confirmation = Confirm.ask(prompt=\"Are you sure?\")\nreturn second_confirmation\nelse:\nlogging.info(\"Okay, skipping\")\nreturn False\n</code></pre>"},{"location":"reference/utils/configure_camply/#camply.utils.configure_camply.generate_configuration","title":"<code>generate_configuration()</code>","text":"<p>Generate the Camply Configuration Config</p> <p>Returns:</p> Type Description <code>OrderedDict</code> <p>Dict of configuration values</p> Source code in <code>camply/utils/configure_camply.py</code> <pre><code>def generate_configuration() -&gt; OrderedDict:\n\"\"\"\n    Generate the Camply Configuration Config\n    Returns\n    -------\n    OrderedDict\n        Dict of configuration values\n    \"\"\"\nconfig_dict = FileConfig.DOT_CAMPLY_FIELDS.copy()\nfor field, field_dict in config_dict.items():\ndefault_value = field_dict[\"default\"]\nfield_note = field_dict[\"notes\"]\nif field_note is not None:\nrich.print(\nf\"[bold blue]{field}:[/bold blue] \"\nf\"[bold green]{field_note}[/bold green]\"\n)\nmessage = f\"Enter value for [bold blue]{field}[/bold blue]\"\nif default_value != \"\":\nmessage += f\" (default: `[bold purple]{default_value}[/bold purple]`)\"\nlogged_input = Prompt.ask(prompt=message)\nconfig_value = logged_input if logged_input != \"\" else default_value\nconfig_dict[field] = config_value\nreturn config_dict\n</code></pre>"},{"location":"reference/utils/configure_camply/#camply.utils.configure_camply.generate_dot_camply_file","title":"<code>generate_dot_camply_file()</code>","text":"<p>Perform the larger Dot Camply File Generation</p> Source code in <code>camply/utils/configure_camply.py</code> <pre><code>def generate_dot_camply_file():\n\"\"\"\n    Perform the larger Dot Camply File Generation\n    \"\"\"\nlogger.info(\"Running camply configuration.\")\nlogger.info(\n\"This process generates a configuration file \"\n\"(https://github.com/juftin/camply/blob/main/docs/examples/example.camply)\"\n)\nlogger.info(\"Do not include quotes around values\")\nlogger.info(\n\"To skip a configuration field or keep it as default, just press &lt;Enter&gt;.\"\n)\nsleep(1.5)\nif isfile(FileConfig.DOT_CAMPLY_FILE):\nlogger.warning(\nf\".camply file already exists on this machine: {FileConfig.DOT_CAMPLY_FILE}\"\n)\noverwrite = double_check(\n\"Would you like to overwrite your \"\n\"[bold yellow].camply[/bold yellow] \"\n\"configuration file?\"\n)\nif overwrite is False:\nsys.exit(0)\nconfig = generate_configuration()\nif double_check(\n\"Are you ready to publish this to a file at \"\nf\"[bold yellow]{FileConfig.DOT_CAMPLY_FILE}[/bold yellow]\"\n):\nwrite_config_to_file(config_dict=config)\nlogger.info(f\"`.camply` file written to machine: {FileConfig.DOT_CAMPLY_FILE}\")\n</code></pre>"},{"location":"reference/utils/configure_camply/#camply.utils.configure_camply.write_config_to_file","title":"<code>write_config_to_file(config_dict)</code>","text":"<p>Write the Configuration Object to a file</p> <p>Parameters:</p> Name Type Description Default <code>config_dict</code> <code>OrderedDict</code> <p>Configuration Object</p> required Source code in <code>camply/utils/configure_camply.py</code> <pre><code>def write_config_to_file(config_dict: OrderedDict) -&gt; None:\n\"\"\"\n    Write the Configuration Object to a file\n    Parameters\n    ----------\n    config_dict : OrderedDict\n        Configuration Object\n    \"\"\"\nstring_list = [\n\"# CAMPLY CONFIGURATION FILE. \",\n\"# SEE https://github.com/juftin/camply/blob/main/docs/examples/example.camply\",\n\"\",\n]\nfor config_key, config_value in config_dict.items():\nstring_list.append(f'{config_key}=\"{config_value}\"')\nstring_list.append(\"\")\nwith open(FileConfig.DOT_CAMPLY_FILE, \"w\") as file_object:\nfile_object.write(\"\\n\".join(string_list))\nfile_object.seek(0)\n</code></pre>"},{"location":"reference/utils/general_utils/","title":"general_utils","text":"<p>Camply General Utilities</p>"},{"location":"reference/utils/general_utils/#camply.utils.general_utils.handle_search_windows","title":"<code>handle_search_windows(start_date, end_date)</code>","text":"<p>Handle Multiple Search Windows by the CLI</p> Source code in <code>camply/utils/general_utils.py</code> <pre><code>def handle_search_windows(\nstart_date: Union[Iterable[str], str, Iterable[datetime.date], datetime.date],\nend_date: Union[Iterable[str], str, Iterable[datetime.date], datetime.date],\n) -&gt; Union[List[SearchWindow], SearchWindow]:\n\"\"\"\n    Handle Multiple Search Windows by the CLI\n    \"\"\"\nif isinstance(start_date, (str, date)):\nstart_date = (start_date,)\nassert isinstance(end_date, (str, date))\nend_date = (end_date,)\nsearch_windows: List[SearchWindow] = []\nfor field in [start_date, end_date]:\nif field is None or (isinstance(field, (tuple, list)) and len(field) == 0):\nlogger.error(\"Campsite searches require a `start_date` and an `end_date`\")\nsys.exit(1)\nif len(start_date) != len(end_date):\nlogger.error(\n\"When searching multiple date windows, you must provide the same amount \"\n\"of `--start-dates` as `--end-dates`\"\n)\nsys.exit(1)\nfor index, date_str in enumerate(start_date):\nsearch_windows.append(\nSearchWindow(start_date=date_str, end_date=end_date[index])\n)\nif len(search_windows) == 1:\nreturn search_windows[0]\nelse:\nreturn search_windows\n</code></pre>"},{"location":"reference/utils/general_utils/#camply.utils.general_utils.is_list_like","title":"<code>is_list_like(obj)</code>","text":"<p>Define if an object is list-like</p> Source code in <code>camply/utils/general_utils.py</code> <pre><code>def is_list_like(obj: Any) -&gt; bool:\n\"\"\"\n    Define if an object is list-like\n    \"\"\"\nreturn isinstance(obj, (list, set, tuple))\n</code></pre>"},{"location":"reference/utils/general_utils/#camply.utils.general_utils.make_list","title":"<code>make_list(obj, coerce=None)</code>","text":"<p>Make Anything An Iterable Instance</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> required <code>coerce</code> <code>Optional[Callable]</code> <code>None</code> <p>Returns:</p> Type Description <code>List[object]</code> Source code in <code>camply/utils/general_utils.py</code> <pre><code>def make_list(obj, coerce: Optional[Callable] = None) -&gt; Optional[List[Any]]:\n\"\"\"\n    Make Anything An Iterable Instance\n    Parameters\n    ----------\n    obj: object\n    coerce: Callable\n    Returns\n    -------\n    List[object]\n    \"\"\"\nif obj is None:\nreturn None\nelif isinstance(obj, CamplyModel):\nreturn [coerce(obj) if coerce is not None else obj]\nelif is_list_like(obj) is True:\nif coerce is not None:\nreturn [coerce(item) for item in obj]\nelse:\nreturn list(obj)\nelse:\nreturn [coerce(obj) if coerce is not None else obj]\n</code></pre>"},{"location":"reference/utils/logging_utils/","title":"logging_utils","text":"<p>Logging Utilities for Pushover Variables</p>"},{"location":"reference/utils/logging_utils/#camply.utils.logging_utils.format_log_string","title":"<code>format_log_string(response)</code>","text":"<p>Generate a formatted string for logging</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Union[CampgroundFacility, RecreationArea, str]</code> required <p>Returns:</p> Type Description <code>str</code> Source code in <code>camply/utils/logging_utils.py</code> <pre><code>def format_log_string(response: Union[CampgroundFacility, RecreationArea, str]) -&gt; str:\n\"\"\"\n    Generate a formatted string for logging\n    Parameters\n    ----------\n    response: Union[CampgroundFacility]\n    Returns\n    -------\n    str\n    \"\"\"\nif isinstance(response, CampgroundFacility):\nif isinstance(response.facility_id, int):\nfacil = f\"#{response.facility_id}\"\nelse:\nfacil = response.facility_id\nreturn (\nf\"\u26f0  {response.recreation_area} (#{response.recreation_area_id}) - \"\nf\"\ud83c\udfd5  {response.facility_name} ({facil})\"\n)\nelif isinstance(response, RecreationArea):\nreturn (\nf\"\u26f0  {response.recreation_area}, {response.recreation_area_location} \"\nf\"(#{response.recreation_area_id})\"\n)\nelif isinstance(response, GoingToCampEquipment):\nreturn f\"{RVMOJI} {response.equipment_name} \" f\"(#{response.equipment_type_id})\"\nelif isinstance(response, str):\nreturn response\nelse:\nraise NotImplementedError\n</code></pre>"},{"location":"reference/utils/logging_utils/#camply.utils.logging_utils.get_emoji","title":"<code>get_emoji(obj)</code>","text":"<p>Return the Right Emoji</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>list</code> required <p>Returns:</p> Type Description <code>str</code> Source code in <code>camply/utils/logging_utils.py</code> <pre><code>def get_emoji(obj: list) -&gt; str:\n\"\"\"\n    Return the Right Emoji\n    Parameters\n    ----------\n    obj: list\n    Returns\n    -------\n    str\n    \"\"\"\nassert isinstance(obj, list)\nif len(obj) &gt;= 1:\nreturn TENTMOJI\nelse:\nreturn XMOJI\n</code></pre>"},{"location":"reference/utils/logging_utils/#camply.utils.logging_utils.log_camply","title":"<code>log_camply(self, message, *args, **kwargs)</code>","text":"<p>Custom Logging Notification Level for Pushover Logging</p> <p>Between logging.ERROR and logging.CRITICAL (45)</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <code>logging.Logger</code> required <code>message</code> <code>str</code> <p>Message String</p> required <code>args</code> <code>()</code> <code>kwargs</code> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> Source code in <code>camply/utils/logging_utils.py</code> <pre><code>def log_camply(self: logging.Logger, message: str, *args, **kwargs) -&gt; None:\n\"\"\"\n    Custom Logging Notification Level for Pushover Logging\n    Between logging.ERROR and logging.CRITICAL (45)\n    Parameters\n    ----------\n    self: logging.Logger\n    message: str\n        Message String\n    args\n    kwargs\n    Returns\n    -------\n    None\n    \"\"\"\nnotification_level = logging.INFO + 1\nlogging.addLevelName(level=notification_level, levelName=\"CAMPLY\")\nif self.isEnabledFor(level=notification_level):\nself._log(level=notification_level, msg=message, args=args, **kwargs)\n</code></pre>"},{"location":"reference/utils/logging_utils/#camply.utils.logging_utils.log_sorted_response","title":"<code>log_sorted_response(response_array)</code>","text":"<p>Log Some Statements in a Nice Sorted way</p> <p>Parameters:</p> Name Type Description Default <code>response_array</code> <code>List[Any]</code> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>camply/utils/logging_utils.py</code> <pre><code>def log_sorted_response(response_array: List[Any]) -&gt; None:\n\"\"\"\n    Log Some Statements in a Nice Sorted way\n    Parameters\n    ----------\n    response_array: List[str]\n    Returns\n    -------\n    None\n    \"\"\"\nlog_array = [format_log_string(obj) for obj in response_array]\nsorted_logs = sorted(log_array)\nfor log_response in sorted_logs:\nlogger.info(log_response)\n</code></pre>"},{"location":"reference/utils/yaml_utils/","title":"yaml_utils","text":"<p>YAML Utilities for Camply</p>"},{"location":"reference/utils/yaml_utils/#camply.utils.yaml_utils.read_yaml","title":"<code>read_yaml(path=None)</code>","text":"<p>Read a YAML File</p> <p>Load a yaml configuration file_path (path) or data object (data) and resolve any environment variables. The environment variables must be in this format to be parsed: ${VAR_NAME}.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>File Path of YAML Object to Read</p> <code>None</code> <p>Examples:</p> <p>database:     host: ${HOST}     port: ${PORT}     ${KEY}: ${VALUE} app:     log_path: \"/var/${LOG_PATH}\"     something_else: \"${AWESOME_ENV_VAR}/var/${A_SECOND_AWESOME_VAR}\"</p> Source code in <code>camply/utils/yaml_utils.py</code> <pre><code>def read_yaml(path: str = None):\n\"\"\"\n    Read a YAML File\n    Load a yaml configuration file_path (path) or data object (data)\n    and resolve any environment variables. The environment\n    variables must be in this format to be parsed: ${VAR_NAME}.\n    Parameters\n    ----------\n    path: str\n        File Path of YAML Object to Read\n    Examples\n    --------\n    database:\n        host: ${HOST}\n        port: ${PORT}\n        ${KEY}: ${VALUE}\n    app:\n        log_path: \"/var/${LOG_PATH}\"\n        something_else: \"${AWESOME_ENV_VAR}/var/${A_SECOND_AWESOME_VAR}\"\n    \"\"\"\npath = os.path.abspath(path)\npattern = compile(r\".*?\\${(\\w+)}.*?\")\nsafe_loader = SafeLoader\nsafe_loader.add_implicit_resolver(tag=None, regexp=pattern, first=None)\ndef env_var_constructor(safe_loader: yaml.Loader, node: Any) -&gt; Any:\n\"\"\"\n        Extracts the environment variable from the node's value\n        Parameters\n        ----------\n        safe_loader: yaml.Loader\n        node: Any\n            The current node in the yaml\n        Returns\n        -------\n        Any\n            the parsed string that contains the value of the environment variable\n        \"\"\"\nvalue = safe_loader.construct_scalar(node=node)\nmatch = pattern.findall(string=value)\nif match:\nfull_value = value\nfor item in match:\nfull_value = full_value.replace(\n\"${{{key}}}\".format(key=item), os.getenv(key=item, default=item)\n)\nreturn full_value\nreturn value\nsafe_loader.add_constructor(tag=None, constructor=env_var_constructor)\nwith open(path) as conf_data:\nreturn load(stream=conf_data, Loader=safe_loader)\n</code></pre>"},{"location":"reference/utils/yaml_utils/#camply.utils.yaml_utils.yaml_file_to_arguments","title":"<code>yaml_file_to_arguments(file_path)</code>","text":"<p>Convert YAML File into A Dictionary to be used as **kwargs</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>File Path to YAML</p> required <p>Returns:</p> Type Description <code>provider, provider_kwargs, search_kwargs</code> <p>Tuple containing provider string, provider kwargs, and search kwargs</p> Source code in <code>camply/utils/yaml_utils.py</code> <pre><code>def yaml_file_to_arguments(\nfile_path: str,\n) -&gt; Tuple[str, Dict[str, object], Dict[str, object]]:\n\"\"\"\n    Convert YAML File into A Dictionary to be used as **kwargs\n    Parameters\n    ----------\n    file_path: str\n        File Path to YAML\n    Returns\n    -------\n    provider, provider_kwargs, search_kwargs: Tuple[str, Dict[str, object], Dict[str, object]]\n        Tuple containing provider string, provider **kwargs, and search **kwargs\n    \"\"\"\nyaml_search = read_yaml(path=file_path)\nlogger.info(f\"YAML File Parsed: {Path(file_path).name}\")\nyaml_model = YamlSearchFile(**yaml_search)\nif isinstance(yaml_model.provider, Enum):\nprovider = yaml_model.provider.value\nelse:\nprovider = yaml_model.provider\nsearch_window = handle_search_windows(\nstart_date=yaml_model.start_date, end_date=yaml_model.end_date\n)\ndays_of_the_week = yaml_model.days\nif days_of_the_week is not None:\nlower_mapping = {\nkey.lower(): value for key, value in days_of_the_week_mapping.items()\n}\ndays_of_the_week = [lower_mapping[item.lower()] for item in days_of_the_week]\nequipment = make_list(yaml_model.equipment)\nif isinstance(equipment, list):\nequipment = [tuple(equip) for equip in equipment]\nprovider_kwargs = {\n\"search_window\": search_window,\n\"recreation_area\": yaml_model.recreation_area,\n\"campgrounds\": yaml_model.campgrounds,\n\"campsites\": yaml_model.campsites,\n\"weekends_only\": yaml_model.weekends,\n\"days_of_the_week\": days_of_the_week,\n\"nights\": yaml_model.nights,\n\"equipment\": equipment,\n\"offline_search\": yaml_model.offline_search,\n\"offline_search_path\": yaml_model.offline_search_path,\n}\nsearch_kwargs = {\n\"log\": True,\n\"verbose\": True,\n\"continuous\": yaml_model.continuous,\n\"polling_interval\": yaml_model.polling_interval,\n\"notify_first_try\": yaml_model.notify_first_try,\n\"notification_provider\": yaml_model.notifications,\n\"search_forever\": yaml_model.search_forever,\n\"search_once\": yaml_model.search_once,\n}\nreturn provider, provider_kwargs, search_kwargs\n</code></pre>"}]}