{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"camply # camply , the campsite finder \u26fa\ufe0f, is a tool to help you book a campground online. Finding reservations at sold out campgrounds can be tough. That's where camply comes in. It searches the APIs of booking services like https://recreation.gov (which indexes thousands of campgrounds across the USA) to continuously check for cancellations and availabilities to pop up. Once a campsite becomes available, camply sends you a notification to book your spot! Table of Contents # Installation PyPI Docker Command Line Usage campsites recreation-areas campgrounds configure Examples Searching for a Campsite Searching for a Campsite by Campground ID Searching for a Specific Campsite by ID Continuously Searching for A Campsite Continue Looking After The First Match Is Found Send a Push Notification Send a Text Message Send a Notification to Different Services Look for Weekend Campsite Availabilities Look for Consecutive Nights at the Same Campsite Look for a Campsite Inside of Yellowstone Look for a Campsite Across Multiple Recreation areas Using a YAML Configuration file to search for campsites Searching for a Campsite That Fits Your Equipment Saving the Results of a Search Search for Recreation Areas by Query String Look for Specific Campgrounds Within a Recreation Area Look for Specific Campgrounds by Query String Finding Recreation Areas IDs and Campground IDs To Search Without Using the Command Line Object-Oriented Usage (Python) Search for a Recreation.gov Campsite Continuously Search for Recreation.gov Campsites Running in Docker Dependencies Recreation data provided by Recreation.gov","title":"camply \u26fa"},{"location":"#camply","text":"camply , the campsite finder \u26fa\ufe0f, is a tool to help you book a campground online. Finding reservations at sold out campgrounds can be tough. That's where camply comes in. It searches the APIs of booking services like https://recreation.gov (which indexes thousands of campgrounds across the USA) to continuously check for cancellations and availabilities to pop up. Once a campsite becomes available, camply sends you a notification to book your spot!","title":"camply"},{"location":"#table-of-contents","text":"Installation PyPI Docker Command Line Usage campsites recreation-areas campgrounds configure Examples Searching for a Campsite Searching for a Campsite by Campground ID Searching for a Specific Campsite by ID Continuously Searching for A Campsite Continue Looking After The First Match Is Found Send a Push Notification Send a Text Message Send a Notification to Different Services Look for Weekend Campsite Availabilities Look for Consecutive Nights at the Same Campsite Look for a Campsite Inside of Yellowstone Look for a Campsite Across Multiple Recreation areas Using a YAML Configuration file to search for campsites Searching for a Campsite That Fits Your Equipment Saving the Results of a Search Search for Recreation Areas by Query String Look for Specific Campgrounds Within a Recreation Area Look for Specific Campgrounds by Query String Finding Recreation Areas IDs and Campground IDs To Search Without Using the Command Line Object-Oriented Usage (Python) Search for a Recreation.gov Campsite Continuously Search for Recreation.gov Campsites Running in Docker Dependencies Recreation data provided by Recreation.gov","title":"Table of Contents"},{"location":"cli/","text":"Command Line Interface # Documentation # camply # Welcome to camply, the campsite finder. Finding reservations at sold out campgrounds can be tough. That's where camply comes in. It searches the APIs of booking services like https://recreation.gov (which indexes thousands of campgrounds across the USA) to continuously check for cancellations and availabilities to pop up. Once a campsite becomes available, camply sends you a notification to book your spot! visit the camply documentation at https://github.com/juftin/camply Usage: camply [OPTIONS] COMMAND [ARGS]... Options: Name Type Description Default --version boolean Show the version and exit. False --provider text Camping Search Provider. Options available are 'Yellowstone' and 'RecreationDotGov'. Defaults to 'RecreationDotGov', not case-sensitive. None --debug / --no-debug boolean Enable extra debugging output None --help boolean Show this message and exit. False Subcommands campgrounds : campsites : configure : recreation-areas : camply campgrounds # Search for Campgrounds (inside of Recreation Areas) and list them Search for Campgrounds and their IDs. Campgrounds are facilities inside of Recreation Areas that contain campsites. Most 'campgrounds' are areas made up of multiple campsites, others are facilities like fire towers or cabins that might only contain a single 'campsite' to book. Usage: camply campgrounds [OPTIONS] Options: Name Type Description Default --search text Search for Campgrounds or Recreation Areas by search string. None --state text Filter by US state code. None --rec-area text Add Recreation Areas (comprised of campgrounds) by ID. None --campground text Add individual Campgrounds by ID. None --campsite text Add individual Campsites by ID. None --provider text Camping Search Provider. Options available are 'Yellowstone' and 'RecreationDotGov'. Defaults to 'RecreationDotGov', not case-sensitive. None --debug / --no-debug boolean Enable extra debugging output None --help boolean Show this message and exit. False camply campsites # Find available Campsites using search criteria Search for a campsite within camply. Campsites are returned based on the search criteria provided. Campsites contain properties like booking date, site type (tent, RV, cabin, etc), capacity, price, and a link to make the booking. Required parameters include --start-date , --end-date , --rec-area / --campground . Constant searching functionality can be enabled with --continuous and notifications can be enabled using --notifications . Usage: camply campsites [OPTIONS] Options: Name Type Description Default --yaml-config , --yml-config text Rather than provide arguments to the command line utility, instead pass a file path to a YAML configuration file. See the documentation for more information on how to structure your configuration file. None --offline-search-path text When offline search is set to True, this is the name of the file to be saved/loaded. Campsites can be saved as a serialized pickle file or a JSON file, depending on the file extension. When not specified, the filename will default to camply_campsites.json None --offline-search boolean When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. False --search-forever boolean If --continuous is activated, this method continues to search after the first availability has been found. The one caveat is that it will never notify about the same identical campsite for the same booking date. False --notify-first-try boolean If --continuous is activated, whether to send all non-silent notifications if more than 5 matching campsites are found on the first try. Defaults to false which only sends the first 5. False --notifications text If --continuous is activated, types of notifications to receive. Options available are 'email', 'pushover', 'pushbullet', 'telegram', 'twilio', or 'silent'. Defaults to 'silent' - which just logs messages to console. ['silent'] --polling-interval integer If --continuous is activated, how often to wait in between checks (in minutes). Defaults to 10, cannot be less than 5. 10 --continuous boolean Continuously check for a campsite to become available, and quit once at least one campsite is found. False --provider text Camping Search Provider. Options available are 'Yellowstone' and 'RecreationDotGov'. Defaults to 'RecreationDotGov', not case-sensitive. None --equipment text Search for campsites compatible with your camping equipment. This argument accepts two options, the equipment name and its length If you don't want to filter based on length provide a length of 0. Accepted equipment names include Tent , RV . Trailer , Vehicle and are not case-sensitive. None --nights integer Search for campsite stays with consecutive nights. Defaults to 1 which returns all campsites found. 1 --weekends boolean Only search for weekend bookings (Fri/Sat nights). False --end-date text (YYYY-MM-DD) End of Search window. You will be checking out this day. None --start-date text (YYYY-MM-DD) Start of Search window. You will be arriving this day. None --campsite text Add individual Campsites by ID. None --campground text Add individual Campgrounds by ID. None --rec-area text Add Recreation Areas (comprised of campgrounds) by ID. None --debug / --no-debug boolean Enable extra debugging output None --help boolean Show this message and exit. False camply configure # Set up camply configuration file with an interactive console In order to send notifications through camply you must set up some authorization values. Whether you need to set up pushover notifications (push notifications on your phone, your pushover account can be set up at https://pushover.net ) or Email messages, everything can be done through the configure command. The end result is a file called .camply in your home folder. Usage: camply configure [OPTIONS] Options: Name Type Description Default --debug / --no-debug boolean Enable extra debugging output None --help boolean Show this message and exit. False camply recreation-areas # Search for Recreation Areas and list them Search for Recreation Areas and their IDs. Recreation Areas are places like National Parks and National Forests that can contain one or many campgrounds. Usage: camply recreation-areas [OPTIONS] Options: Name Type Description Default --search text Search for Campgrounds or Recreation Areas by search string. None --state text Filter by US state code. None --debug / --no-debug boolean Enable extra debugging output None --help boolean Show this message and exit. False","title":"Command Line Interface \u2328\ufe0f"},{"location":"cli/#command-line-interface","text":"","title":"Command Line Interface"},{"location":"cli/#documentation","text":"","title":"Documentation"},{"location":"cli/#camply","text":"Welcome to camply, the campsite finder. Finding reservations at sold out campgrounds can be tough. That's where camply comes in. It searches the APIs of booking services like https://recreation.gov (which indexes thousands of campgrounds across the USA) to continuously check for cancellations and availabilities to pop up. Once a campsite becomes available, camply sends you a notification to book your spot! visit the camply documentation at https://github.com/juftin/camply Usage: camply [OPTIONS] COMMAND [ARGS]... Options: Name Type Description Default --version boolean Show the version and exit. False --provider text Camping Search Provider. Options available are 'Yellowstone' and 'RecreationDotGov'. Defaults to 'RecreationDotGov', not case-sensitive. None --debug / --no-debug boolean Enable extra debugging output None --help boolean Show this message and exit. False Subcommands campgrounds : campsites : configure : recreation-areas :","title":"camply"},{"location":"cli/#camply-campgrounds","text":"Search for Campgrounds (inside of Recreation Areas) and list them Search for Campgrounds and their IDs. Campgrounds are facilities inside of Recreation Areas that contain campsites. Most 'campgrounds' are areas made up of multiple campsites, others are facilities like fire towers or cabins that might only contain a single 'campsite' to book. Usage: camply campgrounds [OPTIONS] Options: Name Type Description Default --search text Search for Campgrounds or Recreation Areas by search string. None --state text Filter by US state code. None --rec-area text Add Recreation Areas (comprised of campgrounds) by ID. None --campground text Add individual Campgrounds by ID. None --campsite text Add individual Campsites by ID. None --provider text Camping Search Provider. Options available are 'Yellowstone' and 'RecreationDotGov'. Defaults to 'RecreationDotGov', not case-sensitive. None --debug / --no-debug boolean Enable extra debugging output None --help boolean Show this message and exit. False","title":"campgrounds"},{"location":"cli/#camply-campsites","text":"Find available Campsites using search criteria Search for a campsite within camply. Campsites are returned based on the search criteria provided. Campsites contain properties like booking date, site type (tent, RV, cabin, etc), capacity, price, and a link to make the booking. Required parameters include --start-date , --end-date , --rec-area / --campground . Constant searching functionality can be enabled with --continuous and notifications can be enabled using --notifications . Usage: camply campsites [OPTIONS] Options: Name Type Description Default --yaml-config , --yml-config text Rather than provide arguments to the command line utility, instead pass a file path to a YAML configuration file. See the documentation for more information on how to structure your configuration file. None --offline-search-path text When offline search is set to True, this is the name of the file to be saved/loaded. Campsites can be saved as a serialized pickle file or a JSON file, depending on the file extension. When not specified, the filename will default to camply_campsites.json None --offline-search boolean When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. False --search-forever boolean If --continuous is activated, this method continues to search after the first availability has been found. The one caveat is that it will never notify about the same identical campsite for the same booking date. False --notify-first-try boolean If --continuous is activated, whether to send all non-silent notifications if more than 5 matching campsites are found on the first try. Defaults to false which only sends the first 5. False --notifications text If --continuous is activated, types of notifications to receive. Options available are 'email', 'pushover', 'pushbullet', 'telegram', 'twilio', or 'silent'. Defaults to 'silent' - which just logs messages to console. ['silent'] --polling-interval integer If --continuous is activated, how often to wait in between checks (in minutes). Defaults to 10, cannot be less than 5. 10 --continuous boolean Continuously check for a campsite to become available, and quit once at least one campsite is found. False --provider text Camping Search Provider. Options available are 'Yellowstone' and 'RecreationDotGov'. Defaults to 'RecreationDotGov', not case-sensitive. None --equipment text Search for campsites compatible with your camping equipment. This argument accepts two options, the equipment name and its length If you don't want to filter based on length provide a length of 0. Accepted equipment names include Tent , RV . Trailer , Vehicle and are not case-sensitive. None --nights integer Search for campsite stays with consecutive nights. Defaults to 1 which returns all campsites found. 1 --weekends boolean Only search for weekend bookings (Fri/Sat nights). False --end-date text (YYYY-MM-DD) End of Search window. You will be checking out this day. None --start-date text (YYYY-MM-DD) Start of Search window. You will be arriving this day. None --campsite text Add individual Campsites by ID. None --campground text Add individual Campgrounds by ID. None --rec-area text Add Recreation Areas (comprised of campgrounds) by ID. None --debug / --no-debug boolean Enable extra debugging output None --help boolean Show this message and exit. False","title":"campsites"},{"location":"cli/#camply-configure","text":"Set up camply configuration file with an interactive console In order to send notifications through camply you must set up some authorization values. Whether you need to set up pushover notifications (push notifications on your phone, your pushover account can be set up at https://pushover.net ) or Email messages, everything can be done through the configure command. The end result is a file called .camply in your home folder. Usage: camply configure [OPTIONS] Options: Name Type Description Default --debug / --no-debug boolean Enable extra debugging output None --help boolean Show this message and exit. False","title":"configure"},{"location":"cli/#camply-recreation-areas","text":"Search for Recreation Areas and list them Search for Recreation Areas and their IDs. Recreation Areas are places like National Parks and National Forests that can contain one or many campgrounds. Usage: camply recreation-areas [OPTIONS] Options: Name Type Description Default --search text Search for Campgrounds or Recreation Areas by search string. None --state text Filter by US state code. None --debug / --no-debug boolean Enable extra debugging output None --help boolean Show this message and exit. False","title":"recreation-areas"},{"location":"command_line_usage/","text":"Command Line Usage # When installed, camply 's command line utility can be invoked with the command, camply . The CLI tool accepts one of four sub-arguments: campsites , recreation-areas , campgrounds , and configure . \u276f camply --help Usage: camply [OPTIONS] COMMAND [ARGS]... Welcome to camply, the campsite finder. Finding reservations at sold out campgrounds can be tough. That's where camply comes in. It searches the APIs of booking services like https://recreation.gov (which indexes thousands of campgrounds across the USA) to continuously check for cancellations and availabilities to pop up. Once a campsite becomes available, camply sends you a notification to book your spot! visit the camply documentation at https://github.com/juftin/camply Options: --version Show the version and exit. --provider TEXT Camping Search Provider. Options available are 'Yellowstone' and 'RecreationDotGov'. Defaults to 'RecreationDotGov', not case-sensitive. --debug / --no-debug Enable extra debugging output --help Show this message and exit. Commands: campgrounds Search for Campgrounds (inside of Recreation Areas)... campsites Find available Campsites using search criteria configure Set up camply configuration file with an interactive... recreation-areas Search for Recreation Areas and list them campsites # Search for a campsite within camply. Campsites are returned based on the search criteria provided. Campsites contain properties like booking date, site type (tent, RV, cabin, etc), capacity, price, and a link to make the booking. Required parameters include --start-date , --end-date , --rec-area / --campground / --campsite . Constant searching functionality can be enabled with --continuous and notifications via Email, Pushover, Pushbullet, and Telegram can be enabled using --notifications . Arguments # --rec-area : RECREATION_AREA_ID Add Recreation Areas (comprised of campgrounds) by ID. ** example --campground : CAMPGROUND_ID Add individual Campgrounds by ID. ** example --campsite : CAMPSITE_ID Add individual Campsites by ID. ** example --start-date : START_DATE YYYY-MM-DD : Start of Search window. You will be arriving this day. ** example --end-date : END_DATE YYYY-MM-DD : End of Search window. You will be checking out this day.. ** example --weekends Only search for weekend bookings (Fri/Sat nights). ** example --nights Search for campsite stays with consecutive nights. Defaults to 1 which returns all campsites found. ** example --provider : PROVIDER Camping Search Provider. Options available are 'Yellowstone' and 'RecreationDotGov'. Defaults to 'RecreationDotGov', not case-sensitive. ** example --continuous Continuously check for a campsite to become available, and quit once at least one campsite is found. ** example --search-forever If --continuous is activated, this method continues to search after the first availability has been found. The one caveat is that it will never notify about the same identical campsite for the same booking date. ** example --notifications : NOTIFICATIONS If --continuous is activated, types of notifications to receive. Options available are email , pushover , pushbullet , telegram , or silent . Defaults to silent - which just logs messages to console. ** example --equipment Search for campsites compatible with your camping equipment. This argument accepts two options, the equipment name and its length If you don't want to filter based on length provide a length of 0. Accepted equipment names include Tent , RV . Trailer , Vehicle and are not case-sensitive. ** example --notify-first-try If --continuous is activated, whether to send all non-silent notifications if more than 5 matching campsites are found on the first try. Defaults to false which only sends the first5. ** example --polling-interval : POLLING_INTERVAL If --continuous is activated, how often to wait in between checks (in minutes). Defaults to 10, cannot be less than 5. ** example --yaml-config Rather than provide arguments to the command line utility, instead pass a file path to a YAML configuration file. See the documentation for more information on how to structure your configuration file. ** example camply campsites \\ --rec-area 2725 \\ --start-date 2023-07-10 \\ --end-date 2023-07-18 recreation-areas # Search for Recreation Areas and their IDs. Recreation Areas are places like National Parks and National Forests that can contain one or many campgrounds. Arguments # --search SEARCH Search for Campgrounds or Recreation Areas by search string. --state STATE Filter by US state code. camply recreation-areas --search \"Yosemite National Park\" ** see the examples for more information campgrounds # Search for Campgrounds and their IDs. Campgrounds are facilities inside of Recreation Areas that contain campsites. Most 'campgrounds' are areas made up of multiple campsites, others are facilities like fire towers or cabins that might only contain a single 'campsite' to book. Arguments # --search SEARCH Search for Campgrounds or Recreation Areas by search string. --state STATE Filter by US state code. --rec-area : RECREATION_AREA_ID Add Recreation Areas (comprised of campgrounds) by ID. --campground : CAMPGROUND_ID Add individual Campgrounds by ID. camply campgrounds --search \"Fire Tower Lookout\" --state CA ** see the examples for more information configure # Set up camply configuration file with an interactive console In order to send notifications through camply you must set up some authorization values. Whether you need to set up Pushover notifications , PushBullet , Telegram , or Email messages, everything can be done through the configure command. The end result is a file called .camply in your home folder. See the Running in Docker section to see how you can use environment variables instead of a config file. camply configure Examples # Read through the examples below to get a better understanding of camply , its features, and the functionality of the different arguments provided to the CLI. Searching for a Campsite # The below search looks for campsites inside of Recreation Area ID #2725 (Glacier National Park) between 2023-07-10 and 2023-07-17. The search will be performed once and any results will be logged to the console. camply searches for campsites inside of search windows in increments of one night. --start-date and --end-date define the bounds of the search window, you will be leaving the day after --end-date . camply campsites \\ --rec-area 2725 \\ --start-date 2023-07-10 \\ --end-date 2023-07-18 Searching for a Campsite by Campground ID # The below search looks for across three campgrounds (all inside Glacier National Park) between 2023-07-10 and 2023-07-17. Multiple Campgrounds (and Recreation Areas too) can be found by supplying the arguments more than once. camply campsites \\ --campground 232493 \\ --campground 251869 \\ --campground 232492 \\ --start-date 2023-07-10 \\ --end-date 2023-07-18 Searching for a Specific Campsite by ID # Sometimes you have a favorite campsite inside your favorite campground. To search for just a specific campsite (and not just all campsites within a campground) you can give its ID to camply with the --campsite argument. For example, site R035 in Many Glacier Campground, MT is close to a trailhead. Its URL is https://www.recreation.gov/camping/campsites/98363 , here we can see that it's ID is 98363 . You can search for one or many campsites by ID by supplying the --campsite argument. You can provide the --campsite argument once or multiple times to search for different campsites. Note, --campsite arguments override any --rec-area or --campground parameters provided. camply campsites \\ --campsite 98363 \\ --start-date 2023-07-10 \\ --end-date 2023-07-18 Continuously Searching for A Campsite # Sometimes you want to look for campgrounds until an eventual match is found. The below snippet will search for matching campsites until it finds a match. It also sends a notification via pushover once matches are found. Alternate notification methods are email , pushbullet , telegram , and silent ( default). Important Note : When camply is told to run --continuous with non-silent notifications set up and it finds more than 5 matching campsites on the first try, it will only send notifications for the first 5 campsites. This is to prevent thousands of campsites flooding your notifications. It's always encouraged to perform an initial online search before setting up a camply search. To bypass this behavior and send all notifications, pass the --notify-first-try argument. camply campsites \\ --rec-area 2725 \\ --start-date 2023-07-12 \\ --end-date 2023-07-13 \\ --continuous \\ --notifications pushover \\ --notify-first-try Continue Looking After The First Match Is Found # Sometimes you want to search for all possible matches up until your arrival date. No problem. Add the --search-forever and camply won't stop sending notifications after the first match is found. One important note, camply will save and store all previous notifications when --search-forever is enabled, so it won't notify you about the exact same campsite availability twice. This can be problematic when certain campsites become available more than once. camply campsites \\ --rec-area 2725 \\ --start-date 2023-07-01 \\ --end-date 2023-08-01 \\ --continuous \\ --notifications pushover \\ --search-forever Send a Push Notification # camply supports notifications via Pushbullet , Pushover , Telegram , and Email . Pushbullet is a great option because it's a free and easy service to sign up for and it supports notifications across different devices and operating systems. Similar to Pushover , Pushbullet requires that you create an account and an API token, and share that token with camply through a configuration file (via the camply configure command) or though environment variables ( PUSHBULLET_API_TOKEN ). camply campsites \\ --rec-area 2991 \\ --start-date 2023-09-10 \\ --end-date 2023-09-21 \\ --continuous \\ --notifications pushbullet Send a Text Message # If you want to sign up for a Twilio account, camply also supports sending text messages via SMS. You can set up your Twilio configuration via camply configure . You will need to set the following config values for Twilio: TWILIO_ACCOUNT_SID , TWILIO_AUTH_TOKEN , TWILIO_SOURCE_NUMBER , TWILIO_DEST_NUMBERS . Sending text messages via Twilio also requires the twilio extras: pip install camply[twilio] camply campsites \\ --rec-area 2991 \\ --start-date 2023-09-10 \\ --end-date 2023-09-21 \\ --continuous \\ --notifications twilio Send a Notification to Different Services # camply supports notifications from different providers. To send notifications to multiple providers you can pass the --notifications parameter multiple times. YAML config entries also accept an array as well. camply campsites \\ --rec-area 2991 \\ --start-date 2023-09-10 \\ --end-date 2023-09-21 \\ --continuous \\ --notifications email \\ --notifications pushover Look for Weekend Campsite Availabilities # This below search looks across larger periods of time, but only if a campground is available to book on a Friday or Saturday night ( --weekends ). It also uses the --polling-interval argument which checks every 5 minutes instead of the default 10 minutes. camply campsites \\ --rec-area 2991 \\ --start-date 2023-05-01 \\ --end-date 2023-08-01 \\ --weekends \\ --continuous \\ --notifications email \\ --polling-interval 5 Look for Consecutive Nights at the Same Campsite # A lot of times you need to search for consecutive nights at the same campsite. By default, any and all campsites with a single nights booking are returned by camply. To search for campsites with consecutive night stays, pass the --nights argument. Note, the --nights argument handles issues with improper search parameters. For example, if you set the --weekends parameter the maximum number of consecutive nights possible is 2. If you supply more than this your --nights parameter will be overwritten to 2. camply campsites \\ --rec-area 2991 \\ --start-date 2023-05-01 \\ --end-date 2023-08-01 \\ --nights 4 Look for a Campsite Inside of Yellowstone # Yellowstone doesn't use https://recreation.gov to manage its campgrounds, instead it uses its own proprietary system. In order to search the Yellowstone API for campsites, make sure to pass the --provider \"yellowstone\" argument. This flag disables --rec-area argument. To learn more about using camply to find campsites at Yellowstone, check out this discussion . camply campsites \\ --provider yellowstone \\ --start-date 2023-07-09 \\ --end-date 2023-07-17 \\ --continuous Look for a Campsite Across Multiple Recreation areas # You don't have to confine your search to a single Recreation or Campground ID. Adding multiple arguments to the command line will search across multiple IDs. Keep in mind that any --campground arguments will overwrite all --rec-area arguments. camply campsites \\ --rec-area 2991 \\ --rec-area 1074 \\ --start-date 2023-07-09 \\ --end-date 2023-07-17 \\ --nights 5 Using a YAML Configuration file to search for campsites # Sometimes, using a YAML configuration file is easier to manage all of your search options. See the below YAML example file and corresponding camply command: provider : RecreationDotGov # RecreationDotGov IF NOT PROVIDED recreation_area : # (LIST OR SINGLE ENTRY) - 2991 # Yosemite National Park, CA (All Campgrounds) - 1074 # Sierra National Forest, CA (All Campgrounds) campgrounds : null # ENTIRE FIELD CAN BE OMITTED IF NOT USED - (LIST OR SINGLE ENTRY) campsites : null # OVERRIDES CAMPGROUNDS / RECREATION AREA - (LIST OR SINGLE ENTRY) start_date : 2023-09-12 # YYYY-MM-DD end_date : 2023-09-13 # YYYY-MM-DD weekends : false # FALSE BY DEFAULT nights : 1 # 1 BY DEFAULT continuous : true # DEFAULTS TO TRUE polling_interval : 5 # DEFAULTS TO 10 , CAN'T BE LESS THAN 5 notifications : email # (silent, email, pushover, pushbullet, and telegram), DEFAULTS TO `silent` search_forever : true # FALSE BY DEFAULT notify_first_try : false # FALSE BY DEFAULT equipment : null # Array of Equipment Search Lists - DEFAULTS TO `null` offline_search : false # FALSE BY DEFAULT offline_search_path : camply_campsites.json # Defaults to `camply_campsites.json` camply campsites --yaml-config example_search.yaml Searching for a Campsite That Fits Your Equipment # Camply can help you filter campsites to fit your specific equipment, like a Trailer or an RV. Most likely, you care that the campsite fits the length of your RV so you can specify that as well. To search for specific equipment and its length provide the --equipment option with two arguments, the equipment name and the equipment length. If you don't want to filter based on length provide a length of zero. If you provide multiple --equipment options, sites matching any of your search equipment will be returned. Current supported equipment names are Vehicle , Tent , RV , and Trailer . Be careful when filtering on Tents and Vehicle length, sometimes Recreation.gov doesn't provide that information, it is safer to set length to 0. camply campsites \\ --rec-area 2991 \\ --start-date 2023-07-09 \\ --end-date 2023-07-17 \\ --nights 5 \\ --equipment RV 25 Here's what the above search would look like on a YAML Config: recreation_area : - 2991 start_date : 2023-07-09 end_date : 2023-07-17 nights : 5 equipment : - [ RV , 25 ] Finally, here's a search that accommodates trailers of all lengths: camply campsites \\ --rec-area 2991 \\ --start-date 2023-07-09 \\ --end-date 2023-07-17 \\ --nights 5 \\ --equipment Trailer 0 Saving the Results of a Search # In some cases, you might want to save all the campsites found during one search and load them into a new search, so you don't receive duplicate notifications. This can be achieved by passing the --offline-search flag. By default, camply will save the results in a file called camply_campsites.json . Optionally, you can also path the --offline-search-path flag to specify a certain file path to save the results as. When a file path with a .json extension is passed camply will export the results as a JSON file. When the .pkl or .pickle extension is used, camply will use a serialized Pickle file. camply \\ campsites \\ --campground 232064 \\ --start-date 2023-09-01 \\ --end-date 2023-10-01 \\ --continuous \\ --offline-search camply \\ campsites \\ --campground 232064 \\ --start-date 2023-09-01 \\ --end-date 2023-10-01 \\ --continuous \\ --offline-search \\ --offline-search-path campsites.pkl Search for Recreation Areas by Query String # Just need to find what your local Recreation Area ID number is? This simple command allows you to search and list recreation areas. It accepts --search and --state arguments. camply recreation-areas --search \"Yosemite National Park\" Look for Specific Campgrounds Within a Recreation Area # Need to get even more specific and search for a particular campground? This search lists campgrounds attached to a recreation area id --rec-area . It also accepts --search and --state arguments. camply campgrounds --rec-area 2991 Look for Specific Campgrounds by Query String # The below search looks for Fire Lookout Towers to stay in inside of California. camply campgrounds --search \"Fire Tower Lookout\" --state CA","title":"Usage \ud83d\udcdd"},{"location":"command_line_usage/#command-line-usage","text":"When installed, camply 's command line utility can be invoked with the command, camply . The CLI tool accepts one of four sub-arguments: campsites , recreation-areas , campgrounds , and configure . \u276f camply --help Usage: camply [OPTIONS] COMMAND [ARGS]... Welcome to camply, the campsite finder. Finding reservations at sold out campgrounds can be tough. That's where camply comes in. It searches the APIs of booking services like https://recreation.gov (which indexes thousands of campgrounds across the USA) to continuously check for cancellations and availabilities to pop up. Once a campsite becomes available, camply sends you a notification to book your spot! visit the camply documentation at https://github.com/juftin/camply Options: --version Show the version and exit. --provider TEXT Camping Search Provider. Options available are 'Yellowstone' and 'RecreationDotGov'. Defaults to 'RecreationDotGov', not case-sensitive. --debug / --no-debug Enable extra debugging output --help Show this message and exit. Commands: campgrounds Search for Campgrounds (inside of Recreation Areas)... campsites Find available Campsites using search criteria configure Set up camply configuration file with an interactive... recreation-areas Search for Recreation Areas and list them","title":"Command Line Usage"},{"location":"command_line_usage/#campsites","text":"Search for a campsite within camply. Campsites are returned based on the search criteria provided. Campsites contain properties like booking date, site type (tent, RV, cabin, etc), capacity, price, and a link to make the booking. Required parameters include --start-date , --end-date , --rec-area / --campground / --campsite . Constant searching functionality can be enabled with --continuous and notifications via Email, Pushover, Pushbullet, and Telegram can be enabled using --notifications .","title":"campsites"},{"location":"command_line_usage/#arguments","text":"--rec-area : RECREATION_AREA_ID Add Recreation Areas (comprised of campgrounds) by ID. ** example --campground : CAMPGROUND_ID Add individual Campgrounds by ID. ** example --campsite : CAMPSITE_ID Add individual Campsites by ID. ** example --start-date : START_DATE YYYY-MM-DD : Start of Search window. You will be arriving this day. ** example --end-date : END_DATE YYYY-MM-DD : End of Search window. You will be checking out this day.. ** example --weekends Only search for weekend bookings (Fri/Sat nights). ** example --nights Search for campsite stays with consecutive nights. Defaults to 1 which returns all campsites found. ** example --provider : PROVIDER Camping Search Provider. Options available are 'Yellowstone' and 'RecreationDotGov'. Defaults to 'RecreationDotGov', not case-sensitive. ** example --continuous Continuously check for a campsite to become available, and quit once at least one campsite is found. ** example --search-forever If --continuous is activated, this method continues to search after the first availability has been found. The one caveat is that it will never notify about the same identical campsite for the same booking date. ** example --notifications : NOTIFICATIONS If --continuous is activated, types of notifications to receive. Options available are email , pushover , pushbullet , telegram , or silent . Defaults to silent - which just logs messages to console. ** example --equipment Search for campsites compatible with your camping equipment. This argument accepts two options, the equipment name and its length If you don't want to filter based on length provide a length of 0. Accepted equipment names include Tent , RV . Trailer , Vehicle and are not case-sensitive. ** example --notify-first-try If --continuous is activated, whether to send all non-silent notifications if more than 5 matching campsites are found on the first try. Defaults to false which only sends the first5. ** example --polling-interval : POLLING_INTERVAL If --continuous is activated, how often to wait in between checks (in minutes). Defaults to 10, cannot be less than 5. ** example --yaml-config Rather than provide arguments to the command line utility, instead pass a file path to a YAML configuration file. See the documentation for more information on how to structure your configuration file. ** example camply campsites \\ --rec-area 2725 \\ --start-date 2023-07-10 \\ --end-date 2023-07-18","title":"Arguments"},{"location":"command_line_usage/#recreation-areas","text":"Search for Recreation Areas and their IDs. Recreation Areas are places like National Parks and National Forests that can contain one or many campgrounds.","title":"recreation-areas"},{"location":"command_line_usage/#arguments_1","text":"--search SEARCH Search for Campgrounds or Recreation Areas by search string. --state STATE Filter by US state code. camply recreation-areas --search \"Yosemite National Park\" ** see the examples for more information","title":"Arguments"},{"location":"command_line_usage/#campgrounds","text":"Search for Campgrounds and their IDs. Campgrounds are facilities inside of Recreation Areas that contain campsites. Most 'campgrounds' are areas made up of multiple campsites, others are facilities like fire towers or cabins that might only contain a single 'campsite' to book.","title":"campgrounds"},{"location":"command_line_usage/#arguments_2","text":"--search SEARCH Search for Campgrounds or Recreation Areas by search string. --state STATE Filter by US state code. --rec-area : RECREATION_AREA_ID Add Recreation Areas (comprised of campgrounds) by ID. --campground : CAMPGROUND_ID Add individual Campgrounds by ID. camply campgrounds --search \"Fire Tower Lookout\" --state CA ** see the examples for more information","title":"Arguments"},{"location":"command_line_usage/#configure","text":"Set up camply configuration file with an interactive console In order to send notifications through camply you must set up some authorization values. Whether you need to set up Pushover notifications , PushBullet , Telegram , or Email messages, everything can be done through the configure command. The end result is a file called .camply in your home folder. See the Running in Docker section to see how you can use environment variables instead of a config file. camply configure","title":"configure"},{"location":"command_line_usage/#examples","text":"Read through the examples below to get a better understanding of camply , its features, and the functionality of the different arguments provided to the CLI.","title":"Examples"},{"location":"command_line_usage/#searching-for-a-campsite","text":"The below search looks for campsites inside of Recreation Area ID #2725 (Glacier National Park) between 2023-07-10 and 2023-07-17. The search will be performed once and any results will be logged to the console. camply searches for campsites inside of search windows in increments of one night. --start-date and --end-date define the bounds of the search window, you will be leaving the day after --end-date . camply campsites \\ --rec-area 2725 \\ --start-date 2023-07-10 \\ --end-date 2023-07-18","title":"Searching for a Campsite"},{"location":"command_line_usage/#searching-for-a-campsite-by-campground-id","text":"The below search looks for across three campgrounds (all inside Glacier National Park) between 2023-07-10 and 2023-07-17. Multiple Campgrounds (and Recreation Areas too) can be found by supplying the arguments more than once. camply campsites \\ --campground 232493 \\ --campground 251869 \\ --campground 232492 \\ --start-date 2023-07-10 \\ --end-date 2023-07-18","title":"Searching for a Campsite by Campground ID"},{"location":"command_line_usage/#searching-for-a-specific-campsite-by-id","text":"Sometimes you have a favorite campsite inside your favorite campground. To search for just a specific campsite (and not just all campsites within a campground) you can give its ID to camply with the --campsite argument. For example, site R035 in Many Glacier Campground, MT is close to a trailhead. Its URL is https://www.recreation.gov/camping/campsites/98363 , here we can see that it's ID is 98363 . You can search for one or many campsites by ID by supplying the --campsite argument. You can provide the --campsite argument once or multiple times to search for different campsites. Note, --campsite arguments override any --rec-area or --campground parameters provided. camply campsites \\ --campsite 98363 \\ --start-date 2023-07-10 \\ --end-date 2023-07-18","title":"Searching for a Specific Campsite by ID"},{"location":"command_line_usage/#continuously-searching-for-a-campsite","text":"Sometimes you want to look for campgrounds until an eventual match is found. The below snippet will search for matching campsites until it finds a match. It also sends a notification via pushover once matches are found. Alternate notification methods are email , pushbullet , telegram , and silent ( default). Important Note : When camply is told to run --continuous with non-silent notifications set up and it finds more than 5 matching campsites on the first try, it will only send notifications for the first 5 campsites. This is to prevent thousands of campsites flooding your notifications. It's always encouraged to perform an initial online search before setting up a camply search. To bypass this behavior and send all notifications, pass the --notify-first-try argument. camply campsites \\ --rec-area 2725 \\ --start-date 2023-07-12 \\ --end-date 2023-07-13 \\ --continuous \\ --notifications pushover \\ --notify-first-try","title":"Continuously Searching for A Campsite"},{"location":"command_line_usage/#continue-looking-after-the-first-match-is-found","text":"Sometimes you want to search for all possible matches up until your arrival date. No problem. Add the --search-forever and camply won't stop sending notifications after the first match is found. One important note, camply will save and store all previous notifications when --search-forever is enabled, so it won't notify you about the exact same campsite availability twice. This can be problematic when certain campsites become available more than once. camply campsites \\ --rec-area 2725 \\ --start-date 2023-07-01 \\ --end-date 2023-08-01 \\ --continuous \\ --notifications pushover \\ --search-forever","title":"Continue Looking After The First Match Is Found"},{"location":"command_line_usage/#send-a-push-notification","text":"camply supports notifications via Pushbullet , Pushover , Telegram , and Email . Pushbullet is a great option because it's a free and easy service to sign up for and it supports notifications across different devices and operating systems. Similar to Pushover , Pushbullet requires that you create an account and an API token, and share that token with camply through a configuration file (via the camply configure command) or though environment variables ( PUSHBULLET_API_TOKEN ). camply campsites \\ --rec-area 2991 \\ --start-date 2023-09-10 \\ --end-date 2023-09-21 \\ --continuous \\ --notifications pushbullet","title":"Send a Push Notification"},{"location":"command_line_usage/#send-a-text-message","text":"If you want to sign up for a Twilio account, camply also supports sending text messages via SMS. You can set up your Twilio configuration via camply configure . You will need to set the following config values for Twilio: TWILIO_ACCOUNT_SID , TWILIO_AUTH_TOKEN , TWILIO_SOURCE_NUMBER , TWILIO_DEST_NUMBERS . Sending text messages via Twilio also requires the twilio extras: pip install camply[twilio] camply campsites \\ --rec-area 2991 \\ --start-date 2023-09-10 \\ --end-date 2023-09-21 \\ --continuous \\ --notifications twilio","title":"Send a Text Message"},{"location":"command_line_usage/#send-a-notification-to-different-services","text":"camply supports notifications from different providers. To send notifications to multiple providers you can pass the --notifications parameter multiple times. YAML config entries also accept an array as well. camply campsites \\ --rec-area 2991 \\ --start-date 2023-09-10 \\ --end-date 2023-09-21 \\ --continuous \\ --notifications email \\ --notifications pushover","title":"Send a Notification to Different Services"},{"location":"command_line_usage/#look-for-weekend-campsite-availabilities","text":"This below search looks across larger periods of time, but only if a campground is available to book on a Friday or Saturday night ( --weekends ). It also uses the --polling-interval argument which checks every 5 minutes instead of the default 10 minutes. camply campsites \\ --rec-area 2991 \\ --start-date 2023-05-01 \\ --end-date 2023-08-01 \\ --weekends \\ --continuous \\ --notifications email \\ --polling-interval 5","title":"Look for Weekend Campsite Availabilities"},{"location":"command_line_usage/#look-for-consecutive-nights-at-the-same-campsite","text":"A lot of times you need to search for consecutive nights at the same campsite. By default, any and all campsites with a single nights booking are returned by camply. To search for campsites with consecutive night stays, pass the --nights argument. Note, the --nights argument handles issues with improper search parameters. For example, if you set the --weekends parameter the maximum number of consecutive nights possible is 2. If you supply more than this your --nights parameter will be overwritten to 2. camply campsites \\ --rec-area 2991 \\ --start-date 2023-05-01 \\ --end-date 2023-08-01 \\ --nights 4","title":"Look for Consecutive Nights at the Same Campsite"},{"location":"command_line_usage/#look-for-a-campsite-inside-of-yellowstone","text":"Yellowstone doesn't use https://recreation.gov to manage its campgrounds, instead it uses its own proprietary system. In order to search the Yellowstone API for campsites, make sure to pass the --provider \"yellowstone\" argument. This flag disables --rec-area argument. To learn more about using camply to find campsites at Yellowstone, check out this discussion . camply campsites \\ --provider yellowstone \\ --start-date 2023-07-09 \\ --end-date 2023-07-17 \\ --continuous","title":"Look for a Campsite Inside of Yellowstone"},{"location":"command_line_usage/#look-for-a-campsite-across-multiple-recreation-areas","text":"You don't have to confine your search to a single Recreation or Campground ID. Adding multiple arguments to the command line will search across multiple IDs. Keep in mind that any --campground arguments will overwrite all --rec-area arguments. camply campsites \\ --rec-area 2991 \\ --rec-area 1074 \\ --start-date 2023-07-09 \\ --end-date 2023-07-17 \\ --nights 5","title":"Look for a Campsite Across Multiple Recreation areas"},{"location":"command_line_usage/#using-a-yaml-configuration-file-to-search-for-campsites","text":"Sometimes, using a YAML configuration file is easier to manage all of your search options. See the below YAML example file and corresponding camply command: provider : RecreationDotGov # RecreationDotGov IF NOT PROVIDED recreation_area : # (LIST OR SINGLE ENTRY) - 2991 # Yosemite National Park, CA (All Campgrounds) - 1074 # Sierra National Forest, CA (All Campgrounds) campgrounds : null # ENTIRE FIELD CAN BE OMITTED IF NOT USED - (LIST OR SINGLE ENTRY) campsites : null # OVERRIDES CAMPGROUNDS / RECREATION AREA - (LIST OR SINGLE ENTRY) start_date : 2023-09-12 # YYYY-MM-DD end_date : 2023-09-13 # YYYY-MM-DD weekends : false # FALSE BY DEFAULT nights : 1 # 1 BY DEFAULT continuous : true # DEFAULTS TO TRUE polling_interval : 5 # DEFAULTS TO 10 , CAN'T BE LESS THAN 5 notifications : email # (silent, email, pushover, pushbullet, and telegram), DEFAULTS TO `silent` search_forever : true # FALSE BY DEFAULT notify_first_try : false # FALSE BY DEFAULT equipment : null # Array of Equipment Search Lists - DEFAULTS TO `null` offline_search : false # FALSE BY DEFAULT offline_search_path : camply_campsites.json # Defaults to `camply_campsites.json` camply campsites --yaml-config example_search.yaml","title":"Using a YAML Configuration file to search for campsites"},{"location":"command_line_usage/#searching-for-a-campsite-that-fits-your-equipment","text":"Camply can help you filter campsites to fit your specific equipment, like a Trailer or an RV. Most likely, you care that the campsite fits the length of your RV so you can specify that as well. To search for specific equipment and its length provide the --equipment option with two arguments, the equipment name and the equipment length. If you don't want to filter based on length provide a length of zero. If you provide multiple --equipment options, sites matching any of your search equipment will be returned. Current supported equipment names are Vehicle , Tent , RV , and Trailer . Be careful when filtering on Tents and Vehicle length, sometimes Recreation.gov doesn't provide that information, it is safer to set length to 0. camply campsites \\ --rec-area 2991 \\ --start-date 2023-07-09 \\ --end-date 2023-07-17 \\ --nights 5 \\ --equipment RV 25 Here's what the above search would look like on a YAML Config: recreation_area : - 2991 start_date : 2023-07-09 end_date : 2023-07-17 nights : 5 equipment : - [ RV , 25 ] Finally, here's a search that accommodates trailers of all lengths: camply campsites \\ --rec-area 2991 \\ --start-date 2023-07-09 \\ --end-date 2023-07-17 \\ --nights 5 \\ --equipment Trailer 0","title":"Searching for a Campsite That Fits Your Equipment"},{"location":"command_line_usage/#saving-the-results-of-a-search","text":"In some cases, you might want to save all the campsites found during one search and load them into a new search, so you don't receive duplicate notifications. This can be achieved by passing the --offline-search flag. By default, camply will save the results in a file called camply_campsites.json . Optionally, you can also path the --offline-search-path flag to specify a certain file path to save the results as. When a file path with a .json extension is passed camply will export the results as a JSON file. When the .pkl or .pickle extension is used, camply will use a serialized Pickle file. camply \\ campsites \\ --campground 232064 \\ --start-date 2023-09-01 \\ --end-date 2023-10-01 \\ --continuous \\ --offline-search camply \\ campsites \\ --campground 232064 \\ --start-date 2023-09-01 \\ --end-date 2023-10-01 \\ --continuous \\ --offline-search \\ --offline-search-path campsites.pkl","title":"Saving the Results of a Search"},{"location":"command_line_usage/#search-for-recreation-areas-by-query-string","text":"Just need to find what your local Recreation Area ID number is? This simple command allows you to search and list recreation areas. It accepts --search and --state arguments. camply recreation-areas --search \"Yosemite National Park\"","title":"Search for Recreation Areas by Query String"},{"location":"command_line_usage/#look-for-specific-campgrounds-within-a-recreation-area","text":"Need to get even more specific and search for a particular campground? This search lists campgrounds attached to a recreation area id --rec-area . It also accepts --search and --state arguments. camply campgrounds --rec-area 2991","title":"Look for Specific Campgrounds Within a Recreation Area"},{"location":"command_line_usage/#look-for-specific-campgrounds-by-query-string","text":"The below search looks for Fire Lookout Towers to stay in inside of California. camply campgrounds --search \"Fire Tower Lookout\" --state CA","title":"Look for Specific Campgrounds by Query String"},{"location":"contributing/","text":"Contributing # Requirements # camply uses Poetry to manage its Python environment. To get started first install poetry : pipx install poetry pipx is preferred, but you can also install with pip install --user . Coding # camply makes use of a couple tools to help with contributing via pre-commit . pre-commit is a tool to manage git-hooks scripts, which are useful for identifying simple issues before submission to code review. pipx install pre-commit pre-commit install camply 's instance of pre-commit uses tools like black and isort to format your code in a standardized way. After cloning this repo run pre-commit install . Done, now pre-commit will run automatically on git commit. To run it manually on your changed code run pre-commit run on your command line. Running # Run the command-line interface from the source tree: poetry install poetry run camply Run an interactive Python session: poetry install poetry run python Testing # tox is a tool to standardize and manage testing and routines using Python virtual environments camply 's instance of tox runs Python unit tests, and uses tools like mypy and flake8 to format. To run all tox tests (which get run as part of GitHub Actions) locally, just enter tox into your command line or use poetry. Run the Full Test Suite: poetry run tox Run Just One Testing Tool: poetry run tox -e mypy Releasing # Releases are triggered entirely by CI/CD via Pull requests being merged into the main branch. The version bump on each release is decided by the labels placed on the Pull Requests. There must be one, and only one, of the following labels on each pull request to the main branch: BUMP_MAJOR , BUMP_MINOR , BUMP_PATCH . Pull Requests will be un-mergeable unless the version on your pyproject.toml matches the main branch and the proper version labels are applied. The Release workflow performs the following automated steps: Publish a GitHub Release. Apply a version tag to the repository. Build and upload the package to PyPI. Build and upload the package to Docker Hub. Release notes are populated with the titles and authors of merged pull requests. You can group the pull requests into separate sections by applying labels to them, like this: Pull Request Label Section in Release Notes breaking \ud83d\udca5 Breaking Changes enhancement \ud83d\ude80 Features removal \ud83d\udd25 Removals and Deprecations bug \ud83d\udc1e Fixes performance \ud83d\udc0e Performance testing \ud83d\udea8 Testing ci \ud83d\udc77 Continuous Integration documentation \ud83d\udcda Documentation refactoring \ud83d\udd28 Refactoring style \ud83d\udc84 Style dependencies \ud83d\udce6 Dependencies","title":"Contributing \ud83d\udc65"},{"location":"contributing/#contributing","text":"","title":"Contributing"},{"location":"contributing/#requirements","text":"camply uses Poetry to manage its Python environment. To get started first install poetry : pipx install poetry pipx is preferred, but you can also install with pip install --user .","title":"Requirements"},{"location":"contributing/#coding","text":"camply makes use of a couple tools to help with contributing via pre-commit . pre-commit is a tool to manage git-hooks scripts, which are useful for identifying simple issues before submission to code review. pipx install pre-commit pre-commit install camply 's instance of pre-commit uses tools like black and isort to format your code in a standardized way. After cloning this repo run pre-commit install . Done, now pre-commit will run automatically on git commit. To run it manually on your changed code run pre-commit run on your command line.","title":"Coding"},{"location":"contributing/#running","text":"Run the command-line interface from the source tree: poetry install poetry run camply Run an interactive Python session: poetry install poetry run python","title":"Running"},{"location":"contributing/#testing","text":"tox is a tool to standardize and manage testing and routines using Python virtual environments camply 's instance of tox runs Python unit tests, and uses tools like mypy and flake8 to format. To run all tox tests (which get run as part of GitHub Actions) locally, just enter tox into your command line or use poetry. Run the Full Test Suite: poetry run tox Run Just One Testing Tool: poetry run tox -e mypy","title":"Testing"},{"location":"contributing/#releasing","text":"Releases are triggered entirely by CI/CD via Pull requests being merged into the main branch. The version bump on each release is decided by the labels placed on the Pull Requests. There must be one, and only one, of the following labels on each pull request to the main branch: BUMP_MAJOR , BUMP_MINOR , BUMP_PATCH . Pull Requests will be un-mergeable unless the version on your pyproject.toml matches the main branch and the proper version labels are applied. The Release workflow performs the following automated steps: Publish a GitHub Release. Apply a version tag to the repository. Build and upload the package to PyPI. Build and upload the package to Docker Hub. Release notes are populated with the titles and authors of merged pull requests. You can group the pull requests into separate sections by applying labels to them, like this: Pull Request Label Section in Release Notes breaking \ud83d\udca5 Breaking Changes enhancement \ud83d\ude80 Features removal \ud83d\udd25 Removals and Deprecations bug \ud83d\udc1e Fixes performance \ud83d\udc0e Performance testing \ud83d\udea8 Testing ci \ud83d\udc77 Continuous Integration documentation \ud83d\udcda Documentation refactoring \ud83d\udd28 Refactoring style \ud83d\udc84 Style dependencies \ud83d\udce6 Dependencies","title":"Releasing"},{"location":"dependencies/","text":"Dependencies # camply is compatible with any Python version >= 3.6 . Currently, there are eight required dependencies: click The click package is used to leverage it's simple Command Line Interface API for camply requests The requests package is used to fetch data from the APIs of Camping Booking Providers. pandas The pandas package is to group and aggregate across large data sets of campsites, campgrounds, and recreation areas. tenacity The tenacity package is used for retrying data searches on the underlying campsite APIs. This retrying methodology handles exceptions allowing for API downtime and facilitating exponential backoff. rich Colorizing the CLI python-dotenv The python-dotenv package reads key-value pairs from a .env file and can set them as environment variables - this helps with the .camply configuration file. pydantic The pydantic package performs data validation against API responses and assists with fancy data containers for camply objects. PyYAML PyYAML is a YAML parsing library - this helps with the YAML file campsite searches.","title":"Dependencies \u267b\ufe0f"},{"location":"dependencies/#dependencies","text":"camply is compatible with any Python version >= 3.6 . Currently, there are eight required dependencies: click The click package is used to leverage it's simple Command Line Interface API for camply requests The requests package is used to fetch data from the APIs of Camping Booking Providers. pandas The pandas package is to group and aggregate across large data sets of campsites, campgrounds, and recreation areas. tenacity The tenacity package is used for retrying data searches on the underlying campsite APIs. This retrying methodology handles exceptions allowing for API downtime and facilitating exponential backoff. rich Colorizing the CLI python-dotenv The python-dotenv package reads key-value pairs from a .env file and can set them as environment variables - this helps with the .camply configuration file. pydantic The pydantic package performs data validation against API responses and assists with fancy data containers for camply objects. PyYAML PyYAML is a YAML parsing library - this helps with the YAML file campsite searches.","title":"Dependencies"},{"location":"docker/","text":"Running in Docker # Here's an example of a detached container searching in the background (notice the -d flag, the container will run detached). docker run -d \\ --name camply-detached-example \\ --env PUSHOVER_PUSH_TOKEN = ${ PUSHOVER_PUSH_TOKEN } \\ --env PUSHOVER_PUSH_USER = ${ PUSHOVER_PUSH_USER } \\ --env TZ = \"America/Denver\" \\ juftin/camply \\ camply campsites \\ --rec-area 2991 \\ --start-date 2023 -08-01 \\ --end-date 2023 -09-01 \\ --continuous \\ --notifications pushover The docker image accepts the following environment variables: Pushover Notifications PUSHOVER_PUSH_USER Email Notifications EMAIL_TO_ADDRESS EMAIL_USERNAME EMAIL_PASSWORD EMAIL_FROM_ADDRESS (defaults to \" camply@juftin.com \") EMAIL_SUBJECT_LINE (defaults to \"camply Notification\") EMAIL_SMTP_SERVER (defaults to \"smtp.gmail.com\") EMAIL_SMTP_PORT (defaults to 465) Optional Environment Variables LOG_LEVEL (sets logging level, defaults to \"INFO\") PUSHOVER_PUSH_TOKEN (Personal Pushover App Token) RIDB_API_KEY (Personal API Key for Recreation.gov API ) TZ ( TZ Database Name for logging, defaults to UTC) Alternatively, if you have already run camply configure locally, you can share your .camply file inside the docker container. docker run \\ --name camply-file-share-example \\ --env TZ = \"America/Denver\" \\ --volume ${ HOME } /.camply:/home/camply/.camply \\ juftin/camply \\ camply campsites \\ --provider yellowstone \\ --start-date 2023 -07-22 \\ --end-date 2023 -07-27 \\ --continuous \\ --notifications email To manage multiple searches (with different notification preferences) I like to use YAML configuration files: docker run -d \\ --name camply-email-example \\ --env TZ = \"America/Denver\" \\ --env EMAIL_TO_ADDRESS = ${ EMAIL_TO_ADDRESS } \\ --env EMAIL_USERNAME = ${ EMAIL_USERNAME } \\ --env EMAIL_PASSWORD = ${ EMAIL_PASSWORD } \\ --volume example_search.yaml:/home/camply/example_search.yaml \\ juftin/camply:latest \\ camply campsites \\ --yaml-config /home/camply/example_search.yaml A docker-compose example of the above YAML Config is also available.","title":"Docker \u26f4"},{"location":"docker/#running-in-docker","text":"Here's an example of a detached container searching in the background (notice the -d flag, the container will run detached). docker run -d \\ --name camply-detached-example \\ --env PUSHOVER_PUSH_TOKEN = ${ PUSHOVER_PUSH_TOKEN } \\ --env PUSHOVER_PUSH_USER = ${ PUSHOVER_PUSH_USER } \\ --env TZ = \"America/Denver\" \\ juftin/camply \\ camply campsites \\ --rec-area 2991 \\ --start-date 2023 -08-01 \\ --end-date 2023 -09-01 \\ --continuous \\ --notifications pushover The docker image accepts the following environment variables: Pushover Notifications PUSHOVER_PUSH_USER Email Notifications EMAIL_TO_ADDRESS EMAIL_USERNAME EMAIL_PASSWORD EMAIL_FROM_ADDRESS (defaults to \" camply@juftin.com \") EMAIL_SUBJECT_LINE (defaults to \"camply Notification\") EMAIL_SMTP_SERVER (defaults to \"smtp.gmail.com\") EMAIL_SMTP_PORT (defaults to 465) Optional Environment Variables LOG_LEVEL (sets logging level, defaults to \"INFO\") PUSHOVER_PUSH_TOKEN (Personal Pushover App Token) RIDB_API_KEY (Personal API Key for Recreation.gov API ) TZ ( TZ Database Name for logging, defaults to UTC) Alternatively, if you have already run camply configure locally, you can share your .camply file inside the docker container. docker run \\ --name camply-file-share-example \\ --env TZ = \"America/Denver\" \\ --volume ${ HOME } /.camply:/home/camply/.camply \\ juftin/camply \\ camply campsites \\ --provider yellowstone \\ --start-date 2023 -07-22 \\ --end-date 2023 -07-27 \\ --continuous \\ --notifications email To manage multiple searches (with different notification preferences) I like to use YAML configuration files: docker run -d \\ --name camply-email-example \\ --env TZ = \"America/Denver\" \\ --env EMAIL_TO_ADDRESS = ${ EMAIL_TO_ADDRESS } \\ --env EMAIL_USERNAME = ${ EMAIL_USERNAME } \\ --env EMAIL_PASSWORD = ${ EMAIL_PASSWORD } \\ --volume example_search.yaml:/home/camply/example_search.yaml \\ juftin/camply:latest \\ camply campsites \\ --yaml-config /home/camply/example_search.yaml A docker-compose example of the above YAML Config is also available.","title":"Running in Docker"},{"location":"installation/","text":"Installation # PyPI # Camply is hosted on PyPI, you can download it directly from tools like pip and pipx. pip install camply If you're using camply on your command line - it's recommended that you use a tool like pipx to easily manage the application in an isolated virtual environment. pipx install camply PyPI Link Docker # docker pull juftin/camply Docker Hub Link ** see Running in Docker .","title":"Installation \u2600\ufe0f"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#pypi","text":"Camply is hosted on PyPI, you can download it directly from tools like pip and pipx. pip install camply If you're using camply on your command line - it's recommended that you use a tool like pipx to easily manage the application in an isolated virtual environment. pipx install camply PyPI Link","title":"PyPI"},{"location":"installation/#docker","text":"docker pull juftin/camply Docker Hub Link ** see Running in Docker .","title":"Docker"},{"location":"python/","text":"Object-Oriented Usage (Python) # Search for a Recreation.gov Campsite # from datetime import datetime import logging from typing import List from camply.containers import AvailableCampsite , SearchWindow from camply.search import SearchRecreationDotGov logging . basicConfig ( format = \" %(asctime)s [ %(levelname)8s ]: %(message)s \" , level = logging . INFO ) month_of_june = SearchWindow ( start_date = datetime ( year = 2022 , month = 6 , day = 1 ), end_date = datetime ( year = 2022 , month = 6 , day = 30 )) camping_finder = SearchRecreationDotGov ( search_window = month_of_june , recreation_area = 2725 , # Glacier Ntl Park weekends_only = False , nights = 1 ) matches : List [ AvailableCampsite ] = camping_finder . get_matching_campsites ( log = True , verbose = True , continuous = False ) The above script returns a list of any matching AvailableCampsite pydantic objects: [ AvailableCampsite ( campsite_id = \"5391\" , booking_date = datetime . datetime ( 2022 , 6 , 13 , 0 , 0 ), campsite_site_name = \"B37\" , campsite_loop_name = \"Loop B\" , campsite_type = \"STANDARD NONELECTRIC\" , campsite_occupancy = ( 0 , 8 ), campsite_use_type = \"Overnight\" , availability_status = \"Available\" , recreation_area = \"Glacier National Park, MT\" , recreation_area_id = \"2725\" , facility_name = \"Fish Creek Campground\" , facility_id = \"232493\" , booking_url = \"https://www.recreation.gov/camping/campsites/5391\" ) ] Continuously Search for Recreation.gov Campsites # You'll notice that the get_matching_campsites function takes accepts parameter values very similar to the commandline arguments. from datetime import datetime import logging from camply.containers import SearchWindow from camply.search import SearchRecreationDotGov logging . basicConfig ( format = \" %(asctime)s [ %(levelname)8s ]: %(message)s \" , level = logging . INFO ) month_of_june = SearchWindow ( start_date = datetime ( year = 2022 , month = 6 , day = 1 ), end_date = datetime ( year = 2022 , month = 6 , day = 30 )) camping_finder = SearchRecreationDotGov ( search_window = month_of_june , recreation_area = [ 2991 , 1074 ], # Multiple Rec Areas weekends_only = False , nights = 3 ) camping_finder . get_matching_campsites ( log = True , verbose = True , continuous = True , polling_interval = 5 , notification_provider = \"pushover\" , search_forever = True , notify_first_try = False )","title":"Object Oriented Usage \ud83d\udc0d"},{"location":"python/#object-oriented-usage-python","text":"","title":"Object-Oriented Usage (Python)"},{"location":"python/#search-for-a-recreationgov-campsite","text":"from datetime import datetime import logging from typing import List from camply.containers import AvailableCampsite , SearchWindow from camply.search import SearchRecreationDotGov logging . basicConfig ( format = \" %(asctime)s [ %(levelname)8s ]: %(message)s \" , level = logging . INFO ) month_of_june = SearchWindow ( start_date = datetime ( year = 2022 , month = 6 , day = 1 ), end_date = datetime ( year = 2022 , month = 6 , day = 30 )) camping_finder = SearchRecreationDotGov ( search_window = month_of_june , recreation_area = 2725 , # Glacier Ntl Park weekends_only = False , nights = 1 ) matches : List [ AvailableCampsite ] = camping_finder . get_matching_campsites ( log = True , verbose = True , continuous = False ) The above script returns a list of any matching AvailableCampsite pydantic objects: [ AvailableCampsite ( campsite_id = \"5391\" , booking_date = datetime . datetime ( 2022 , 6 , 13 , 0 , 0 ), campsite_site_name = \"B37\" , campsite_loop_name = \"Loop B\" , campsite_type = \"STANDARD NONELECTRIC\" , campsite_occupancy = ( 0 , 8 ), campsite_use_type = \"Overnight\" , availability_status = \"Available\" , recreation_area = \"Glacier National Park, MT\" , recreation_area_id = \"2725\" , facility_name = \"Fish Creek Campground\" , facility_id = \"232493\" , booking_url = \"https://www.recreation.gov/camping/campsites/5391\" ) ]","title":"Search for a Recreation.gov Campsite"},{"location":"python/#continuously-search-for-recreationgov-campsites","text":"You'll notice that the get_matching_campsites function takes accepts parameter values very similar to the commandline arguments. from datetime import datetime import logging from camply.containers import SearchWindow from camply.search import SearchRecreationDotGov logging . basicConfig ( format = \" %(asctime)s [ %(levelname)8s ]: %(message)s \" , level = logging . INFO ) month_of_june = SearchWindow ( start_date = datetime ( year = 2022 , month = 6 , day = 1 ), end_date = datetime ( year = 2022 , month = 6 , day = 30 )) camping_finder = SearchRecreationDotGov ( search_window = month_of_june , recreation_area = [ 2991 , 1074 ], # Multiple Rec Areas weekends_only = False , nights = 3 ) camping_finder . get_matching_campsites ( log = True , verbose = True , continuous = True , polling_interval = 5 , notification_provider = \"pushover\" , search_forever = True , notify_first_try = False )","title":"Continuously Search for Recreation.gov Campsites"},{"location":"recreationdotgov/","text":"Finding Recreation Areas IDs and Campground IDs To Search Without Using the Command Line # You can uncover campground and recreation area IDs just by using the https://recreation.gov search functionality. Use the below example for a campground within Glacier National Park. First, perform your search on https://recreation.gov . The above search will take you to a URL like this: https://www.recreation.gov/search?q=Glacier%20National%20Park&entity_id=2725&entity_type=recarea . Taking a closer look at the URL components you can see that Glacier National Park has the Recreation Area ID #2725. Searching deeper into campgrounds inside of Glacier National Park you might find Fish Creek Campground at a URL like https://www.recreation.gov/camping/campgrounds/232493 . Here, we can see that this campground has a Campground ID of #232493.","title":"Finding Campsites on Recreation.gov \ud83c\udf32"},{"location":"recreationdotgov/#finding-recreation-areas-ids-and-campground-ids-to-search-without-using-the-command-line","text":"You can uncover campground and recreation area IDs just by using the https://recreation.gov search functionality. Use the below example for a campground within Glacier National Park. First, perform your search on https://recreation.gov . The above search will take you to a URL like this: https://www.recreation.gov/search?q=Glacier%20National%20Park&entity_id=2725&entity_type=recarea . Taking a closer look at the URL components you can see that Glacier National Park has the Recreation Area ID #2725. Searching deeper into campgrounds inside of Glacier National Park you might find Fish Creek Campground at a URL like https://www.recreation.gov/camping/campgrounds/232493 . Here, we can see that this campground has a Campground ID of #232493.","title":"Finding Recreation Areas IDs and Campground IDs To Search Without Using the Command Line"},{"location":"reference/","text":"camply init file AvailableCampsite # Bases: CamplyModel Campsite Storage This container should be universal regardless of API Provider Source code in camply/containers/data_containers.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class AvailableCampsite ( CamplyModel ): \"\"\" Campsite Storage This container should be universal regardless of API Provider \"\"\" campsite_id : Union [ int , str ] booking_date : datetime . datetime booking_end_date : datetime . datetime booking_nights : int campsite_site_name : str campsite_loop_name : str campsite_type : str campsite_occupancy : Tuple [ int , int ] campsite_use_type : str availability_status : str recreation_area : str recreation_area_id : int facility_name : str facility_id : Union [ int , str ] booking_url : str permitted_equipment : Optional [ List [ RecDotGovEquipment ]] campsite_attributes : Optional [ List [ RecDotGovAttribute ]] __unhashable__ = { \"permitted_equipment\" , \"campsite_attributes\" } EquipmentOptions # Bases: str , Enum Enumeration of the Equipment Options Source code in camply/config/search_config.py 22 23 24 25 26 27 28 29 30 31 32 33 class EquipmentOptions ( str , Enum ): \"\"\" Enumeration of the Equipment Options \"\"\" tent = \"tent\" rv = \"rv\" trailer = \"trailer\" vehicle = \"vehicle\" other = \"other\" __all_accepted_equipment__ = [ tent , rv , trailer , vehicle ] RecreationDotGov # Bases: BaseProvider Python Class for Working with Recreation.gov API / NPS APIs Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 class RecreationDotGov ( BaseProvider ): \"\"\" Python Class for Working with Recreation.gov API / NPS APIs \"\"\" def __init__ ( self , api_key : str = None ): \"\"\" Initialize with Search Dates \"\"\" if api_key is None : _api_key = RIDBConfig . API_KEY if isinstance ( _api_key , bytes ): _api_key : str = b64decode ( RIDBConfig . API_KEY ) . decode ( \"utf-8\" ) else : _api_key : str = api_key self . _ridb_api_headers : dict = dict ( accept = \"application/json\" , apikey = _api_key ) def __repr__ ( self ): \"\"\" String Representation Returns ------- str \"\"\" return \"<RecreationDotGov>\" def find_recreation_areas ( self , search_string : str = None , ** kwargs ) -> List [ dict ]: \"\"\" Find Matching Campsites Based on Search String Parameters ---------- search_string: str Search Keyword(s) Returns ------- filtered_responses: List[dict] Array of Matching Campsites \"\"\" try : assert any ( [ kwargs . get ( \"state\" , None ) is not None , search_string is not None and search_string != \"\" , ] ) except AssertionError : raise RuntimeError ( \"You must provide a search query or state(s) \" \"to find Recreation Areas\" ) logger . info ( f 'Searching for Recreation Areas: \" { search_string } \"' ) state_arg = kwargs . get ( \"state\" , None ) if state_arg is not None : kwargs . update ({ \"state\" : state_arg . upper ()}) params = dict ( query = search_string , sort = \"Name\" , full = \"true\" , ** kwargs ) if search_string is None : params . pop ( \"query\" ) api_response = self . _ridb_get_paginate ( path = RIDBConfig . REC_AREA_API_PATH , params = params ) logger . info ( f \" { len ( api_response ) } recreation areas found.\" ) logging_messages = list () for recreation_area_object in api_response : _ , recreation_area = self . _process_rec_area_response ( recreation_area = recreation_area_object ) if recreation_area is not None : logging_messages . append ( recreation_area ) log_sorted_response ( response_array = logging_messages ) return api_response def find_campgrounds ( self , search_string : str = None , rec_area_id : Optional [ List [ int ]] = None , campground_id : Optional [ List [ int ]] = None , campsite_id : Optional [ List [ int ]] = None , ** kwargs , ) -> List [ CampgroundFacility ]: \"\"\" Find Bookable Campgrounds Given a Set of Search Criteria Parameters ---------- search_string: str Search Keyword(s) rec_area_id: Optional[List[int]] Recreation Area ID to filter with campground_id: Optional[List[int]] ID of the Campground campsite_id: Optional[List[int]] ID of the Campsite Returns ------- facilities: List[CampgroundFacility] Array of Matching Campsites \"\"\" if campsite_id not in ( None , [], ()): facilities = self . _process_specific_campsites_provided ( campsite_id = campsite_id ) elif campground_id not in ( None , [], ()): facilities = self . _find_facilities_from_campgrounds ( campground_id = campground_id ) elif rec_area_id not in ( None , [], ()): facilities = list () for recreation_area in rec_area_id : facilities += self . find_facilities_per_recreation_area ( rec_area_id = recreation_area ) else : state_arg = kwargs . get ( \"state\" , None ) if state_arg is not None : kwargs . update ({ \"state\" : state_arg . upper ()}) if search_string in [ \"\" , None ] and state_arg is None : raise RuntimeError ( \"You must provide a search query or state to find campsites\" ) facilities = self . _find_facilities_from_search ( search = search_string , ** kwargs ) return facilities def find_facilities_per_recreation_area ( self , rec_area_id : int = None , ** kwargs ) -> List [ CampgroundFacility ]: \"\"\" Find Matching Campsites Based from Recreation Area Parameters ---------- rec_area_id: int Recreation Area ID Returns ------- campgrounds: List[CampgroundFacility] Array of Matching Campsites \"\"\" logger . info ( f \"Retrieving Facility Information for Recreation Area ID: ` { rec_area_id } `.\" ) api_path = f \" { RIDBConfig . REC_AREA_API_PATH } / { rec_area_id } / { RIDBConfig . FACILITIES_API_PATH } \" api_response = self . _ridb_get_paginate ( path = api_path , params = dict ( full = \"true\" , ** kwargs ) ) filtered_facilities = self . _filter_facilities_responses ( responses = api_response ) campgrounds = list () logger . info ( f \" { len ( filtered_facilities ) } Matching Campgrounds Found\" ) for facility in filtered_facilities : _ , campground_facility = self . process_facilities_responses ( facility = facility ) if campground_facility is not None : campgrounds . append ( campground_facility ) log_sorted_response ( response_array = campgrounds ) return campgrounds def _find_facilities_from_campgrounds ( self , campground_id : Union [ int , List [ int ]] ) -> List [ CampgroundFacility ]: \"\"\" Find Matching Campsites from Campground ID Parameters ---------- campground_id: Union[int, List[int]] ID of the Campsite Returns ------- filtered_responses: List[CampgroundFacility] Array of Matching Campsites \"\"\" campgrounds = list () for campground_identifier in campground_id : facility_data = self . get_ridb_data ( path = f \" { RIDBConfig . FACILITIES_API_PATH } / { campground_identifier } \" , params = dict ( full = True ), ) filtered_facility = self . _filter_facilities_responses ( responses = [ facility_data ] ) _ , campground_facility = self . process_facilities_responses ( facility = filtered_facility [ 0 ] ) if campground_facility is not None : campgrounds . append ( campground_facility ) logger . info ( f \" { len ( campgrounds ) } Matching Campgrounds Found\" ) log_sorted_response ( response_array = campgrounds ) return campgrounds def _find_facilities_from_search ( self , search : str , ** kwargs ) -> List [ dict ]: \"\"\" Find Matching Campgrounds Based on Search String Parameters ---------- search: str Search String Returns ------- campgrounds: List[dict] Array of Matching Campsites \"\"\" facilities_response = self . _ridb_get_paginate ( path = RIDBConfig . FACILITIES_API_PATH , params = dict ( query = search , activity = \"CAMPING\" , full = \"true\" , ** kwargs ), ) filtered_responses = self . _filter_facilities_responses ( responses = facilities_response ) logger . info ( f \" { len ( filtered_responses ) } Matching Campgrounds Found\" ) campgrounds = list () for facility in filtered_responses : _ , campground_facility = self . process_facilities_responses ( facility = facility ) if campground_facility is not None : campgrounds . append ( campground_facility ) log_sorted_response ( response_array = campgrounds ) return campgrounds @classmethod def _ridb_get_endpoint ( cls , path : str ) -> str : \"\"\" Return an API Endpoint for the RIDP Parameters ---------- path: str URL Endpoint, see https://ridb.recreation.gov/docs Returns ------- endpoint_url: str URL for the API Endpoint \"\"\" assert RIDBConfig . RIDB_BASE_PATH . endswith ( \"/\" ) base_url = api_utils . generate_url ( scheme = RIDBConfig . RIDB_SCHEME , netloc = RIDBConfig . RIDB_NET_LOC , path = RIDBConfig . RIDB_BASE_PATH , ) endpoint_url = parse . urljoin ( base_url , path ) return endpoint_url @tenacity . retry ( wait = tenacity . wait_random_exponential ( multiplier = 2 , max = 10 ), stop = tenacity . stop . stop_after_delay ( 15 ), ) def get_ridb_data ( self , path : str , params : Optional [ dict ] = None ) -> Union [ dict , list ]: \"\"\" Find Matching Campsites Based on Search String Parameters ---------- path: str URL Endpoint, see https://ridb.recreation.gov/docs params: Optional[dict] API Call Parameters Returns ------- Union[dict, list] \"\"\" api_endpoint = self . _ridb_get_endpoint ( path = path ) headers = self . _ridb_api_headers . copy () headers . update ( choice ( USER_AGENTS )) response = requests . get ( url = api_endpoint , headers = headers , params = params , timeout = 30 ) try : assert response . status_code == 200 except AssertionError : error_message = ( f \"Receiving bad data from Recreation.gov API: { response . text } \" ) logger . error ( error_message ) raise ConnectionError ( error_message ) return loads ( response . content ) def _ridb_get_paginate ( self , path : str , params : Optional [ dict ] = None , ) -> List [ dict ]: \"\"\" Return the Paginated Response from the RIDP Parameters ---------- path: str URL Endpoint, see https://ridb.recreation.gov/docs params: Optional[dict] API Call Parameters Returns ------- paginated_response: list Concatted Response \"\"\" if params is None : params = {} paginated_response = list () data_incomplete = True offset : int = 0 historical_results = 0 while data_incomplete is True : params . update ( offset = offset ) data_response = self . get_ridb_data ( path = path , params = params ) response_object = GenericResponse ( ** data_response ) paginated_response += response_object . RECDATA result_count = response_object . METADATA . RESULTS . CURRENT_COUNT historical_results += result_count total_count = response_object . METADATA . RESULTS . TOTAL_COUNT if offset >= 500 : logger . info ( f \"Too Many Results returned ( { total_count } ), \" \"try performing a more specific search\" ) data_incomplete = False elif historical_results < total_count : offset = historical_results else : data_incomplete = False return paginated_response @classmethod def _filter_facilities_responses ( cls , responses = List [ dict ]) -> List [ dict ]: \"\"\" Filter Facilities to Actual Reservable Campsites Parameters ---------- responses Returns ------- List[dict] \"\"\" filtered_responses = list () for possible_match in responses : try : facility = FacilityResponse ( ** possible_match ) except ValidationError as e : logger . error ( \"That doesn't look like a valid Campground Facility\" ) logger . error ( json . dumps ( possible_match )) logger . exception ( e ) raise ProviderSearchError ( \"Invalid Campground Facility Returned\" ) if all ( [ facility . FacilityTypeDescription == RIDBConfig . CAMPGROUND_FACILITY_FIELD_QUALIFIER , facility . Enabled is True , facility . Reservable is True , ] ): filtered_responses . append ( possible_match ) return filtered_responses @classmethod def process_facilities_responses ( cls , facility : dict ) -> Tuple [ dict , Optional [ CampgroundFacility ]]: \"\"\" Process Facilities Responses to be More Usable Parameters ---------- facility: dict Returns ------- Tuple[dict, CampgroundFacility] \"\"\" facility_object = FacilityResponse ( ** facility ) try : facility_state = facility_object . FACILITYADDRESS [ 0 ] . AddressStateCode . upper () except ( KeyError , IndexError ): facility_state = \"USA\" try : if len ( facility_object . RECAREA ) == 0 : recreation_area_id = facility_object . ParentRecAreaID formatted_recreation_area = ( f \" { facility_object . ORGANIZATION [ 0 ] . OrgName } , { facility_state } \" ) else : recreation_area = facility_object . RECAREA [ 0 ] . RecAreaName recreation_area_id = facility_object . RECAREA [ 0 ] . RecAreaID formatted_recreation_area = f \" { recreation_area } , { facility_state } \" campground_facility = CampgroundFacility ( facility_name = facility_object . FacilityName . title (), recreation_area = formatted_recreation_area , facility_id = facility_object . FacilityID , recreation_area_id = recreation_area_id , ) return facility , campground_facility except ( KeyError , IndexError ): return facility , None @classmethod def _process_rec_area_response ( cls , recreation_area = dict ) -> Tuple [ dict , Optional [ RecreationArea ]]: \"\"\" Process Rec Area Responses to be More Usable Parameters ---------- recreation_area: dict Returns ------- Tuple[dict, RecreationArea] \"\"\" rec_area_response = RecreationAreaResponse ( ** recreation_area ) try : recreation_area_location = rec_area_response . RECAREAADDRESS [ 0 ] . AddressStateCode recreation_area_tuple = RecreationArea ( recreation_area = rec_area_response . RecAreaName , recreation_area_id = rec_area_response . RecAreaID , recreation_area_location = recreation_area_location , ) return recreation_area , recreation_area_tuple except IndexError : return recreation_area , None @classmethod def _rec_availability_get_endpoint ( cls , path : str ) -> str : \"\"\" Return an API Endpoint for the Recreation.gov Campground Availability API Parameters ---------- path: str URL Endpoint Path Returns ------- endpoint_url: str URL for the API Endpoint \"\"\" base_url = api_utils . generate_url ( scheme = RecreationBookingConfig . API_SCHEME , netloc = RecreationBookingConfig . API_NET_LOC , path = RecreationBookingConfig . API_BASE_PATH , ) endpoint_url = parse . urljoin ( base_url , path ) return endpoint_url @classmethod def make_recdotgov_request ( cls , url : str , method : str = \"GET\" , params : Optional [ Dict [ str , Any ]] = None , ** kwargs , ) -> requests . Response : \"\"\" Make a Raw Request to RecreationDotGov Parameters ---------- url: str method: str params: Optional[Dict[str, Any]] Returns ------- requests.Response \"\"\" # BUILD THE HEADERS EXPECTED FROM THE API headers = STANDARD_HEADERS . copy () headers . update ( choice ( USER_AGENTS )) headers . update ( RecreationBookingConfig . API_REFERRERS ) response = requests . request ( method = method , url = url , headers = headers , params = params , timeout = 30 , ** kwargs ) return response @classmethod @tenacity . retry ( wait = tenacity . wait_random_exponential ( multiplier = 2 , max = 10 ), stop = tenacity . stop . stop_after_delay ( 15 ), ) def make_recdotgov_request_retry ( cls , url : str , method : str = \"GET\" , params : Optional [ Dict [ str , Any ]] = None , ** kwargs , ) -> requests . Response : \"\"\" Make a Raw Request to RecreationDotGov - But Handle 404 Parameters ---------- url: str method: str params: Optional[Dict[str, Any]] Returns ------- requests.Response \"\"\" response = cls . make_recdotgov_request ( url = url , method = method , params = params , ** kwargs ) response . raise_for_status () return response def paginate_recdotgov_campsites ( self , facility_id : int , equipment : Optional [ List [ str ]] = None ) -> List [ RecDotGovCampsite ]: \"\"\" Paginate through the RecDotGov Campsite Metadata \"\"\" results = 0 continue_paginate = True endpoint_url = api_utils . generate_url ( scheme = RecreationBookingConfig . API_SCHEME , netloc = RecreationBookingConfig . API_NET_LOC , path = \"api/search/campsites\" , ) fq_list = [ f \"asset_id: { facility_id } \" ] if isinstance ( equipment , list ) and len ( equipment ) > 0 : for item in equipment : fq_list . append ( f \"campsite_equipment_name: { item } \" ) params = dict ( start = 0 , size = 1000 , fq = fq_list , include_non_site_specific_campsites = True , ) campsites = [] while continue_paginate is True : response = self . make_recdotgov_request_retry ( method = \"GET\" , url = endpoint_url , params = params , ) returned_data = json . loads ( response . content ) campsite_response = RecDotGovCampsiteResponse ( ** returned_data ) campsites += campsite_response . campsites results += campsite_response . size params . update ( start = results ) if results == campsite_response . total : continue_paginate = False return campsites @tenacity . retry ( wait = tenacity . wait_random_exponential ( multiplier = 3 , max = 1800 ), stop = tenacity . stop . stop_after_delay ( 6000 ), ) def _make_recdotgov_availability_request ( self , campground_id : int , month : datetime , ) -> requests . Response : \"\"\" Make a request to the RecreationDotGov API - Handle Exponential Backoff Parameters ---------- campground_id month Returns ------- requests.Response \"\"\" try : api_endpoint = self . _rec_availability_get_endpoint ( path = f \" { campground_id } / { RecreationBookingConfig . API_MONTH_PATH } \" ) formatted_month = month . strftime ( \"%Y-%m-01T00:00:00.000Z\" ) query_params = dict ( start_date = formatted_month ) response = self . make_recdotgov_request ( method = \"GET\" , url = api_endpoint , params = query_params , ) assert response . status_code == 200 except AssertionError : response_error = response . text error_message = \"Bad Data Returned from the RecreationDotGov API\" logger . debug ( f \" { error_message } , will continue to retry\" ) logger . debug ( f \"Error Details: { response_error } \" ) raise ConnectionError ( f \" { error_message } : { response_error } \" ) return response def get_recdotgov_data ( self , campground_id : int , month : datetime ) -> Union [ dict , list ]: \"\"\" Find Campsite Availability Data Parameters ---------- campground_id: int Campground ID from the RIDB API. Can also be pulled of URLs on Recreation.gov month: datetime datetime object, results will be filtered to month Returns ------- Union[dict, list] \"\"\" try : response = self . _make_recdotgov_availability_request ( campground_id = campground_id , month = month ) except tenacity . RetryError : raise RuntimeError ( \"Something went wrong in fetching data from the \" \"RecreationDotGov API.\" ) return loads ( response . content ) @classmethod def _items_to_unique_dicts ( cls , item : Union [ List [ Dict [ str , Any ]], pd . Series ] ) -> List [ Dict [ str , Any ]]: \"\"\" Ensure the proper items are parsed for equipment and attributes \"\"\" if isinstance ( item , pd . Series ): list_of_dicts = list ( chain . from_iterable ( item . tolist ())) unique_list_of_dicts = [ dict ( s ) for s in set ( frozenset ( d . items ()) for d in list_of_dicts ) ] return unique_list_of_dicts else : return item @classmethod def _get_equipment_and_attributes ( cls , campsite_id : int , campsite_metadata : pd . DataFrame , ) -> Tuple [ List [ Dict [ str , Any ]], List [ Dict [ str , Any ]]]: \"\"\" Index a DataFrame in a Complicated Way \"\"\" try : equipment = campsite_metadata . at [ campsite_id , \"permitted_equipment\" ] except LookupError : equipment = None try : attributes = campsite_metadata . at [ campsite_id , \"attributes\" ] except LookupError : attributes = None equipment = cls . _items_to_unique_dicts ( item = equipment ) attributes = cls . _items_to_unique_dicts ( item = attributes ) return equipment , attributes @classmethod def process_campsite_availability ( cls , availability : dict , recreation_area : str , recreation_area_id : int , facility_name : str , facility_id : int , month : datetime , campsite_metadata : pd . DataFrame , ) -> List [ Optional [ AvailableCampsite ]]: \"\"\" Parse the JSON Response and return availabilities Parameters ---------- availability: dict API Response recreation_area: str Name of Recreation Area recreation_area_id: int ID of Recreation Area facility_name: str Campground Facility Name facility_id: int Campground Facility ID month: datetime Month to Process campsite_metadata: pd.DataFrame Metadata Fetched from the Recreation.gov API about the Campsites Returns ------- total_campsite_availability: List[Optional[AvailableCampsite]] Any monthly availabilities \"\"\" total_campsite_availability : List [ Optional [ AvailableCampsite ]] = list () campsite_data = CampsiteAvailabilityResponse ( ** availability ) for campsite_id , site_related_data in campsite_data . campsites . items (): for ( matching_date , availability_status , ) in site_related_data . availabilities . items (): if ( availability_status not in RecreationBookingConfig . CAMPSITE_UNAVAILABLE_STRINGS ): booking_url = ( f \" { RecreationBookingConfig . CAMPSITE_BOOKING_URL } / { campsite_id } \" ) equipment , attributes = cls . _get_equipment_and_attributes ( campsite_id = campsite_id , campsite_metadata = campsite_metadata ) available_campsite = AvailableCampsite ( campsite_id = campsite_id , booking_date = matching_date , booking_end_date = matching_date + timedelta ( days = 1 ), booking_nights = 1 , campsite_site_name = site_related_data . site , campsite_loop_name = site_related_data . loop , campsite_type = site_related_data . campsite_type , campsite_occupancy = ( site_related_data . min_num_people , site_related_data . max_num_people , ), campsite_use_type = site_related_data . type_of_use , availability_status = availability_status , recreation_area = recreation_area , recreation_area_id = recreation_area_id , facility_name = facility_name , facility_id = facility_id , booking_url = booking_url , permitted_equipment = equipment , campsite_attributes = attributes , ) total_campsite_availability . append ( available_campsite ) logger . info ( f \" \\t { logging_utils . get_emoji ( total_campsite_availability ) } \\t \" f \" { len ( total_campsite_availability ) } total sites found in month of \" f \" { month . strftime ( '%B' ) } \" ) return total_campsite_availability def get_campsite_by_id ( self , campsite_id : int ) -> CampsiteResponse : \"\"\" Get a Campsite's Details Parameters ---------- campsite_id: int Returns ------- CampsiteResponse \"\"\" data = self . get_ridb_data ( path = f \" { RIDBConfig . CAMPSITE_API_PATH } / { campsite_id } \" ) try : response = CampsiteResponse ( ** data [ 0 ]) except IndexError : raise ProviderSearchError ( f \"Campsite with ID # { campsite_id } not found.\" ) return response def get_campground_ids_by_campsites ( self , campsite_ids : List [ int ] ) -> Tuple [ List [ int ], List [ CampsiteResponse ]]: \"\"\" Retrieve a list of FacilityIDs, and Facilities from a Campsite ID List Parameters ---------- campsite_ids: List[int] List of Campsite IDs Returns ------- Tuple[List[int], List[CampsiteResponse]] \"\"\" campground_ids = list () campgrounds = list () for campsite_id in campsite_ids : campsite = self . get_campsite_by_id ( campsite_id = campsite_id ) campgrounds . append ( campsite ) campground_ids . append ( campsite . FacilityID ) return list ( set ( campground_ids )), list ( campgrounds ) def _process_specific_campsites_provided ( self , campsite_id : List [ int ] = None ) -> List [ CampgroundFacility ]: \"\"\" Process Requests for Campgrounds into Facilities Parameters ---------- campsite_id: Optional[List[int]] Returns ------- List[CampgroundFacility] \"\"\" facility_ids , campsites = self . get_campground_ids_by_campsites ( campsite_ids = campsite_id ) facilities = list () for campsite in campsites : facility = self . _find_facilities_from_campgrounds ( campground_id = [ campsite . FacilityID ] )[ 0 ] facilities . append ( facility ) logger . info ( \"Searching Specific Campsite: \u26fa\ufe0f \" f \" { campsite . CampsiteName } (# { campsite . CampsiteID } ) - \" f \" { facility . facility_name } , { facility . recreation_area } \" ) return facilities def get_internal_campsite_metadata ( self , facility_ids : List [ int ]) -> pd . DataFrame : \"\"\" Retrieve Metadata About all of the underlying Campsites to Search \"\"\" all_campsites : List [ RecDotGovCampsite ] = [] for facility_id in facility_ids : all_campsites += self . paginate_recdotgov_campsites ( facility_id = facility_id ) all_campsite_df = pd . DataFrame ( [ item . dict () for item in all_campsites ], columns = RecDotGovCampsite . __fields__ , ) all_campsite_df . set_index ( \"campsite_id\" , inplace = True ) return all_campsite_df __init__ ( api_key = None ) # Initialize with Search Dates Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 48 49 50 51 52 53 54 55 56 57 58 def __init__ ( self , api_key : str = None ): \"\"\" Initialize with Search Dates \"\"\" if api_key is None : _api_key = RIDBConfig . API_KEY if isinstance ( _api_key , bytes ): _api_key : str = b64decode ( RIDBConfig . API_KEY ) . decode ( \"utf-8\" ) else : _api_key : str = api_key self . _ridb_api_headers : dict = dict ( accept = \"application/json\" , apikey = _api_key ) __repr__ () # String Representation Returns # str Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 60 61 62 63 64 65 66 67 68 def __repr__ ( self ): \"\"\" String Representation Returns ------- str \"\"\" return \"<RecreationDotGov>\" find_campgrounds ( search_string = None , rec_area_id = None , campground_id = None , campsite_id = None , ** kwargs ) # Find Bookable Campgrounds Given a Set of Search Criteria Parameters # str Search Keyword(s) Optional[List[int]] Recreation Area ID to filter with Optional[List[int]] ID of the Campground Optional[List[int]] ID of the Campsite Returns # List[CampgroundFacility] Array of Matching Campsites Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def find_campgrounds ( self , search_string : str = None , rec_area_id : Optional [ List [ int ]] = None , campground_id : Optional [ List [ int ]] = None , campsite_id : Optional [ List [ int ]] = None , ** kwargs , ) -> List [ CampgroundFacility ]: \"\"\" Find Bookable Campgrounds Given a Set of Search Criteria Parameters ---------- search_string: str Search Keyword(s) rec_area_id: Optional[List[int]] Recreation Area ID to filter with campground_id: Optional[List[int]] ID of the Campground campsite_id: Optional[List[int]] ID of the Campsite Returns ------- facilities: List[CampgroundFacility] Array of Matching Campsites \"\"\" if campsite_id not in ( None , [], ()): facilities = self . _process_specific_campsites_provided ( campsite_id = campsite_id ) elif campground_id not in ( None , [], ()): facilities = self . _find_facilities_from_campgrounds ( campground_id = campground_id ) elif rec_area_id not in ( None , [], ()): facilities = list () for recreation_area in rec_area_id : facilities += self . find_facilities_per_recreation_area ( rec_area_id = recreation_area ) else : state_arg = kwargs . get ( \"state\" , None ) if state_arg is not None : kwargs . update ({ \"state\" : state_arg . upper ()}) if search_string in [ \"\" , None ] and state_arg is None : raise RuntimeError ( \"You must provide a search query or state to find campsites\" ) facilities = self . _find_facilities_from_search ( search = search_string , ** kwargs ) return facilities find_facilities_per_recreation_area ( rec_area_id = None , ** kwargs ) # Find Matching Campsites Based from Recreation Area Parameters # int Recreation Area ID Returns # List[CampgroundFacility] Array of Matching Campsites Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 def find_facilities_per_recreation_area ( self , rec_area_id : int = None , ** kwargs ) -> List [ CampgroundFacility ]: \"\"\" Find Matching Campsites Based from Recreation Area Parameters ---------- rec_area_id: int Recreation Area ID Returns ------- campgrounds: List[CampgroundFacility] Array of Matching Campsites \"\"\" logger . info ( f \"Retrieving Facility Information for Recreation Area ID: ` { rec_area_id } `.\" ) api_path = f \" { RIDBConfig . REC_AREA_API_PATH } / { rec_area_id } / { RIDBConfig . FACILITIES_API_PATH } \" api_response = self . _ridb_get_paginate ( path = api_path , params = dict ( full = \"true\" , ** kwargs ) ) filtered_facilities = self . _filter_facilities_responses ( responses = api_response ) campgrounds = list () logger . info ( f \" { len ( filtered_facilities ) } Matching Campgrounds Found\" ) for facility in filtered_facilities : _ , campground_facility = self . process_facilities_responses ( facility = facility ) if campground_facility is not None : campgrounds . append ( campground_facility ) log_sorted_response ( response_array = campgrounds ) return campgrounds find_recreation_areas ( search_string = None , ** kwargs ) # Find Matching Campsites Based on Search String Parameters # str Search Keyword(s) Returns # List[dict] Array of Matching Campsites Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def find_recreation_areas ( self , search_string : str = None , ** kwargs ) -> List [ dict ]: \"\"\" Find Matching Campsites Based on Search String Parameters ---------- search_string: str Search Keyword(s) Returns ------- filtered_responses: List[dict] Array of Matching Campsites \"\"\" try : assert any ( [ kwargs . get ( \"state\" , None ) is not None , search_string is not None and search_string != \"\" , ] ) except AssertionError : raise RuntimeError ( \"You must provide a search query or state(s) \" \"to find Recreation Areas\" ) logger . info ( f 'Searching for Recreation Areas: \" { search_string } \"' ) state_arg = kwargs . get ( \"state\" , None ) if state_arg is not None : kwargs . update ({ \"state\" : state_arg . upper ()}) params = dict ( query = search_string , sort = \"Name\" , full = \"true\" , ** kwargs ) if search_string is None : params . pop ( \"query\" ) api_response = self . _ridb_get_paginate ( path = RIDBConfig . REC_AREA_API_PATH , params = params ) logger . info ( f \" { len ( api_response ) } recreation areas found.\" ) logging_messages = list () for recreation_area_object in api_response : _ , recreation_area = self . _process_rec_area_response ( recreation_area = recreation_area_object ) if recreation_area is not None : logging_messages . append ( recreation_area ) log_sorted_response ( response_array = logging_messages ) return api_response get_campground_ids_by_campsites ( campsite_ids ) # Retrieve a list of FacilityIDs, and Facilities from a Campsite ID List Parameters # List[int] List of Campsite IDs Returns # Tuple[List[int], List[CampsiteResponse]] Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 def get_campground_ids_by_campsites ( self , campsite_ids : List [ int ] ) -> Tuple [ List [ int ], List [ CampsiteResponse ]]: \"\"\" Retrieve a list of FacilityIDs, and Facilities from a Campsite ID List Parameters ---------- campsite_ids: List[int] List of Campsite IDs Returns ------- Tuple[List[int], List[CampsiteResponse]] \"\"\" campground_ids = list () campgrounds = list () for campsite_id in campsite_ids : campsite = self . get_campsite_by_id ( campsite_id = campsite_id ) campgrounds . append ( campsite ) campground_ids . append ( campsite . FacilityID ) return list ( set ( campground_ids )), list ( campgrounds ) get_campsite_by_id ( campsite_id ) # Get a Campsite's Details Parameters # campsite_id: int Returns # CampsiteResponse Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 def get_campsite_by_id ( self , campsite_id : int ) -> CampsiteResponse : \"\"\" Get a Campsite's Details Parameters ---------- campsite_id: int Returns ------- CampsiteResponse \"\"\" data = self . get_ridb_data ( path = f \" { RIDBConfig . CAMPSITE_API_PATH } / { campsite_id } \" ) try : response = CampsiteResponse ( ** data [ 0 ]) except IndexError : raise ProviderSearchError ( f \"Campsite with ID # { campsite_id } not found.\" ) return response get_internal_campsite_metadata ( facility_ids ) # Retrieve Metadata About all of the underlying Campsites to Search Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 866 867 868 869 870 871 872 873 874 875 876 877 878 def get_internal_campsite_metadata ( self , facility_ids : List [ int ]) -> pd . DataFrame : \"\"\" Retrieve Metadata About all of the underlying Campsites to Search \"\"\" all_campsites : List [ RecDotGovCampsite ] = [] for facility_id in facility_ids : all_campsites += self . paginate_recdotgov_campsites ( facility_id = facility_id ) all_campsite_df = pd . DataFrame ( [ item . dict () for item in all_campsites ], columns = RecDotGovCampsite . __fields__ , ) all_campsite_df . set_index ( \"campsite_id\" , inplace = True ) return all_campsite_df get_recdotgov_data ( campground_id , month ) # Find Campsite Availability Data Parameters # int Campground ID from the RIDB API. Can also be pulled of URLs on Recreation.gov datetime datetime object, results will be filtered to month Returns # Union[dict, list] Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 def get_recdotgov_data ( self , campground_id : int , month : datetime ) -> Union [ dict , list ]: \"\"\" Find Campsite Availability Data Parameters ---------- campground_id: int Campground ID from the RIDB API. Can also be pulled of URLs on Recreation.gov month: datetime datetime object, results will be filtered to month Returns ------- Union[dict, list] \"\"\" try : response = self . _make_recdotgov_availability_request ( campground_id = campground_id , month = month ) except tenacity . RetryError : raise RuntimeError ( \"Something went wrong in fetching data from the \" \"RecreationDotGov API.\" ) return loads ( response . content ) get_ridb_data ( path , params = None ) # Find Matching Campsites Based on Search String Parameters # str URL Endpoint, see https://ridb.recreation.gov/docs Returns # Union[dict, list] Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 @tenacity . retry ( wait = tenacity . wait_random_exponential ( multiplier = 2 , max = 10 ), stop = tenacity . stop . stop_after_delay ( 15 ), ) def get_ridb_data ( self , path : str , params : Optional [ dict ] = None ) -> Union [ dict , list ]: \"\"\" Find Matching Campsites Based on Search String Parameters ---------- path: str URL Endpoint, see https://ridb.recreation.gov/docs params: Optional[dict] API Call Parameters Returns ------- Union[dict, list] \"\"\" api_endpoint = self . _ridb_get_endpoint ( path = path ) headers = self . _ridb_api_headers . copy () headers . update ( choice ( USER_AGENTS )) response = requests . get ( url = api_endpoint , headers = headers , params = params , timeout = 30 ) try : assert response . status_code == 200 except AssertionError : error_message = ( f \"Receiving bad data from Recreation.gov API: { response . text } \" ) logger . error ( error_message ) raise ConnectionError ( error_message ) return loads ( response . content ) make_recdotgov_request ( url , method = 'GET' , params = None , ** kwargs ) classmethod # Make a Raw Request to RecreationDotGov Parameters # url: str method: str Returns # requests.Response Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 @classmethod def make_recdotgov_request ( cls , url : str , method : str = \"GET\" , params : Optional [ Dict [ str , Any ]] = None , ** kwargs , ) -> requests . Response : \"\"\" Make a Raw Request to RecreationDotGov Parameters ---------- url: str method: str params: Optional[Dict[str, Any]] Returns ------- requests.Response \"\"\" # BUILD THE HEADERS EXPECTED FROM THE API headers = STANDARD_HEADERS . copy () headers . update ( choice ( USER_AGENTS )) headers . update ( RecreationBookingConfig . API_REFERRERS ) response = requests . request ( method = method , url = url , headers = headers , params = params , timeout = 30 , ** kwargs ) return response make_recdotgov_request_retry ( url , method = 'GET' , params = None , ** kwargs ) classmethod # Make a Raw Request to RecreationDotGov - But Handle 404 Parameters # url: str method: str Returns # requests.Response Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 @classmethod @tenacity . retry ( wait = tenacity . wait_random_exponential ( multiplier = 2 , max = 10 ), stop = tenacity . stop . stop_after_delay ( 15 ), ) def make_recdotgov_request_retry ( cls , url : str , method : str = \"GET\" , params : Optional [ Dict [ str , Any ]] = None , ** kwargs , ) -> requests . Response : \"\"\" Make a Raw Request to RecreationDotGov - But Handle 404 Parameters ---------- url: str method: str params: Optional[Dict[str, Any]] Returns ------- requests.Response \"\"\" response = cls . make_recdotgov_request ( url = url , method = method , params = params , ** kwargs ) response . raise_for_status () return response paginate_recdotgov_campsites ( facility_id , equipment = None ) # Paginate through the RecDotGov Campsite Metadata Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 def paginate_recdotgov_campsites ( self , facility_id : int , equipment : Optional [ List [ str ]] = None ) -> List [ RecDotGovCampsite ]: \"\"\" Paginate through the RecDotGov Campsite Metadata \"\"\" results = 0 continue_paginate = True endpoint_url = api_utils . generate_url ( scheme = RecreationBookingConfig . API_SCHEME , netloc = RecreationBookingConfig . API_NET_LOC , path = \"api/search/campsites\" , ) fq_list = [ f \"asset_id: { facility_id } \" ] if isinstance ( equipment , list ) and len ( equipment ) > 0 : for item in equipment : fq_list . append ( f \"campsite_equipment_name: { item } \" ) params = dict ( start = 0 , size = 1000 , fq = fq_list , include_non_site_specific_campsites = True , ) campsites = [] while continue_paginate is True : response = self . make_recdotgov_request_retry ( method = \"GET\" , url = endpoint_url , params = params , ) returned_data = json . loads ( response . content ) campsite_response = RecDotGovCampsiteResponse ( ** returned_data ) campsites += campsite_response . campsites results += campsite_response . size params . update ( start = results ) if results == campsite_response . total : continue_paginate = False return campsites process_campsite_availability ( availability , recreation_area , recreation_area_id , facility_name , facility_id , month , campsite_metadata ) classmethod # Parse the JSON Response and return availabilities Parameters # dict API Response str Name of Recreation Area int ID of Recreation Area str Campground Facility Name int Campground Facility ID datetime Month to Process pd.DataFrame Metadata Fetched from the Recreation.gov API about the Campsites Returns # List[Optional[AvailableCampsite]] Any monthly availabilities Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 @classmethod def process_campsite_availability ( cls , availability : dict , recreation_area : str , recreation_area_id : int , facility_name : str , facility_id : int , month : datetime , campsite_metadata : pd . DataFrame , ) -> List [ Optional [ AvailableCampsite ]]: \"\"\" Parse the JSON Response and return availabilities Parameters ---------- availability: dict API Response recreation_area: str Name of Recreation Area recreation_area_id: int ID of Recreation Area facility_name: str Campground Facility Name facility_id: int Campground Facility ID month: datetime Month to Process campsite_metadata: pd.DataFrame Metadata Fetched from the Recreation.gov API about the Campsites Returns ------- total_campsite_availability: List[Optional[AvailableCampsite]] Any monthly availabilities \"\"\" total_campsite_availability : List [ Optional [ AvailableCampsite ]] = list () campsite_data = CampsiteAvailabilityResponse ( ** availability ) for campsite_id , site_related_data in campsite_data . campsites . items (): for ( matching_date , availability_status , ) in site_related_data . availabilities . items (): if ( availability_status not in RecreationBookingConfig . CAMPSITE_UNAVAILABLE_STRINGS ): booking_url = ( f \" { RecreationBookingConfig . CAMPSITE_BOOKING_URL } / { campsite_id } \" ) equipment , attributes = cls . _get_equipment_and_attributes ( campsite_id = campsite_id , campsite_metadata = campsite_metadata ) available_campsite = AvailableCampsite ( campsite_id = campsite_id , booking_date = matching_date , booking_end_date = matching_date + timedelta ( days = 1 ), booking_nights = 1 , campsite_site_name = site_related_data . site , campsite_loop_name = site_related_data . loop , campsite_type = site_related_data . campsite_type , campsite_occupancy = ( site_related_data . min_num_people , site_related_data . max_num_people , ), campsite_use_type = site_related_data . type_of_use , availability_status = availability_status , recreation_area = recreation_area , recreation_area_id = recreation_area_id , facility_name = facility_name , facility_id = facility_id , booking_url = booking_url , permitted_equipment = equipment , campsite_attributes = attributes , ) total_campsite_availability . append ( available_campsite ) logger . info ( f \" \\t { logging_utils . get_emoji ( total_campsite_availability ) } \\t \" f \" { len ( total_campsite_availability ) } total sites found in month of \" f \" { month . strftime ( '%B' ) } \" ) return total_campsite_availability process_facilities_responses ( facility ) classmethod # Process Facilities Responses to be More Usable Parameters # facility: dict Returns # Tuple[dict, CampgroundFacility] Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 @classmethod def process_facilities_responses ( cls , facility : dict ) -> Tuple [ dict , Optional [ CampgroundFacility ]]: \"\"\" Process Facilities Responses to be More Usable Parameters ---------- facility: dict Returns ------- Tuple[dict, CampgroundFacility] \"\"\" facility_object = FacilityResponse ( ** facility ) try : facility_state = facility_object . FACILITYADDRESS [ 0 ] . AddressStateCode . upper () except ( KeyError , IndexError ): facility_state = \"USA\" try : if len ( facility_object . RECAREA ) == 0 : recreation_area_id = facility_object . ParentRecAreaID formatted_recreation_area = ( f \" { facility_object . ORGANIZATION [ 0 ] . OrgName } , { facility_state } \" ) else : recreation_area = facility_object . RECAREA [ 0 ] . RecAreaName recreation_area_id = facility_object . RECAREA [ 0 ] . RecAreaID formatted_recreation_area = f \" { recreation_area } , { facility_state } \" campground_facility = CampgroundFacility ( facility_name = facility_object . FacilityName . title (), recreation_area = formatted_recreation_area , facility_id = facility_object . FacilityID , recreation_area_id = recreation_area_id , ) return facility , campground_facility except ( KeyError , IndexError ): return facility , None SearchRecreationDotGov # Bases: BaseCampingSearch Camping Search Object Source code in camply/search/search_recreationdotgov.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 class SearchRecreationDotGov ( BaseCampingSearch ): \"\"\" Camping Search Object \"\"\" def __init__ ( self , search_window : Union [ SearchWindow , List [ SearchWindow ]], recreation_area : Optional [ Union [ List [ int ], int ]] = None , campgrounds : Optional [ Union [ List [ int ], int ]] = None , campsites : Optional [ Union [ List [ int ], int ]] = None , weekends_only : bool = False , nights : int = 1 , equipment : Optional [ List [ Tuple [ str , Optional [ int ]]]] = None , offline_search : bool = False , offline_search_path : Optional [ str ] = None , ** kwargs , ) -> None : \"\"\" Initialize with Search Parameters Parameters ---------- search_window: Union[SearchWindow, List[SearchWindow]] Search Window tuple containing start date and End Date recreation_area: Optional[Union[List[int], int]] ID of Recreation Area (i.e. 2907 - Rocky Mountain National Park) campgrounds: Optional[Union[List[int], int]] Campground ID or List of Campground IDs campsites: Optional[Union[List[int], int]] Campsite ID or List of Campsite IDs weekends_only: bool Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights) nights: int minimum number of consecutive nights to search per campsite,defaults to 1 equipment: Optional[List[Tuple[str, Optional[int]]]] List of Tuples of Equipment to Search for. An equipment tuple array looks like this: `[(\"Tent\", None), (\"RV\", 20)]` - meaning the selected search looks for sites to accommodate any tent size and RVs less than or equal to 20 feet. Tuples contain the Equipment name and an optional equipment length, otherwise provide None. Equipment names include `Tent`, `RV`, `Trailer`, `Vehicle` and are not case-sensitive. offline_search: bool When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. offline_search_path: Optional[str] When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to `camply_campsites.json` \"\"\" self . campsite_finder : RecreationDotGov super ( SearchRecreationDotGov , self ) . __init__ ( provider = RecreationDotGov (), search_window = search_window , weekends_only = weekends_only , nights = nights , offline_search = offline_search , offline_search_path = offline_search_path , ) self . _recreation_area_id = make_list ( recreation_area ) self . _campground_object = campgrounds self . weekends_only = weekends_only assert ( any ( [ campsites not in [[], None ], campgrounds not in [[], None ], recreation_area is not None , ] ) is True ) self . campsites = make_list ( campsites ) self . campgrounds = self . _get_searchable_campgrounds () self . campsite_metadata : Optional [ pd . DataFrame ] = None self . equipment : List [ Tuple [ str , Optional [ int ]]] = [] self . equipment = self . _get_searchable_equipment ( equipment = equipment ) def _get_searchable_campgrounds ( self ) -> List [ CampgroundFacility ]: \"\"\" Return a List of Campgrounds to search This handles scenarios where a recreation area is provided instead of a campground list Returns ------- searchable_campgrounds: List[int] List of searchable campground IDs \"\"\" if self . campsites not in [(), [], None ]: self . campsites = [ int ( campsite_id ) for campsite_id in self . campsites ] searchable_campgrounds = self . _get_campgrounds_by_campsite_id () elif self . _campground_object not in [(), [], None ]: searchable_campgrounds = self . _get_campgrounds_by_campground_id () elif self . _recreation_area_id not in [(), [], None ]: searchable_campgrounds = self . _get_campgrounds_by_recreation_area_id () else : raise RuntimeError ( \"You must provide a Campground or Recreation Area ID\" ) return list ( set ( searchable_campgrounds )) @classmethod def _get_searchable_equipment ( cls , equipment : Optional [ List [ Tuple [ str , Optional [ int ]]]] ) -> Optional [ List [ Tuple [ str , Optional [ int ]]]]: \"\"\" Sort through and validate Equipment Parameters ---------- equipment: Optional[List[Tuple[str, Optional[int]]]] Returns ------- Optional[List[Tuple[str, Optional[int]]]] \"\"\" equipment_names = [] final_equipment = None if isinstance ( equipment , ( list , tuple )): final_equipment = [] for equipment_name , equipment_length in equipment : if ( equipment_name . lower () not in EquipmentOptions . __all_accepted_equipment__ ): logger . warning ( f \"Equipment name not recognized: { equipment_name } . This won't \" \"be used for filtering.\" \"Acceptable options are: \" f \" { ', ' . join ( EquipmentOptions . __all_accepted_equipment__ ) } \" ) else : final_equipment . append (( equipment_name , equipment_length )) equipment_names . append ( equipment_name ) if len ( final_equipment ) > 0 : logger . info ( f \"Filtering Campsites based on Equipment: { ' | ' . join ( equipment_names ) } \" ) return final_equipment def _get_campgrounds_by_campground_id ( self ) -> List [ CampgroundFacility ]: \"\"\" Return a List of Campgrounds to search when provided with campground IDs Returns ------- returned_sites: List[int] List of searchable campground IDs \"\"\" campground_list = make_list ( self . _campground_object ) facilities = self . campsite_finder . find_campgrounds ( campground_id = campground_list ) return facilities def _get_campgrounds_by_campsite_id ( self ) -> List [ CampgroundFacility ]: \"\"\" Return a List of Campgrounds to search when provided with Campsite IDs Returns ------- returned_sites: List[int] List of searchable campground IDs \"\"\" campsite_list = make_list ( self . campsites ) facilities = self . campsite_finder . find_campgrounds ( campsite_id = campsite_list ) return facilities def _get_campgrounds_by_recreation_area_id ( self ) -> List [ CampgroundFacility ]: \"\"\" Return a List of Campgrounds to search when provided with Recreation Area IDs Returns ------- campgrounds: List[CampgroundFacility] \"\"\" campgrounds = list () for rec_area in self . _recreation_area_id : campground_array = self . campsite_finder . find_facilities_per_recreation_area ( rec_area_id = rec_area ) campgrounds += campground_array return campgrounds def get_all_campsites ( self ) -> List [ AvailableCampsite ]: \"\"\" Perform the Search and Return All Monthly Availabilities Returns ------- List[AvailableCampsite] \"\"\" found_campsites = list () if len ( self . campgrounds ) == 0 : error_message = \"No campgrounds found to search\" logger . error ( error_message ) raise SearchError ( error_message ) logger . info ( f \"Searching across { len ( self . campgrounds ) } campgrounds\" ) if self . campsite_metadata is None : self . campsite_metadata = ( self . campsite_finder . get_internal_campsite_metadata ( facility_ids = [ facil . facility_id for facil in self . campgrounds ] ) ) logger . info ( \"Metadata fetched for %s campsites\" , len ( self . campsite_metadata ) ) for index , campground in enumerate ( self . campgrounds ): for month in self . search_months : logger . info ( f \"Searching { campground . facility_name } , { campground . recreation_area } \" f \"( { campground . facility_id } ) for availability: \" f \" { month . strftime ( '%B, %Y' ) } \" ) availabilities = self . campsite_finder . get_recdotgov_data ( campground_id = campground . facility_id , month = month ) campsites = self . campsite_finder . process_campsite_availability ( availability = availabilities , recreation_area = campground . recreation_area , recreation_area_id = campground . recreation_area_id , facility_name = campground . facility_name , facility_id = campground . facility_id , month = month , campsite_metadata = self . campsite_metadata , ) if self . campsites not in [ None , []]: campsites = [ campsite_obj for campsite_obj in campsites if int ( campsite_obj . campsite_id ) in self . campsites ] found_campsites += campsites if index + 1 < len ( self . campgrounds ): sleep ( round ( uniform ( * RecreationBookingConfig . RATE_LIMITING ), 2 )) campsite_df = self . campsites_to_df ( campsites = found_campsites ) campsite_df_validated = self . _filter_date_overlap ( campsites = campsite_df ) compiled_campsite_df = self . _consolidate_campsites ( campsite_df = campsite_df_validated , nights = self . nights ) equipment_filtered_campsites = self . filter_campsites_to_equipment ( campsites = compiled_campsite_df ) compiled_campsites = self . df_to_campsites ( campsite_df = equipment_filtered_campsites ) return compiled_campsites def filter_campsites_to_equipment ( self , campsites : pd . DataFrame ) -> pd . DataFrame : \"\"\" Filter a Campsite DataFrame down to specified equipment Parameters ---------- campsites: pd.DataFrame Returns ------- pd.DataFrame \"\"\" if self . equipment is None or len ( self . equipment ) == 0 or len ( campsites ) == 0 : return campsites column_names = [ \"campsite_id\" , \"permitted_equipment\" ] exploded_data = campsites [ column_names ] . explode ( \"permitted_equipment\" ) expanded_data = exploded_data [ \"permitted_equipment\" ] . apply ( pd . Series ) joined_data = pd . DataFrame ( pd . concat ([ exploded_data , expanded_data ], axis = 1 ), columns = column_names + [ \"equipment_name\" , \"max_length\" ], ) joined_data [ \"equipment_name_normalized\" ] = ( joined_data [ \"equipment_name\" ] . fillna ( \"\" ) . apply ( lambda x : EquipmentConfig . EQUIPMENT_REVERSE_MAPPING [ x ]) ) equipment_types = [ item [ 0 ] . lower () for item in self . equipment ] matching_equipment = joined_data [ joined_data [ \"equipment_name_normalized\" ] . isin ( equipment_types ) ] matching_ids = [] for equipment_name , equipment_length in self . equipment : matching_data = matching_equipment [ matching_equipment [ \"equipment_name_normalized\" ] == equipment_name . lower () ] . copy () if equipment_length is not None : matching_data = matching_data [ matching_data [ \"max_length\" ] >= float ( equipment_length ) ] matching_ids += list ( matching_data [ \"campsite_id\" ] . unique ()) original_campsites = campsites [ campsites [ \"campsite_id\" ] . isin ( matching_ids ) ] . copy () return original_campsites __init__ ( search_window , recreation_area = None , campgrounds = None , campsites = None , weekends_only = False , nights = 1 , equipment = None , offline_search = False , offline_search_path = None , ** kwargs ) # Initialize with Search Parameters Parameters # Union[SearchWindow, List[SearchWindow]] Search Window tuple containing start date and End Date Optional[Union[List[int], int]] ID of Recreation Area (i.e. 2907 - Rocky Mountain National Park) Optional[Union[List[int], int]] Campground ID or List of Campground IDs Optional[Union[List[int], int]] Campsite ID or List of Campsite IDs bool Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights) int minimum number of consecutive nights to search per campsite,defaults to 1 Optional[List[Tuple[str, Optional[int]]]] List of Tuples of Equipment to Search for. An equipment tuple array looks like this: [(\"Tent\", None), (\"RV\", 20)] - meaning the selected search looks for sites to accommodate any tent size and RVs less than or equal to 20 feet. Tuples contain the Equipment name and an optional equipment length, otherwise provide None. Equipment names include Tent , RV , Trailer , Vehicle and are not case-sensitive. bool When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. Optional[str] When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to camply_campsites.json Source code in camply/search/search_recreationdotgov.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def __init__ ( self , search_window : Union [ SearchWindow , List [ SearchWindow ]], recreation_area : Optional [ Union [ List [ int ], int ]] = None , campgrounds : Optional [ Union [ List [ int ], int ]] = None , campsites : Optional [ Union [ List [ int ], int ]] = None , weekends_only : bool = False , nights : int = 1 , equipment : Optional [ List [ Tuple [ str , Optional [ int ]]]] = None , offline_search : bool = False , offline_search_path : Optional [ str ] = None , ** kwargs , ) -> None : \"\"\" Initialize with Search Parameters Parameters ---------- search_window: Union[SearchWindow, List[SearchWindow]] Search Window tuple containing start date and End Date recreation_area: Optional[Union[List[int], int]] ID of Recreation Area (i.e. 2907 - Rocky Mountain National Park) campgrounds: Optional[Union[List[int], int]] Campground ID or List of Campground IDs campsites: Optional[Union[List[int], int]] Campsite ID or List of Campsite IDs weekends_only: bool Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights) nights: int minimum number of consecutive nights to search per campsite,defaults to 1 equipment: Optional[List[Tuple[str, Optional[int]]]] List of Tuples of Equipment to Search for. An equipment tuple array looks like this: `[(\"Tent\", None), (\"RV\", 20)]` - meaning the selected search looks for sites to accommodate any tent size and RVs less than or equal to 20 feet. Tuples contain the Equipment name and an optional equipment length, otherwise provide None. Equipment names include `Tent`, `RV`, `Trailer`, `Vehicle` and are not case-sensitive. offline_search: bool When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. offline_search_path: Optional[str] When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to `camply_campsites.json` \"\"\" self . campsite_finder : RecreationDotGov super ( SearchRecreationDotGov , self ) . __init__ ( provider = RecreationDotGov (), search_window = search_window , weekends_only = weekends_only , nights = nights , offline_search = offline_search , offline_search_path = offline_search_path , ) self . _recreation_area_id = make_list ( recreation_area ) self . _campground_object = campgrounds self . weekends_only = weekends_only assert ( any ( [ campsites not in [[], None ], campgrounds not in [[], None ], recreation_area is not None , ] ) is True ) self . campsites = make_list ( campsites ) self . campgrounds = self . _get_searchable_campgrounds () self . campsite_metadata : Optional [ pd . DataFrame ] = None self . equipment : List [ Tuple [ str , Optional [ int ]]] = [] self . equipment = self . _get_searchable_equipment ( equipment = equipment ) filter_campsites_to_equipment ( campsites ) # Filter a Campsite DataFrame down to specified equipment Parameters # campsites: pd.DataFrame Returns # pd.DataFrame Source code in camply/search/search_recreationdotgov.py 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 def filter_campsites_to_equipment ( self , campsites : pd . DataFrame ) -> pd . DataFrame : \"\"\" Filter a Campsite DataFrame down to specified equipment Parameters ---------- campsites: pd.DataFrame Returns ------- pd.DataFrame \"\"\" if self . equipment is None or len ( self . equipment ) == 0 or len ( campsites ) == 0 : return campsites column_names = [ \"campsite_id\" , \"permitted_equipment\" ] exploded_data = campsites [ column_names ] . explode ( \"permitted_equipment\" ) expanded_data = exploded_data [ \"permitted_equipment\" ] . apply ( pd . Series ) joined_data = pd . DataFrame ( pd . concat ([ exploded_data , expanded_data ], axis = 1 ), columns = column_names + [ \"equipment_name\" , \"max_length\" ], ) joined_data [ \"equipment_name_normalized\" ] = ( joined_data [ \"equipment_name\" ] . fillna ( \"\" ) . apply ( lambda x : EquipmentConfig . EQUIPMENT_REVERSE_MAPPING [ x ]) ) equipment_types = [ item [ 0 ] . lower () for item in self . equipment ] matching_equipment = joined_data [ joined_data [ \"equipment_name_normalized\" ] . isin ( equipment_types ) ] matching_ids = [] for equipment_name , equipment_length in self . equipment : matching_data = matching_equipment [ matching_equipment [ \"equipment_name_normalized\" ] == equipment_name . lower () ] . copy () if equipment_length is not None : matching_data = matching_data [ matching_data [ \"max_length\" ] >= float ( equipment_length ) ] matching_ids += list ( matching_data [ \"campsite_id\" ] . unique ()) original_campsites = campsites [ campsites [ \"campsite_id\" ] . isin ( matching_ids ) ] . copy () return original_campsites get_all_campsites () # Perform the Search and Return All Monthly Availabilities Returns # List[AvailableCampsite] Source code in camply/search/search_recreationdotgov.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 def get_all_campsites ( self ) -> List [ AvailableCampsite ]: \"\"\" Perform the Search and Return All Monthly Availabilities Returns ------- List[AvailableCampsite] \"\"\" found_campsites = list () if len ( self . campgrounds ) == 0 : error_message = \"No campgrounds found to search\" logger . error ( error_message ) raise SearchError ( error_message ) logger . info ( f \"Searching across { len ( self . campgrounds ) } campgrounds\" ) if self . campsite_metadata is None : self . campsite_metadata = ( self . campsite_finder . get_internal_campsite_metadata ( facility_ids = [ facil . facility_id for facil in self . campgrounds ] ) ) logger . info ( \"Metadata fetched for %s campsites\" , len ( self . campsite_metadata ) ) for index , campground in enumerate ( self . campgrounds ): for month in self . search_months : logger . info ( f \"Searching { campground . facility_name } , { campground . recreation_area } \" f \"( { campground . facility_id } ) for availability: \" f \" { month . strftime ( '%B, %Y' ) } \" ) availabilities = self . campsite_finder . get_recdotgov_data ( campground_id = campground . facility_id , month = month ) campsites = self . campsite_finder . process_campsite_availability ( availability = availabilities , recreation_area = campground . recreation_area , recreation_area_id = campground . recreation_area_id , facility_name = campground . facility_name , facility_id = campground . facility_id , month = month , campsite_metadata = self . campsite_metadata , ) if self . campsites not in [ None , []]: campsites = [ campsite_obj for campsite_obj in campsites if int ( campsite_obj . campsite_id ) in self . campsites ] found_campsites += campsites if index + 1 < len ( self . campgrounds ): sleep ( round ( uniform ( * RecreationBookingConfig . RATE_LIMITING ), 2 )) campsite_df = self . campsites_to_df ( campsites = found_campsites ) campsite_df_validated = self . _filter_date_overlap ( campsites = campsite_df ) compiled_campsite_df = self . _consolidate_campsites ( campsite_df = campsite_df_validated , nights = self . nights ) equipment_filtered_campsites = self . filter_campsites_to_equipment ( campsites = compiled_campsite_df ) compiled_campsites = self . df_to_campsites ( campsite_df = equipment_filtered_campsites ) return compiled_campsites SearchWindow # Bases: CamplyModel Search Window for Campsite Search Source code in camply/containers/data_containers.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class SearchWindow ( CamplyModel ): \"\"\" Search Window for Campsite Search \"\"\" start_date : datetime . date end_date : datetime . date def get_date_range ( self ) -> List [ datetime . date ]: \"\"\" Generate a List of Dates Between two Dates Returns ------- List[datetime.date] \"\"\" return [ self . start_date + datetime . timedelta ( days = x ) for x in range (( self . end_date - self . start_date ) . days ) ] get_date_range () # Generate a List of Dates Between two Dates Returns # List[datetime.date] Source code in camply/containers/data_containers.py 26 27 28 29 30 31 32 33 34 35 36 37 def get_date_range ( self ) -> List [ datetime . date ]: \"\"\" Generate a List of Dates Between two Dates Returns ------- List[datetime.date] \"\"\" return [ self . start_date + datetime . timedelta ( days = x ) for x in range (( self . end_date - self . start_date ) . days ) ] SearchYellowstone # Bases: BaseCampingSearch Camping Search Object Source code in camply/search/search_yellowstone.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 class SearchYellowstone ( BaseCampingSearch ): \"\"\" Camping Search Object \"\"\" # noinspection PyUnusedLocal def __init__ ( self , search_window : Union [ SearchWindow , List [ SearchWindow ]], weekends_only : bool = False , campgrounds : Optional [ Union [ List [ str ], str ]] = None , nights : int = 1 , offline_search : bool = False , offline_search_path : Optional [ str ] = None , ** kwargs , ) -> None : \"\"\" Initialize with Search Parameters Parameters ---------- search_window: Union[SearchWindow, List[SearchWindow]] Search Window tuple containing start date and End Date weekends_only: bool Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights) campgrounds: Optional[Union[List[str], str]] Campground ID or List of Campground IDs nights: int minimum number of consecutive nights to search per campsite,defaults to 1 offline_search: bool When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. offline_search_path: Optional[str] When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to `camply_campsites.json` \"\"\" super () . __init__ ( provider = YellowstoneLodging (), search_window = search_window , weekends_only = weekends_only , nights = nights , offline_search = offline_search , offline_search_path = offline_search_path , ) self . campgrounds = make_list ( campgrounds ) def get_all_campsites ( self ) -> List [ AvailableCampsite ]: \"\"\" Search for all matching campsites in Yellowstone. Returns ------- List[AvailableCampsite] \"\"\" all_campsites = list () searchable_campgrounds = self . _get_searchable_campgrounds () this_month = datetime . now () . date () . replace ( day = 1 ) for month in self . search_months : if month >= this_month : all_campsites += self . campsite_finder . get_monthly_campsites ( month = month , nights = None if self . nights == 1 else self . nights ) matching_campsites = self . _filter_campsites_to_campgrounds ( campsites = all_campsites , searchable_campgrounds = searchable_campgrounds ) campsite_df = self . campsites_to_df ( campsites = matching_campsites ) campsite_df_validated = self . _filter_date_overlap ( campsites = campsite_df ) time_window_end = max ( self . search_days ) + timedelta ( days = 1 ) compiled_campsite_df = campsite_df_validated [ campsite_df_validated . booking_end_date <= pd . Timestamp ( time_window_end ) ] compiled_campsites = self . df_to_campsites ( campsite_df = compiled_campsite_df ) return compiled_campsites def _get_searchable_campgrounds ( self ) -> Optional [ Set [ str ]]: \"\"\" Return the Campgrounds for the Camping Search Returns ------- Optional[Set[str]] \"\"\" if self . campgrounds in [ None , []]: return None supported_campsites = set ( YellowstoneConfig . YELLOWSTONE_CAMPGROUNDS . keys ()) selected_campsites = set ( self . campgrounds ) searchable_campgrounds = supported_campsites . intersection ( selected_campsites ) if len ( searchable_campgrounds ) == 0 : campground_ids = [ f \"` { key } ` ( { value } )\" for key , value in YellowstoneConfig . YELLOWSTONE_CAMPGROUNDS . items () ] error_message = ( \"You must supply a YellowstoneNationalParkLodges supported \" \"campground ID. Current supported Campground IDs: \" f \" { ', ' . join ( campground_ids ) } \" ) logger . error ( error_message ) raise SearchError ( error_message ) logger . info ( f \" { len ( searchable_campgrounds ) } Matching Campgrounds Found\" ) for campground in searchable_campgrounds : logger . info ( f \"\u26f0 { YellowstoneConfig . YELLOWSTONE_RECREATION_AREA_FORMAL_NAME } \" f \"(# { YellowstoneConfig . YELLOWSTONE_RECREATION_AREA_ID } ) - \ud83c\udfd5 \" f \" { YellowstoneConfig . YELLOWSTONE_CAMPGROUNDS [ campground ] } ( { campground } )\" ) return searchable_campgrounds def _filter_campsites_to_campgrounds ( self , campsites : List [ AvailableCampsite ], searchable_campgrounds : Set [ str ] ) -> List [ AvailableCampsite ]: \"\"\" Filter Campsites Down to Matching Campgrounds Parameters ---------- campsites: List[AvailableCampsite] searchable_campgrounds: Set[str] Returns ------- List[AvailableCampsite] \"\"\" if self . campgrounds in [ None , []]: return campsites matching_campsites = [ campsite for campsite in campsites if campsite . facility_id in searchable_campgrounds ] return matching_campsites @staticmethod def print_campgrounds () -> None : \"\"\" Print the Campgrounds inside of Yellowstone \"\"\" log_sorted_response ( YellowstoneConfig . YELLOWSTONE_CAMPGROUND_OBJECTS ) __init__ ( search_window , weekends_only = False , campgrounds = None , nights = 1 , offline_search = False , offline_search_path = None , ** kwargs ) # Initialize with Search Parameters Parameters # Union[SearchWindow, List[SearchWindow]] Search Window tuple containing start date and End Date bool Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights) Optional[Union[List[str], str]] Campground ID or List of Campground IDs int minimum number of consecutive nights to search per campsite,defaults to 1 bool When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. Optional[str] When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to camply_campsites.json Source code in camply/search/search_yellowstone.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def __init__ ( self , search_window : Union [ SearchWindow , List [ SearchWindow ]], weekends_only : bool = False , campgrounds : Optional [ Union [ List [ str ], str ]] = None , nights : int = 1 , offline_search : bool = False , offline_search_path : Optional [ str ] = None , ** kwargs , ) -> None : \"\"\" Initialize with Search Parameters Parameters ---------- search_window: Union[SearchWindow, List[SearchWindow]] Search Window tuple containing start date and End Date weekends_only: bool Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights) campgrounds: Optional[Union[List[str], str]] Campground ID or List of Campground IDs nights: int minimum number of consecutive nights to search per campsite,defaults to 1 offline_search: bool When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. offline_search_path: Optional[str] When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to `camply_campsites.json` \"\"\" super () . __init__ ( provider = YellowstoneLodging (), search_window = search_window , weekends_only = weekends_only , nights = nights , offline_search = offline_search , offline_search_path = offline_search_path , ) self . campgrounds = make_list ( campgrounds ) get_all_campsites () # Search for all matching campsites in Yellowstone. Returns # List[AvailableCampsite] Source code in camply/search/search_yellowstone.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def get_all_campsites ( self ) -> List [ AvailableCampsite ]: \"\"\" Search for all matching campsites in Yellowstone. Returns ------- List[AvailableCampsite] \"\"\" all_campsites = list () searchable_campgrounds = self . _get_searchable_campgrounds () this_month = datetime . now () . date () . replace ( day = 1 ) for month in self . search_months : if month >= this_month : all_campsites += self . campsite_finder . get_monthly_campsites ( month = month , nights = None if self . nights == 1 else self . nights ) matching_campsites = self . _filter_campsites_to_campgrounds ( campsites = all_campsites , searchable_campgrounds = searchable_campgrounds ) campsite_df = self . campsites_to_df ( campsites = matching_campsites ) campsite_df_validated = self . _filter_date_overlap ( campsites = campsite_df ) time_window_end = max ( self . search_days ) + timedelta ( days = 1 ) compiled_campsite_df = campsite_df_validated [ campsite_df_validated . booking_end_date <= pd . Timestamp ( time_window_end ) ] compiled_campsites = self . df_to_campsites ( campsite_df = compiled_campsite_df ) return compiled_campsites print_campgrounds () staticmethod # Print the Campgrounds inside of Yellowstone Source code in camply/search/search_yellowstone.py 155 156 157 158 159 160 @staticmethod def print_campgrounds () -> None : \"\"\" Print the Campgrounds inside of Yellowstone \"\"\" log_sorted_response ( YellowstoneConfig . YELLOWSTONE_CAMPGROUND_OBJECTS ) YellowstoneLodging # Bases: BaseProvider Scanner for Lodging in Yellowstone Source code in camply/providers/xanterra/yellowstone_lodging.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 class YellowstoneLodging ( BaseProvider ): \"\"\" Scanner for Lodging in Yellowstone \"\"\" def __repr__ ( self ): \"\"\" String Representation Returns ------- str \"\"\" return \"<YellowstoneLodging>\" def _get_monthly_availability ( self , month : datetime , nights : int = None ) -> dict : \"\"\" Check All Lodging in Yellowstone for Campground Data Returns ------- data_availability: dict Data Availability Dictionary \"\"\" query_dict = dict ( date = self . _ensure_current_month ( month = month ), limit = 31 , rate_code = YellowstoneConfig . RATE_CODE , ) if nights is not None : query_dict . update ( dict ( nights = nights )) api_endpoint = self . _get_api_endpoint ( url_path = YellowstoneConfig . YELLOWSTONE_LODGING_PATH , query = None ) logger . info ( f \"Searching for Yellowstone Lodging Availability: { month . strftime ( '%B, %Y' ) } \" ) all_resort_availability_data = self . make_yellowstone_request ( endpoint = api_endpoint , params = query_dict ) return all_resort_availability_data @staticmethod @tenacity . retry ( wait = tenacity . wait_random_exponential ( multiplier = 3 , max = 1800 ), stop = tenacity . stop . stop_after_delay ( 6000 ), ) def _try_retry_get_data ( endpoint : str , params : Optional [ dict ] = None ) -> dict : \"\"\" Try and Retry Fetching Data from the Yellowstone API. Unfortunately this is a required method to request the data since the Yellowstone API doesn't always return data. Parameters ---------- endpoint: str API Endpoint params Returns ------- dict \"\"\" yellowstone_headers = choice ( USER_AGENTS ) yellowstone_headers . update ( STANDARD_HEADERS ) yellowstone_headers . update ( YellowstoneConfig . API_REFERRERS ) response = requests . get ( url = endpoint , headers = yellowstone_headers , params = params , timeout = 30 ) if response . status_code == 200 and response . text . strip () != \"\" : return loads ( response . content ) else : error_message = ( \"Something went wrong with checking the \" \"Yellowstone Booking API. Will continue retrying.\" ) logger . warning ( error_message ) raise RuntimeError ( error_message ) @staticmethod def make_yellowstone_request ( endpoint : str , params : Optional [ dict ] = None ) -> dict : \"\"\" Try and Retry Fetching Data from the Yellowstone API. Unfortunately this is a required method to request the data since the Yellowstone API doesn't always return data. Parameters ---------- endpoint: str API Endpoint params Returns ------- dict \"\"\" try : content = YellowstoneLodging . _try_retry_get_data ( endpoint = endpoint , params = params ) except RuntimeError as re : raise RuntimeError ( f \"error_message: { re } \" ) return content @classmethod def _get_api_endpoint ( cls , url_path : str , query : Optional [ dict ] = None ) -> str : \"\"\" Build the API Endpoint for All Yellowstone Lodging \"\"\" if query is not None : query_string = parse . urlencode ( query = query ) else : query_string = \"\" url_components = dict ( scheme = YellowstoneConfig . API_SCHEME , netloc = YellowstoneConfig . API_BASE_ENDPOINT , url = url_path , params = \"\" , query = query_string , fragment = \"\" , ) api_endpoint = parse . urlunparse ( tuple ( url_components . values ())) return api_endpoint @classmethod def _return_lodging_url ( cls , lodging_code : str , month : datetime , params : Optional [ dict ] = \"\" ) -> str : \"\"\" Return a Browser Loadable URL to book from Parameters ---------- lodging_code: str Lodging Code from API month: datetime Month to return bookings filtered to params: Optional[dict] Optional URL Parameters Returns ------- str URL String \"\"\" query = dict ( dateFrom = month . strftime ( \"%m- %d -%Y\" ), adults = 1 , destination = lodging_code , children = 0 , ) if params is not None : query . update ( params ) query_string = parse . urlencode ( query = query ) url_components = dict ( scheme = YellowstoneConfig . API_SCHEME , netloc = YellowstoneConfig . WEBUI_BASE_ENDPOINT , url = YellowstoneConfig . WEBUI_BOOKING_PATH , params = \"\" , query = query_string , fragment = \"\" , ) webui_endpoint = parse . urlunparse ( tuple ( url_components . values ())) return webui_endpoint @classmethod def _compile_campground_availabilities ( cls , availability : XantResortData ) -> List [ dict ]: \"\"\" Gather Data about campground availabilities within a JSON Availability Objet Parameters ---------- availability: ResortData JSON Availability Object Returns ------- available_campsites: List[dict] List of Availabilities as JSON \"\"\" available_campsites = list () for booking_date , daily_data in availability . availability . items (): camping_keys = [ key for key in daily_data . keys () if YellowstoneConfig . LODGING_CAMPGROUND_QUALIFIER in key ] for hotel_code in camping_keys : hotel_data = daily_data [ hotel_code ] try : hotel_title = hotel_data . rates [ YellowstoneConfig . RATE_CODE ] . title hotel_rate_mins = hotel_data . rates [ YellowstoneConfig . RATE_CODE ] . mins if hotel_rate_mins != { 1 : 0 }: min_capacity = min ( hotel_rate_mins . keys ()) max_capacity = max ( hotel_rate_mins . keys ()) capacity = ( min_capacity , max_capacity ) campsite = dict ( campsite_id = None , booking_date = booking_date , campsite_occupancy = capacity , recreation_area = YellowstoneConfig . YELLOWSTONE_RECREATION_AREA_NAME , recreation_area_id = YellowstoneConfig . YELLOWSTONE_RECREATION_AREA_ID , facility_name = hotel_title . replace ( * YellowstoneConfig . YELLOWSTONE_CAMPGROUND_NAME_REPLACE ), facility_id = hotel_code , ) available_campsites . append ( campsite ) except KeyError : pass logger . info ( f \" \\t { logging_utils . get_emoji ( available_campsites ) } \\t \" f \" { len ( available_campsites ) } sites found.\" ) return available_campsites def _gather_campsite_specific_availability ( self , available_campsites : List [ dict ], month : datetime , nights : Optional [ int ] = None , ) -> List [ dict ]: \"\"\" Get campsite extra information Given a DataFrame of campsite availability, return updated Data with details about the actual campsites that are available (i.e Tent Size, RV Length, Etc) Parameters ---------- available_campsites: List[dict] List of Available Campsites as JSON objects month: datetime Month object Returns ------- List[dict] \"\"\" available_room_array = list () availability_df = DataFrame ( data = available_campsites ) if availability_df . empty is True : return available_room_array for facility_id , _facility_df in availability_df . groupby ( YellowstoneConfig . FACILITY_ID ): api_endpoint = self . _get_api_endpoint ( url_path = YellowstoneConfig . YELLOWSTONE_CAMPSITE_AVAILABILITY , query = None ) params = dict ( date = self . _ensure_current_month ( month = month ), limit = 31 ) if nights is not None : params . update ( dict ( nights = nights )) campsite_data = self . make_yellowstone_request ( endpoint = f \" { api_endpoint } / { facility_id } \" , params = params ) campsite_availability = campsite_data [ YellowstoneConfig . BOOKING_AVAILABILITY ] booking_dates = campsite_availability . keys () availabilities = self . _process_daily_availability ( booking_dates = booking_dates , campsite_availability = campsite_availability , facility_id = facility_id , ) available_room_array += availabilities return available_room_array @classmethod def _process_daily_availability ( cls , booking_dates : List [ str ], campsite_availability : dict , facility_id : str ) -> List [ dict ]: \"\"\" Process Monthly Availability Parameters ---------- booking_dates: List[str] List of booking dates to process campsite_availability: dict Campsite availability dict facility_id: str Identification of the Facility Returns ------- List[dict] \"\"\" daily_availabilities = list () for booking_date_str in booking_dates : daily_availability = campsite_availability [ booking_date_str ] if ( daily_availability [ YellowstoneConfig . FACILITY_STATUS ] == YellowstoneConfig . FACILITY_STATUS_QUALIFIER ): available_rooms = daily_availability [ YellowstoneConfig . FACILITY_ROOMS ] for room in available_rooms : if room [ YellowstoneConfig . FACILITY_AVAILABLE_QUALIFIER ] > 0 : daily_availabilities . append ( dict ( booking_date = booking_date_str , facility_id = facility_id , campsite_code = room [ YellowstoneConfig . FACILITY_ROOM_CODE ], available = room [ YellowstoneConfig . FACILITY_AVAILABLE_QUALIFIER ], price = room [ YellowstoneConfig . FACILITY_PRICE ], ) ) return daily_availabilities def _get_property_information ( self , available_rooms : List [ dict ]) -> List [ dict ]: \"\"\" Gather Information About All Campgrounds / Hotels within Yellowstone Parameters ---------- available_rooms: List[dict] Returns ------- List[dict] \"\"\" property_info_array = list () availability_df = DataFrame ( data = available_rooms ) if availability_df . empty is True : return property_info_array facility_identifiers = availability_df [ YellowstoneConfig . FACILITY_ID ] . unique () for facility_id in facility_identifiers : api_endpoint = self . _get_api_endpoint ( url_path = YellowstoneConfig . YELLOWSTONE_PROPERTY_INFO , query = None ) campsite_info = self . make_yellowstone_request ( endpoint = f \" { api_endpoint } / { facility_id } \" ) campsite_codes = campsite_info . keys () for campsite_code in campsite_codes : campsite_data = campsite_info [ campsite_code ] property_info_array . append ( dict ( facility_id = facility_id , campsite_code = campsite_code , campsite_title = campsite_data [ YellowstoneConfig . LODGING_TITLE ], campsite_type = campsite_data [ YellowstoneConfig . FACILITY_TYPE ] . upper (), capacity = ( campsite_data [ YellowstoneConfig . LODGING_OCCUPANCY_BASE ], campsite_data [ YellowstoneConfig . LODGING_OCCUPANCY_MAX ], ), ) ) return property_info_array def get_monthly_campsites ( self , month : datetime , nights : Optional [ int ] = None ) -> List [ AvailableCampsite ]: \"\"\" Return All Campsites Available in a Given Month Parameters ---------- month: datetime Month to Search nights: Optional[int] Search for consecutive nights Returns ------- List[AvailableCampsite] \"\"\" now = datetime . now () . date () search_date = month . replace ( day = 1 ) if month <= now : logger . info ( \"Cannot input search dates before today, adjusting search parameters.\" ) search_date = search_date . replace ( year = now . year , month = now . month , day = now . day ) availability_found = self . _get_monthly_availability ( month = search_date , nights = nights ) availability = XantResortData ( ** availability_found ) monthly_campsites = self . _compile_campground_availabilities ( availability = availability ) campsite_data = DataFrame ( monthly_campsites , columns = YellowstoneConfig . CAMPSITE_DATA_COLUMNS ) . drop_duplicates () if campsite_data . empty is True : return list () available_room_array = self . _gather_campsite_specific_availability ( available_campsites = monthly_campsites , month = month , nights = nights ) available_rooms = DataFrame ( available_room_array ) property_info = self . _get_property_information ( available_rooms = available_room_array ) properties = DataFrame ( property_info ) merged_campsites = available_rooms . merge ( properties , on = [ YellowstoneConfig . FACILITY_ID_COLUMN , YellowstoneConfig . CAMPSITE_ID_COLUMN , ], ) merged_campsites [ YellowstoneConfig . BOOKING_DATE_COLUMN ] = to_datetime ( merged_campsites [ YellowstoneConfig . BOOKING_DATE_COLUMN ] ) if nights is not None : nights_param = dict ( nights = nights ) else : nights_param = dict ( nights = 1 ) booking_nights = nights_param . get ( \"nights\" ) merged_campsites [ YellowstoneConfig . BOOKING_END_DATE_COLUMN ] = merged_campsites [ YellowstoneConfig . BOOKING_DATE_COLUMN ] + timedelta ( days = booking_nights ) merged_campsites [ YellowstoneConfig . BOOKING_NIGHTS_COLUMN ] = booking_nights final_campsites = merged_campsites . merge ( campsite_data , on = YellowstoneConfig . FACILITY_ID_COLUMN ) . sort_values ( by = YellowstoneConfig . BOOKING_DATE_COLUMN ) final_campsites [ YellowstoneConfig . BOOKING_URL_COLUMN ] = final_campsites . apply ( lambda x : self . _return_lodging_url ( lodging_code = x . facility_id , month = x . booking_date , params = nights_param ), axis = 1 , ) all_monthly_campsite_array = self . _df_to_campsites ( campsite_df = final_campsites ) return all_monthly_campsite_array @classmethod def _df_to_campsites ( cls , campsite_df : DataFrame ) -> List [ AvailableCampsite ]: \"\"\" Transform a DataFrame into an array of AvailableCampsites Parameters ---------- campsite_df: DataFrame Returns ------- List[AvailableCampsite] \"\"\" all_monthly_campsite_array = list () for _ , row in campsite_df . iterrows (): campsite = AvailableCampsite ( campsite_id = row [ YellowstoneConfig . CAMPSITE_ID_COLUMN ], booking_date = row [ YellowstoneConfig . BOOKING_DATE_COLUMN ], booking_end_date = row [ YellowstoneConfig . BOOKING_END_DATE_COLUMN ], booking_nights = row [ YellowstoneConfig . BOOKING_NIGHTS_COLUMN ], campsite_site_name = row [ YellowstoneConfig . CAMPSITE_SITE_NAME_COLUMN ], campsite_loop_name = YellowstoneConfig . YELLOWSTONE_LOOP_NAME , campsite_type = row [ YellowstoneConfig . CAMPSITE_TYPE_COLUMN ], campsite_occupancy = row [ YellowstoneConfig . CAMPSITE_OCCUPANCY_COLUMN ], campsite_use_type = row [ YellowstoneConfig . CAMPSITE_USE_TYPE_COLUMN ], availability_status = YellowstoneConfig . CAMPSITE_AVAILABILITY_STATUS , recreation_area = YellowstoneConfig . YELLOWSTONE_RECREATION_AREA_NAME , recreation_area_id = YellowstoneConfig . YELLOWSTONE_RECREATION_AREA_ID , facility_name = row [ YellowstoneConfig . FACILITY_NAME_COLUMN ], facility_id = row [ YellowstoneConfig . FACILITY_ID_COLUMN ], booking_url = row [ YellowstoneConfig . BOOKING_URL_COLUMN ], ) all_monthly_campsite_array . append ( campsite ) return all_monthly_campsite_array @classmethod def _ensure_current_month ( cls , month : datetime ) -> datetime : \"\"\" Ensure That We Never Give the Yellowstone API Dates in the past. Parameters ---------- month: datetime Returns ------- datetime \"\"\" yellowstone_timezone = timezone ( YellowstoneConfig . YELLOWSTONE_TIMEZONE ) yellowstone_current_time = datetime . now ( yellowstone_timezone ) . date () today = datetime ( year = yellowstone_current_time . year , month = yellowstone_current_time . month , day = yellowstone_current_time . day , ) . date () if today > month : month = today return month __repr__ () # String Representation Returns # str Source code in camply/providers/xanterra/yellowstone_lodging.py 31 32 33 34 35 36 37 38 39 def __repr__ ( self ): \"\"\" String Representation Returns ------- str \"\"\" return \"<YellowstoneLodging>\" get_monthly_campsites ( month , nights = None ) # Return All Campsites Available in a Given Month Parameters # datetime Month to Search Optional[int] Search for consecutive nights Returns # List[AvailableCampsite] Source code in camply/providers/xanterra/yellowstone_lodging.py 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 def get_monthly_campsites ( self , month : datetime , nights : Optional [ int ] = None ) -> List [ AvailableCampsite ]: \"\"\" Return All Campsites Available in a Given Month Parameters ---------- month: datetime Month to Search nights: Optional[int] Search for consecutive nights Returns ------- List[AvailableCampsite] \"\"\" now = datetime . now () . date () search_date = month . replace ( day = 1 ) if month <= now : logger . info ( \"Cannot input search dates before today, adjusting search parameters.\" ) search_date = search_date . replace ( year = now . year , month = now . month , day = now . day ) availability_found = self . _get_monthly_availability ( month = search_date , nights = nights ) availability = XantResortData ( ** availability_found ) monthly_campsites = self . _compile_campground_availabilities ( availability = availability ) campsite_data = DataFrame ( monthly_campsites , columns = YellowstoneConfig . CAMPSITE_DATA_COLUMNS ) . drop_duplicates () if campsite_data . empty is True : return list () available_room_array = self . _gather_campsite_specific_availability ( available_campsites = monthly_campsites , month = month , nights = nights ) available_rooms = DataFrame ( available_room_array ) property_info = self . _get_property_information ( available_rooms = available_room_array ) properties = DataFrame ( property_info ) merged_campsites = available_rooms . merge ( properties , on = [ YellowstoneConfig . FACILITY_ID_COLUMN , YellowstoneConfig . CAMPSITE_ID_COLUMN , ], ) merged_campsites [ YellowstoneConfig . BOOKING_DATE_COLUMN ] = to_datetime ( merged_campsites [ YellowstoneConfig . BOOKING_DATE_COLUMN ] ) if nights is not None : nights_param = dict ( nights = nights ) else : nights_param = dict ( nights = 1 ) booking_nights = nights_param . get ( \"nights\" ) merged_campsites [ YellowstoneConfig . BOOKING_END_DATE_COLUMN ] = merged_campsites [ YellowstoneConfig . BOOKING_DATE_COLUMN ] + timedelta ( days = booking_nights ) merged_campsites [ YellowstoneConfig . BOOKING_NIGHTS_COLUMN ] = booking_nights final_campsites = merged_campsites . merge ( campsite_data , on = YellowstoneConfig . FACILITY_ID_COLUMN ) . sort_values ( by = YellowstoneConfig . BOOKING_DATE_COLUMN ) final_campsites [ YellowstoneConfig . BOOKING_URL_COLUMN ] = final_campsites . apply ( lambda x : self . _return_lodging_url ( lodging_code = x . facility_id , month = x . booking_date , params = nights_param ), axis = 1 , ) all_monthly_campsite_array = self . _df_to_campsites ( campsite_df = final_campsites ) return all_monthly_campsite_array make_yellowstone_request ( endpoint , params = None ) staticmethod # Try and Retry Fetching Data from the Yellowstone API. Unfortunately this is a required method to request the data since the Yellowstone API doesn't always return data. Parameters # str API Endpoint params Returns # dict Source code in camply/providers/xanterra/yellowstone_lodging.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 @staticmethod def make_yellowstone_request ( endpoint : str , params : Optional [ dict ] = None ) -> dict : \"\"\" Try and Retry Fetching Data from the Yellowstone API. Unfortunately this is a required method to request the data since the Yellowstone API doesn't always return data. Parameters ---------- endpoint: str API Endpoint params Returns ------- dict \"\"\" try : content = YellowstoneLodging . _try_retry_get_data ( endpoint = endpoint , params = params ) except RuntimeError as re : raise RuntimeError ( f \"error_message: { re } \" ) return content","title":"camply"},{"location":"reference/#camply.AvailableCampsite","text":"Bases: CamplyModel Campsite Storage This container should be universal regardless of API Provider Source code in camply/containers/data_containers.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class AvailableCampsite ( CamplyModel ): \"\"\" Campsite Storage This container should be universal regardless of API Provider \"\"\" campsite_id : Union [ int , str ] booking_date : datetime . datetime booking_end_date : datetime . datetime booking_nights : int campsite_site_name : str campsite_loop_name : str campsite_type : str campsite_occupancy : Tuple [ int , int ] campsite_use_type : str availability_status : str recreation_area : str recreation_area_id : int facility_name : str facility_id : Union [ int , str ] booking_url : str permitted_equipment : Optional [ List [ RecDotGovEquipment ]] campsite_attributes : Optional [ List [ RecDotGovAttribute ]] __unhashable__ = { \"permitted_equipment\" , \"campsite_attributes\" }","title":"AvailableCampsite"},{"location":"reference/#camply.EquipmentOptions","text":"Bases: str , Enum Enumeration of the Equipment Options Source code in camply/config/search_config.py 22 23 24 25 26 27 28 29 30 31 32 33 class EquipmentOptions ( str , Enum ): \"\"\" Enumeration of the Equipment Options \"\"\" tent = \"tent\" rv = \"rv\" trailer = \"trailer\" vehicle = \"vehicle\" other = \"other\" __all_accepted_equipment__ = [ tent , rv , trailer , vehicle ]","title":"EquipmentOptions"},{"location":"reference/#camply.RecreationDotGov","text":"Bases: BaseProvider Python Class for Working with Recreation.gov API / NPS APIs Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 class RecreationDotGov ( BaseProvider ): \"\"\" Python Class for Working with Recreation.gov API / NPS APIs \"\"\" def __init__ ( self , api_key : str = None ): \"\"\" Initialize with Search Dates \"\"\" if api_key is None : _api_key = RIDBConfig . API_KEY if isinstance ( _api_key , bytes ): _api_key : str = b64decode ( RIDBConfig . API_KEY ) . decode ( \"utf-8\" ) else : _api_key : str = api_key self . _ridb_api_headers : dict = dict ( accept = \"application/json\" , apikey = _api_key ) def __repr__ ( self ): \"\"\" String Representation Returns ------- str \"\"\" return \"<RecreationDotGov>\" def find_recreation_areas ( self , search_string : str = None , ** kwargs ) -> List [ dict ]: \"\"\" Find Matching Campsites Based on Search String Parameters ---------- search_string: str Search Keyword(s) Returns ------- filtered_responses: List[dict] Array of Matching Campsites \"\"\" try : assert any ( [ kwargs . get ( \"state\" , None ) is not None , search_string is not None and search_string != \"\" , ] ) except AssertionError : raise RuntimeError ( \"You must provide a search query or state(s) \" \"to find Recreation Areas\" ) logger . info ( f 'Searching for Recreation Areas: \" { search_string } \"' ) state_arg = kwargs . get ( \"state\" , None ) if state_arg is not None : kwargs . update ({ \"state\" : state_arg . upper ()}) params = dict ( query = search_string , sort = \"Name\" , full = \"true\" , ** kwargs ) if search_string is None : params . pop ( \"query\" ) api_response = self . _ridb_get_paginate ( path = RIDBConfig . REC_AREA_API_PATH , params = params ) logger . info ( f \" { len ( api_response ) } recreation areas found.\" ) logging_messages = list () for recreation_area_object in api_response : _ , recreation_area = self . _process_rec_area_response ( recreation_area = recreation_area_object ) if recreation_area is not None : logging_messages . append ( recreation_area ) log_sorted_response ( response_array = logging_messages ) return api_response def find_campgrounds ( self , search_string : str = None , rec_area_id : Optional [ List [ int ]] = None , campground_id : Optional [ List [ int ]] = None , campsite_id : Optional [ List [ int ]] = None , ** kwargs , ) -> List [ CampgroundFacility ]: \"\"\" Find Bookable Campgrounds Given a Set of Search Criteria Parameters ---------- search_string: str Search Keyword(s) rec_area_id: Optional[List[int]] Recreation Area ID to filter with campground_id: Optional[List[int]] ID of the Campground campsite_id: Optional[List[int]] ID of the Campsite Returns ------- facilities: List[CampgroundFacility] Array of Matching Campsites \"\"\" if campsite_id not in ( None , [], ()): facilities = self . _process_specific_campsites_provided ( campsite_id = campsite_id ) elif campground_id not in ( None , [], ()): facilities = self . _find_facilities_from_campgrounds ( campground_id = campground_id ) elif rec_area_id not in ( None , [], ()): facilities = list () for recreation_area in rec_area_id : facilities += self . find_facilities_per_recreation_area ( rec_area_id = recreation_area ) else : state_arg = kwargs . get ( \"state\" , None ) if state_arg is not None : kwargs . update ({ \"state\" : state_arg . upper ()}) if search_string in [ \"\" , None ] and state_arg is None : raise RuntimeError ( \"You must provide a search query or state to find campsites\" ) facilities = self . _find_facilities_from_search ( search = search_string , ** kwargs ) return facilities def find_facilities_per_recreation_area ( self , rec_area_id : int = None , ** kwargs ) -> List [ CampgroundFacility ]: \"\"\" Find Matching Campsites Based from Recreation Area Parameters ---------- rec_area_id: int Recreation Area ID Returns ------- campgrounds: List[CampgroundFacility] Array of Matching Campsites \"\"\" logger . info ( f \"Retrieving Facility Information for Recreation Area ID: ` { rec_area_id } `.\" ) api_path = f \" { RIDBConfig . REC_AREA_API_PATH } / { rec_area_id } / { RIDBConfig . FACILITIES_API_PATH } \" api_response = self . _ridb_get_paginate ( path = api_path , params = dict ( full = \"true\" , ** kwargs ) ) filtered_facilities = self . _filter_facilities_responses ( responses = api_response ) campgrounds = list () logger . info ( f \" { len ( filtered_facilities ) } Matching Campgrounds Found\" ) for facility in filtered_facilities : _ , campground_facility = self . process_facilities_responses ( facility = facility ) if campground_facility is not None : campgrounds . append ( campground_facility ) log_sorted_response ( response_array = campgrounds ) return campgrounds def _find_facilities_from_campgrounds ( self , campground_id : Union [ int , List [ int ]] ) -> List [ CampgroundFacility ]: \"\"\" Find Matching Campsites from Campground ID Parameters ---------- campground_id: Union[int, List[int]] ID of the Campsite Returns ------- filtered_responses: List[CampgroundFacility] Array of Matching Campsites \"\"\" campgrounds = list () for campground_identifier in campground_id : facility_data = self . get_ridb_data ( path = f \" { RIDBConfig . FACILITIES_API_PATH } / { campground_identifier } \" , params = dict ( full = True ), ) filtered_facility = self . _filter_facilities_responses ( responses = [ facility_data ] ) _ , campground_facility = self . process_facilities_responses ( facility = filtered_facility [ 0 ] ) if campground_facility is not None : campgrounds . append ( campground_facility ) logger . info ( f \" { len ( campgrounds ) } Matching Campgrounds Found\" ) log_sorted_response ( response_array = campgrounds ) return campgrounds def _find_facilities_from_search ( self , search : str , ** kwargs ) -> List [ dict ]: \"\"\" Find Matching Campgrounds Based on Search String Parameters ---------- search: str Search String Returns ------- campgrounds: List[dict] Array of Matching Campsites \"\"\" facilities_response = self . _ridb_get_paginate ( path = RIDBConfig . FACILITIES_API_PATH , params = dict ( query = search , activity = \"CAMPING\" , full = \"true\" , ** kwargs ), ) filtered_responses = self . _filter_facilities_responses ( responses = facilities_response ) logger . info ( f \" { len ( filtered_responses ) } Matching Campgrounds Found\" ) campgrounds = list () for facility in filtered_responses : _ , campground_facility = self . process_facilities_responses ( facility = facility ) if campground_facility is not None : campgrounds . append ( campground_facility ) log_sorted_response ( response_array = campgrounds ) return campgrounds @classmethod def _ridb_get_endpoint ( cls , path : str ) -> str : \"\"\" Return an API Endpoint for the RIDP Parameters ---------- path: str URL Endpoint, see https://ridb.recreation.gov/docs Returns ------- endpoint_url: str URL for the API Endpoint \"\"\" assert RIDBConfig . RIDB_BASE_PATH . endswith ( \"/\" ) base_url = api_utils . generate_url ( scheme = RIDBConfig . RIDB_SCHEME , netloc = RIDBConfig . RIDB_NET_LOC , path = RIDBConfig . RIDB_BASE_PATH , ) endpoint_url = parse . urljoin ( base_url , path ) return endpoint_url @tenacity . retry ( wait = tenacity . wait_random_exponential ( multiplier = 2 , max = 10 ), stop = tenacity . stop . stop_after_delay ( 15 ), ) def get_ridb_data ( self , path : str , params : Optional [ dict ] = None ) -> Union [ dict , list ]: \"\"\" Find Matching Campsites Based on Search String Parameters ---------- path: str URL Endpoint, see https://ridb.recreation.gov/docs params: Optional[dict] API Call Parameters Returns ------- Union[dict, list] \"\"\" api_endpoint = self . _ridb_get_endpoint ( path = path ) headers = self . _ridb_api_headers . copy () headers . update ( choice ( USER_AGENTS )) response = requests . get ( url = api_endpoint , headers = headers , params = params , timeout = 30 ) try : assert response . status_code == 200 except AssertionError : error_message = ( f \"Receiving bad data from Recreation.gov API: { response . text } \" ) logger . error ( error_message ) raise ConnectionError ( error_message ) return loads ( response . content ) def _ridb_get_paginate ( self , path : str , params : Optional [ dict ] = None , ) -> List [ dict ]: \"\"\" Return the Paginated Response from the RIDP Parameters ---------- path: str URL Endpoint, see https://ridb.recreation.gov/docs params: Optional[dict] API Call Parameters Returns ------- paginated_response: list Concatted Response \"\"\" if params is None : params = {} paginated_response = list () data_incomplete = True offset : int = 0 historical_results = 0 while data_incomplete is True : params . update ( offset = offset ) data_response = self . get_ridb_data ( path = path , params = params ) response_object = GenericResponse ( ** data_response ) paginated_response += response_object . RECDATA result_count = response_object . METADATA . RESULTS . CURRENT_COUNT historical_results += result_count total_count = response_object . METADATA . RESULTS . TOTAL_COUNT if offset >= 500 : logger . info ( f \"Too Many Results returned ( { total_count } ), \" \"try performing a more specific search\" ) data_incomplete = False elif historical_results < total_count : offset = historical_results else : data_incomplete = False return paginated_response @classmethod def _filter_facilities_responses ( cls , responses = List [ dict ]) -> List [ dict ]: \"\"\" Filter Facilities to Actual Reservable Campsites Parameters ---------- responses Returns ------- List[dict] \"\"\" filtered_responses = list () for possible_match in responses : try : facility = FacilityResponse ( ** possible_match ) except ValidationError as e : logger . error ( \"That doesn't look like a valid Campground Facility\" ) logger . error ( json . dumps ( possible_match )) logger . exception ( e ) raise ProviderSearchError ( \"Invalid Campground Facility Returned\" ) if all ( [ facility . FacilityTypeDescription == RIDBConfig . CAMPGROUND_FACILITY_FIELD_QUALIFIER , facility . Enabled is True , facility . Reservable is True , ] ): filtered_responses . append ( possible_match ) return filtered_responses @classmethod def process_facilities_responses ( cls , facility : dict ) -> Tuple [ dict , Optional [ CampgroundFacility ]]: \"\"\" Process Facilities Responses to be More Usable Parameters ---------- facility: dict Returns ------- Tuple[dict, CampgroundFacility] \"\"\" facility_object = FacilityResponse ( ** facility ) try : facility_state = facility_object . FACILITYADDRESS [ 0 ] . AddressStateCode . upper () except ( KeyError , IndexError ): facility_state = \"USA\" try : if len ( facility_object . RECAREA ) == 0 : recreation_area_id = facility_object . ParentRecAreaID formatted_recreation_area = ( f \" { facility_object . ORGANIZATION [ 0 ] . OrgName } , { facility_state } \" ) else : recreation_area = facility_object . RECAREA [ 0 ] . RecAreaName recreation_area_id = facility_object . RECAREA [ 0 ] . RecAreaID formatted_recreation_area = f \" { recreation_area } , { facility_state } \" campground_facility = CampgroundFacility ( facility_name = facility_object . FacilityName . title (), recreation_area = formatted_recreation_area , facility_id = facility_object . FacilityID , recreation_area_id = recreation_area_id , ) return facility , campground_facility except ( KeyError , IndexError ): return facility , None @classmethod def _process_rec_area_response ( cls , recreation_area = dict ) -> Tuple [ dict , Optional [ RecreationArea ]]: \"\"\" Process Rec Area Responses to be More Usable Parameters ---------- recreation_area: dict Returns ------- Tuple[dict, RecreationArea] \"\"\" rec_area_response = RecreationAreaResponse ( ** recreation_area ) try : recreation_area_location = rec_area_response . RECAREAADDRESS [ 0 ] . AddressStateCode recreation_area_tuple = RecreationArea ( recreation_area = rec_area_response . RecAreaName , recreation_area_id = rec_area_response . RecAreaID , recreation_area_location = recreation_area_location , ) return recreation_area , recreation_area_tuple except IndexError : return recreation_area , None @classmethod def _rec_availability_get_endpoint ( cls , path : str ) -> str : \"\"\" Return an API Endpoint for the Recreation.gov Campground Availability API Parameters ---------- path: str URL Endpoint Path Returns ------- endpoint_url: str URL for the API Endpoint \"\"\" base_url = api_utils . generate_url ( scheme = RecreationBookingConfig . API_SCHEME , netloc = RecreationBookingConfig . API_NET_LOC , path = RecreationBookingConfig . API_BASE_PATH , ) endpoint_url = parse . urljoin ( base_url , path ) return endpoint_url @classmethod def make_recdotgov_request ( cls , url : str , method : str = \"GET\" , params : Optional [ Dict [ str , Any ]] = None , ** kwargs , ) -> requests . Response : \"\"\" Make a Raw Request to RecreationDotGov Parameters ---------- url: str method: str params: Optional[Dict[str, Any]] Returns ------- requests.Response \"\"\" # BUILD THE HEADERS EXPECTED FROM THE API headers = STANDARD_HEADERS . copy () headers . update ( choice ( USER_AGENTS )) headers . update ( RecreationBookingConfig . API_REFERRERS ) response = requests . request ( method = method , url = url , headers = headers , params = params , timeout = 30 , ** kwargs ) return response @classmethod @tenacity . retry ( wait = tenacity . wait_random_exponential ( multiplier = 2 , max = 10 ), stop = tenacity . stop . stop_after_delay ( 15 ), ) def make_recdotgov_request_retry ( cls , url : str , method : str = \"GET\" , params : Optional [ Dict [ str , Any ]] = None , ** kwargs , ) -> requests . Response : \"\"\" Make a Raw Request to RecreationDotGov - But Handle 404 Parameters ---------- url: str method: str params: Optional[Dict[str, Any]] Returns ------- requests.Response \"\"\" response = cls . make_recdotgov_request ( url = url , method = method , params = params , ** kwargs ) response . raise_for_status () return response def paginate_recdotgov_campsites ( self , facility_id : int , equipment : Optional [ List [ str ]] = None ) -> List [ RecDotGovCampsite ]: \"\"\" Paginate through the RecDotGov Campsite Metadata \"\"\" results = 0 continue_paginate = True endpoint_url = api_utils . generate_url ( scheme = RecreationBookingConfig . API_SCHEME , netloc = RecreationBookingConfig . API_NET_LOC , path = \"api/search/campsites\" , ) fq_list = [ f \"asset_id: { facility_id } \" ] if isinstance ( equipment , list ) and len ( equipment ) > 0 : for item in equipment : fq_list . append ( f \"campsite_equipment_name: { item } \" ) params = dict ( start = 0 , size = 1000 , fq = fq_list , include_non_site_specific_campsites = True , ) campsites = [] while continue_paginate is True : response = self . make_recdotgov_request_retry ( method = \"GET\" , url = endpoint_url , params = params , ) returned_data = json . loads ( response . content ) campsite_response = RecDotGovCampsiteResponse ( ** returned_data ) campsites += campsite_response . campsites results += campsite_response . size params . update ( start = results ) if results == campsite_response . total : continue_paginate = False return campsites @tenacity . retry ( wait = tenacity . wait_random_exponential ( multiplier = 3 , max = 1800 ), stop = tenacity . stop . stop_after_delay ( 6000 ), ) def _make_recdotgov_availability_request ( self , campground_id : int , month : datetime , ) -> requests . Response : \"\"\" Make a request to the RecreationDotGov API - Handle Exponential Backoff Parameters ---------- campground_id month Returns ------- requests.Response \"\"\" try : api_endpoint = self . _rec_availability_get_endpoint ( path = f \" { campground_id } / { RecreationBookingConfig . API_MONTH_PATH } \" ) formatted_month = month . strftime ( \"%Y-%m-01T00:00:00.000Z\" ) query_params = dict ( start_date = formatted_month ) response = self . make_recdotgov_request ( method = \"GET\" , url = api_endpoint , params = query_params , ) assert response . status_code == 200 except AssertionError : response_error = response . text error_message = \"Bad Data Returned from the RecreationDotGov API\" logger . debug ( f \" { error_message } , will continue to retry\" ) logger . debug ( f \"Error Details: { response_error } \" ) raise ConnectionError ( f \" { error_message } : { response_error } \" ) return response def get_recdotgov_data ( self , campground_id : int , month : datetime ) -> Union [ dict , list ]: \"\"\" Find Campsite Availability Data Parameters ---------- campground_id: int Campground ID from the RIDB API. Can also be pulled of URLs on Recreation.gov month: datetime datetime object, results will be filtered to month Returns ------- Union[dict, list] \"\"\" try : response = self . _make_recdotgov_availability_request ( campground_id = campground_id , month = month ) except tenacity . RetryError : raise RuntimeError ( \"Something went wrong in fetching data from the \" \"RecreationDotGov API.\" ) return loads ( response . content ) @classmethod def _items_to_unique_dicts ( cls , item : Union [ List [ Dict [ str , Any ]], pd . Series ] ) -> List [ Dict [ str , Any ]]: \"\"\" Ensure the proper items are parsed for equipment and attributes \"\"\" if isinstance ( item , pd . Series ): list_of_dicts = list ( chain . from_iterable ( item . tolist ())) unique_list_of_dicts = [ dict ( s ) for s in set ( frozenset ( d . items ()) for d in list_of_dicts ) ] return unique_list_of_dicts else : return item @classmethod def _get_equipment_and_attributes ( cls , campsite_id : int , campsite_metadata : pd . DataFrame , ) -> Tuple [ List [ Dict [ str , Any ]], List [ Dict [ str , Any ]]]: \"\"\" Index a DataFrame in a Complicated Way \"\"\" try : equipment = campsite_metadata . at [ campsite_id , \"permitted_equipment\" ] except LookupError : equipment = None try : attributes = campsite_metadata . at [ campsite_id , \"attributes\" ] except LookupError : attributes = None equipment = cls . _items_to_unique_dicts ( item = equipment ) attributes = cls . _items_to_unique_dicts ( item = attributes ) return equipment , attributes @classmethod def process_campsite_availability ( cls , availability : dict , recreation_area : str , recreation_area_id : int , facility_name : str , facility_id : int , month : datetime , campsite_metadata : pd . DataFrame , ) -> List [ Optional [ AvailableCampsite ]]: \"\"\" Parse the JSON Response and return availabilities Parameters ---------- availability: dict API Response recreation_area: str Name of Recreation Area recreation_area_id: int ID of Recreation Area facility_name: str Campground Facility Name facility_id: int Campground Facility ID month: datetime Month to Process campsite_metadata: pd.DataFrame Metadata Fetched from the Recreation.gov API about the Campsites Returns ------- total_campsite_availability: List[Optional[AvailableCampsite]] Any monthly availabilities \"\"\" total_campsite_availability : List [ Optional [ AvailableCampsite ]] = list () campsite_data = CampsiteAvailabilityResponse ( ** availability ) for campsite_id , site_related_data in campsite_data . campsites . items (): for ( matching_date , availability_status , ) in site_related_data . availabilities . items (): if ( availability_status not in RecreationBookingConfig . CAMPSITE_UNAVAILABLE_STRINGS ): booking_url = ( f \" { RecreationBookingConfig . CAMPSITE_BOOKING_URL } / { campsite_id } \" ) equipment , attributes = cls . _get_equipment_and_attributes ( campsite_id = campsite_id , campsite_metadata = campsite_metadata ) available_campsite = AvailableCampsite ( campsite_id = campsite_id , booking_date = matching_date , booking_end_date = matching_date + timedelta ( days = 1 ), booking_nights = 1 , campsite_site_name = site_related_data . site , campsite_loop_name = site_related_data . loop , campsite_type = site_related_data . campsite_type , campsite_occupancy = ( site_related_data . min_num_people , site_related_data . max_num_people , ), campsite_use_type = site_related_data . type_of_use , availability_status = availability_status , recreation_area = recreation_area , recreation_area_id = recreation_area_id , facility_name = facility_name , facility_id = facility_id , booking_url = booking_url , permitted_equipment = equipment , campsite_attributes = attributes , ) total_campsite_availability . append ( available_campsite ) logger . info ( f \" \\t { logging_utils . get_emoji ( total_campsite_availability ) } \\t \" f \" { len ( total_campsite_availability ) } total sites found in month of \" f \" { month . strftime ( '%B' ) } \" ) return total_campsite_availability def get_campsite_by_id ( self , campsite_id : int ) -> CampsiteResponse : \"\"\" Get a Campsite's Details Parameters ---------- campsite_id: int Returns ------- CampsiteResponse \"\"\" data = self . get_ridb_data ( path = f \" { RIDBConfig . CAMPSITE_API_PATH } / { campsite_id } \" ) try : response = CampsiteResponse ( ** data [ 0 ]) except IndexError : raise ProviderSearchError ( f \"Campsite with ID # { campsite_id } not found.\" ) return response def get_campground_ids_by_campsites ( self , campsite_ids : List [ int ] ) -> Tuple [ List [ int ], List [ CampsiteResponse ]]: \"\"\" Retrieve a list of FacilityIDs, and Facilities from a Campsite ID List Parameters ---------- campsite_ids: List[int] List of Campsite IDs Returns ------- Tuple[List[int], List[CampsiteResponse]] \"\"\" campground_ids = list () campgrounds = list () for campsite_id in campsite_ids : campsite = self . get_campsite_by_id ( campsite_id = campsite_id ) campgrounds . append ( campsite ) campground_ids . append ( campsite . FacilityID ) return list ( set ( campground_ids )), list ( campgrounds ) def _process_specific_campsites_provided ( self , campsite_id : List [ int ] = None ) -> List [ CampgroundFacility ]: \"\"\" Process Requests for Campgrounds into Facilities Parameters ---------- campsite_id: Optional[List[int]] Returns ------- List[CampgroundFacility] \"\"\" facility_ids , campsites = self . get_campground_ids_by_campsites ( campsite_ids = campsite_id ) facilities = list () for campsite in campsites : facility = self . _find_facilities_from_campgrounds ( campground_id = [ campsite . FacilityID ] )[ 0 ] facilities . append ( facility ) logger . info ( \"Searching Specific Campsite: \u26fa\ufe0f \" f \" { campsite . CampsiteName } (# { campsite . CampsiteID } ) - \" f \" { facility . facility_name } , { facility . recreation_area } \" ) return facilities def get_internal_campsite_metadata ( self , facility_ids : List [ int ]) -> pd . DataFrame : \"\"\" Retrieve Metadata About all of the underlying Campsites to Search \"\"\" all_campsites : List [ RecDotGovCampsite ] = [] for facility_id in facility_ids : all_campsites += self . paginate_recdotgov_campsites ( facility_id = facility_id ) all_campsite_df = pd . DataFrame ( [ item . dict () for item in all_campsites ], columns = RecDotGovCampsite . __fields__ , ) all_campsite_df . set_index ( \"campsite_id\" , inplace = True ) return all_campsite_df","title":"RecreationDotGov"},{"location":"reference/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.__init__","text":"Initialize with Search Dates Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 48 49 50 51 52 53 54 55 56 57 58 def __init__ ( self , api_key : str = None ): \"\"\" Initialize with Search Dates \"\"\" if api_key is None : _api_key = RIDBConfig . API_KEY if isinstance ( _api_key , bytes ): _api_key : str = b64decode ( RIDBConfig . API_KEY ) . decode ( \"utf-8\" ) else : _api_key : str = api_key self . _ridb_api_headers : dict = dict ( accept = \"application/json\" , apikey = _api_key )","title":"__init__()"},{"location":"reference/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.__repr__","text":"String Representation","title":"__repr__()"},{"location":"reference/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.__repr__--returns","text":"str Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 60 61 62 63 64 65 66 67 68 def __repr__ ( self ): \"\"\" String Representation Returns ------- str \"\"\" return \"<RecreationDotGov>\"","title":"Returns"},{"location":"reference/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.find_campgrounds","text":"Find Bookable Campgrounds Given a Set of Search Criteria","title":"find_campgrounds()"},{"location":"reference/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.find_campgrounds--parameters","text":"str Search Keyword(s) Optional[List[int]] Recreation Area ID to filter with Optional[List[int]] ID of the Campground Optional[List[int]] ID of the Campsite","title":"Parameters"},{"location":"reference/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.find_campgrounds--returns","text":"List[CampgroundFacility] Array of Matching Campsites Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def find_campgrounds ( self , search_string : str = None , rec_area_id : Optional [ List [ int ]] = None , campground_id : Optional [ List [ int ]] = None , campsite_id : Optional [ List [ int ]] = None , ** kwargs , ) -> List [ CampgroundFacility ]: \"\"\" Find Bookable Campgrounds Given a Set of Search Criteria Parameters ---------- search_string: str Search Keyword(s) rec_area_id: Optional[List[int]] Recreation Area ID to filter with campground_id: Optional[List[int]] ID of the Campground campsite_id: Optional[List[int]] ID of the Campsite Returns ------- facilities: List[CampgroundFacility] Array of Matching Campsites \"\"\" if campsite_id not in ( None , [], ()): facilities = self . _process_specific_campsites_provided ( campsite_id = campsite_id ) elif campground_id not in ( None , [], ()): facilities = self . _find_facilities_from_campgrounds ( campground_id = campground_id ) elif rec_area_id not in ( None , [], ()): facilities = list () for recreation_area in rec_area_id : facilities += self . find_facilities_per_recreation_area ( rec_area_id = recreation_area ) else : state_arg = kwargs . get ( \"state\" , None ) if state_arg is not None : kwargs . update ({ \"state\" : state_arg . upper ()}) if search_string in [ \"\" , None ] and state_arg is None : raise RuntimeError ( \"You must provide a search query or state to find campsites\" ) facilities = self . _find_facilities_from_search ( search = search_string , ** kwargs ) return facilities","title":"Returns"},{"location":"reference/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.find_facilities_per_recreation_area","text":"Find Matching Campsites Based from Recreation Area","title":"find_facilities_per_recreation_area()"},{"location":"reference/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.find_facilities_per_recreation_area--parameters","text":"int Recreation Area ID","title":"Parameters"},{"location":"reference/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.find_facilities_per_recreation_area--returns","text":"List[CampgroundFacility] Array of Matching Campsites Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 def find_facilities_per_recreation_area ( self , rec_area_id : int = None , ** kwargs ) -> List [ CampgroundFacility ]: \"\"\" Find Matching Campsites Based from Recreation Area Parameters ---------- rec_area_id: int Recreation Area ID Returns ------- campgrounds: List[CampgroundFacility] Array of Matching Campsites \"\"\" logger . info ( f \"Retrieving Facility Information for Recreation Area ID: ` { rec_area_id } `.\" ) api_path = f \" { RIDBConfig . REC_AREA_API_PATH } / { rec_area_id } / { RIDBConfig . FACILITIES_API_PATH } \" api_response = self . _ridb_get_paginate ( path = api_path , params = dict ( full = \"true\" , ** kwargs ) ) filtered_facilities = self . _filter_facilities_responses ( responses = api_response ) campgrounds = list () logger . info ( f \" { len ( filtered_facilities ) } Matching Campgrounds Found\" ) for facility in filtered_facilities : _ , campground_facility = self . process_facilities_responses ( facility = facility ) if campground_facility is not None : campgrounds . append ( campground_facility ) log_sorted_response ( response_array = campgrounds ) return campgrounds","title":"Returns"},{"location":"reference/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.find_recreation_areas","text":"Find Matching Campsites Based on Search String","title":"find_recreation_areas()"},{"location":"reference/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.find_recreation_areas--parameters","text":"str Search Keyword(s)","title":"Parameters"},{"location":"reference/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.find_recreation_areas--returns","text":"List[dict] Array of Matching Campsites Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def find_recreation_areas ( self , search_string : str = None , ** kwargs ) -> List [ dict ]: \"\"\" Find Matching Campsites Based on Search String Parameters ---------- search_string: str Search Keyword(s) Returns ------- filtered_responses: List[dict] Array of Matching Campsites \"\"\" try : assert any ( [ kwargs . get ( \"state\" , None ) is not None , search_string is not None and search_string != \"\" , ] ) except AssertionError : raise RuntimeError ( \"You must provide a search query or state(s) \" \"to find Recreation Areas\" ) logger . info ( f 'Searching for Recreation Areas: \" { search_string } \"' ) state_arg = kwargs . get ( \"state\" , None ) if state_arg is not None : kwargs . update ({ \"state\" : state_arg . upper ()}) params = dict ( query = search_string , sort = \"Name\" , full = \"true\" , ** kwargs ) if search_string is None : params . pop ( \"query\" ) api_response = self . _ridb_get_paginate ( path = RIDBConfig . REC_AREA_API_PATH , params = params ) logger . info ( f \" { len ( api_response ) } recreation areas found.\" ) logging_messages = list () for recreation_area_object in api_response : _ , recreation_area = self . _process_rec_area_response ( recreation_area = recreation_area_object ) if recreation_area is not None : logging_messages . append ( recreation_area ) log_sorted_response ( response_array = logging_messages ) return api_response","title":"Returns"},{"location":"reference/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.get_campground_ids_by_campsites","text":"Retrieve a list of FacilityIDs, and Facilities from a Campsite ID List","title":"get_campground_ids_by_campsites()"},{"location":"reference/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.get_campground_ids_by_campsites--parameters","text":"List[int] List of Campsite IDs","title":"Parameters"},{"location":"reference/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.get_campground_ids_by_campsites--returns","text":"Tuple[List[int], List[CampsiteResponse]] Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 def get_campground_ids_by_campsites ( self , campsite_ids : List [ int ] ) -> Tuple [ List [ int ], List [ CampsiteResponse ]]: \"\"\" Retrieve a list of FacilityIDs, and Facilities from a Campsite ID List Parameters ---------- campsite_ids: List[int] List of Campsite IDs Returns ------- Tuple[List[int], List[CampsiteResponse]] \"\"\" campground_ids = list () campgrounds = list () for campsite_id in campsite_ids : campsite = self . get_campsite_by_id ( campsite_id = campsite_id ) campgrounds . append ( campsite ) campground_ids . append ( campsite . FacilityID ) return list ( set ( campground_ids )), list ( campgrounds )","title":"Returns"},{"location":"reference/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.get_campsite_by_id","text":"Get a Campsite's Details","title":"get_campsite_by_id()"},{"location":"reference/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.get_campsite_by_id--parameters","text":"campsite_id: int","title":"Parameters"},{"location":"reference/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.get_campsite_by_id--returns","text":"CampsiteResponse Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 def get_campsite_by_id ( self , campsite_id : int ) -> CampsiteResponse : \"\"\" Get a Campsite's Details Parameters ---------- campsite_id: int Returns ------- CampsiteResponse \"\"\" data = self . get_ridb_data ( path = f \" { RIDBConfig . CAMPSITE_API_PATH } / { campsite_id } \" ) try : response = CampsiteResponse ( ** data [ 0 ]) except IndexError : raise ProviderSearchError ( f \"Campsite with ID # { campsite_id } not found.\" ) return response","title":"Returns"},{"location":"reference/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.get_internal_campsite_metadata","text":"Retrieve Metadata About all of the underlying Campsites to Search Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 866 867 868 869 870 871 872 873 874 875 876 877 878 def get_internal_campsite_metadata ( self , facility_ids : List [ int ]) -> pd . DataFrame : \"\"\" Retrieve Metadata About all of the underlying Campsites to Search \"\"\" all_campsites : List [ RecDotGovCampsite ] = [] for facility_id in facility_ids : all_campsites += self . paginate_recdotgov_campsites ( facility_id = facility_id ) all_campsite_df = pd . DataFrame ( [ item . dict () for item in all_campsites ], columns = RecDotGovCampsite . __fields__ , ) all_campsite_df . set_index ( \"campsite_id\" , inplace = True ) return all_campsite_df","title":"get_internal_campsite_metadata()"},{"location":"reference/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.get_recdotgov_data","text":"Find Campsite Availability Data","title":"get_recdotgov_data()"},{"location":"reference/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.get_recdotgov_data--parameters","text":"int Campground ID from the RIDB API. Can also be pulled of URLs on Recreation.gov datetime datetime object, results will be filtered to month","title":"Parameters"},{"location":"reference/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.get_recdotgov_data--returns","text":"Union[dict, list] Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 def get_recdotgov_data ( self , campground_id : int , month : datetime ) -> Union [ dict , list ]: \"\"\" Find Campsite Availability Data Parameters ---------- campground_id: int Campground ID from the RIDB API. Can also be pulled of URLs on Recreation.gov month: datetime datetime object, results will be filtered to month Returns ------- Union[dict, list] \"\"\" try : response = self . _make_recdotgov_availability_request ( campground_id = campground_id , month = month ) except tenacity . RetryError : raise RuntimeError ( \"Something went wrong in fetching data from the \" \"RecreationDotGov API.\" ) return loads ( response . content )","title":"Returns"},{"location":"reference/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.get_ridb_data","text":"Find Matching Campsites Based on Search String","title":"get_ridb_data()"},{"location":"reference/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.get_ridb_data--parameters","text":"str URL Endpoint, see https://ridb.recreation.gov/docs","title":"Parameters"},{"location":"reference/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.get_ridb_data--returns","text":"Union[dict, list] Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 @tenacity . retry ( wait = tenacity . wait_random_exponential ( multiplier = 2 , max = 10 ), stop = tenacity . stop . stop_after_delay ( 15 ), ) def get_ridb_data ( self , path : str , params : Optional [ dict ] = None ) -> Union [ dict , list ]: \"\"\" Find Matching Campsites Based on Search String Parameters ---------- path: str URL Endpoint, see https://ridb.recreation.gov/docs params: Optional[dict] API Call Parameters Returns ------- Union[dict, list] \"\"\" api_endpoint = self . _ridb_get_endpoint ( path = path ) headers = self . _ridb_api_headers . copy () headers . update ( choice ( USER_AGENTS )) response = requests . get ( url = api_endpoint , headers = headers , params = params , timeout = 30 ) try : assert response . status_code == 200 except AssertionError : error_message = ( f \"Receiving bad data from Recreation.gov API: { response . text } \" ) logger . error ( error_message ) raise ConnectionError ( error_message ) return loads ( response . content )","title":"Returns"},{"location":"reference/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.make_recdotgov_request","text":"Make a Raw Request to RecreationDotGov","title":"make_recdotgov_request()"},{"location":"reference/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.make_recdotgov_request--parameters","text":"url: str method: str","title":"Parameters"},{"location":"reference/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.make_recdotgov_request--returns","text":"requests.Response Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 @classmethod def make_recdotgov_request ( cls , url : str , method : str = \"GET\" , params : Optional [ Dict [ str , Any ]] = None , ** kwargs , ) -> requests . Response : \"\"\" Make a Raw Request to RecreationDotGov Parameters ---------- url: str method: str params: Optional[Dict[str, Any]] Returns ------- requests.Response \"\"\" # BUILD THE HEADERS EXPECTED FROM THE API headers = STANDARD_HEADERS . copy () headers . update ( choice ( USER_AGENTS )) headers . update ( RecreationBookingConfig . API_REFERRERS ) response = requests . request ( method = method , url = url , headers = headers , params = params , timeout = 30 , ** kwargs ) return response","title":"Returns"},{"location":"reference/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.make_recdotgov_request_retry","text":"Make a Raw Request to RecreationDotGov - But Handle 404","title":"make_recdotgov_request_retry()"},{"location":"reference/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.make_recdotgov_request_retry--parameters","text":"url: str method: str","title":"Parameters"},{"location":"reference/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.make_recdotgov_request_retry--returns","text":"requests.Response Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 @classmethod @tenacity . retry ( wait = tenacity . wait_random_exponential ( multiplier = 2 , max = 10 ), stop = tenacity . stop . stop_after_delay ( 15 ), ) def make_recdotgov_request_retry ( cls , url : str , method : str = \"GET\" , params : Optional [ Dict [ str , Any ]] = None , ** kwargs , ) -> requests . Response : \"\"\" Make a Raw Request to RecreationDotGov - But Handle 404 Parameters ---------- url: str method: str params: Optional[Dict[str, Any]] Returns ------- requests.Response \"\"\" response = cls . make_recdotgov_request ( url = url , method = method , params = params , ** kwargs ) response . raise_for_status () return response","title":"Returns"},{"location":"reference/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.paginate_recdotgov_campsites","text":"Paginate through the RecDotGov Campsite Metadata Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 def paginate_recdotgov_campsites ( self , facility_id : int , equipment : Optional [ List [ str ]] = None ) -> List [ RecDotGovCampsite ]: \"\"\" Paginate through the RecDotGov Campsite Metadata \"\"\" results = 0 continue_paginate = True endpoint_url = api_utils . generate_url ( scheme = RecreationBookingConfig . API_SCHEME , netloc = RecreationBookingConfig . API_NET_LOC , path = \"api/search/campsites\" , ) fq_list = [ f \"asset_id: { facility_id } \" ] if isinstance ( equipment , list ) and len ( equipment ) > 0 : for item in equipment : fq_list . append ( f \"campsite_equipment_name: { item } \" ) params = dict ( start = 0 , size = 1000 , fq = fq_list , include_non_site_specific_campsites = True , ) campsites = [] while continue_paginate is True : response = self . make_recdotgov_request_retry ( method = \"GET\" , url = endpoint_url , params = params , ) returned_data = json . loads ( response . content ) campsite_response = RecDotGovCampsiteResponse ( ** returned_data ) campsites += campsite_response . campsites results += campsite_response . size params . update ( start = results ) if results == campsite_response . total : continue_paginate = False return campsites","title":"paginate_recdotgov_campsites()"},{"location":"reference/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.process_campsite_availability","text":"Parse the JSON Response and return availabilities","title":"process_campsite_availability()"},{"location":"reference/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.process_campsite_availability--parameters","text":"dict API Response str Name of Recreation Area int ID of Recreation Area str Campground Facility Name int Campground Facility ID datetime Month to Process pd.DataFrame Metadata Fetched from the Recreation.gov API about the Campsites","title":"Parameters"},{"location":"reference/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.process_campsite_availability--returns","text":"List[Optional[AvailableCampsite]] Any monthly availabilities Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 @classmethod def process_campsite_availability ( cls , availability : dict , recreation_area : str , recreation_area_id : int , facility_name : str , facility_id : int , month : datetime , campsite_metadata : pd . DataFrame , ) -> List [ Optional [ AvailableCampsite ]]: \"\"\" Parse the JSON Response and return availabilities Parameters ---------- availability: dict API Response recreation_area: str Name of Recreation Area recreation_area_id: int ID of Recreation Area facility_name: str Campground Facility Name facility_id: int Campground Facility ID month: datetime Month to Process campsite_metadata: pd.DataFrame Metadata Fetched from the Recreation.gov API about the Campsites Returns ------- total_campsite_availability: List[Optional[AvailableCampsite]] Any monthly availabilities \"\"\" total_campsite_availability : List [ Optional [ AvailableCampsite ]] = list () campsite_data = CampsiteAvailabilityResponse ( ** availability ) for campsite_id , site_related_data in campsite_data . campsites . items (): for ( matching_date , availability_status , ) in site_related_data . availabilities . items (): if ( availability_status not in RecreationBookingConfig . CAMPSITE_UNAVAILABLE_STRINGS ): booking_url = ( f \" { RecreationBookingConfig . CAMPSITE_BOOKING_URL } / { campsite_id } \" ) equipment , attributes = cls . _get_equipment_and_attributes ( campsite_id = campsite_id , campsite_metadata = campsite_metadata ) available_campsite = AvailableCampsite ( campsite_id = campsite_id , booking_date = matching_date , booking_end_date = matching_date + timedelta ( days = 1 ), booking_nights = 1 , campsite_site_name = site_related_data . site , campsite_loop_name = site_related_data . loop , campsite_type = site_related_data . campsite_type , campsite_occupancy = ( site_related_data . min_num_people , site_related_data . max_num_people , ), campsite_use_type = site_related_data . type_of_use , availability_status = availability_status , recreation_area = recreation_area , recreation_area_id = recreation_area_id , facility_name = facility_name , facility_id = facility_id , booking_url = booking_url , permitted_equipment = equipment , campsite_attributes = attributes , ) total_campsite_availability . append ( available_campsite ) logger . info ( f \" \\t { logging_utils . get_emoji ( total_campsite_availability ) } \\t \" f \" { len ( total_campsite_availability ) } total sites found in month of \" f \" { month . strftime ( '%B' ) } \" ) return total_campsite_availability","title":"Returns"},{"location":"reference/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.process_facilities_responses","text":"Process Facilities Responses to be More Usable","title":"process_facilities_responses()"},{"location":"reference/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.process_facilities_responses--parameters","text":"facility: dict","title":"Parameters"},{"location":"reference/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.process_facilities_responses--returns","text":"Tuple[dict, CampgroundFacility] Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 @classmethod def process_facilities_responses ( cls , facility : dict ) -> Tuple [ dict , Optional [ CampgroundFacility ]]: \"\"\" Process Facilities Responses to be More Usable Parameters ---------- facility: dict Returns ------- Tuple[dict, CampgroundFacility] \"\"\" facility_object = FacilityResponse ( ** facility ) try : facility_state = facility_object . FACILITYADDRESS [ 0 ] . AddressStateCode . upper () except ( KeyError , IndexError ): facility_state = \"USA\" try : if len ( facility_object . RECAREA ) == 0 : recreation_area_id = facility_object . ParentRecAreaID formatted_recreation_area = ( f \" { facility_object . ORGANIZATION [ 0 ] . OrgName } , { facility_state } \" ) else : recreation_area = facility_object . RECAREA [ 0 ] . RecAreaName recreation_area_id = facility_object . RECAREA [ 0 ] . RecAreaID formatted_recreation_area = f \" { recreation_area } , { facility_state } \" campground_facility = CampgroundFacility ( facility_name = facility_object . FacilityName . title (), recreation_area = formatted_recreation_area , facility_id = facility_object . FacilityID , recreation_area_id = recreation_area_id , ) return facility , campground_facility except ( KeyError , IndexError ): return facility , None","title":"Returns"},{"location":"reference/#camply.SearchRecreationDotGov","text":"Bases: BaseCampingSearch Camping Search Object Source code in camply/search/search_recreationdotgov.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 class SearchRecreationDotGov ( BaseCampingSearch ): \"\"\" Camping Search Object \"\"\" def __init__ ( self , search_window : Union [ SearchWindow , List [ SearchWindow ]], recreation_area : Optional [ Union [ List [ int ], int ]] = None , campgrounds : Optional [ Union [ List [ int ], int ]] = None , campsites : Optional [ Union [ List [ int ], int ]] = None , weekends_only : bool = False , nights : int = 1 , equipment : Optional [ List [ Tuple [ str , Optional [ int ]]]] = None , offline_search : bool = False , offline_search_path : Optional [ str ] = None , ** kwargs , ) -> None : \"\"\" Initialize with Search Parameters Parameters ---------- search_window: Union[SearchWindow, List[SearchWindow]] Search Window tuple containing start date and End Date recreation_area: Optional[Union[List[int], int]] ID of Recreation Area (i.e. 2907 - Rocky Mountain National Park) campgrounds: Optional[Union[List[int], int]] Campground ID or List of Campground IDs campsites: Optional[Union[List[int], int]] Campsite ID or List of Campsite IDs weekends_only: bool Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights) nights: int minimum number of consecutive nights to search per campsite,defaults to 1 equipment: Optional[List[Tuple[str, Optional[int]]]] List of Tuples of Equipment to Search for. An equipment tuple array looks like this: `[(\"Tent\", None), (\"RV\", 20)]` - meaning the selected search looks for sites to accommodate any tent size and RVs less than or equal to 20 feet. Tuples contain the Equipment name and an optional equipment length, otherwise provide None. Equipment names include `Tent`, `RV`, `Trailer`, `Vehicle` and are not case-sensitive. offline_search: bool When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. offline_search_path: Optional[str] When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to `camply_campsites.json` \"\"\" self . campsite_finder : RecreationDotGov super ( SearchRecreationDotGov , self ) . __init__ ( provider = RecreationDotGov (), search_window = search_window , weekends_only = weekends_only , nights = nights , offline_search = offline_search , offline_search_path = offline_search_path , ) self . _recreation_area_id = make_list ( recreation_area ) self . _campground_object = campgrounds self . weekends_only = weekends_only assert ( any ( [ campsites not in [[], None ], campgrounds not in [[], None ], recreation_area is not None , ] ) is True ) self . campsites = make_list ( campsites ) self . campgrounds = self . _get_searchable_campgrounds () self . campsite_metadata : Optional [ pd . DataFrame ] = None self . equipment : List [ Tuple [ str , Optional [ int ]]] = [] self . equipment = self . _get_searchable_equipment ( equipment = equipment ) def _get_searchable_campgrounds ( self ) -> List [ CampgroundFacility ]: \"\"\" Return a List of Campgrounds to search This handles scenarios where a recreation area is provided instead of a campground list Returns ------- searchable_campgrounds: List[int] List of searchable campground IDs \"\"\" if self . campsites not in [(), [], None ]: self . campsites = [ int ( campsite_id ) for campsite_id in self . campsites ] searchable_campgrounds = self . _get_campgrounds_by_campsite_id () elif self . _campground_object not in [(), [], None ]: searchable_campgrounds = self . _get_campgrounds_by_campground_id () elif self . _recreation_area_id not in [(), [], None ]: searchable_campgrounds = self . _get_campgrounds_by_recreation_area_id () else : raise RuntimeError ( \"You must provide a Campground or Recreation Area ID\" ) return list ( set ( searchable_campgrounds )) @classmethod def _get_searchable_equipment ( cls , equipment : Optional [ List [ Tuple [ str , Optional [ int ]]]] ) -> Optional [ List [ Tuple [ str , Optional [ int ]]]]: \"\"\" Sort through and validate Equipment Parameters ---------- equipment: Optional[List[Tuple[str, Optional[int]]]] Returns ------- Optional[List[Tuple[str, Optional[int]]]] \"\"\" equipment_names = [] final_equipment = None if isinstance ( equipment , ( list , tuple )): final_equipment = [] for equipment_name , equipment_length in equipment : if ( equipment_name . lower () not in EquipmentOptions . __all_accepted_equipment__ ): logger . warning ( f \"Equipment name not recognized: { equipment_name } . This won't \" \"be used for filtering.\" \"Acceptable options are: \" f \" { ', ' . join ( EquipmentOptions . __all_accepted_equipment__ ) } \" ) else : final_equipment . append (( equipment_name , equipment_length )) equipment_names . append ( equipment_name ) if len ( final_equipment ) > 0 : logger . info ( f \"Filtering Campsites based on Equipment: { ' | ' . join ( equipment_names ) } \" ) return final_equipment def _get_campgrounds_by_campground_id ( self ) -> List [ CampgroundFacility ]: \"\"\" Return a List of Campgrounds to search when provided with campground IDs Returns ------- returned_sites: List[int] List of searchable campground IDs \"\"\" campground_list = make_list ( self . _campground_object ) facilities = self . campsite_finder . find_campgrounds ( campground_id = campground_list ) return facilities def _get_campgrounds_by_campsite_id ( self ) -> List [ CampgroundFacility ]: \"\"\" Return a List of Campgrounds to search when provided with Campsite IDs Returns ------- returned_sites: List[int] List of searchable campground IDs \"\"\" campsite_list = make_list ( self . campsites ) facilities = self . campsite_finder . find_campgrounds ( campsite_id = campsite_list ) return facilities def _get_campgrounds_by_recreation_area_id ( self ) -> List [ CampgroundFacility ]: \"\"\" Return a List of Campgrounds to search when provided with Recreation Area IDs Returns ------- campgrounds: List[CampgroundFacility] \"\"\" campgrounds = list () for rec_area in self . _recreation_area_id : campground_array = self . campsite_finder . find_facilities_per_recreation_area ( rec_area_id = rec_area ) campgrounds += campground_array return campgrounds def get_all_campsites ( self ) -> List [ AvailableCampsite ]: \"\"\" Perform the Search and Return All Monthly Availabilities Returns ------- List[AvailableCampsite] \"\"\" found_campsites = list () if len ( self . campgrounds ) == 0 : error_message = \"No campgrounds found to search\" logger . error ( error_message ) raise SearchError ( error_message ) logger . info ( f \"Searching across { len ( self . campgrounds ) } campgrounds\" ) if self . campsite_metadata is None : self . campsite_metadata = ( self . campsite_finder . get_internal_campsite_metadata ( facility_ids = [ facil . facility_id for facil in self . campgrounds ] ) ) logger . info ( \"Metadata fetched for %s campsites\" , len ( self . campsite_metadata ) ) for index , campground in enumerate ( self . campgrounds ): for month in self . search_months : logger . info ( f \"Searching { campground . facility_name } , { campground . recreation_area } \" f \"( { campground . facility_id } ) for availability: \" f \" { month . strftime ( '%B, %Y' ) } \" ) availabilities = self . campsite_finder . get_recdotgov_data ( campground_id = campground . facility_id , month = month ) campsites = self . campsite_finder . process_campsite_availability ( availability = availabilities , recreation_area = campground . recreation_area , recreation_area_id = campground . recreation_area_id , facility_name = campground . facility_name , facility_id = campground . facility_id , month = month , campsite_metadata = self . campsite_metadata , ) if self . campsites not in [ None , []]: campsites = [ campsite_obj for campsite_obj in campsites if int ( campsite_obj . campsite_id ) in self . campsites ] found_campsites += campsites if index + 1 < len ( self . campgrounds ): sleep ( round ( uniform ( * RecreationBookingConfig . RATE_LIMITING ), 2 )) campsite_df = self . campsites_to_df ( campsites = found_campsites ) campsite_df_validated = self . _filter_date_overlap ( campsites = campsite_df ) compiled_campsite_df = self . _consolidate_campsites ( campsite_df = campsite_df_validated , nights = self . nights ) equipment_filtered_campsites = self . filter_campsites_to_equipment ( campsites = compiled_campsite_df ) compiled_campsites = self . df_to_campsites ( campsite_df = equipment_filtered_campsites ) return compiled_campsites def filter_campsites_to_equipment ( self , campsites : pd . DataFrame ) -> pd . DataFrame : \"\"\" Filter a Campsite DataFrame down to specified equipment Parameters ---------- campsites: pd.DataFrame Returns ------- pd.DataFrame \"\"\" if self . equipment is None or len ( self . equipment ) == 0 or len ( campsites ) == 0 : return campsites column_names = [ \"campsite_id\" , \"permitted_equipment\" ] exploded_data = campsites [ column_names ] . explode ( \"permitted_equipment\" ) expanded_data = exploded_data [ \"permitted_equipment\" ] . apply ( pd . Series ) joined_data = pd . DataFrame ( pd . concat ([ exploded_data , expanded_data ], axis = 1 ), columns = column_names + [ \"equipment_name\" , \"max_length\" ], ) joined_data [ \"equipment_name_normalized\" ] = ( joined_data [ \"equipment_name\" ] . fillna ( \"\" ) . apply ( lambda x : EquipmentConfig . EQUIPMENT_REVERSE_MAPPING [ x ]) ) equipment_types = [ item [ 0 ] . lower () for item in self . equipment ] matching_equipment = joined_data [ joined_data [ \"equipment_name_normalized\" ] . isin ( equipment_types ) ] matching_ids = [] for equipment_name , equipment_length in self . equipment : matching_data = matching_equipment [ matching_equipment [ \"equipment_name_normalized\" ] == equipment_name . lower () ] . copy () if equipment_length is not None : matching_data = matching_data [ matching_data [ \"max_length\" ] >= float ( equipment_length ) ] matching_ids += list ( matching_data [ \"campsite_id\" ] . unique ()) original_campsites = campsites [ campsites [ \"campsite_id\" ] . isin ( matching_ids ) ] . copy () return original_campsites","title":"SearchRecreationDotGov"},{"location":"reference/#camply.search.search_recreationdotgov.SearchRecreationDotGov.__init__","text":"Initialize with Search Parameters","title":"__init__()"},{"location":"reference/#camply.search.search_recreationdotgov.SearchRecreationDotGov.__init__--parameters","text":"Union[SearchWindow, List[SearchWindow]] Search Window tuple containing start date and End Date Optional[Union[List[int], int]] ID of Recreation Area (i.e. 2907 - Rocky Mountain National Park) Optional[Union[List[int], int]] Campground ID or List of Campground IDs Optional[Union[List[int], int]] Campsite ID or List of Campsite IDs bool Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights) int minimum number of consecutive nights to search per campsite,defaults to 1 Optional[List[Tuple[str, Optional[int]]]] List of Tuples of Equipment to Search for. An equipment tuple array looks like this: [(\"Tent\", None), (\"RV\", 20)] - meaning the selected search looks for sites to accommodate any tent size and RVs less than or equal to 20 feet. Tuples contain the Equipment name and an optional equipment length, otherwise provide None. Equipment names include Tent , RV , Trailer , Vehicle and are not case-sensitive. bool When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. Optional[str] When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to camply_campsites.json Source code in camply/search/search_recreationdotgov.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def __init__ ( self , search_window : Union [ SearchWindow , List [ SearchWindow ]], recreation_area : Optional [ Union [ List [ int ], int ]] = None , campgrounds : Optional [ Union [ List [ int ], int ]] = None , campsites : Optional [ Union [ List [ int ], int ]] = None , weekends_only : bool = False , nights : int = 1 , equipment : Optional [ List [ Tuple [ str , Optional [ int ]]]] = None , offline_search : bool = False , offline_search_path : Optional [ str ] = None , ** kwargs , ) -> None : \"\"\" Initialize with Search Parameters Parameters ---------- search_window: Union[SearchWindow, List[SearchWindow]] Search Window tuple containing start date and End Date recreation_area: Optional[Union[List[int], int]] ID of Recreation Area (i.e. 2907 - Rocky Mountain National Park) campgrounds: Optional[Union[List[int], int]] Campground ID or List of Campground IDs campsites: Optional[Union[List[int], int]] Campsite ID or List of Campsite IDs weekends_only: bool Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights) nights: int minimum number of consecutive nights to search per campsite,defaults to 1 equipment: Optional[List[Tuple[str, Optional[int]]]] List of Tuples of Equipment to Search for. An equipment tuple array looks like this: `[(\"Tent\", None), (\"RV\", 20)]` - meaning the selected search looks for sites to accommodate any tent size and RVs less than or equal to 20 feet. Tuples contain the Equipment name and an optional equipment length, otherwise provide None. Equipment names include `Tent`, `RV`, `Trailer`, `Vehicle` and are not case-sensitive. offline_search: bool When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. offline_search_path: Optional[str] When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to `camply_campsites.json` \"\"\" self . campsite_finder : RecreationDotGov super ( SearchRecreationDotGov , self ) . __init__ ( provider = RecreationDotGov (), search_window = search_window , weekends_only = weekends_only , nights = nights , offline_search = offline_search , offline_search_path = offline_search_path , ) self . _recreation_area_id = make_list ( recreation_area ) self . _campground_object = campgrounds self . weekends_only = weekends_only assert ( any ( [ campsites not in [[], None ], campgrounds not in [[], None ], recreation_area is not None , ] ) is True ) self . campsites = make_list ( campsites ) self . campgrounds = self . _get_searchable_campgrounds () self . campsite_metadata : Optional [ pd . DataFrame ] = None self . equipment : List [ Tuple [ str , Optional [ int ]]] = [] self . equipment = self . _get_searchable_equipment ( equipment = equipment )","title":"Parameters"},{"location":"reference/#camply.search.search_recreationdotgov.SearchRecreationDotGov.filter_campsites_to_equipment","text":"Filter a Campsite DataFrame down to specified equipment","title":"filter_campsites_to_equipment()"},{"location":"reference/#camply.search.search_recreationdotgov.SearchRecreationDotGov.filter_campsites_to_equipment--parameters","text":"campsites: pd.DataFrame","title":"Parameters"},{"location":"reference/#camply.search.search_recreationdotgov.SearchRecreationDotGov.filter_campsites_to_equipment--returns","text":"pd.DataFrame Source code in camply/search/search_recreationdotgov.py 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 def filter_campsites_to_equipment ( self , campsites : pd . DataFrame ) -> pd . DataFrame : \"\"\" Filter a Campsite DataFrame down to specified equipment Parameters ---------- campsites: pd.DataFrame Returns ------- pd.DataFrame \"\"\" if self . equipment is None or len ( self . equipment ) == 0 or len ( campsites ) == 0 : return campsites column_names = [ \"campsite_id\" , \"permitted_equipment\" ] exploded_data = campsites [ column_names ] . explode ( \"permitted_equipment\" ) expanded_data = exploded_data [ \"permitted_equipment\" ] . apply ( pd . Series ) joined_data = pd . DataFrame ( pd . concat ([ exploded_data , expanded_data ], axis = 1 ), columns = column_names + [ \"equipment_name\" , \"max_length\" ], ) joined_data [ \"equipment_name_normalized\" ] = ( joined_data [ \"equipment_name\" ] . fillna ( \"\" ) . apply ( lambda x : EquipmentConfig . EQUIPMENT_REVERSE_MAPPING [ x ]) ) equipment_types = [ item [ 0 ] . lower () for item in self . equipment ] matching_equipment = joined_data [ joined_data [ \"equipment_name_normalized\" ] . isin ( equipment_types ) ] matching_ids = [] for equipment_name , equipment_length in self . equipment : matching_data = matching_equipment [ matching_equipment [ \"equipment_name_normalized\" ] == equipment_name . lower () ] . copy () if equipment_length is not None : matching_data = matching_data [ matching_data [ \"max_length\" ] >= float ( equipment_length ) ] matching_ids += list ( matching_data [ \"campsite_id\" ] . unique ()) original_campsites = campsites [ campsites [ \"campsite_id\" ] . isin ( matching_ids ) ] . copy () return original_campsites","title":"Returns"},{"location":"reference/#camply.search.search_recreationdotgov.SearchRecreationDotGov.get_all_campsites","text":"Perform the Search and Return All Monthly Availabilities","title":"get_all_campsites()"},{"location":"reference/#camply.search.search_recreationdotgov.SearchRecreationDotGov.get_all_campsites--returns","text":"List[AvailableCampsite] Source code in camply/search/search_recreationdotgov.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 def get_all_campsites ( self ) -> List [ AvailableCampsite ]: \"\"\" Perform the Search and Return All Monthly Availabilities Returns ------- List[AvailableCampsite] \"\"\" found_campsites = list () if len ( self . campgrounds ) == 0 : error_message = \"No campgrounds found to search\" logger . error ( error_message ) raise SearchError ( error_message ) logger . info ( f \"Searching across { len ( self . campgrounds ) } campgrounds\" ) if self . campsite_metadata is None : self . campsite_metadata = ( self . campsite_finder . get_internal_campsite_metadata ( facility_ids = [ facil . facility_id for facil in self . campgrounds ] ) ) logger . info ( \"Metadata fetched for %s campsites\" , len ( self . campsite_metadata ) ) for index , campground in enumerate ( self . campgrounds ): for month in self . search_months : logger . info ( f \"Searching { campground . facility_name } , { campground . recreation_area } \" f \"( { campground . facility_id } ) for availability: \" f \" { month . strftime ( '%B, %Y' ) } \" ) availabilities = self . campsite_finder . get_recdotgov_data ( campground_id = campground . facility_id , month = month ) campsites = self . campsite_finder . process_campsite_availability ( availability = availabilities , recreation_area = campground . recreation_area , recreation_area_id = campground . recreation_area_id , facility_name = campground . facility_name , facility_id = campground . facility_id , month = month , campsite_metadata = self . campsite_metadata , ) if self . campsites not in [ None , []]: campsites = [ campsite_obj for campsite_obj in campsites if int ( campsite_obj . campsite_id ) in self . campsites ] found_campsites += campsites if index + 1 < len ( self . campgrounds ): sleep ( round ( uniform ( * RecreationBookingConfig . RATE_LIMITING ), 2 )) campsite_df = self . campsites_to_df ( campsites = found_campsites ) campsite_df_validated = self . _filter_date_overlap ( campsites = campsite_df ) compiled_campsite_df = self . _consolidate_campsites ( campsite_df = campsite_df_validated , nights = self . nights ) equipment_filtered_campsites = self . filter_campsites_to_equipment ( campsites = compiled_campsite_df ) compiled_campsites = self . df_to_campsites ( campsite_df = equipment_filtered_campsites ) return compiled_campsites","title":"Returns"},{"location":"reference/#camply.SearchWindow","text":"Bases: CamplyModel Search Window for Campsite Search Source code in camply/containers/data_containers.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class SearchWindow ( CamplyModel ): \"\"\" Search Window for Campsite Search \"\"\" start_date : datetime . date end_date : datetime . date def get_date_range ( self ) -> List [ datetime . date ]: \"\"\" Generate a List of Dates Between two Dates Returns ------- List[datetime.date] \"\"\" return [ self . start_date + datetime . timedelta ( days = x ) for x in range (( self . end_date - self . start_date ) . days ) ]","title":"SearchWindow"},{"location":"reference/#camply.containers.data_containers.SearchWindow.get_date_range","text":"Generate a List of Dates Between two Dates","title":"get_date_range()"},{"location":"reference/#camply.containers.data_containers.SearchWindow.get_date_range--returns","text":"List[datetime.date] Source code in camply/containers/data_containers.py 26 27 28 29 30 31 32 33 34 35 36 37 def get_date_range ( self ) -> List [ datetime . date ]: \"\"\" Generate a List of Dates Between two Dates Returns ------- List[datetime.date] \"\"\" return [ self . start_date + datetime . timedelta ( days = x ) for x in range (( self . end_date - self . start_date ) . days ) ]","title":"Returns"},{"location":"reference/#camply.SearchYellowstone","text":"Bases: BaseCampingSearch Camping Search Object Source code in camply/search/search_yellowstone.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 class SearchYellowstone ( BaseCampingSearch ): \"\"\" Camping Search Object \"\"\" # noinspection PyUnusedLocal def __init__ ( self , search_window : Union [ SearchWindow , List [ SearchWindow ]], weekends_only : bool = False , campgrounds : Optional [ Union [ List [ str ], str ]] = None , nights : int = 1 , offline_search : bool = False , offline_search_path : Optional [ str ] = None , ** kwargs , ) -> None : \"\"\" Initialize with Search Parameters Parameters ---------- search_window: Union[SearchWindow, List[SearchWindow]] Search Window tuple containing start date and End Date weekends_only: bool Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights) campgrounds: Optional[Union[List[str], str]] Campground ID or List of Campground IDs nights: int minimum number of consecutive nights to search per campsite,defaults to 1 offline_search: bool When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. offline_search_path: Optional[str] When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to `camply_campsites.json` \"\"\" super () . __init__ ( provider = YellowstoneLodging (), search_window = search_window , weekends_only = weekends_only , nights = nights , offline_search = offline_search , offline_search_path = offline_search_path , ) self . campgrounds = make_list ( campgrounds ) def get_all_campsites ( self ) -> List [ AvailableCampsite ]: \"\"\" Search for all matching campsites in Yellowstone. Returns ------- List[AvailableCampsite] \"\"\" all_campsites = list () searchable_campgrounds = self . _get_searchable_campgrounds () this_month = datetime . now () . date () . replace ( day = 1 ) for month in self . search_months : if month >= this_month : all_campsites += self . campsite_finder . get_monthly_campsites ( month = month , nights = None if self . nights == 1 else self . nights ) matching_campsites = self . _filter_campsites_to_campgrounds ( campsites = all_campsites , searchable_campgrounds = searchable_campgrounds ) campsite_df = self . campsites_to_df ( campsites = matching_campsites ) campsite_df_validated = self . _filter_date_overlap ( campsites = campsite_df ) time_window_end = max ( self . search_days ) + timedelta ( days = 1 ) compiled_campsite_df = campsite_df_validated [ campsite_df_validated . booking_end_date <= pd . Timestamp ( time_window_end ) ] compiled_campsites = self . df_to_campsites ( campsite_df = compiled_campsite_df ) return compiled_campsites def _get_searchable_campgrounds ( self ) -> Optional [ Set [ str ]]: \"\"\" Return the Campgrounds for the Camping Search Returns ------- Optional[Set[str]] \"\"\" if self . campgrounds in [ None , []]: return None supported_campsites = set ( YellowstoneConfig . YELLOWSTONE_CAMPGROUNDS . keys ()) selected_campsites = set ( self . campgrounds ) searchable_campgrounds = supported_campsites . intersection ( selected_campsites ) if len ( searchable_campgrounds ) == 0 : campground_ids = [ f \"` { key } ` ( { value } )\" for key , value in YellowstoneConfig . YELLOWSTONE_CAMPGROUNDS . items () ] error_message = ( \"You must supply a YellowstoneNationalParkLodges supported \" \"campground ID. Current supported Campground IDs: \" f \" { ', ' . join ( campground_ids ) } \" ) logger . error ( error_message ) raise SearchError ( error_message ) logger . info ( f \" { len ( searchable_campgrounds ) } Matching Campgrounds Found\" ) for campground in searchable_campgrounds : logger . info ( f \"\u26f0 { YellowstoneConfig . YELLOWSTONE_RECREATION_AREA_FORMAL_NAME } \" f \"(# { YellowstoneConfig . YELLOWSTONE_RECREATION_AREA_ID } ) - \ud83c\udfd5 \" f \" { YellowstoneConfig . YELLOWSTONE_CAMPGROUNDS [ campground ] } ( { campground } )\" ) return searchable_campgrounds def _filter_campsites_to_campgrounds ( self , campsites : List [ AvailableCampsite ], searchable_campgrounds : Set [ str ] ) -> List [ AvailableCampsite ]: \"\"\" Filter Campsites Down to Matching Campgrounds Parameters ---------- campsites: List[AvailableCampsite] searchable_campgrounds: Set[str] Returns ------- List[AvailableCampsite] \"\"\" if self . campgrounds in [ None , []]: return campsites matching_campsites = [ campsite for campsite in campsites if campsite . facility_id in searchable_campgrounds ] return matching_campsites @staticmethod def print_campgrounds () -> None : \"\"\" Print the Campgrounds inside of Yellowstone \"\"\" log_sorted_response ( YellowstoneConfig . YELLOWSTONE_CAMPGROUND_OBJECTS )","title":"SearchYellowstone"},{"location":"reference/#camply.search.search_yellowstone.SearchYellowstone.__init__","text":"Initialize with Search Parameters","title":"__init__()"},{"location":"reference/#camply.search.search_yellowstone.SearchYellowstone.__init__--parameters","text":"Union[SearchWindow, List[SearchWindow]] Search Window tuple containing start date and End Date bool Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights) Optional[Union[List[str], str]] Campground ID or List of Campground IDs int minimum number of consecutive nights to search per campsite,defaults to 1 bool When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. Optional[str] When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to camply_campsites.json Source code in camply/search/search_yellowstone.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def __init__ ( self , search_window : Union [ SearchWindow , List [ SearchWindow ]], weekends_only : bool = False , campgrounds : Optional [ Union [ List [ str ], str ]] = None , nights : int = 1 , offline_search : bool = False , offline_search_path : Optional [ str ] = None , ** kwargs , ) -> None : \"\"\" Initialize with Search Parameters Parameters ---------- search_window: Union[SearchWindow, List[SearchWindow]] Search Window tuple containing start date and End Date weekends_only: bool Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights) campgrounds: Optional[Union[List[str], str]] Campground ID or List of Campground IDs nights: int minimum number of consecutive nights to search per campsite,defaults to 1 offline_search: bool When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. offline_search_path: Optional[str] When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to `camply_campsites.json` \"\"\" super () . __init__ ( provider = YellowstoneLodging (), search_window = search_window , weekends_only = weekends_only , nights = nights , offline_search = offline_search , offline_search_path = offline_search_path , ) self . campgrounds = make_list ( campgrounds )","title":"Parameters"},{"location":"reference/#camply.search.search_yellowstone.SearchYellowstone.get_all_campsites","text":"Search for all matching campsites in Yellowstone.","title":"get_all_campsites()"},{"location":"reference/#camply.search.search_yellowstone.SearchYellowstone.get_all_campsites--returns","text":"List[AvailableCampsite] Source code in camply/search/search_yellowstone.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def get_all_campsites ( self ) -> List [ AvailableCampsite ]: \"\"\" Search for all matching campsites in Yellowstone. Returns ------- List[AvailableCampsite] \"\"\" all_campsites = list () searchable_campgrounds = self . _get_searchable_campgrounds () this_month = datetime . now () . date () . replace ( day = 1 ) for month in self . search_months : if month >= this_month : all_campsites += self . campsite_finder . get_monthly_campsites ( month = month , nights = None if self . nights == 1 else self . nights ) matching_campsites = self . _filter_campsites_to_campgrounds ( campsites = all_campsites , searchable_campgrounds = searchable_campgrounds ) campsite_df = self . campsites_to_df ( campsites = matching_campsites ) campsite_df_validated = self . _filter_date_overlap ( campsites = campsite_df ) time_window_end = max ( self . search_days ) + timedelta ( days = 1 ) compiled_campsite_df = campsite_df_validated [ campsite_df_validated . booking_end_date <= pd . Timestamp ( time_window_end ) ] compiled_campsites = self . df_to_campsites ( campsite_df = compiled_campsite_df ) return compiled_campsites","title":"Returns"},{"location":"reference/#camply.search.search_yellowstone.SearchYellowstone.print_campgrounds","text":"Print the Campgrounds inside of Yellowstone Source code in camply/search/search_yellowstone.py 155 156 157 158 159 160 @staticmethod def print_campgrounds () -> None : \"\"\" Print the Campgrounds inside of Yellowstone \"\"\" log_sorted_response ( YellowstoneConfig . YELLOWSTONE_CAMPGROUND_OBJECTS )","title":"print_campgrounds()"},{"location":"reference/#camply.YellowstoneLodging","text":"Bases: BaseProvider Scanner for Lodging in Yellowstone Source code in camply/providers/xanterra/yellowstone_lodging.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 class YellowstoneLodging ( BaseProvider ): \"\"\" Scanner for Lodging in Yellowstone \"\"\" def __repr__ ( self ): \"\"\" String Representation Returns ------- str \"\"\" return \"<YellowstoneLodging>\" def _get_monthly_availability ( self , month : datetime , nights : int = None ) -> dict : \"\"\" Check All Lodging in Yellowstone for Campground Data Returns ------- data_availability: dict Data Availability Dictionary \"\"\" query_dict = dict ( date = self . _ensure_current_month ( month = month ), limit = 31 , rate_code = YellowstoneConfig . RATE_CODE , ) if nights is not None : query_dict . update ( dict ( nights = nights )) api_endpoint = self . _get_api_endpoint ( url_path = YellowstoneConfig . YELLOWSTONE_LODGING_PATH , query = None ) logger . info ( f \"Searching for Yellowstone Lodging Availability: { month . strftime ( '%B, %Y' ) } \" ) all_resort_availability_data = self . make_yellowstone_request ( endpoint = api_endpoint , params = query_dict ) return all_resort_availability_data @staticmethod @tenacity . retry ( wait = tenacity . wait_random_exponential ( multiplier = 3 , max = 1800 ), stop = tenacity . stop . stop_after_delay ( 6000 ), ) def _try_retry_get_data ( endpoint : str , params : Optional [ dict ] = None ) -> dict : \"\"\" Try and Retry Fetching Data from the Yellowstone API. Unfortunately this is a required method to request the data since the Yellowstone API doesn't always return data. Parameters ---------- endpoint: str API Endpoint params Returns ------- dict \"\"\" yellowstone_headers = choice ( USER_AGENTS ) yellowstone_headers . update ( STANDARD_HEADERS ) yellowstone_headers . update ( YellowstoneConfig . API_REFERRERS ) response = requests . get ( url = endpoint , headers = yellowstone_headers , params = params , timeout = 30 ) if response . status_code == 200 and response . text . strip () != \"\" : return loads ( response . content ) else : error_message = ( \"Something went wrong with checking the \" \"Yellowstone Booking API. Will continue retrying.\" ) logger . warning ( error_message ) raise RuntimeError ( error_message ) @staticmethod def make_yellowstone_request ( endpoint : str , params : Optional [ dict ] = None ) -> dict : \"\"\" Try and Retry Fetching Data from the Yellowstone API. Unfortunately this is a required method to request the data since the Yellowstone API doesn't always return data. Parameters ---------- endpoint: str API Endpoint params Returns ------- dict \"\"\" try : content = YellowstoneLodging . _try_retry_get_data ( endpoint = endpoint , params = params ) except RuntimeError as re : raise RuntimeError ( f \"error_message: { re } \" ) return content @classmethod def _get_api_endpoint ( cls , url_path : str , query : Optional [ dict ] = None ) -> str : \"\"\" Build the API Endpoint for All Yellowstone Lodging \"\"\" if query is not None : query_string = parse . urlencode ( query = query ) else : query_string = \"\" url_components = dict ( scheme = YellowstoneConfig . API_SCHEME , netloc = YellowstoneConfig . API_BASE_ENDPOINT , url = url_path , params = \"\" , query = query_string , fragment = \"\" , ) api_endpoint = parse . urlunparse ( tuple ( url_components . values ())) return api_endpoint @classmethod def _return_lodging_url ( cls , lodging_code : str , month : datetime , params : Optional [ dict ] = \"\" ) -> str : \"\"\" Return a Browser Loadable URL to book from Parameters ---------- lodging_code: str Lodging Code from API month: datetime Month to return bookings filtered to params: Optional[dict] Optional URL Parameters Returns ------- str URL String \"\"\" query = dict ( dateFrom = month . strftime ( \"%m- %d -%Y\" ), adults = 1 , destination = lodging_code , children = 0 , ) if params is not None : query . update ( params ) query_string = parse . urlencode ( query = query ) url_components = dict ( scheme = YellowstoneConfig . API_SCHEME , netloc = YellowstoneConfig . WEBUI_BASE_ENDPOINT , url = YellowstoneConfig . WEBUI_BOOKING_PATH , params = \"\" , query = query_string , fragment = \"\" , ) webui_endpoint = parse . urlunparse ( tuple ( url_components . values ())) return webui_endpoint @classmethod def _compile_campground_availabilities ( cls , availability : XantResortData ) -> List [ dict ]: \"\"\" Gather Data about campground availabilities within a JSON Availability Objet Parameters ---------- availability: ResortData JSON Availability Object Returns ------- available_campsites: List[dict] List of Availabilities as JSON \"\"\" available_campsites = list () for booking_date , daily_data in availability . availability . items (): camping_keys = [ key for key in daily_data . keys () if YellowstoneConfig . LODGING_CAMPGROUND_QUALIFIER in key ] for hotel_code in camping_keys : hotel_data = daily_data [ hotel_code ] try : hotel_title = hotel_data . rates [ YellowstoneConfig . RATE_CODE ] . title hotel_rate_mins = hotel_data . rates [ YellowstoneConfig . RATE_CODE ] . mins if hotel_rate_mins != { 1 : 0 }: min_capacity = min ( hotel_rate_mins . keys ()) max_capacity = max ( hotel_rate_mins . keys ()) capacity = ( min_capacity , max_capacity ) campsite = dict ( campsite_id = None , booking_date = booking_date , campsite_occupancy = capacity , recreation_area = YellowstoneConfig . YELLOWSTONE_RECREATION_AREA_NAME , recreation_area_id = YellowstoneConfig . YELLOWSTONE_RECREATION_AREA_ID , facility_name = hotel_title . replace ( * YellowstoneConfig . YELLOWSTONE_CAMPGROUND_NAME_REPLACE ), facility_id = hotel_code , ) available_campsites . append ( campsite ) except KeyError : pass logger . info ( f \" \\t { logging_utils . get_emoji ( available_campsites ) } \\t \" f \" { len ( available_campsites ) } sites found.\" ) return available_campsites def _gather_campsite_specific_availability ( self , available_campsites : List [ dict ], month : datetime , nights : Optional [ int ] = None , ) -> List [ dict ]: \"\"\" Get campsite extra information Given a DataFrame of campsite availability, return updated Data with details about the actual campsites that are available (i.e Tent Size, RV Length, Etc) Parameters ---------- available_campsites: List[dict] List of Available Campsites as JSON objects month: datetime Month object Returns ------- List[dict] \"\"\" available_room_array = list () availability_df = DataFrame ( data = available_campsites ) if availability_df . empty is True : return available_room_array for facility_id , _facility_df in availability_df . groupby ( YellowstoneConfig . FACILITY_ID ): api_endpoint = self . _get_api_endpoint ( url_path = YellowstoneConfig . YELLOWSTONE_CAMPSITE_AVAILABILITY , query = None ) params = dict ( date = self . _ensure_current_month ( month = month ), limit = 31 ) if nights is not None : params . update ( dict ( nights = nights )) campsite_data = self . make_yellowstone_request ( endpoint = f \" { api_endpoint } / { facility_id } \" , params = params ) campsite_availability = campsite_data [ YellowstoneConfig . BOOKING_AVAILABILITY ] booking_dates = campsite_availability . keys () availabilities = self . _process_daily_availability ( booking_dates = booking_dates , campsite_availability = campsite_availability , facility_id = facility_id , ) available_room_array += availabilities return available_room_array @classmethod def _process_daily_availability ( cls , booking_dates : List [ str ], campsite_availability : dict , facility_id : str ) -> List [ dict ]: \"\"\" Process Monthly Availability Parameters ---------- booking_dates: List[str] List of booking dates to process campsite_availability: dict Campsite availability dict facility_id: str Identification of the Facility Returns ------- List[dict] \"\"\" daily_availabilities = list () for booking_date_str in booking_dates : daily_availability = campsite_availability [ booking_date_str ] if ( daily_availability [ YellowstoneConfig . FACILITY_STATUS ] == YellowstoneConfig . FACILITY_STATUS_QUALIFIER ): available_rooms = daily_availability [ YellowstoneConfig . FACILITY_ROOMS ] for room in available_rooms : if room [ YellowstoneConfig . FACILITY_AVAILABLE_QUALIFIER ] > 0 : daily_availabilities . append ( dict ( booking_date = booking_date_str , facility_id = facility_id , campsite_code = room [ YellowstoneConfig . FACILITY_ROOM_CODE ], available = room [ YellowstoneConfig . FACILITY_AVAILABLE_QUALIFIER ], price = room [ YellowstoneConfig . FACILITY_PRICE ], ) ) return daily_availabilities def _get_property_information ( self , available_rooms : List [ dict ]) -> List [ dict ]: \"\"\" Gather Information About All Campgrounds / Hotels within Yellowstone Parameters ---------- available_rooms: List[dict] Returns ------- List[dict] \"\"\" property_info_array = list () availability_df = DataFrame ( data = available_rooms ) if availability_df . empty is True : return property_info_array facility_identifiers = availability_df [ YellowstoneConfig . FACILITY_ID ] . unique () for facility_id in facility_identifiers : api_endpoint = self . _get_api_endpoint ( url_path = YellowstoneConfig . YELLOWSTONE_PROPERTY_INFO , query = None ) campsite_info = self . make_yellowstone_request ( endpoint = f \" { api_endpoint } / { facility_id } \" ) campsite_codes = campsite_info . keys () for campsite_code in campsite_codes : campsite_data = campsite_info [ campsite_code ] property_info_array . append ( dict ( facility_id = facility_id , campsite_code = campsite_code , campsite_title = campsite_data [ YellowstoneConfig . LODGING_TITLE ], campsite_type = campsite_data [ YellowstoneConfig . FACILITY_TYPE ] . upper (), capacity = ( campsite_data [ YellowstoneConfig . LODGING_OCCUPANCY_BASE ], campsite_data [ YellowstoneConfig . LODGING_OCCUPANCY_MAX ], ), ) ) return property_info_array def get_monthly_campsites ( self , month : datetime , nights : Optional [ int ] = None ) -> List [ AvailableCampsite ]: \"\"\" Return All Campsites Available in a Given Month Parameters ---------- month: datetime Month to Search nights: Optional[int] Search for consecutive nights Returns ------- List[AvailableCampsite] \"\"\" now = datetime . now () . date () search_date = month . replace ( day = 1 ) if month <= now : logger . info ( \"Cannot input search dates before today, adjusting search parameters.\" ) search_date = search_date . replace ( year = now . year , month = now . month , day = now . day ) availability_found = self . _get_monthly_availability ( month = search_date , nights = nights ) availability = XantResortData ( ** availability_found ) monthly_campsites = self . _compile_campground_availabilities ( availability = availability ) campsite_data = DataFrame ( monthly_campsites , columns = YellowstoneConfig . CAMPSITE_DATA_COLUMNS ) . drop_duplicates () if campsite_data . empty is True : return list () available_room_array = self . _gather_campsite_specific_availability ( available_campsites = monthly_campsites , month = month , nights = nights ) available_rooms = DataFrame ( available_room_array ) property_info = self . _get_property_information ( available_rooms = available_room_array ) properties = DataFrame ( property_info ) merged_campsites = available_rooms . merge ( properties , on = [ YellowstoneConfig . FACILITY_ID_COLUMN , YellowstoneConfig . CAMPSITE_ID_COLUMN , ], ) merged_campsites [ YellowstoneConfig . BOOKING_DATE_COLUMN ] = to_datetime ( merged_campsites [ YellowstoneConfig . BOOKING_DATE_COLUMN ] ) if nights is not None : nights_param = dict ( nights = nights ) else : nights_param = dict ( nights = 1 ) booking_nights = nights_param . get ( \"nights\" ) merged_campsites [ YellowstoneConfig . BOOKING_END_DATE_COLUMN ] = merged_campsites [ YellowstoneConfig . BOOKING_DATE_COLUMN ] + timedelta ( days = booking_nights ) merged_campsites [ YellowstoneConfig . BOOKING_NIGHTS_COLUMN ] = booking_nights final_campsites = merged_campsites . merge ( campsite_data , on = YellowstoneConfig . FACILITY_ID_COLUMN ) . sort_values ( by = YellowstoneConfig . BOOKING_DATE_COLUMN ) final_campsites [ YellowstoneConfig . BOOKING_URL_COLUMN ] = final_campsites . apply ( lambda x : self . _return_lodging_url ( lodging_code = x . facility_id , month = x . booking_date , params = nights_param ), axis = 1 , ) all_monthly_campsite_array = self . _df_to_campsites ( campsite_df = final_campsites ) return all_monthly_campsite_array @classmethod def _df_to_campsites ( cls , campsite_df : DataFrame ) -> List [ AvailableCampsite ]: \"\"\" Transform a DataFrame into an array of AvailableCampsites Parameters ---------- campsite_df: DataFrame Returns ------- List[AvailableCampsite] \"\"\" all_monthly_campsite_array = list () for _ , row in campsite_df . iterrows (): campsite = AvailableCampsite ( campsite_id = row [ YellowstoneConfig . CAMPSITE_ID_COLUMN ], booking_date = row [ YellowstoneConfig . BOOKING_DATE_COLUMN ], booking_end_date = row [ YellowstoneConfig . BOOKING_END_DATE_COLUMN ], booking_nights = row [ YellowstoneConfig . BOOKING_NIGHTS_COLUMN ], campsite_site_name = row [ YellowstoneConfig . CAMPSITE_SITE_NAME_COLUMN ], campsite_loop_name = YellowstoneConfig . YELLOWSTONE_LOOP_NAME , campsite_type = row [ YellowstoneConfig . CAMPSITE_TYPE_COLUMN ], campsite_occupancy = row [ YellowstoneConfig . CAMPSITE_OCCUPANCY_COLUMN ], campsite_use_type = row [ YellowstoneConfig . CAMPSITE_USE_TYPE_COLUMN ], availability_status = YellowstoneConfig . CAMPSITE_AVAILABILITY_STATUS , recreation_area = YellowstoneConfig . YELLOWSTONE_RECREATION_AREA_NAME , recreation_area_id = YellowstoneConfig . YELLOWSTONE_RECREATION_AREA_ID , facility_name = row [ YellowstoneConfig . FACILITY_NAME_COLUMN ], facility_id = row [ YellowstoneConfig . FACILITY_ID_COLUMN ], booking_url = row [ YellowstoneConfig . BOOKING_URL_COLUMN ], ) all_monthly_campsite_array . append ( campsite ) return all_monthly_campsite_array @classmethod def _ensure_current_month ( cls , month : datetime ) -> datetime : \"\"\" Ensure That We Never Give the Yellowstone API Dates in the past. Parameters ---------- month: datetime Returns ------- datetime \"\"\" yellowstone_timezone = timezone ( YellowstoneConfig . YELLOWSTONE_TIMEZONE ) yellowstone_current_time = datetime . now ( yellowstone_timezone ) . date () today = datetime ( year = yellowstone_current_time . year , month = yellowstone_current_time . month , day = yellowstone_current_time . day , ) . date () if today > month : month = today return month","title":"YellowstoneLodging"},{"location":"reference/#camply.providers.xanterra.yellowstone_lodging.YellowstoneLodging.__repr__","text":"String Representation","title":"__repr__()"},{"location":"reference/#camply.providers.xanterra.yellowstone_lodging.YellowstoneLodging.__repr__--returns","text":"str Source code in camply/providers/xanterra/yellowstone_lodging.py 31 32 33 34 35 36 37 38 39 def __repr__ ( self ): \"\"\" String Representation Returns ------- str \"\"\" return \"<YellowstoneLodging>\"","title":"Returns"},{"location":"reference/#camply.providers.xanterra.yellowstone_lodging.YellowstoneLodging.get_monthly_campsites","text":"Return All Campsites Available in a Given Month","title":"get_monthly_campsites()"},{"location":"reference/#camply.providers.xanterra.yellowstone_lodging.YellowstoneLodging.get_monthly_campsites--parameters","text":"datetime Month to Search Optional[int] Search for consecutive nights","title":"Parameters"},{"location":"reference/#camply.providers.xanterra.yellowstone_lodging.YellowstoneLodging.get_monthly_campsites--returns","text":"List[AvailableCampsite] Source code in camply/providers/xanterra/yellowstone_lodging.py 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 def get_monthly_campsites ( self , month : datetime , nights : Optional [ int ] = None ) -> List [ AvailableCampsite ]: \"\"\" Return All Campsites Available in a Given Month Parameters ---------- month: datetime Month to Search nights: Optional[int] Search for consecutive nights Returns ------- List[AvailableCampsite] \"\"\" now = datetime . now () . date () search_date = month . replace ( day = 1 ) if month <= now : logger . info ( \"Cannot input search dates before today, adjusting search parameters.\" ) search_date = search_date . replace ( year = now . year , month = now . month , day = now . day ) availability_found = self . _get_monthly_availability ( month = search_date , nights = nights ) availability = XantResortData ( ** availability_found ) monthly_campsites = self . _compile_campground_availabilities ( availability = availability ) campsite_data = DataFrame ( monthly_campsites , columns = YellowstoneConfig . CAMPSITE_DATA_COLUMNS ) . drop_duplicates () if campsite_data . empty is True : return list () available_room_array = self . _gather_campsite_specific_availability ( available_campsites = monthly_campsites , month = month , nights = nights ) available_rooms = DataFrame ( available_room_array ) property_info = self . _get_property_information ( available_rooms = available_room_array ) properties = DataFrame ( property_info ) merged_campsites = available_rooms . merge ( properties , on = [ YellowstoneConfig . FACILITY_ID_COLUMN , YellowstoneConfig . CAMPSITE_ID_COLUMN , ], ) merged_campsites [ YellowstoneConfig . BOOKING_DATE_COLUMN ] = to_datetime ( merged_campsites [ YellowstoneConfig . BOOKING_DATE_COLUMN ] ) if nights is not None : nights_param = dict ( nights = nights ) else : nights_param = dict ( nights = 1 ) booking_nights = nights_param . get ( \"nights\" ) merged_campsites [ YellowstoneConfig . BOOKING_END_DATE_COLUMN ] = merged_campsites [ YellowstoneConfig . BOOKING_DATE_COLUMN ] + timedelta ( days = booking_nights ) merged_campsites [ YellowstoneConfig . BOOKING_NIGHTS_COLUMN ] = booking_nights final_campsites = merged_campsites . merge ( campsite_data , on = YellowstoneConfig . FACILITY_ID_COLUMN ) . sort_values ( by = YellowstoneConfig . BOOKING_DATE_COLUMN ) final_campsites [ YellowstoneConfig . BOOKING_URL_COLUMN ] = final_campsites . apply ( lambda x : self . _return_lodging_url ( lodging_code = x . facility_id , month = x . booking_date , params = nights_param ), axis = 1 , ) all_monthly_campsite_array = self . _df_to_campsites ( campsite_df = final_campsites ) return all_monthly_campsite_array","title":"Returns"},{"location":"reference/#camply.providers.xanterra.yellowstone_lodging.YellowstoneLodging.make_yellowstone_request","text":"Try and Retry Fetching Data from the Yellowstone API. Unfortunately this is a required method to request the data since the Yellowstone API doesn't always return data.","title":"make_yellowstone_request()"},{"location":"reference/#camply.providers.xanterra.yellowstone_lodging.YellowstoneLodging.make_yellowstone_request--parameters","text":"str API Endpoint params","title":"Parameters"},{"location":"reference/#camply.providers.xanterra.yellowstone_lodging.YellowstoneLodging.make_yellowstone_request--returns","text":"dict Source code in camply/providers/xanterra/yellowstone_lodging.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 @staticmethod def make_yellowstone_request ( endpoint : str , params : Optional [ dict ] = None ) -> dict : \"\"\" Try and Retry Fetching Data from the Yellowstone API. Unfortunately this is a required method to request the data since the Yellowstone API doesn't always return data. Parameters ---------- endpoint: str API Endpoint params Returns ------- dict \"\"\" try : content = YellowstoneLodging . _try_retry_get_data ( endpoint = endpoint , params = params ) except RuntimeError as re : raise RuntimeError ( f \"error_message: { re } \" ) return content","title":"Returns"},{"location":"reference/SUMMARY/","text":"camply _version cli config api_config data_columns file_config logging_config notification_config search_config yellowstone_config containers api_responses base_container data_containers notifications base_notifications email_notifications multi_provider_notifications pushbullet pushover silent_notifications slack telegram twilio providers base_provider recreation_dot_gov recdotgov_provider xanterra yellowstone_lodging search base_search search_recreationdotgov search_yellowstone utils api_utils configure_camply general_utils logging_utils yaml_utils","title":"SUMMARY"},{"location":"reference/_version/","text":"camply Version file","title":"_version"},{"location":"reference/cli/","text":"Camply Command Line Interface CamplyContext dataclass # Context Object Passed Around Application Source code in camply/cli.py 28 29 30 31 32 33 34 35 @dataclass class CamplyContext : \"\"\" Context Object Passed Around Application \"\"\" debug : Optional [ bool ] = None provider : Optional [ str ] = None campgrounds ( context , debug , search = None , state = None , rec_area = None , campground = None , campsite = None , provider = 'RecreationDotGov' ) # Search for Campgrounds (inside of Recreation Areas) and list them Search for Campgrounds and their IDs. Campgrounds are facilities inside of Recreation Areas that contain campsites. Most 'campgrounds' are areas made up of multiple campsites, others are facilities like fire towers or cabins that might only contain a single 'campsite' to book. Source code in camply/cli.py 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 @camply_command_line . command () @search_argument @state_argument @rec_area_argument @campground_argument @campsite_id_argument @provider_argument @debug_option @click . pass_obj def campgrounds ( context : CamplyContext , debug : bool , search : Optional [ str ] = None , state : Optional [ str ] = None , rec_area : Optional [ int ] = None , campground : Optional [ int ] = None , campsite : Optional [ int ] = None , provider : Optional [ str ] = \"RecreationDotGov\" , ) -> None : \"\"\" Search for Campgrounds (inside of Recreation Areas) and list them Search for Campgrounds and their IDs. Campgrounds are facilities inside of Recreation Areas that contain campsites. Most 'campgrounds' are areas made up of multiple campsites, others are facilities like fire towers or cabins that might only contain a single 'campsite' to book. \"\"\" if context . debug is None : context . debug = debug _set_up_debug ( debug = context . debug ) if context . provider is None : context . provider = provider provider = DEFAULT_CAMPLY_PROVIDER if context . provider is None else context . provider if provider . lower () == \"yellowstone\" : SearchYellowstone . print_campgrounds () exit ( 0 ) if all ( [ search is None , state is None , len ( rec_area ) == 0 , len ( campground ) == 0 , len ( campsite ) == 0 , ] ): logger . error ( \"You must add a --search, --state, --campground, --campsite, \" \"or --rec-area parameter to search for Campgrounds.\" ) exit ( 1 ) camp_finder = RecreationDotGov () params = dict () if state is not None : params . update ( dict ( state = state )) camp_finder . find_campgrounds ( search_string = search , rec_area_id = make_list ( rec_area , coerce = int ), campground_id = make_list ( campground , coerce = int ), campsite_id = make_list ( campsite , coerce = int ), ** params , ) camply_command_line ( ctx , provider , debug ) # Welcome to camply, the campsite finder. Finding reservations at sold out campgrounds can be tough. That's where camply comes in. It searches the APIs of booking services like https://recreation.gov (which indexes thousands of campgrounds across the USA) to continuously check for cancellations and availabilities to pop up. Once a campsite becomes available, camply sends you a notification to book your spot! visit the camply documentation at https://github.com/juftin/camply Source code in camply/cli.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 @click . group () @click . version_option ( version = __version__ , prog_name = __application__ ) @provider_argument @debug_option @click . pass_context def camply_command_line ( ctx : click . core . Context , provider : str , debug : bool ) -> None : \"\"\" Welcome to camply, the campsite finder. Finding reservations at sold out campgrounds can be tough. That's where camply comes in. It searches the APIs of booking services like https://recreation.gov (which indexes thousands of campgrounds across the USA) to continuously check for cancellations and availabilities to pop up. Once a campsite becomes available, camply sends you a notification to book your spot! visit the camply documentation at https://github.com/juftin/camply \"\"\" set_up_logging ( log_level = None if debug is False else logging . INFO ) logger . camply ( \"camply, the campsite finder \u26fa\ufe0f\" ) # noqa ctx . obj = CamplyContext ( debug = debug , provider = provider ) _set_up_debug ( debug = debug ) campsites ( context , debug , rec_area = None , campground = None , campsite = None , start_date = None , end_date = None , weekends = False , nights = 1 , provider = 'RecreationDotGov' , continuous = False , polling_interval = SearchConfig . RECOMMENDED_POLLING_INTERVAL , notifications = 'silent' , notify_first_try = False , search_forever = False , yaml_config = None , equipment = None , offline_search = False , offline_search_path = None ) # Find available Campsites using search criteria Search for a campsite within camply. Campsites are returned based on the search criteria provided. Campsites contain properties like booking date, site type (tent, RV, cabin, etc), capacity, price, and a link to make the booking. Required parameters include --start-date , --end-date , --rec-area / --campground . Constant searching functionality can be enabled with --continuous and notifications can be enabled using --notifications . Source code in camply/cli.py 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 @camply_command_line . command () @yaml_config_argument @offline_search_path_argument @offline_search_argument @search_forever_argument @notify_first_try_argument @notifications_argument @polling_interval_argument @continuous_argument @provider_argument @equipment_argument @nights_argument @weekends_argument @end_date_argument @start_date_argument @campsite_id_argument @campground_argument @rec_area_argument @debug_option @click . pass_obj def campsites ( context : CamplyContext , debug : bool , rec_area : Optional [ int ] = None , campground : Optional [ int ] = None , campsite : Optional [ int ] = None , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , weekends : bool = False , nights : int = 1 , provider : str = \"RecreationDotGov\" , continuous : bool = False , polling_interval : int = SearchConfig . RECOMMENDED_POLLING_INTERVAL , notifications : Union [ str , List [ str ]] = \"silent\" , notify_first_try : bool = False , search_forever : bool = False , yaml_config : Optional [ str ] = None , equipment : Optional [ List [ str ]] = None , offline_search : bool = False , offline_search_path : Optional [ str ] = None , ) -> None : \"\"\" Find available Campsites using search criteria Search for a campsite within camply. Campsites are returned based on the search criteria provided. Campsites contain properties like booking date, site type (tent, RV, cabin, etc), capacity, price, and a link to make the booking. Required parameters include `--start-date`, `--end-date`, `--rec-area` / `--campground`. Constant searching functionality can be enabled with `--continuous` and notifications can be enabled using `--notifications`. \"\"\" if context . debug is None : context . debug = debug _set_up_debug ( debug = context . debug ) if context . provider is None : context . provider = provider provider = DEFAULT_CAMPLY_PROVIDER if context . provider is None else context . provider notifications = make_list ( notifications ) _validate_campsites ( rec_area = rec_area , campground = campground , campsite = campsite , start_date = start_date , end_date = end_date , weekends = weekends , nights = nights , provider = provider , continuous = continuous , polling_interval = polling_interval , notifications = notifications , notify_first_try = notify_first_try , search_forever = search_forever , yaml_config = yaml_config , ) if yaml_config is not None : provider , provider_kwargs , search_kwargs = yaml_utils . yaml_file_to_arguments ( file_path = yaml_config ) else : provider = provider . lower () search_window = SearchWindow ( start_date = datetime . strptime ( start_date , \"%Y-%m- %d \" ), end_date = datetime . strptime ( end_date , \"%Y-%m- %d \" ), ) provider_kwargs = dict ( search_window = search_window , recreation_area = make_list ( rec_area ), campgrounds = make_list ( campground ), campsites = make_list ( campsite ), weekends_only = weekends , nights = int ( nights ), equipment = make_list ( equipment ), offline_search = offline_search , offline_search_path = offline_search_path , ) search_kwargs = dict ( log = True , verbose = True , continuous = continuous , polling_interval = float ( polling_interval ), notify_first_try = notify_first_try , notification_provider = notifications , search_forever = search_forever , ) provider_class = { key . lower (): value for key , value in CAMPSITE_SEARCH_PROVIDER . items () }[ provider . lower ()] camping_finder = provider_class ( ** provider_kwargs ) camping_finder . get_matching_campsites ( ** search_kwargs ) cli () # Camply Command Line Utility Wrapper Source code in camply/cli.py 506 507 508 509 510 511 512 513 514 515 def cli (): \"\"\" Camply Command Line Utility Wrapper \"\"\" try : camply_command_line () except KeyboardInterrupt : logger . debug ( \"Handling Exit Request\" ) finally : logger . camply ( \"Exiting camply \ud83d\udc4b\" ) # noqa configure ( context , debug ) # Set up camply configuration file with an interactive console In order to send notifications through camply you must set up some authorization values. Whether you need to set up pushover notifications (push notifications on your phone, your pushover account can be set up at https://pushover.net ) or Email messages, everything can be done through the configure command. The end result is a file called .camply in your home folder. Source code in camply/cli.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 @camply_command_line . command () @debug_option @click . pass_obj def configure ( context : CamplyContext , debug : bool ) -> None : \"\"\" Set up camply configuration file with an interactive console In order to send notifications through camply you must set up some authorization values. Whether you need to set up pushover notifications (push notifications on your phone, your pushover account can be set up at https://pushover.net) or Email messages, everything can be done through the configure command. The end result is a file called .camply in your home folder. \"\"\" if context . debug is None : context . debug = debug _set_up_debug ( debug = context . debug ) configure_camply . generate_dot_camply_file () recreation_areas ( context , search , state , debug ) # Search for Recreation Areas and list them Search for Recreation Areas and their IDs. Recreation Areas are places like National Parks and National Forests that can contain one or many campgrounds. Source code in camply/cli.py 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 @camply_command_line . command () @search_argument @state_argument @debug_option @click . pass_obj def recreation_areas ( context : CamplyContext , search : Optional [ str ], state : Optional [ str ], debug : bool ) -> None : \"\"\" Search for Recreation Areas and list them Search for Recreation Areas and their IDs. Recreation Areas are places like National Parks and National Forests that can contain one or many campgrounds. \"\"\" if context . debug is None : context . debug = debug _set_up_debug ( debug = context . debug ) if all ([ search is None , state is None ]): logger . error ( \"You must add a --search or --state parameter to search \" \"for Recreation Areas.\" ) exit ( 1 ) camp_finder = RecreationDotGov () params = dict () if state is not None : params . update ( dict ( state = state )) camp_finder . find_recreation_areas ( search_string = search , ** params )","title":"cli"},{"location":"reference/cli/#camply.cli.CamplyContext","text":"Context Object Passed Around Application Source code in camply/cli.py 28 29 30 31 32 33 34 35 @dataclass class CamplyContext : \"\"\" Context Object Passed Around Application \"\"\" debug : Optional [ bool ] = None provider : Optional [ str ] = None","title":"CamplyContext"},{"location":"reference/cli/#camply.cli.campgrounds","text":"Search for Campgrounds (inside of Recreation Areas) and list them Search for Campgrounds and their IDs. Campgrounds are facilities inside of Recreation Areas that contain campsites. Most 'campgrounds' are areas made up of multiple campsites, others are facilities like fire towers or cabins that might only contain a single 'campsite' to book. Source code in camply/cli.py 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 @camply_command_line . command () @search_argument @state_argument @rec_area_argument @campground_argument @campsite_id_argument @provider_argument @debug_option @click . pass_obj def campgrounds ( context : CamplyContext , debug : bool , search : Optional [ str ] = None , state : Optional [ str ] = None , rec_area : Optional [ int ] = None , campground : Optional [ int ] = None , campsite : Optional [ int ] = None , provider : Optional [ str ] = \"RecreationDotGov\" , ) -> None : \"\"\" Search for Campgrounds (inside of Recreation Areas) and list them Search for Campgrounds and their IDs. Campgrounds are facilities inside of Recreation Areas that contain campsites. Most 'campgrounds' are areas made up of multiple campsites, others are facilities like fire towers or cabins that might only contain a single 'campsite' to book. \"\"\" if context . debug is None : context . debug = debug _set_up_debug ( debug = context . debug ) if context . provider is None : context . provider = provider provider = DEFAULT_CAMPLY_PROVIDER if context . provider is None else context . provider if provider . lower () == \"yellowstone\" : SearchYellowstone . print_campgrounds () exit ( 0 ) if all ( [ search is None , state is None , len ( rec_area ) == 0 , len ( campground ) == 0 , len ( campsite ) == 0 , ] ): logger . error ( \"You must add a --search, --state, --campground, --campsite, \" \"or --rec-area parameter to search for Campgrounds.\" ) exit ( 1 ) camp_finder = RecreationDotGov () params = dict () if state is not None : params . update ( dict ( state = state )) camp_finder . find_campgrounds ( search_string = search , rec_area_id = make_list ( rec_area , coerce = int ), campground_id = make_list ( campground , coerce = int ), campsite_id = make_list ( campsite , coerce = int ), ** params , )","title":"campgrounds()"},{"location":"reference/cli/#camply.cli.camply_command_line","text":"Welcome to camply, the campsite finder. Finding reservations at sold out campgrounds can be tough. That's where camply comes in. It searches the APIs of booking services like https://recreation.gov (which indexes thousands of campgrounds across the USA) to continuously check for cancellations and availabilities to pop up. Once a campsite becomes available, camply sends you a notification to book your spot! visit the camply documentation at https://github.com/juftin/camply Source code in camply/cli.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 @click . group () @click . version_option ( version = __version__ , prog_name = __application__ ) @provider_argument @debug_option @click . pass_context def camply_command_line ( ctx : click . core . Context , provider : str , debug : bool ) -> None : \"\"\" Welcome to camply, the campsite finder. Finding reservations at sold out campgrounds can be tough. That's where camply comes in. It searches the APIs of booking services like https://recreation.gov (which indexes thousands of campgrounds across the USA) to continuously check for cancellations and availabilities to pop up. Once a campsite becomes available, camply sends you a notification to book your spot! visit the camply documentation at https://github.com/juftin/camply \"\"\" set_up_logging ( log_level = None if debug is False else logging . INFO ) logger . camply ( \"camply, the campsite finder \u26fa\ufe0f\" ) # noqa ctx . obj = CamplyContext ( debug = debug , provider = provider ) _set_up_debug ( debug = debug )","title":"camply_command_line()"},{"location":"reference/cli/#camply.cli.campsites","text":"Find available Campsites using search criteria Search for a campsite within camply. Campsites are returned based on the search criteria provided. Campsites contain properties like booking date, site type (tent, RV, cabin, etc), capacity, price, and a link to make the booking. Required parameters include --start-date , --end-date , --rec-area / --campground . Constant searching functionality can be enabled with --continuous and notifications can be enabled using --notifications . Source code in camply/cli.py 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 @camply_command_line . command () @yaml_config_argument @offline_search_path_argument @offline_search_argument @search_forever_argument @notify_first_try_argument @notifications_argument @polling_interval_argument @continuous_argument @provider_argument @equipment_argument @nights_argument @weekends_argument @end_date_argument @start_date_argument @campsite_id_argument @campground_argument @rec_area_argument @debug_option @click . pass_obj def campsites ( context : CamplyContext , debug : bool , rec_area : Optional [ int ] = None , campground : Optional [ int ] = None , campsite : Optional [ int ] = None , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , weekends : bool = False , nights : int = 1 , provider : str = \"RecreationDotGov\" , continuous : bool = False , polling_interval : int = SearchConfig . RECOMMENDED_POLLING_INTERVAL , notifications : Union [ str , List [ str ]] = \"silent\" , notify_first_try : bool = False , search_forever : bool = False , yaml_config : Optional [ str ] = None , equipment : Optional [ List [ str ]] = None , offline_search : bool = False , offline_search_path : Optional [ str ] = None , ) -> None : \"\"\" Find available Campsites using search criteria Search for a campsite within camply. Campsites are returned based on the search criteria provided. Campsites contain properties like booking date, site type (tent, RV, cabin, etc), capacity, price, and a link to make the booking. Required parameters include `--start-date`, `--end-date`, `--rec-area` / `--campground`. Constant searching functionality can be enabled with `--continuous` and notifications can be enabled using `--notifications`. \"\"\" if context . debug is None : context . debug = debug _set_up_debug ( debug = context . debug ) if context . provider is None : context . provider = provider provider = DEFAULT_CAMPLY_PROVIDER if context . provider is None else context . provider notifications = make_list ( notifications ) _validate_campsites ( rec_area = rec_area , campground = campground , campsite = campsite , start_date = start_date , end_date = end_date , weekends = weekends , nights = nights , provider = provider , continuous = continuous , polling_interval = polling_interval , notifications = notifications , notify_first_try = notify_first_try , search_forever = search_forever , yaml_config = yaml_config , ) if yaml_config is not None : provider , provider_kwargs , search_kwargs = yaml_utils . yaml_file_to_arguments ( file_path = yaml_config ) else : provider = provider . lower () search_window = SearchWindow ( start_date = datetime . strptime ( start_date , \"%Y-%m- %d \" ), end_date = datetime . strptime ( end_date , \"%Y-%m- %d \" ), ) provider_kwargs = dict ( search_window = search_window , recreation_area = make_list ( rec_area ), campgrounds = make_list ( campground ), campsites = make_list ( campsite ), weekends_only = weekends , nights = int ( nights ), equipment = make_list ( equipment ), offline_search = offline_search , offline_search_path = offline_search_path , ) search_kwargs = dict ( log = True , verbose = True , continuous = continuous , polling_interval = float ( polling_interval ), notify_first_try = notify_first_try , notification_provider = notifications , search_forever = search_forever , ) provider_class = { key . lower (): value for key , value in CAMPSITE_SEARCH_PROVIDER . items () }[ provider . lower ()] camping_finder = provider_class ( ** provider_kwargs ) camping_finder . get_matching_campsites ( ** search_kwargs )","title":"campsites()"},{"location":"reference/cli/#camply.cli.cli","text":"Camply Command Line Utility Wrapper Source code in camply/cli.py 506 507 508 509 510 511 512 513 514 515 def cli (): \"\"\" Camply Command Line Utility Wrapper \"\"\" try : camply_command_line () except KeyboardInterrupt : logger . debug ( \"Handling Exit Request\" ) finally : logger . camply ( \"Exiting camply \ud83d\udc4b\" ) # noqa","title":"cli()"},{"location":"reference/cli/#camply.cli.configure","text":"Set up camply configuration file with an interactive console In order to send notifications through camply you must set up some authorization values. Whether you need to set up pushover notifications (push notifications on your phone, your pushover account can be set up at https://pushover.net ) or Email messages, everything can be done through the configure command. The end result is a file called .camply in your home folder. Source code in camply/cli.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 @camply_command_line . command () @debug_option @click . pass_obj def configure ( context : CamplyContext , debug : bool ) -> None : \"\"\" Set up camply configuration file with an interactive console In order to send notifications through camply you must set up some authorization values. Whether you need to set up pushover notifications (push notifications on your phone, your pushover account can be set up at https://pushover.net) or Email messages, everything can be done through the configure command. The end result is a file called .camply in your home folder. \"\"\" if context . debug is None : context . debug = debug _set_up_debug ( debug = context . debug ) configure_camply . generate_dot_camply_file ()","title":"configure()"},{"location":"reference/cli/#camply.cli.recreation_areas","text":"Search for Recreation Areas and list them Search for Recreation Areas and their IDs. Recreation Areas are places like National Parks and National Forests that can contain one or many campgrounds. Source code in camply/cli.py 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 @camply_command_line . command () @search_argument @state_argument @debug_option @click . pass_obj def recreation_areas ( context : CamplyContext , search : Optional [ str ], state : Optional [ str ], debug : bool ) -> None : \"\"\" Search for Recreation Areas and list them Search for Recreation Areas and their IDs. Recreation Areas are places like National Parks and National Forests that can contain one or many campgrounds. \"\"\" if context . debug is None : context . debug = debug _set_up_debug ( debug = context . debug ) if all ([ search is None , state is None ]): logger . error ( \"You must add a --search or --state parameter to search \" \"for Recreation Areas.\" ) exit ( 1 ) camp_finder = RecreationDotGov () params = dict () if state is not None : params . update ( dict ( state = state )) camp_finder . find_recreation_areas ( search_string = search , ** params )","title":"recreation_areas()"},{"location":"reference/config/","text":"Config init file CampsiteContainerFields # String Variable Storage Class Source code in camply/config/data_columns.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class CampsiteContainerFields : \"\"\" String Variable Storage Class \"\"\" CAMPSITE_ID : str = \"campsite_id\" CAMPGROUND_ID : str = \"facility_id\" BOOKING_DATE : str = \"booking_date\" CAMPSITE_GROUP : str = \"campsite_group\" BOOKING_END_DATE : str = \"booking_end_date\" BOOKING_URL : str = \"booking_url\" PERMITTED_EQUIPMENT : str = \"permitted_equipment\" CAMPSITE_ATTRIBUTES : str = \"campsite_attributes\" DataColumns # Variable Storage Class Source code in camply/config/data_columns.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class DataColumns : \"\"\" Variable Storage Class \"\"\" CAMPSITE_ID_COLUMN : str = \"campsite_code\" BOOKING_DATE_COLUMN : str = \"booking_date\" BOOKING_END_DATE_COLUMN : str = \"booking_end_date\" BOOKING_NIGHTS_COLUMN : str = \"booking_nights\" CAMPSITE_SITE_NAME_COLUMN : str = \"campsite_title\" CAMPSITE_TYPE_COLUMN : str = \"campsite_type\" CAMPSITE_OCCUPANCY_COLUMN : str = \"capacity\" CAMPSITE_USE_TYPE_COLUMN : str = \"campsite_type\" AVAILABILITY_STATUS_COLUMN : str = \"Available\" RECREATION_AREA_COLUMN : str = \"recreation_area\" FACILITY_NAME_COLUMN : str = \"facility_name\" FACILITY_ID_COLUMN : str = \"facility_id\" BOOKING_URL_COLUMN : str = \"booking_url\" EmailConfig # Email Notification Config Class Source code in camply/config/notification_config.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 class EmailConfig : \"\"\" Email Notification Config Class \"\"\" EMAIL_TO_ADDRESS : Optional [ str ] = getenv ( \"EMAIL_TO_ADDRESS\" , None ) DEFAULT_FROM_ADDRESS : str = \"camply@juftin.com\" EMAIL_FROM_ADDRESS : str = getenv ( \"EMAIL_FROM_ADDRESS\" , DEFAULT_FROM_ADDRESS ) DEFAULT_SUBJECT_LINE : str = \"Camply Notification\" EMAIL_SUBJECT_LINE : str = getenv ( \"EMAIL_SUBJECT_LINE\" , DEFAULT_SUBJECT_LINE ) DEFAULT_SMTP_SERVER : str = \"smtp.gmail.com\" EMAIL_SMTP_SERVER : str = getenv ( \"EMAIL_SMTP_SERVER\" , DEFAULT_SMTP_SERVER ) EMAIL_USERNAME : Optional [ str ] = getenv ( \"EMAIL_USERNAME\" , None ) EMAIL_PASSWORD : Optional [ str ] = getenv ( \"EMAIL_PASSWORD\" , None ) DEFAULT_SMTP_PORT : int = 465 EMAIL_SMTP_PORT : int = int ( getenv ( \"EMAIL_SMTP_PORT\" , DEFAULT_SMTP_PORT )) ENVIRONMENT_VARIABLE_NAMES : List [ str ] = [ \"EMAIL_TO_ADDRESS\" , \"EMAIL_USERNAME\" , \"EMAIL_PASSWORD\" , ] OPTIONAL_ENVIRONMENT_VARIABLE : List [ str ] = [ f \"EMAIL_SMTP_SERVER (default: { DEFAULT_SMTP_SERVER } )\" , f \"EMAIL_FROM_ADDRESS (default: { DEFAULT_FROM_ADDRESS } )\" , f 'EMAIL_SUBJECT_LINE (default: \" { DEFAULT_SUBJECT_LINE } \")' , f \"EMAIL_SMTP_PORT (default: { DEFAULT_SMTP_PORT } )\" , ] EquipmentOptions # Bases: str , Enum Enumeration of the Equipment Options Source code in camply/config/search_config.py 22 23 24 25 26 27 28 29 30 31 32 33 class EquipmentOptions ( str , Enum ): \"\"\" Enumeration of the Equipment Options \"\"\" tent = \"tent\" rv = \"rv\" trailer = \"trailer\" vehicle = \"vehicle\" other = \"other\" __all_accepted_equipment__ = [ tent , rv , trailer , vehicle ] FileConfig # File Path Storage Class Source code in camply/config/file_config.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class FileConfig : \"\"\" File Path Storage Class \"\"\" HOME_PATH = abspath ( Path . home ()) DOT_CAMPLY_FILE = join ( HOME_PATH , \".camply\" ) _file_config_file = Path ( abspath ( __file__ )) _config_dir = _file_config_file . parent CAMPLY_DIRECTORY = _config_dir . parent ROOT_DIRECTORY = CAMPLY_DIRECTORY . parent DOT_CAMPLY_FIELDS = OrderedDict ( PUSHOVER_PUSH_USER = dict ( default = \"\" , notes = \"Enables Pushover Notifications\" ), PUSHBULLET_API_TOKEN = dict ( default = \"\" , notes = \"Enables Pushbullet Notifications\" ), SLACK_WEBHOOK = dict ( default = \"\" , notes = \"Enables Slack Notifications\" ), TELEGRAM_BOT_TOKEN = dict ( default = \"\" , notes = \"Enables Telegram Notifications\" ), TELEGRAM_CHAT_ID = dict ( default = \"\" , notes = \"Telegram Notification will be sent here\" ), TWILIO_ACCOUNT_SID = dict ( default = \"\" , notes = \"Twilio Account SID\" ), TWILIO_AUTH_TOKEN = dict ( default = \"\" , notes = \"Twilio Auth Token\" ), TWILIO_SOURCE_NUMBER = dict ( default = \"\" , notes = \"Twilio Source number. E.164 format\" ), TWILIO_DEST_NUMBERS = dict ( default = \"\" , notes = \"Comma-separated list of phone numbers.\" ), EMAIL_TO_ADDRESS = dict ( default = \"\" , notes = \"Email Notifications will be sent here\" ), EMAIL_USERNAME = dict ( default = \"\" , notes = \"Email Authorization Login Username\" ), EMAIL_PASSWORD = dict ( default = \"\" , notes = \"Email Authorization Login Password\" ), EMAIL_SMTP_SERVER = dict ( default = \"smtp.gmail.com\" , notes = \"Email Authorization SMTP Server Address\" ), EMAIL_SMTP_PORT = dict ( default = 465 , notes = \"Email Authorization SMTP Server Port\" ), EMAIL_FROM_ADDRESS = dict ( default = \"camply@juftin.com\" , notes = \"Email Notifications Will Come From this Email\" , ), EMAIL_SUBJECT_LINE = dict ( default = \"Camply Notification\" , notes = \"Email Notifications Will Have This Subject Line\" , ), PUSHOVER_PUSH_TOKEN = dict ( default = \"\" , notes = \"Pushover Notifications From Your Custom App \" \"(not required)\" , ), RIDB_API_KEY = dict ( default = \"\" , notes = \"Personal Recreation.gov API Key (not required)\" ), ) PushbulletConfig # Pushbullet Notification Config Class Source code in camply/config/notification_config.py 60 61 62 63 64 65 66 67 68 class PushbulletConfig : \"\"\" Pushbullet Notification Config Class \"\"\" PUSHBULLET_API_ENDPOINT : str = \"https://api.pushbullet.com/v2/pushes\" API_HEADERS : dict = { \"Content-Type\" : \"application/json\" } API_TOKEN = getenv ( \"PUSHBULLET_API_TOKEN\" , None ) PushoverConfig # Pushover Notification Config Class Source code in camply/config/notification_config.py 17 18 19 20 21 22 23 24 25 26 27 class PushoverConfig : \"\"\" Pushover Notification Config Class \"\"\" PUSHOVER_API_ENDPOINT : str = \"https://api.pushover.net/1/messages.json\" PUSHOVER_DEFAULT_API_TOKEN : bytes = b \"YWpjN3M1a2hhYTRlOG1zYWhncnFnaHduZGdtbmI3\" API_HEADERS : dict = { \"Content-Type\" : \"application/json\" } PUSH_TOKEN : str = getenv ( \"PUSHOVER_PUSH_TOKEN\" , None ) PUSH_USER : str = getenv ( \"PUSHOVER_PUSH_USER\" , None ) RIDBConfig # RIDB API Configuration https://ridb.recreation.gov/docs Source code in camply/config/api_config.py 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 class RIDBConfig : \"\"\" RIDB API Configuration https://ridb.recreation.gov/docs \"\"\" _camply_ridb_service_account_api_token : bytes = ( b \"YTc0MTY0NzEtMWI1ZC00YTY0LWFkM2QtYTIzM2U3Y2I1YzQ0\" ) _api_key : Union [ str , bytes ] = getenv ( \"RIDB_API_KEY\" , _camply_ridb_service_account_api_token ) API_KEY = _camply_ridb_service_account_api_token if _api_key == \"\" else _api_key RIDB_SCHEME : str = \"https\" RIDB_NET_LOC : str = \"ridb.recreation.gov\" RIDB_BASE_PATH : str = \"api/v1/\" # FACILITIES_API_PATH FIELDS FACILITIES_API_PATH : str = \"facilities\" CAMPGROUND_FACILITY_FIELD_QUALIFIER : str = \"Campground\" # RECREATION AREA FIELDS REC_AREA_API_PATH : str = \"recareas\" # CAMPSITE DETAILS CAMPSITE_API_PATH : str = \"campsites\" RecreationBookingConfig # Variable Storage Class for Recreation.gov Booking API Source code in camply/config/api_config.py 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 class RecreationBookingConfig : \"\"\" Variable Storage Class for Recreation.gov Booking API \"\"\" API_SCHEME : str = \"https\" API_NET_LOC = \"www.recreation.gov\" API_BASE_PATH : str = \"api/camps/availability/campground/\" API_MONTH_PATH : str = \"month\" API_REFERRERS : dict = { \"Referer\" : \"https://www.recreation.gov/\" } CAMPSITE_UNAVAILABLE_STRINGS : list = [ \"Reserved\" , \"Not Available\" , \"Not Reservable\" , \"Not Reservable Management\" , \"Not Available Cutoff\" , \"Lottery\" , \"Open\" , \"NYR\" , ] CAMPSITE_LOCATION_LOOP_DEFAULT : str = \"Default Loop\" CAMPSITE_LOCATION_SITE_DEFAULT : str = \"Default Site\" CAMPSITE_BOOKING_URL : str = \"https://www.recreation.gov/camping/campsites\" RATE_LIMITING = ( 1.01 , 1.51 ) SearchConfig # File Path Storage Class Source code in camply/config/search_config.py 10 11 12 13 14 15 16 17 18 19 class SearchConfig : \"\"\" File Path Storage Class \"\"\" POLLING_INTERVAL_MINIMUM : int = 5 # 5 MINUTES RECOMMENDED_POLLING_INTERVAL : int = 10 # 10 MINUTES ERROR_MESSAGE : str = \"No search days configured. Exiting\" MINIMUM_CAMPSITES_FIRST_NOTIFY : int = 5 MAXIMUM_NOTIFICATION_BATCH_SIZE : int = 20 SlackConfig # Slack Notification Config Class Source code in camply/config/notification_config.py 83 84 85 86 87 88 class SlackConfig : \"\"\" Slack Notification Config Class \"\"\" SLACK_WEBHOOK : Optional [ str ] = getenv ( \"SLACK_WEBHOOK\" , None ) TelegramConfig # Telegram Notification Config Class Source code in camply/config/notification_config.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 class TelegramConfig : \"\"\" Telegram Notification Config Class \"\"\" BOT_TOKEN = getenv ( \"TELEGRAM_BOT_TOKEN\" , None ) CHAT_ID = getenv ( \"TELEGRAM_CHAT_ID\" , None ) API_ENDPOINT : str = f \"https://api.telegram.org/bot { BOT_TOKEN } /sendMessage\" API_HEADERS : dict = { \"Content-Type\" : \"application/json\" } API_CONTENT : dict = { \"chat_id\" : CHAT_ID , \"parse_mode\" : \"MarkdownV2\" , \"disable_web_page_preview\" : \"true\" , } TwilioConfig # Twilio Notification Config Class Source code in camply/config/notification_config.py 71 72 73 74 75 76 77 78 79 80 class TwilioConfig : \"\"\" Twilio Notification Config Class \"\"\" ACCOUNT_SID = getenv ( \"TWILIO_ACCOUNT_SID\" , None ) AUTH_TOKEN = getenv ( \"TWILIO_AUTH_TOKEN\" , None ) SOURCE_NUMBER = getenv ( \"TWILIO_SOURCE_NUMBER\" , None ) # comma separated set of phone numbers DEST_NUMBERS = getenv ( \"TWILIO_DEST_NUMBERS\" , None ) YellowstoneConfig # Bases: DataColumns Variable Storage Class Source code in camply/config/yellowstone_config.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 class YellowstoneConfig ( DataColumns ): \"\"\" Variable Storage Class \"\"\" API_SCHEME : str = \"https\" API_BASE_ENDPOINT : str = \"webapi.xanterra.net\" API_BASE_PATH : str = \"v1/api\" LODGING_PATH : str = f \"/ { API_BASE_PATH } /availability/hotels\" YELLOWSTONE_PARK_PATH : str = \"yellowstonenationalparklodges\" YELLOWSTONE_LODGING_PATH : str = f \" { LODGING_PATH } / { YELLOWSTONE_PARK_PATH } \" CAMPSITE_AVAILABILITY : str = f \" { API_BASE_PATH } /availability/rooms\" YELLOWSTONE_CAMPSITE_AVAILABILITY : str = ( f \" { CAMPSITE_AVAILABILITY } / { YELLOWSTONE_PARK_PATH } \" ) YELLOWSTONE_PROPERTY_INFO : str = ( f \" { API_BASE_PATH } /property/rooms/ { YELLOWSTONE_PARK_PATH } \" ) API_REFERRERS : dict = { \"Host\" : \"webapi.xanterra.net\" , \"Origin\" : \"https://secure.yellowstonenationalparklodges.com\" , \"Referer\" : \"https://secure.yellowstonenationalparklodges.com/\" , } LODGING_CAMPGROUND_QUALIFIER : str = \":RV\" # JSON FILTERING BOOKING_AVAILABILITY : str = \"availability\" # DATAFRAME FILTERING FACILITY_ID : str = \"facility_id\" FACILITY_STATUS : str = \"status\" FACILITY_STATUS_QUALIFIER : str = \"OPEN\" FACILITY_ROOMS : str = \"rooms\" FACILITY_AVAILABLE_QUALIFIER : str = \"available\" FACILITY_HOTEL_CODE : str = \"hotelCode\" FACILITY_ROOM_CODE : str = \"roomCode\" FACILITY_PRICE : str = \"price\" FACILITY_TYPE : str = \"type\" CAMPSITE_DATA_COLUMNS : List [ str ] = [ \"facility_id\" , \"facility_name\" , \"booking_url\" ] RATE_CODE : str = \"INTERNET\" LODGING_RATES : str = \"rates\" LODGING_TITLE : str = \"title\" LODGING_BASE_PRICES : str = \"mins\" LODGING_OCCUPANCY_BASE : str = \"occupancyBase\" LODGING_OCCUPANCY_MAX : str = \"occupancyMax\" LODGING_ERROR_MESSAGE : str = \"message\" MINIMUM_POLLING_INTERVAL : int = 45 WEBUI_ALIAS_ENDPOINT : str = \"yellowstonenationalparklodges.com\" WEBUI_BASE_ENDPOINT : str = \"secure.yellowstonenationalparklodges.com\" WEBUI_BOOKING_PATH : str = \"booking/lodging-select\" YELLOWSTONE_RECREATION_AREA_ID : int = 1 YELLOWSTONE_RECREATION_AREA_NAME : str = \"Yellowstone\" YELLOWSTONE_RECREATION_AREA_FORMAL_NAME : str = \"Yellowstone National Park, USA\" YELLOWSTONE_LOOP_NAME : str = \"N/A\" CAMPSITE_AVAILABILITY_STATUS : str = \"Available\" YELLOWSTONE_CAMPGROUND_NAME_REPLACE : Tuple [ str , str ] = ( \"CG Internet Rate\" , \"Campground\" , ) YELLOWSTONE_TIMEZONE : str = \"America/Denver\" # LODGES: https://webapi.xanterra.net/v1/api/property/hotels/yellowstonenationalparklodges YELLOWSTONE_CAMPGROUNDS : Dict [ str , str ] = { \"YLYC:RV\" : \"Canyon Campground\" , \"YLYB:RV\" : \"Bridge Bay Campground\" , \"YLYG:RV\" : \"Grant Campground\" , \"YLYM:RV\" : \"Madison Campground\" , \"YLYF:RV\" : \"Fishing Bridge RV Park\" , } YELLOWSTONE_CAMPGROUND_OBJECTS : List [ CampgroundFacility ] = [] for key , value in YELLOWSTONE_CAMPGROUNDS . items (): YELLOWSTONE_CAMPGROUND_OBJECTS . append ( CampgroundFacility ( recreation_area_id = YELLOWSTONE_RECREATION_AREA_ID , recreation_area = YELLOWSTONE_RECREATION_AREA_FORMAL_NAME , facility_name = value , facility_id = str ( key ), ) )","title":"config"},{"location":"reference/config/#camply.config.CampsiteContainerFields","text":"String Variable Storage Class Source code in camply/config/data_columns.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class CampsiteContainerFields : \"\"\" String Variable Storage Class \"\"\" CAMPSITE_ID : str = \"campsite_id\" CAMPGROUND_ID : str = \"facility_id\" BOOKING_DATE : str = \"booking_date\" CAMPSITE_GROUP : str = \"campsite_group\" BOOKING_END_DATE : str = \"booking_end_date\" BOOKING_URL : str = \"booking_url\" PERMITTED_EQUIPMENT : str = \"permitted_equipment\" CAMPSITE_ATTRIBUTES : str = \"campsite_attributes\"","title":"CampsiteContainerFields"},{"location":"reference/config/#camply.config.DataColumns","text":"Variable Storage Class Source code in camply/config/data_columns.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class DataColumns : \"\"\" Variable Storage Class \"\"\" CAMPSITE_ID_COLUMN : str = \"campsite_code\" BOOKING_DATE_COLUMN : str = \"booking_date\" BOOKING_END_DATE_COLUMN : str = \"booking_end_date\" BOOKING_NIGHTS_COLUMN : str = \"booking_nights\" CAMPSITE_SITE_NAME_COLUMN : str = \"campsite_title\" CAMPSITE_TYPE_COLUMN : str = \"campsite_type\" CAMPSITE_OCCUPANCY_COLUMN : str = \"capacity\" CAMPSITE_USE_TYPE_COLUMN : str = \"campsite_type\" AVAILABILITY_STATUS_COLUMN : str = \"Available\" RECREATION_AREA_COLUMN : str = \"recreation_area\" FACILITY_NAME_COLUMN : str = \"facility_name\" FACILITY_ID_COLUMN : str = \"facility_id\" BOOKING_URL_COLUMN : str = \"booking_url\"","title":"DataColumns"},{"location":"reference/config/#camply.config.EmailConfig","text":"Email Notification Config Class Source code in camply/config/notification_config.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 class EmailConfig : \"\"\" Email Notification Config Class \"\"\" EMAIL_TO_ADDRESS : Optional [ str ] = getenv ( \"EMAIL_TO_ADDRESS\" , None ) DEFAULT_FROM_ADDRESS : str = \"camply@juftin.com\" EMAIL_FROM_ADDRESS : str = getenv ( \"EMAIL_FROM_ADDRESS\" , DEFAULT_FROM_ADDRESS ) DEFAULT_SUBJECT_LINE : str = \"Camply Notification\" EMAIL_SUBJECT_LINE : str = getenv ( \"EMAIL_SUBJECT_LINE\" , DEFAULT_SUBJECT_LINE ) DEFAULT_SMTP_SERVER : str = \"smtp.gmail.com\" EMAIL_SMTP_SERVER : str = getenv ( \"EMAIL_SMTP_SERVER\" , DEFAULT_SMTP_SERVER ) EMAIL_USERNAME : Optional [ str ] = getenv ( \"EMAIL_USERNAME\" , None ) EMAIL_PASSWORD : Optional [ str ] = getenv ( \"EMAIL_PASSWORD\" , None ) DEFAULT_SMTP_PORT : int = 465 EMAIL_SMTP_PORT : int = int ( getenv ( \"EMAIL_SMTP_PORT\" , DEFAULT_SMTP_PORT )) ENVIRONMENT_VARIABLE_NAMES : List [ str ] = [ \"EMAIL_TO_ADDRESS\" , \"EMAIL_USERNAME\" , \"EMAIL_PASSWORD\" , ] OPTIONAL_ENVIRONMENT_VARIABLE : List [ str ] = [ f \"EMAIL_SMTP_SERVER (default: { DEFAULT_SMTP_SERVER } )\" , f \"EMAIL_FROM_ADDRESS (default: { DEFAULT_FROM_ADDRESS } )\" , f 'EMAIL_SUBJECT_LINE (default: \" { DEFAULT_SUBJECT_LINE } \")' , f \"EMAIL_SMTP_PORT (default: { DEFAULT_SMTP_PORT } )\" , ]","title":"EmailConfig"},{"location":"reference/config/#camply.config.EquipmentOptions","text":"Bases: str , Enum Enumeration of the Equipment Options Source code in camply/config/search_config.py 22 23 24 25 26 27 28 29 30 31 32 33 class EquipmentOptions ( str , Enum ): \"\"\" Enumeration of the Equipment Options \"\"\" tent = \"tent\" rv = \"rv\" trailer = \"trailer\" vehicle = \"vehicle\" other = \"other\" __all_accepted_equipment__ = [ tent , rv , trailer , vehicle ]","title":"EquipmentOptions"},{"location":"reference/config/#camply.config.FileConfig","text":"File Path Storage Class Source code in camply/config/file_config.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class FileConfig : \"\"\" File Path Storage Class \"\"\" HOME_PATH = abspath ( Path . home ()) DOT_CAMPLY_FILE = join ( HOME_PATH , \".camply\" ) _file_config_file = Path ( abspath ( __file__ )) _config_dir = _file_config_file . parent CAMPLY_DIRECTORY = _config_dir . parent ROOT_DIRECTORY = CAMPLY_DIRECTORY . parent DOT_CAMPLY_FIELDS = OrderedDict ( PUSHOVER_PUSH_USER = dict ( default = \"\" , notes = \"Enables Pushover Notifications\" ), PUSHBULLET_API_TOKEN = dict ( default = \"\" , notes = \"Enables Pushbullet Notifications\" ), SLACK_WEBHOOK = dict ( default = \"\" , notes = \"Enables Slack Notifications\" ), TELEGRAM_BOT_TOKEN = dict ( default = \"\" , notes = \"Enables Telegram Notifications\" ), TELEGRAM_CHAT_ID = dict ( default = \"\" , notes = \"Telegram Notification will be sent here\" ), TWILIO_ACCOUNT_SID = dict ( default = \"\" , notes = \"Twilio Account SID\" ), TWILIO_AUTH_TOKEN = dict ( default = \"\" , notes = \"Twilio Auth Token\" ), TWILIO_SOURCE_NUMBER = dict ( default = \"\" , notes = \"Twilio Source number. E.164 format\" ), TWILIO_DEST_NUMBERS = dict ( default = \"\" , notes = \"Comma-separated list of phone numbers.\" ), EMAIL_TO_ADDRESS = dict ( default = \"\" , notes = \"Email Notifications will be sent here\" ), EMAIL_USERNAME = dict ( default = \"\" , notes = \"Email Authorization Login Username\" ), EMAIL_PASSWORD = dict ( default = \"\" , notes = \"Email Authorization Login Password\" ), EMAIL_SMTP_SERVER = dict ( default = \"smtp.gmail.com\" , notes = \"Email Authorization SMTP Server Address\" ), EMAIL_SMTP_PORT = dict ( default = 465 , notes = \"Email Authorization SMTP Server Port\" ), EMAIL_FROM_ADDRESS = dict ( default = \"camply@juftin.com\" , notes = \"Email Notifications Will Come From this Email\" , ), EMAIL_SUBJECT_LINE = dict ( default = \"Camply Notification\" , notes = \"Email Notifications Will Have This Subject Line\" , ), PUSHOVER_PUSH_TOKEN = dict ( default = \"\" , notes = \"Pushover Notifications From Your Custom App \" \"(not required)\" , ), RIDB_API_KEY = dict ( default = \"\" , notes = \"Personal Recreation.gov API Key (not required)\" ), )","title":"FileConfig"},{"location":"reference/config/#camply.config.PushbulletConfig","text":"Pushbullet Notification Config Class Source code in camply/config/notification_config.py 60 61 62 63 64 65 66 67 68 class PushbulletConfig : \"\"\" Pushbullet Notification Config Class \"\"\" PUSHBULLET_API_ENDPOINT : str = \"https://api.pushbullet.com/v2/pushes\" API_HEADERS : dict = { \"Content-Type\" : \"application/json\" } API_TOKEN = getenv ( \"PUSHBULLET_API_TOKEN\" , None )","title":"PushbulletConfig"},{"location":"reference/config/#camply.config.PushoverConfig","text":"Pushover Notification Config Class Source code in camply/config/notification_config.py 17 18 19 20 21 22 23 24 25 26 27 class PushoverConfig : \"\"\" Pushover Notification Config Class \"\"\" PUSHOVER_API_ENDPOINT : str = \"https://api.pushover.net/1/messages.json\" PUSHOVER_DEFAULT_API_TOKEN : bytes = b \"YWpjN3M1a2hhYTRlOG1zYWhncnFnaHduZGdtbmI3\" API_HEADERS : dict = { \"Content-Type\" : \"application/json\" } PUSH_TOKEN : str = getenv ( \"PUSHOVER_PUSH_TOKEN\" , None ) PUSH_USER : str = getenv ( \"PUSHOVER_PUSH_USER\" , None )","title":"PushoverConfig"},{"location":"reference/config/#camply.config.RIDBConfig","text":"RIDB API Configuration https://ridb.recreation.gov/docs Source code in camply/config/api_config.py 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 class RIDBConfig : \"\"\" RIDB API Configuration https://ridb.recreation.gov/docs \"\"\" _camply_ridb_service_account_api_token : bytes = ( b \"YTc0MTY0NzEtMWI1ZC00YTY0LWFkM2QtYTIzM2U3Y2I1YzQ0\" ) _api_key : Union [ str , bytes ] = getenv ( \"RIDB_API_KEY\" , _camply_ridb_service_account_api_token ) API_KEY = _camply_ridb_service_account_api_token if _api_key == \"\" else _api_key RIDB_SCHEME : str = \"https\" RIDB_NET_LOC : str = \"ridb.recreation.gov\" RIDB_BASE_PATH : str = \"api/v1/\" # FACILITIES_API_PATH FIELDS FACILITIES_API_PATH : str = \"facilities\" CAMPGROUND_FACILITY_FIELD_QUALIFIER : str = \"Campground\" # RECREATION AREA FIELDS REC_AREA_API_PATH : str = \"recareas\" # CAMPSITE DETAILS CAMPSITE_API_PATH : str = \"campsites\"","title":"RIDBConfig"},{"location":"reference/config/#camply.config.RecreationBookingConfig","text":"Variable Storage Class for Recreation.gov Booking API Source code in camply/config/api_config.py 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 class RecreationBookingConfig : \"\"\" Variable Storage Class for Recreation.gov Booking API \"\"\" API_SCHEME : str = \"https\" API_NET_LOC = \"www.recreation.gov\" API_BASE_PATH : str = \"api/camps/availability/campground/\" API_MONTH_PATH : str = \"month\" API_REFERRERS : dict = { \"Referer\" : \"https://www.recreation.gov/\" } CAMPSITE_UNAVAILABLE_STRINGS : list = [ \"Reserved\" , \"Not Available\" , \"Not Reservable\" , \"Not Reservable Management\" , \"Not Available Cutoff\" , \"Lottery\" , \"Open\" , \"NYR\" , ] CAMPSITE_LOCATION_LOOP_DEFAULT : str = \"Default Loop\" CAMPSITE_LOCATION_SITE_DEFAULT : str = \"Default Site\" CAMPSITE_BOOKING_URL : str = \"https://www.recreation.gov/camping/campsites\" RATE_LIMITING = ( 1.01 , 1.51 )","title":"RecreationBookingConfig"},{"location":"reference/config/#camply.config.SearchConfig","text":"File Path Storage Class Source code in camply/config/search_config.py 10 11 12 13 14 15 16 17 18 19 class SearchConfig : \"\"\" File Path Storage Class \"\"\" POLLING_INTERVAL_MINIMUM : int = 5 # 5 MINUTES RECOMMENDED_POLLING_INTERVAL : int = 10 # 10 MINUTES ERROR_MESSAGE : str = \"No search days configured. Exiting\" MINIMUM_CAMPSITES_FIRST_NOTIFY : int = 5 MAXIMUM_NOTIFICATION_BATCH_SIZE : int = 20","title":"SearchConfig"},{"location":"reference/config/#camply.config.SlackConfig","text":"Slack Notification Config Class Source code in camply/config/notification_config.py 83 84 85 86 87 88 class SlackConfig : \"\"\" Slack Notification Config Class \"\"\" SLACK_WEBHOOK : Optional [ str ] = getenv ( \"SLACK_WEBHOOK\" , None )","title":"SlackConfig"},{"location":"reference/config/#camply.config.TelegramConfig","text":"Telegram Notification Config Class Source code in camply/config/notification_config.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 class TelegramConfig : \"\"\" Telegram Notification Config Class \"\"\" BOT_TOKEN = getenv ( \"TELEGRAM_BOT_TOKEN\" , None ) CHAT_ID = getenv ( \"TELEGRAM_CHAT_ID\" , None ) API_ENDPOINT : str = f \"https://api.telegram.org/bot { BOT_TOKEN } /sendMessage\" API_HEADERS : dict = { \"Content-Type\" : \"application/json\" } API_CONTENT : dict = { \"chat_id\" : CHAT_ID , \"parse_mode\" : \"MarkdownV2\" , \"disable_web_page_preview\" : \"true\" , }","title":"TelegramConfig"},{"location":"reference/config/#camply.config.TwilioConfig","text":"Twilio Notification Config Class Source code in camply/config/notification_config.py 71 72 73 74 75 76 77 78 79 80 class TwilioConfig : \"\"\" Twilio Notification Config Class \"\"\" ACCOUNT_SID = getenv ( \"TWILIO_ACCOUNT_SID\" , None ) AUTH_TOKEN = getenv ( \"TWILIO_AUTH_TOKEN\" , None ) SOURCE_NUMBER = getenv ( \"TWILIO_SOURCE_NUMBER\" , None ) # comma separated set of phone numbers DEST_NUMBERS = getenv ( \"TWILIO_DEST_NUMBERS\" , None )","title":"TwilioConfig"},{"location":"reference/config/#camply.config.YellowstoneConfig","text":"Bases: DataColumns Variable Storage Class Source code in camply/config/yellowstone_config.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 class YellowstoneConfig ( DataColumns ): \"\"\" Variable Storage Class \"\"\" API_SCHEME : str = \"https\" API_BASE_ENDPOINT : str = \"webapi.xanterra.net\" API_BASE_PATH : str = \"v1/api\" LODGING_PATH : str = f \"/ { API_BASE_PATH } /availability/hotels\" YELLOWSTONE_PARK_PATH : str = \"yellowstonenationalparklodges\" YELLOWSTONE_LODGING_PATH : str = f \" { LODGING_PATH } / { YELLOWSTONE_PARK_PATH } \" CAMPSITE_AVAILABILITY : str = f \" { API_BASE_PATH } /availability/rooms\" YELLOWSTONE_CAMPSITE_AVAILABILITY : str = ( f \" { CAMPSITE_AVAILABILITY } / { YELLOWSTONE_PARK_PATH } \" ) YELLOWSTONE_PROPERTY_INFO : str = ( f \" { API_BASE_PATH } /property/rooms/ { YELLOWSTONE_PARK_PATH } \" ) API_REFERRERS : dict = { \"Host\" : \"webapi.xanterra.net\" , \"Origin\" : \"https://secure.yellowstonenationalparklodges.com\" , \"Referer\" : \"https://secure.yellowstonenationalparklodges.com/\" , } LODGING_CAMPGROUND_QUALIFIER : str = \":RV\" # JSON FILTERING BOOKING_AVAILABILITY : str = \"availability\" # DATAFRAME FILTERING FACILITY_ID : str = \"facility_id\" FACILITY_STATUS : str = \"status\" FACILITY_STATUS_QUALIFIER : str = \"OPEN\" FACILITY_ROOMS : str = \"rooms\" FACILITY_AVAILABLE_QUALIFIER : str = \"available\" FACILITY_HOTEL_CODE : str = \"hotelCode\" FACILITY_ROOM_CODE : str = \"roomCode\" FACILITY_PRICE : str = \"price\" FACILITY_TYPE : str = \"type\" CAMPSITE_DATA_COLUMNS : List [ str ] = [ \"facility_id\" , \"facility_name\" , \"booking_url\" ] RATE_CODE : str = \"INTERNET\" LODGING_RATES : str = \"rates\" LODGING_TITLE : str = \"title\" LODGING_BASE_PRICES : str = \"mins\" LODGING_OCCUPANCY_BASE : str = \"occupancyBase\" LODGING_OCCUPANCY_MAX : str = \"occupancyMax\" LODGING_ERROR_MESSAGE : str = \"message\" MINIMUM_POLLING_INTERVAL : int = 45 WEBUI_ALIAS_ENDPOINT : str = \"yellowstonenationalparklodges.com\" WEBUI_BASE_ENDPOINT : str = \"secure.yellowstonenationalparklodges.com\" WEBUI_BOOKING_PATH : str = \"booking/lodging-select\" YELLOWSTONE_RECREATION_AREA_ID : int = 1 YELLOWSTONE_RECREATION_AREA_NAME : str = \"Yellowstone\" YELLOWSTONE_RECREATION_AREA_FORMAL_NAME : str = \"Yellowstone National Park, USA\" YELLOWSTONE_LOOP_NAME : str = \"N/A\" CAMPSITE_AVAILABILITY_STATUS : str = \"Available\" YELLOWSTONE_CAMPGROUND_NAME_REPLACE : Tuple [ str , str ] = ( \"CG Internet Rate\" , \"Campground\" , ) YELLOWSTONE_TIMEZONE : str = \"America/Denver\" # LODGES: https://webapi.xanterra.net/v1/api/property/hotels/yellowstonenationalparklodges YELLOWSTONE_CAMPGROUNDS : Dict [ str , str ] = { \"YLYC:RV\" : \"Canyon Campground\" , \"YLYB:RV\" : \"Bridge Bay Campground\" , \"YLYG:RV\" : \"Grant Campground\" , \"YLYM:RV\" : \"Madison Campground\" , \"YLYF:RV\" : \"Fishing Bridge RV Park\" , } YELLOWSTONE_CAMPGROUND_OBJECTS : List [ CampgroundFacility ] = [] for key , value in YELLOWSTONE_CAMPGROUNDS . items (): YELLOWSTONE_CAMPGROUND_OBJECTS . append ( CampgroundFacility ( recreation_area_id = YELLOWSTONE_RECREATION_AREA_ID , recreation_area = YELLOWSTONE_RECREATION_AREA_FORMAL_NAME , facility_name = value , facility_id = str ( key ), ) )","title":"YellowstoneConfig"},{"location":"reference/config/api_config/","text":"API Searching Configuration RIDBConfig # RIDB API Configuration https://ridb.recreation.gov/docs Source code in camply/config/api_config.py 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 class RIDBConfig : \"\"\" RIDB API Configuration https://ridb.recreation.gov/docs \"\"\" _camply_ridb_service_account_api_token : bytes = ( b \"YTc0MTY0NzEtMWI1ZC00YTY0LWFkM2QtYTIzM2U3Y2I1YzQ0\" ) _api_key : Union [ str , bytes ] = getenv ( \"RIDB_API_KEY\" , _camply_ridb_service_account_api_token ) API_KEY = _camply_ridb_service_account_api_token if _api_key == \"\" else _api_key RIDB_SCHEME : str = \"https\" RIDB_NET_LOC : str = \"ridb.recreation.gov\" RIDB_BASE_PATH : str = \"api/v1/\" # FACILITIES_API_PATH FIELDS FACILITIES_API_PATH : str = \"facilities\" CAMPGROUND_FACILITY_FIELD_QUALIFIER : str = \"Campground\" # RECREATION AREA FIELDS REC_AREA_API_PATH : str = \"recareas\" # CAMPSITE DETAILS CAMPSITE_API_PATH : str = \"campsites\" RecreationBookingConfig # Variable Storage Class for Recreation.gov Booking API Source code in camply/config/api_config.py 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 class RecreationBookingConfig : \"\"\" Variable Storage Class for Recreation.gov Booking API \"\"\" API_SCHEME : str = \"https\" API_NET_LOC = \"www.recreation.gov\" API_BASE_PATH : str = \"api/camps/availability/campground/\" API_MONTH_PATH : str = \"month\" API_REFERRERS : dict = { \"Referer\" : \"https://www.recreation.gov/\" } CAMPSITE_UNAVAILABLE_STRINGS : list = [ \"Reserved\" , \"Not Available\" , \"Not Reservable\" , \"Not Reservable Management\" , \"Not Available Cutoff\" , \"Lottery\" , \"Open\" , \"NYR\" , ] CAMPSITE_LOCATION_LOOP_DEFAULT : str = \"Default Loop\" CAMPSITE_LOCATION_SITE_DEFAULT : str = \"Default Site\" CAMPSITE_BOOKING_URL : str = \"https://www.recreation.gov/camping/campsites\" RATE_LIMITING = ( 1.01 , 1.51 )","title":"api_config"},{"location":"reference/config/api_config/#camply.config.api_config.RIDBConfig","text":"RIDB API Configuration https://ridb.recreation.gov/docs Source code in camply/config/api_config.py 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 class RIDBConfig : \"\"\" RIDB API Configuration https://ridb.recreation.gov/docs \"\"\" _camply_ridb_service_account_api_token : bytes = ( b \"YTc0MTY0NzEtMWI1ZC00YTY0LWFkM2QtYTIzM2U3Y2I1YzQ0\" ) _api_key : Union [ str , bytes ] = getenv ( \"RIDB_API_KEY\" , _camply_ridb_service_account_api_token ) API_KEY = _camply_ridb_service_account_api_token if _api_key == \"\" else _api_key RIDB_SCHEME : str = \"https\" RIDB_NET_LOC : str = \"ridb.recreation.gov\" RIDB_BASE_PATH : str = \"api/v1/\" # FACILITIES_API_PATH FIELDS FACILITIES_API_PATH : str = \"facilities\" CAMPGROUND_FACILITY_FIELD_QUALIFIER : str = \"Campground\" # RECREATION AREA FIELDS REC_AREA_API_PATH : str = \"recareas\" # CAMPSITE DETAILS CAMPSITE_API_PATH : str = \"campsites\"","title":"RIDBConfig"},{"location":"reference/config/api_config/#camply.config.api_config.RecreationBookingConfig","text":"Variable Storage Class for Recreation.gov Booking API Source code in camply/config/api_config.py 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 class RecreationBookingConfig : \"\"\" Variable Storage Class for Recreation.gov Booking API \"\"\" API_SCHEME : str = \"https\" API_NET_LOC = \"www.recreation.gov\" API_BASE_PATH : str = \"api/camps/availability/campground/\" API_MONTH_PATH : str = \"month\" API_REFERRERS : dict = { \"Referer\" : \"https://www.recreation.gov/\" } CAMPSITE_UNAVAILABLE_STRINGS : list = [ \"Reserved\" , \"Not Available\" , \"Not Reservable\" , \"Not Reservable Management\" , \"Not Available Cutoff\" , \"Lottery\" , \"Open\" , \"NYR\" , ] CAMPSITE_LOCATION_LOOP_DEFAULT : str = \"Default Loop\" CAMPSITE_LOCATION_SITE_DEFAULT : str = \"Default Site\" CAMPSITE_BOOKING_URL : str = \"https://www.recreation.gov/camping/campsites\" RATE_LIMITING = ( 1.01 , 1.51 )","title":"RecreationBookingConfig"},{"location":"reference/config/data_columns/","text":"Project Configuration for Data Variable Labels CampsiteContainerFields # String Variable Storage Class Source code in camply/config/data_columns.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class CampsiteContainerFields : \"\"\" String Variable Storage Class \"\"\" CAMPSITE_ID : str = \"campsite_id\" CAMPGROUND_ID : str = \"facility_id\" BOOKING_DATE : str = \"booking_date\" CAMPSITE_GROUP : str = \"campsite_group\" BOOKING_END_DATE : str = \"booking_end_date\" BOOKING_URL : str = \"booking_url\" PERMITTED_EQUIPMENT : str = \"permitted_equipment\" CAMPSITE_ATTRIBUTES : str = \"campsite_attributes\" DataColumns # Variable Storage Class Source code in camply/config/data_columns.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class DataColumns : \"\"\" Variable Storage Class \"\"\" CAMPSITE_ID_COLUMN : str = \"campsite_code\" BOOKING_DATE_COLUMN : str = \"booking_date\" BOOKING_END_DATE_COLUMN : str = \"booking_end_date\" BOOKING_NIGHTS_COLUMN : str = \"booking_nights\" CAMPSITE_SITE_NAME_COLUMN : str = \"campsite_title\" CAMPSITE_TYPE_COLUMN : str = \"campsite_type\" CAMPSITE_OCCUPANCY_COLUMN : str = \"capacity\" CAMPSITE_USE_TYPE_COLUMN : str = \"campsite_type\" AVAILABILITY_STATUS_COLUMN : str = \"Available\" RECREATION_AREA_COLUMN : str = \"recreation_area\" FACILITY_NAME_COLUMN : str = \"facility_name\" FACILITY_ID_COLUMN : str = \"facility_id\" BOOKING_URL_COLUMN : str = \"booking_url\"","title":"data_columns"},{"location":"reference/config/data_columns/#camply.config.data_columns.CampsiteContainerFields","text":"String Variable Storage Class Source code in camply/config/data_columns.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class CampsiteContainerFields : \"\"\" String Variable Storage Class \"\"\" CAMPSITE_ID : str = \"campsite_id\" CAMPGROUND_ID : str = \"facility_id\" BOOKING_DATE : str = \"booking_date\" CAMPSITE_GROUP : str = \"campsite_group\" BOOKING_END_DATE : str = \"booking_end_date\" BOOKING_URL : str = \"booking_url\" PERMITTED_EQUIPMENT : str = \"permitted_equipment\" CAMPSITE_ATTRIBUTES : str = \"campsite_attributes\"","title":"CampsiteContainerFields"},{"location":"reference/config/data_columns/#camply.config.data_columns.DataColumns","text":"Variable Storage Class Source code in camply/config/data_columns.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class DataColumns : \"\"\" Variable Storage Class \"\"\" CAMPSITE_ID_COLUMN : str = \"campsite_code\" BOOKING_DATE_COLUMN : str = \"booking_date\" BOOKING_END_DATE_COLUMN : str = \"booking_end_date\" BOOKING_NIGHTS_COLUMN : str = \"booking_nights\" CAMPSITE_SITE_NAME_COLUMN : str = \"campsite_title\" CAMPSITE_TYPE_COLUMN : str = \"campsite_type\" CAMPSITE_OCCUPANCY_COLUMN : str = \"capacity\" CAMPSITE_USE_TYPE_COLUMN : str = \"campsite_type\" AVAILABILITY_STATUS_COLUMN : str = \"Available\" RECREATION_AREA_COLUMN : str = \"recreation_area\" FACILITY_NAME_COLUMN : str = \"facility_name\" FACILITY_ID_COLUMN : str = \"facility_id\" BOOKING_URL_COLUMN : str = \"booking_url\"","title":"DataColumns"},{"location":"reference/config/file_config/","text":"Project Configuration for Yellowstone Variables FileConfig # File Path Storage Class Source code in camply/config/file_config.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class FileConfig : \"\"\" File Path Storage Class \"\"\" HOME_PATH = abspath ( Path . home ()) DOT_CAMPLY_FILE = join ( HOME_PATH , \".camply\" ) _file_config_file = Path ( abspath ( __file__ )) _config_dir = _file_config_file . parent CAMPLY_DIRECTORY = _config_dir . parent ROOT_DIRECTORY = CAMPLY_DIRECTORY . parent DOT_CAMPLY_FIELDS = OrderedDict ( PUSHOVER_PUSH_USER = dict ( default = \"\" , notes = \"Enables Pushover Notifications\" ), PUSHBULLET_API_TOKEN = dict ( default = \"\" , notes = \"Enables Pushbullet Notifications\" ), SLACK_WEBHOOK = dict ( default = \"\" , notes = \"Enables Slack Notifications\" ), TELEGRAM_BOT_TOKEN = dict ( default = \"\" , notes = \"Enables Telegram Notifications\" ), TELEGRAM_CHAT_ID = dict ( default = \"\" , notes = \"Telegram Notification will be sent here\" ), TWILIO_ACCOUNT_SID = dict ( default = \"\" , notes = \"Twilio Account SID\" ), TWILIO_AUTH_TOKEN = dict ( default = \"\" , notes = \"Twilio Auth Token\" ), TWILIO_SOURCE_NUMBER = dict ( default = \"\" , notes = \"Twilio Source number. E.164 format\" ), TWILIO_DEST_NUMBERS = dict ( default = \"\" , notes = \"Comma-separated list of phone numbers.\" ), EMAIL_TO_ADDRESS = dict ( default = \"\" , notes = \"Email Notifications will be sent here\" ), EMAIL_USERNAME = dict ( default = \"\" , notes = \"Email Authorization Login Username\" ), EMAIL_PASSWORD = dict ( default = \"\" , notes = \"Email Authorization Login Password\" ), EMAIL_SMTP_SERVER = dict ( default = \"smtp.gmail.com\" , notes = \"Email Authorization SMTP Server Address\" ), EMAIL_SMTP_PORT = dict ( default = 465 , notes = \"Email Authorization SMTP Server Port\" ), EMAIL_FROM_ADDRESS = dict ( default = \"camply@juftin.com\" , notes = \"Email Notifications Will Come From this Email\" , ), EMAIL_SUBJECT_LINE = dict ( default = \"Camply Notification\" , notes = \"Email Notifications Will Have This Subject Line\" , ), PUSHOVER_PUSH_TOKEN = dict ( default = \"\" , notes = \"Pushover Notifications From Your Custom App \" \"(not required)\" , ), RIDB_API_KEY = dict ( default = \"\" , notes = \"Personal Recreation.gov API Key (not required)\" ), )","title":"file_config"},{"location":"reference/config/file_config/#camply.config.file_config.FileConfig","text":"File Path Storage Class Source code in camply/config/file_config.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class FileConfig : \"\"\" File Path Storage Class \"\"\" HOME_PATH = abspath ( Path . home ()) DOT_CAMPLY_FILE = join ( HOME_PATH , \".camply\" ) _file_config_file = Path ( abspath ( __file__ )) _config_dir = _file_config_file . parent CAMPLY_DIRECTORY = _config_dir . parent ROOT_DIRECTORY = CAMPLY_DIRECTORY . parent DOT_CAMPLY_FIELDS = OrderedDict ( PUSHOVER_PUSH_USER = dict ( default = \"\" , notes = \"Enables Pushover Notifications\" ), PUSHBULLET_API_TOKEN = dict ( default = \"\" , notes = \"Enables Pushbullet Notifications\" ), SLACK_WEBHOOK = dict ( default = \"\" , notes = \"Enables Slack Notifications\" ), TELEGRAM_BOT_TOKEN = dict ( default = \"\" , notes = \"Enables Telegram Notifications\" ), TELEGRAM_CHAT_ID = dict ( default = \"\" , notes = \"Telegram Notification will be sent here\" ), TWILIO_ACCOUNT_SID = dict ( default = \"\" , notes = \"Twilio Account SID\" ), TWILIO_AUTH_TOKEN = dict ( default = \"\" , notes = \"Twilio Auth Token\" ), TWILIO_SOURCE_NUMBER = dict ( default = \"\" , notes = \"Twilio Source number. E.164 format\" ), TWILIO_DEST_NUMBERS = dict ( default = \"\" , notes = \"Comma-separated list of phone numbers.\" ), EMAIL_TO_ADDRESS = dict ( default = \"\" , notes = \"Email Notifications will be sent here\" ), EMAIL_USERNAME = dict ( default = \"\" , notes = \"Email Authorization Login Username\" ), EMAIL_PASSWORD = dict ( default = \"\" , notes = \"Email Authorization Login Password\" ), EMAIL_SMTP_SERVER = dict ( default = \"smtp.gmail.com\" , notes = \"Email Authorization SMTP Server Address\" ), EMAIL_SMTP_PORT = dict ( default = 465 , notes = \"Email Authorization SMTP Server Port\" ), EMAIL_FROM_ADDRESS = dict ( default = \"camply@juftin.com\" , notes = \"Email Notifications Will Come From this Email\" , ), EMAIL_SUBJECT_LINE = dict ( default = \"Camply Notification\" , notes = \"Email Notifications Will Have This Subject Line\" , ), PUSHOVER_PUSH_TOKEN = dict ( default = \"\" , notes = \"Pushover Notifications From Your Custom App \" \"(not required)\" , ), RIDB_API_KEY = dict ( default = \"\" , notes = \"Personal Recreation.gov API Key (not required)\" ), )","title":"FileConfig"},{"location":"reference/config/logging_config/","text":"Dynamic Logging Configuration get_log_handler ( log_level = None ) # Determine which logging handler should be used Parameters # Optional[int] Which logging level should be used. If none is provided the LOG_LEVEL environment variable will be used, defaulting to \"INFO\". Returns # Tuple[logging.Handler, Union[int, str]] Source code in camply/config/logging_config.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def get_log_handler ( log_level : Optional [ int ] = None , ) -> Tuple [ logging . Handler , Union [ int , str ]]: \"\"\" Determine which logging handler should be used Parameters ---------- log_level: Optional[int] Which logging level should be used. If none is provided the LOG_LEVEL environment variable will be used, defaulting to \"INFO\". Returns ------- Tuple[logging.Handler, Union[int, str]] \"\"\" if log_level is None : log_level = logging . getLevelName ( getenv ( \"LOG_LEVEL\" , \"INFO\" ) . upper ()) rich_handler = RichHandler ( level = log_level , rich_tracebacks = True , omit_repeated_times = False , show_path = False , ) python_handler = logging . StreamHandler () python_formatter = logging . Formatter ( \" %(asctime)s [ %(levelname)8s ]: %(message)s \" ) python_handler . setFormatter ( python_formatter ) python_handler . setLevel ( log_level ) _log_dict = { \"rich\" : rich_handler , \"python\" : python_handler , } log_handler_name = os . getenv ( \"CAMPLY_LOG_HANDLER\" , \"rich\" ) log_handler : logging . Handler = _log_dict . get ( log_handler_name . lower (), rich_handler ) return log_handler , log_level set_up_logging ( log_level = None ) # Set Up a Root Logger Parameters # Optional[int] Which logging level should be used. If none is provided the LOG_LEVEL environment variable will be used, defaulting to \"INFO\". Source code in camply/config/logging_config.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def set_up_logging ( log_level : Optional [ int ] = None ) -> None : \"\"\" Set Up a Root Logger Parameters ---------- log_level: Optional[int] Which logging level should be used. If none is provided the LOG_LEVEL environment variable will be used, defaulting to \"INFO\". \"\"\" log_handler , level_to_log = get_log_handler ( log_level = log_level ) logging . root . handlers = [ log_handler ] if isinstance ( log_handler , RichHandler ): rich_formatter = logging . Formatter ( datefmt = \"[%Y-%m- %d %H:%M:%S]\" , fmt = \" %(message)s \" ) logging . root . handlers [ 0 ] . setFormatter ( rich_formatter ) level_to_log = logging . NOTSET logging . root . setLevel ( level_to_log )","title":"logging_config"},{"location":"reference/config/logging_config/#camply.config.logging_config.get_log_handler","text":"Determine which logging handler should be used","title":"get_log_handler()"},{"location":"reference/config/logging_config/#camply.config.logging_config.get_log_handler--parameters","text":"Optional[int] Which logging level should be used. If none is provided the LOG_LEVEL environment variable will be used, defaulting to \"INFO\".","title":"Parameters"},{"location":"reference/config/logging_config/#camply.config.logging_config.get_log_handler--returns","text":"Tuple[logging.Handler, Union[int, str]] Source code in camply/config/logging_config.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def get_log_handler ( log_level : Optional [ int ] = None , ) -> Tuple [ logging . Handler , Union [ int , str ]]: \"\"\" Determine which logging handler should be used Parameters ---------- log_level: Optional[int] Which logging level should be used. If none is provided the LOG_LEVEL environment variable will be used, defaulting to \"INFO\". Returns ------- Tuple[logging.Handler, Union[int, str]] \"\"\" if log_level is None : log_level = logging . getLevelName ( getenv ( \"LOG_LEVEL\" , \"INFO\" ) . upper ()) rich_handler = RichHandler ( level = log_level , rich_tracebacks = True , omit_repeated_times = False , show_path = False , ) python_handler = logging . StreamHandler () python_formatter = logging . Formatter ( \" %(asctime)s [ %(levelname)8s ]: %(message)s \" ) python_handler . setFormatter ( python_formatter ) python_handler . setLevel ( log_level ) _log_dict = { \"rich\" : rich_handler , \"python\" : python_handler , } log_handler_name = os . getenv ( \"CAMPLY_LOG_HANDLER\" , \"rich\" ) log_handler : logging . Handler = _log_dict . get ( log_handler_name . lower (), rich_handler ) return log_handler , log_level","title":"Returns"},{"location":"reference/config/logging_config/#camply.config.logging_config.set_up_logging","text":"Set Up a Root Logger","title":"set_up_logging()"},{"location":"reference/config/logging_config/#camply.config.logging_config.set_up_logging--parameters","text":"Optional[int] Which logging level should be used. If none is provided the LOG_LEVEL environment variable will be used, defaulting to \"INFO\". Source code in camply/config/logging_config.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def set_up_logging ( log_level : Optional [ int ] = None ) -> None : \"\"\" Set Up a Root Logger Parameters ---------- log_level: Optional[int] Which logging level should be used. If none is provided the LOG_LEVEL environment variable will be used, defaulting to \"INFO\". \"\"\" log_handler , level_to_log = get_log_handler ( log_level = log_level ) logging . root . handlers = [ log_handler ] if isinstance ( log_handler , RichHandler ): rich_formatter = logging . Formatter ( datefmt = \"[%Y-%m- %d %H:%M:%S]\" , fmt = \" %(message)s \" ) logging . root . handlers [ 0 ] . setFormatter ( rich_formatter ) level_to_log = logging . NOTSET logging . root . setLevel ( level_to_log )","title":"Parameters"},{"location":"reference/config/notification_config/","text":"Project Configuration for Pushover Variables EmailConfig # Email Notification Config Class Source code in camply/config/notification_config.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 class EmailConfig : \"\"\" Email Notification Config Class \"\"\" EMAIL_TO_ADDRESS : Optional [ str ] = getenv ( \"EMAIL_TO_ADDRESS\" , None ) DEFAULT_FROM_ADDRESS : str = \"camply@juftin.com\" EMAIL_FROM_ADDRESS : str = getenv ( \"EMAIL_FROM_ADDRESS\" , DEFAULT_FROM_ADDRESS ) DEFAULT_SUBJECT_LINE : str = \"Camply Notification\" EMAIL_SUBJECT_LINE : str = getenv ( \"EMAIL_SUBJECT_LINE\" , DEFAULT_SUBJECT_LINE ) DEFAULT_SMTP_SERVER : str = \"smtp.gmail.com\" EMAIL_SMTP_SERVER : str = getenv ( \"EMAIL_SMTP_SERVER\" , DEFAULT_SMTP_SERVER ) EMAIL_USERNAME : Optional [ str ] = getenv ( \"EMAIL_USERNAME\" , None ) EMAIL_PASSWORD : Optional [ str ] = getenv ( \"EMAIL_PASSWORD\" , None ) DEFAULT_SMTP_PORT : int = 465 EMAIL_SMTP_PORT : int = int ( getenv ( \"EMAIL_SMTP_PORT\" , DEFAULT_SMTP_PORT )) ENVIRONMENT_VARIABLE_NAMES : List [ str ] = [ \"EMAIL_TO_ADDRESS\" , \"EMAIL_USERNAME\" , \"EMAIL_PASSWORD\" , ] OPTIONAL_ENVIRONMENT_VARIABLE : List [ str ] = [ f \"EMAIL_SMTP_SERVER (default: { DEFAULT_SMTP_SERVER } )\" , f \"EMAIL_FROM_ADDRESS (default: { DEFAULT_FROM_ADDRESS } )\" , f 'EMAIL_SUBJECT_LINE (default: \" { DEFAULT_SUBJECT_LINE } \")' , f \"EMAIL_SMTP_PORT (default: { DEFAULT_SMTP_PORT } )\" , ] PushbulletConfig # Pushbullet Notification Config Class Source code in camply/config/notification_config.py 60 61 62 63 64 65 66 67 68 class PushbulletConfig : \"\"\" Pushbullet Notification Config Class \"\"\" PUSHBULLET_API_ENDPOINT : str = \"https://api.pushbullet.com/v2/pushes\" API_HEADERS : dict = { \"Content-Type\" : \"application/json\" } API_TOKEN = getenv ( \"PUSHBULLET_API_TOKEN\" , None ) PushoverConfig # Pushover Notification Config Class Source code in camply/config/notification_config.py 17 18 19 20 21 22 23 24 25 26 27 class PushoverConfig : \"\"\" Pushover Notification Config Class \"\"\" PUSHOVER_API_ENDPOINT : str = \"https://api.pushover.net/1/messages.json\" PUSHOVER_DEFAULT_API_TOKEN : bytes = b \"YWpjN3M1a2hhYTRlOG1zYWhncnFnaHduZGdtbmI3\" API_HEADERS : dict = { \"Content-Type\" : \"application/json\" } PUSH_TOKEN : str = getenv ( \"PUSHOVER_PUSH_TOKEN\" , None ) PUSH_USER : str = getenv ( \"PUSHOVER_PUSH_USER\" , None ) SlackConfig # Slack Notification Config Class Source code in camply/config/notification_config.py 83 84 85 86 87 88 class SlackConfig : \"\"\" Slack Notification Config Class \"\"\" SLACK_WEBHOOK : Optional [ str ] = getenv ( \"SLACK_WEBHOOK\" , None ) TelegramConfig # Telegram Notification Config Class Source code in camply/config/notification_config.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 class TelegramConfig : \"\"\" Telegram Notification Config Class \"\"\" BOT_TOKEN = getenv ( \"TELEGRAM_BOT_TOKEN\" , None ) CHAT_ID = getenv ( \"TELEGRAM_CHAT_ID\" , None ) API_ENDPOINT : str = f \"https://api.telegram.org/bot { BOT_TOKEN } /sendMessage\" API_HEADERS : dict = { \"Content-Type\" : \"application/json\" } API_CONTENT : dict = { \"chat_id\" : CHAT_ID , \"parse_mode\" : \"MarkdownV2\" , \"disable_web_page_preview\" : \"true\" , } TwilioConfig # Twilio Notification Config Class Source code in camply/config/notification_config.py 71 72 73 74 75 76 77 78 79 80 class TwilioConfig : \"\"\" Twilio Notification Config Class \"\"\" ACCOUNT_SID = getenv ( \"TWILIO_ACCOUNT_SID\" , None ) AUTH_TOKEN = getenv ( \"TWILIO_AUTH_TOKEN\" , None ) SOURCE_NUMBER = getenv ( \"TWILIO_SOURCE_NUMBER\" , None ) # comma separated set of phone numbers DEST_NUMBERS = getenv ( \"TWILIO_DEST_NUMBERS\" , None )","title":"notification_config"},{"location":"reference/config/notification_config/#camply.config.notification_config.EmailConfig","text":"Email Notification Config Class Source code in camply/config/notification_config.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 class EmailConfig : \"\"\" Email Notification Config Class \"\"\" EMAIL_TO_ADDRESS : Optional [ str ] = getenv ( \"EMAIL_TO_ADDRESS\" , None ) DEFAULT_FROM_ADDRESS : str = \"camply@juftin.com\" EMAIL_FROM_ADDRESS : str = getenv ( \"EMAIL_FROM_ADDRESS\" , DEFAULT_FROM_ADDRESS ) DEFAULT_SUBJECT_LINE : str = \"Camply Notification\" EMAIL_SUBJECT_LINE : str = getenv ( \"EMAIL_SUBJECT_LINE\" , DEFAULT_SUBJECT_LINE ) DEFAULT_SMTP_SERVER : str = \"smtp.gmail.com\" EMAIL_SMTP_SERVER : str = getenv ( \"EMAIL_SMTP_SERVER\" , DEFAULT_SMTP_SERVER ) EMAIL_USERNAME : Optional [ str ] = getenv ( \"EMAIL_USERNAME\" , None ) EMAIL_PASSWORD : Optional [ str ] = getenv ( \"EMAIL_PASSWORD\" , None ) DEFAULT_SMTP_PORT : int = 465 EMAIL_SMTP_PORT : int = int ( getenv ( \"EMAIL_SMTP_PORT\" , DEFAULT_SMTP_PORT )) ENVIRONMENT_VARIABLE_NAMES : List [ str ] = [ \"EMAIL_TO_ADDRESS\" , \"EMAIL_USERNAME\" , \"EMAIL_PASSWORD\" , ] OPTIONAL_ENVIRONMENT_VARIABLE : List [ str ] = [ f \"EMAIL_SMTP_SERVER (default: { DEFAULT_SMTP_SERVER } )\" , f \"EMAIL_FROM_ADDRESS (default: { DEFAULT_FROM_ADDRESS } )\" , f 'EMAIL_SUBJECT_LINE (default: \" { DEFAULT_SUBJECT_LINE } \")' , f \"EMAIL_SMTP_PORT (default: { DEFAULT_SMTP_PORT } )\" , ]","title":"EmailConfig"},{"location":"reference/config/notification_config/#camply.config.notification_config.PushbulletConfig","text":"Pushbullet Notification Config Class Source code in camply/config/notification_config.py 60 61 62 63 64 65 66 67 68 class PushbulletConfig : \"\"\" Pushbullet Notification Config Class \"\"\" PUSHBULLET_API_ENDPOINT : str = \"https://api.pushbullet.com/v2/pushes\" API_HEADERS : dict = { \"Content-Type\" : \"application/json\" } API_TOKEN = getenv ( \"PUSHBULLET_API_TOKEN\" , None )","title":"PushbulletConfig"},{"location":"reference/config/notification_config/#camply.config.notification_config.PushoverConfig","text":"Pushover Notification Config Class Source code in camply/config/notification_config.py 17 18 19 20 21 22 23 24 25 26 27 class PushoverConfig : \"\"\" Pushover Notification Config Class \"\"\" PUSHOVER_API_ENDPOINT : str = \"https://api.pushover.net/1/messages.json\" PUSHOVER_DEFAULT_API_TOKEN : bytes = b \"YWpjN3M1a2hhYTRlOG1zYWhncnFnaHduZGdtbmI3\" API_HEADERS : dict = { \"Content-Type\" : \"application/json\" } PUSH_TOKEN : str = getenv ( \"PUSHOVER_PUSH_TOKEN\" , None ) PUSH_USER : str = getenv ( \"PUSHOVER_PUSH_USER\" , None )","title":"PushoverConfig"},{"location":"reference/config/notification_config/#camply.config.notification_config.SlackConfig","text":"Slack Notification Config Class Source code in camply/config/notification_config.py 83 84 85 86 87 88 class SlackConfig : \"\"\" Slack Notification Config Class \"\"\" SLACK_WEBHOOK : Optional [ str ] = getenv ( \"SLACK_WEBHOOK\" , None )","title":"SlackConfig"},{"location":"reference/config/notification_config/#camply.config.notification_config.TelegramConfig","text":"Telegram Notification Config Class Source code in camply/config/notification_config.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 class TelegramConfig : \"\"\" Telegram Notification Config Class \"\"\" BOT_TOKEN = getenv ( \"TELEGRAM_BOT_TOKEN\" , None ) CHAT_ID = getenv ( \"TELEGRAM_CHAT_ID\" , None ) API_ENDPOINT : str = f \"https://api.telegram.org/bot { BOT_TOKEN } /sendMessage\" API_HEADERS : dict = { \"Content-Type\" : \"application/json\" } API_CONTENT : dict = { \"chat_id\" : CHAT_ID , \"parse_mode\" : \"MarkdownV2\" , \"disable_web_page_preview\" : \"true\" , }","title":"TelegramConfig"},{"location":"reference/config/notification_config/#camply.config.notification_config.TwilioConfig","text":"Twilio Notification Config Class Source code in camply/config/notification_config.py 71 72 73 74 75 76 77 78 79 80 class TwilioConfig : \"\"\" Twilio Notification Config Class \"\"\" ACCOUNT_SID = getenv ( \"TWILIO_ACCOUNT_SID\" , None ) AUTH_TOKEN = getenv ( \"TWILIO_AUTH_TOKEN\" , None ) SOURCE_NUMBER = getenv ( \"TWILIO_SOURCE_NUMBER\" , None ) # comma separated set of phone numbers DEST_NUMBERS = getenv ( \"TWILIO_DEST_NUMBERS\" , None )","title":"TwilioConfig"},{"location":"reference/config/search_config/","text":"Project Configuration for Yellowstone Variables EquipmentConfig # Campsite Equipment Configuration Source code in camply/config/search_config.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 class EquipmentConfig : \"\"\" Campsite Equipment Configuration \"\"\" EQUIPMENT_MAPPING = OrderedDict () EQUIPMENT_MAPPING [ EquipmentOptions . tent ] = [ \"Tent\" , \"Large Tent Over 9X12\" , r \"Large Tent Over 9X12`\" , \"Small Tent\" , ] EQUIPMENT_MAPPING [ EquipmentOptions . rv ] = [ \"RV\" , \"Pop up\" , \"Caravan/Camper Van\" , \"RV/Motorhome\" , \"Fifth Wheel\" , ] EQUIPMENT_MAPPING [ EquipmentOptions . trailer ] = [ \"Trailer\" ] EQUIPMENT_MAPPING [ EquipmentOptions . vehicle ] = [ \"Pickup Camper\" , \"Vehicle\" , \"Car\" , ] EQUIPMENT_MAPPING [ EquipmentOptions . other ] = [ \"Hammock\" , \"Horse\" , \"Boat\" , \"\" ] EQUIPMENT_REVERSE_MAPPING : Dict [ str , str ] = {} for key , list_of_values in EQUIPMENT_MAPPING . items (): for value in list_of_values : EQUIPMENT_REVERSE_MAPPING [ value ] = key EquipmentOptions # Bases: str , Enum Enumeration of the Equipment Options Source code in camply/config/search_config.py 22 23 24 25 26 27 28 29 30 31 32 33 class EquipmentOptions ( str , Enum ): \"\"\" Enumeration of the Equipment Options \"\"\" tent = \"tent\" rv = \"rv\" trailer = \"trailer\" vehicle = \"vehicle\" other = \"other\" __all_accepted_equipment__ = [ tent , rv , trailer , vehicle ] SearchConfig # File Path Storage Class Source code in camply/config/search_config.py 10 11 12 13 14 15 16 17 18 19 class SearchConfig : \"\"\" File Path Storage Class \"\"\" POLLING_INTERVAL_MINIMUM : int = 5 # 5 MINUTES RECOMMENDED_POLLING_INTERVAL : int = 10 # 10 MINUTES ERROR_MESSAGE : str = \"No search days configured. Exiting\" MINIMUM_CAMPSITES_FIRST_NOTIFY : int = 5 MAXIMUM_NOTIFICATION_BATCH_SIZE : int = 20","title":"search_config"},{"location":"reference/config/search_config/#camply.config.search_config.EquipmentConfig","text":"Campsite Equipment Configuration Source code in camply/config/search_config.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 class EquipmentConfig : \"\"\" Campsite Equipment Configuration \"\"\" EQUIPMENT_MAPPING = OrderedDict () EQUIPMENT_MAPPING [ EquipmentOptions . tent ] = [ \"Tent\" , \"Large Tent Over 9X12\" , r \"Large Tent Over 9X12`\" , \"Small Tent\" , ] EQUIPMENT_MAPPING [ EquipmentOptions . rv ] = [ \"RV\" , \"Pop up\" , \"Caravan/Camper Van\" , \"RV/Motorhome\" , \"Fifth Wheel\" , ] EQUIPMENT_MAPPING [ EquipmentOptions . trailer ] = [ \"Trailer\" ] EQUIPMENT_MAPPING [ EquipmentOptions . vehicle ] = [ \"Pickup Camper\" , \"Vehicle\" , \"Car\" , ] EQUIPMENT_MAPPING [ EquipmentOptions . other ] = [ \"Hammock\" , \"Horse\" , \"Boat\" , \"\" ] EQUIPMENT_REVERSE_MAPPING : Dict [ str , str ] = {} for key , list_of_values in EQUIPMENT_MAPPING . items (): for value in list_of_values : EQUIPMENT_REVERSE_MAPPING [ value ] = key","title":"EquipmentConfig"},{"location":"reference/config/search_config/#camply.config.search_config.EquipmentOptions","text":"Bases: str , Enum Enumeration of the Equipment Options Source code in camply/config/search_config.py 22 23 24 25 26 27 28 29 30 31 32 33 class EquipmentOptions ( str , Enum ): \"\"\" Enumeration of the Equipment Options \"\"\" tent = \"tent\" rv = \"rv\" trailer = \"trailer\" vehicle = \"vehicle\" other = \"other\" __all_accepted_equipment__ = [ tent , rv , trailer , vehicle ]","title":"EquipmentOptions"},{"location":"reference/config/search_config/#camply.config.search_config.SearchConfig","text":"File Path Storage Class Source code in camply/config/search_config.py 10 11 12 13 14 15 16 17 18 19 class SearchConfig : \"\"\" File Path Storage Class \"\"\" POLLING_INTERVAL_MINIMUM : int = 5 # 5 MINUTES RECOMMENDED_POLLING_INTERVAL : int = 10 # 10 MINUTES ERROR_MESSAGE : str = \"No search days configured. Exiting\" MINIMUM_CAMPSITES_FIRST_NOTIFY : int = 5 MAXIMUM_NOTIFICATION_BATCH_SIZE : int = 20","title":"SearchConfig"},{"location":"reference/config/yellowstone_config/","text":"Project Configuration for Yellowstone Variables YellowstoneConfig # Bases: DataColumns Variable Storage Class Source code in camply/config/yellowstone_config.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 class YellowstoneConfig ( DataColumns ): \"\"\" Variable Storage Class \"\"\" API_SCHEME : str = \"https\" API_BASE_ENDPOINT : str = \"webapi.xanterra.net\" API_BASE_PATH : str = \"v1/api\" LODGING_PATH : str = f \"/ { API_BASE_PATH } /availability/hotels\" YELLOWSTONE_PARK_PATH : str = \"yellowstonenationalparklodges\" YELLOWSTONE_LODGING_PATH : str = f \" { LODGING_PATH } / { YELLOWSTONE_PARK_PATH } \" CAMPSITE_AVAILABILITY : str = f \" { API_BASE_PATH } /availability/rooms\" YELLOWSTONE_CAMPSITE_AVAILABILITY : str = ( f \" { CAMPSITE_AVAILABILITY } / { YELLOWSTONE_PARK_PATH } \" ) YELLOWSTONE_PROPERTY_INFO : str = ( f \" { API_BASE_PATH } /property/rooms/ { YELLOWSTONE_PARK_PATH } \" ) API_REFERRERS : dict = { \"Host\" : \"webapi.xanterra.net\" , \"Origin\" : \"https://secure.yellowstonenationalparklodges.com\" , \"Referer\" : \"https://secure.yellowstonenationalparklodges.com/\" , } LODGING_CAMPGROUND_QUALIFIER : str = \":RV\" # JSON FILTERING BOOKING_AVAILABILITY : str = \"availability\" # DATAFRAME FILTERING FACILITY_ID : str = \"facility_id\" FACILITY_STATUS : str = \"status\" FACILITY_STATUS_QUALIFIER : str = \"OPEN\" FACILITY_ROOMS : str = \"rooms\" FACILITY_AVAILABLE_QUALIFIER : str = \"available\" FACILITY_HOTEL_CODE : str = \"hotelCode\" FACILITY_ROOM_CODE : str = \"roomCode\" FACILITY_PRICE : str = \"price\" FACILITY_TYPE : str = \"type\" CAMPSITE_DATA_COLUMNS : List [ str ] = [ \"facility_id\" , \"facility_name\" , \"booking_url\" ] RATE_CODE : str = \"INTERNET\" LODGING_RATES : str = \"rates\" LODGING_TITLE : str = \"title\" LODGING_BASE_PRICES : str = \"mins\" LODGING_OCCUPANCY_BASE : str = \"occupancyBase\" LODGING_OCCUPANCY_MAX : str = \"occupancyMax\" LODGING_ERROR_MESSAGE : str = \"message\" MINIMUM_POLLING_INTERVAL : int = 45 WEBUI_ALIAS_ENDPOINT : str = \"yellowstonenationalparklodges.com\" WEBUI_BASE_ENDPOINT : str = \"secure.yellowstonenationalparklodges.com\" WEBUI_BOOKING_PATH : str = \"booking/lodging-select\" YELLOWSTONE_RECREATION_AREA_ID : int = 1 YELLOWSTONE_RECREATION_AREA_NAME : str = \"Yellowstone\" YELLOWSTONE_RECREATION_AREA_FORMAL_NAME : str = \"Yellowstone National Park, USA\" YELLOWSTONE_LOOP_NAME : str = \"N/A\" CAMPSITE_AVAILABILITY_STATUS : str = \"Available\" YELLOWSTONE_CAMPGROUND_NAME_REPLACE : Tuple [ str , str ] = ( \"CG Internet Rate\" , \"Campground\" , ) YELLOWSTONE_TIMEZONE : str = \"America/Denver\" # LODGES: https://webapi.xanterra.net/v1/api/property/hotels/yellowstonenationalparklodges YELLOWSTONE_CAMPGROUNDS : Dict [ str , str ] = { \"YLYC:RV\" : \"Canyon Campground\" , \"YLYB:RV\" : \"Bridge Bay Campground\" , \"YLYG:RV\" : \"Grant Campground\" , \"YLYM:RV\" : \"Madison Campground\" , \"YLYF:RV\" : \"Fishing Bridge RV Park\" , } YELLOWSTONE_CAMPGROUND_OBJECTS : List [ CampgroundFacility ] = [] for key , value in YELLOWSTONE_CAMPGROUNDS . items (): YELLOWSTONE_CAMPGROUND_OBJECTS . append ( CampgroundFacility ( recreation_area_id = YELLOWSTONE_RECREATION_AREA_ID , recreation_area = YELLOWSTONE_RECREATION_AREA_FORMAL_NAME , facility_name = value , facility_id = str ( key ), ) )","title":"yellowstone_config"},{"location":"reference/config/yellowstone_config/#camply.config.yellowstone_config.YellowstoneConfig","text":"Bases: DataColumns Variable Storage Class Source code in camply/config/yellowstone_config.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 class YellowstoneConfig ( DataColumns ): \"\"\" Variable Storage Class \"\"\" API_SCHEME : str = \"https\" API_BASE_ENDPOINT : str = \"webapi.xanterra.net\" API_BASE_PATH : str = \"v1/api\" LODGING_PATH : str = f \"/ { API_BASE_PATH } /availability/hotels\" YELLOWSTONE_PARK_PATH : str = \"yellowstonenationalparklodges\" YELLOWSTONE_LODGING_PATH : str = f \" { LODGING_PATH } / { YELLOWSTONE_PARK_PATH } \" CAMPSITE_AVAILABILITY : str = f \" { API_BASE_PATH } /availability/rooms\" YELLOWSTONE_CAMPSITE_AVAILABILITY : str = ( f \" { CAMPSITE_AVAILABILITY } / { YELLOWSTONE_PARK_PATH } \" ) YELLOWSTONE_PROPERTY_INFO : str = ( f \" { API_BASE_PATH } /property/rooms/ { YELLOWSTONE_PARK_PATH } \" ) API_REFERRERS : dict = { \"Host\" : \"webapi.xanterra.net\" , \"Origin\" : \"https://secure.yellowstonenationalparklodges.com\" , \"Referer\" : \"https://secure.yellowstonenationalparklodges.com/\" , } LODGING_CAMPGROUND_QUALIFIER : str = \":RV\" # JSON FILTERING BOOKING_AVAILABILITY : str = \"availability\" # DATAFRAME FILTERING FACILITY_ID : str = \"facility_id\" FACILITY_STATUS : str = \"status\" FACILITY_STATUS_QUALIFIER : str = \"OPEN\" FACILITY_ROOMS : str = \"rooms\" FACILITY_AVAILABLE_QUALIFIER : str = \"available\" FACILITY_HOTEL_CODE : str = \"hotelCode\" FACILITY_ROOM_CODE : str = \"roomCode\" FACILITY_PRICE : str = \"price\" FACILITY_TYPE : str = \"type\" CAMPSITE_DATA_COLUMNS : List [ str ] = [ \"facility_id\" , \"facility_name\" , \"booking_url\" ] RATE_CODE : str = \"INTERNET\" LODGING_RATES : str = \"rates\" LODGING_TITLE : str = \"title\" LODGING_BASE_PRICES : str = \"mins\" LODGING_OCCUPANCY_BASE : str = \"occupancyBase\" LODGING_OCCUPANCY_MAX : str = \"occupancyMax\" LODGING_ERROR_MESSAGE : str = \"message\" MINIMUM_POLLING_INTERVAL : int = 45 WEBUI_ALIAS_ENDPOINT : str = \"yellowstonenationalparklodges.com\" WEBUI_BASE_ENDPOINT : str = \"secure.yellowstonenationalparklodges.com\" WEBUI_BOOKING_PATH : str = \"booking/lodging-select\" YELLOWSTONE_RECREATION_AREA_ID : int = 1 YELLOWSTONE_RECREATION_AREA_NAME : str = \"Yellowstone\" YELLOWSTONE_RECREATION_AREA_FORMAL_NAME : str = \"Yellowstone National Park, USA\" YELLOWSTONE_LOOP_NAME : str = \"N/A\" CAMPSITE_AVAILABILITY_STATUS : str = \"Available\" YELLOWSTONE_CAMPGROUND_NAME_REPLACE : Tuple [ str , str ] = ( \"CG Internet Rate\" , \"Campground\" , ) YELLOWSTONE_TIMEZONE : str = \"America/Denver\" # LODGES: https://webapi.xanterra.net/v1/api/property/hotels/yellowstonenationalparklodges YELLOWSTONE_CAMPGROUNDS : Dict [ str , str ] = { \"YLYC:RV\" : \"Canyon Campground\" , \"YLYB:RV\" : \"Bridge Bay Campground\" , \"YLYG:RV\" : \"Grant Campground\" , \"YLYM:RV\" : \"Madison Campground\" , \"YLYF:RV\" : \"Fishing Bridge RV Park\" , } YELLOWSTONE_CAMPGROUND_OBJECTS : List [ CampgroundFacility ] = [] for key , value in YELLOWSTONE_CAMPGROUNDS . items (): YELLOWSTONE_CAMPGROUND_OBJECTS . append ( CampgroundFacility ( recreation_area_id = YELLOWSTONE_RECREATION_AREA_ID , recreation_area = YELLOWSTONE_RECREATION_AREA_FORMAL_NAME , facility_name = value , facility_id = str ( key ), ) )","title":"YellowstoneConfig"},{"location":"reference/containers/","text":"camply Data Storage Objects AvailableCampsite # Bases: CamplyModel Campsite Storage This container should be universal regardless of API Provider Source code in camply/containers/data_containers.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class AvailableCampsite ( CamplyModel ): \"\"\" Campsite Storage This container should be universal regardless of API Provider \"\"\" campsite_id : Union [ int , str ] booking_date : datetime . datetime booking_end_date : datetime . datetime booking_nights : int campsite_site_name : str campsite_loop_name : str campsite_type : str campsite_occupancy : Tuple [ int , int ] campsite_use_type : str availability_status : str recreation_area : str recreation_area_id : int facility_name : str facility_id : Union [ int , str ] booking_url : str permitted_equipment : Optional [ List [ RecDotGovEquipment ]] campsite_attributes : Optional [ List [ RecDotGovAttribute ]] __unhashable__ = { \"permitted_equipment\" , \"campsite_attributes\" } CampgroundFacility # Bases: CamplyModel Campground Facility Data Storage Source code in camply/containers/data_containers.py 69 70 71 72 73 74 75 76 77 class CampgroundFacility ( CamplyModel ): \"\"\" Campground Facility Data Storage \"\"\" facility_name : str recreation_area : str facility_id : Union [ int , str ] recreation_area_id : int CamplyModel # Bases: BaseModel Hashable Pydantic Model Source code in camply/containers/base_container.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class CamplyModel ( BaseModel ): \"\"\" Hashable Pydantic Model \"\"\" __unhashable__ : Set [ str ] = set () def __hash__ ( self ): \"\"\" Hash Method for Pydantic BaseModels \"\"\" return hash ( self . __class__ ) + hash ( tuple ( value for key , value in self . __dict__ . items () if key not in self . __unhashable__ ) ) def __eq__ ( self , other : Any ) -> bool : \"\"\" Exclude Unhashable Fields When Evaluating Equality \"\"\" if isinstance ( other , CamplyModel ): return self . dict ( exclude = self . __unhashable__ ) == other . dict ( exclude = other . __unhashable__ ) else : return self . dict ( exclude = self . __unhashable__ ) == other __eq__ ( other ) # Exclude Unhashable Fields When Evaluating Equality Source code in camply/containers/base_container.py 29 30 31 32 33 34 35 36 37 38 def __eq__ ( self , other : Any ) -> bool : \"\"\" Exclude Unhashable Fields When Evaluating Equality \"\"\" if isinstance ( other , CamplyModel ): return self . dict ( exclude = self . __unhashable__ ) == other . dict ( exclude = other . __unhashable__ ) else : return self . dict ( exclude = self . __unhashable__ ) == other __hash__ () # Hash Method for Pydantic BaseModels Source code in camply/containers/base_container.py 17 18 19 20 21 22 23 24 25 26 27 def __hash__ ( self ): \"\"\" Hash Method for Pydantic BaseModels \"\"\" return hash ( self . __class__ ) + hash ( tuple ( value for key , value in self . __dict__ . items () if key not in self . __unhashable__ ) ) RecreationArea # Bases: CamplyModel Recreation Area Data Storage Source code in camply/containers/data_containers.py 80 81 82 83 84 85 86 87 class RecreationArea ( CamplyModel ): \"\"\" Recreation Area Data Storage \"\"\" recreation_area : str recreation_area_id : int recreation_area_location : str SearchWindow # Bases: CamplyModel Search Window for Campsite Search Source code in camply/containers/data_containers.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class SearchWindow ( CamplyModel ): \"\"\" Search Window for Campsite Search \"\"\" start_date : datetime . date end_date : datetime . date def get_date_range ( self ) -> List [ datetime . date ]: \"\"\" Generate a List of Dates Between two Dates Returns ------- List[datetime.date] \"\"\" return [ self . start_date + datetime . timedelta ( days = x ) for x in range (( self . end_date - self . start_date ) . days ) ] get_date_range () # Generate a List of Dates Between two Dates Returns # List[datetime.date] Source code in camply/containers/data_containers.py 26 27 28 29 30 31 32 33 34 35 36 37 def get_date_range ( self ) -> List [ datetime . date ]: \"\"\" Generate a List of Dates Between two Dates Returns ------- List[datetime.date] \"\"\" return [ self . start_date + datetime . timedelta ( days = x ) for x in range (( self . end_date - self . start_date ) . days ) ]","title":"containers"},{"location":"reference/containers/#camply.containers.AvailableCampsite","text":"Bases: CamplyModel Campsite Storage This container should be universal regardless of API Provider Source code in camply/containers/data_containers.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class AvailableCampsite ( CamplyModel ): \"\"\" Campsite Storage This container should be universal regardless of API Provider \"\"\" campsite_id : Union [ int , str ] booking_date : datetime . datetime booking_end_date : datetime . datetime booking_nights : int campsite_site_name : str campsite_loop_name : str campsite_type : str campsite_occupancy : Tuple [ int , int ] campsite_use_type : str availability_status : str recreation_area : str recreation_area_id : int facility_name : str facility_id : Union [ int , str ] booking_url : str permitted_equipment : Optional [ List [ RecDotGovEquipment ]] campsite_attributes : Optional [ List [ RecDotGovAttribute ]] __unhashable__ = { \"permitted_equipment\" , \"campsite_attributes\" }","title":"AvailableCampsite"},{"location":"reference/containers/#camply.containers.CampgroundFacility","text":"Bases: CamplyModel Campground Facility Data Storage Source code in camply/containers/data_containers.py 69 70 71 72 73 74 75 76 77 class CampgroundFacility ( CamplyModel ): \"\"\" Campground Facility Data Storage \"\"\" facility_name : str recreation_area : str facility_id : Union [ int , str ] recreation_area_id : int","title":"CampgroundFacility"},{"location":"reference/containers/#camply.containers.CamplyModel","text":"Bases: BaseModel Hashable Pydantic Model Source code in camply/containers/base_container.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class CamplyModel ( BaseModel ): \"\"\" Hashable Pydantic Model \"\"\" __unhashable__ : Set [ str ] = set () def __hash__ ( self ): \"\"\" Hash Method for Pydantic BaseModels \"\"\" return hash ( self . __class__ ) + hash ( tuple ( value for key , value in self . __dict__ . items () if key not in self . __unhashable__ ) ) def __eq__ ( self , other : Any ) -> bool : \"\"\" Exclude Unhashable Fields When Evaluating Equality \"\"\" if isinstance ( other , CamplyModel ): return self . dict ( exclude = self . __unhashable__ ) == other . dict ( exclude = other . __unhashable__ ) else : return self . dict ( exclude = self . __unhashable__ ) == other","title":"CamplyModel"},{"location":"reference/containers/#camply.containers.base_container.CamplyModel.__eq__","text":"Exclude Unhashable Fields When Evaluating Equality Source code in camply/containers/base_container.py 29 30 31 32 33 34 35 36 37 38 def __eq__ ( self , other : Any ) -> bool : \"\"\" Exclude Unhashable Fields When Evaluating Equality \"\"\" if isinstance ( other , CamplyModel ): return self . dict ( exclude = self . __unhashable__ ) == other . dict ( exclude = other . __unhashable__ ) else : return self . dict ( exclude = self . __unhashable__ ) == other","title":"__eq__()"},{"location":"reference/containers/#camply.containers.base_container.CamplyModel.__hash__","text":"Hash Method for Pydantic BaseModels Source code in camply/containers/base_container.py 17 18 19 20 21 22 23 24 25 26 27 def __hash__ ( self ): \"\"\" Hash Method for Pydantic BaseModels \"\"\" return hash ( self . __class__ ) + hash ( tuple ( value for key , value in self . __dict__ . items () if key not in self . __unhashable__ ) )","title":"__hash__()"},{"location":"reference/containers/#camply.containers.RecreationArea","text":"Bases: CamplyModel Recreation Area Data Storage Source code in camply/containers/data_containers.py 80 81 82 83 84 85 86 87 class RecreationArea ( CamplyModel ): \"\"\" Recreation Area Data Storage \"\"\" recreation_area : str recreation_area_id : int recreation_area_location : str","title":"RecreationArea"},{"location":"reference/containers/#camply.containers.SearchWindow","text":"Bases: CamplyModel Search Window for Campsite Search Source code in camply/containers/data_containers.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class SearchWindow ( CamplyModel ): \"\"\" Search Window for Campsite Search \"\"\" start_date : datetime . date end_date : datetime . date def get_date_range ( self ) -> List [ datetime . date ]: \"\"\" Generate a List of Dates Between two Dates Returns ------- List[datetime.date] \"\"\" return [ self . start_date + datetime . timedelta ( days = x ) for x in range (( self . end_date - self . start_date ) . days ) ]","title":"SearchWindow"},{"location":"reference/containers/#camply.containers.data_containers.SearchWindow.get_date_range","text":"Generate a List of Dates Between two Dates","title":"get_date_range()"},{"location":"reference/containers/#camply.containers.data_containers.SearchWindow.get_date_range--returns","text":"List[datetime.date] Source code in camply/containers/data_containers.py 26 27 28 29 30 31 32 33 34 35 36 37 def get_date_range ( self ) -> List [ datetime . date ]: \"\"\" Generate a List of Dates Between two Dates Returns ------- List[datetime.date] \"\"\" return [ self . start_date + datetime . timedelta ( days = x ) for x in range (( self . end_date - self . start_date ) . days ) ]","title":"Returns"},{"location":"reference/containers/api_responses/","text":"API Response Objects These are JSON Responses from APIs CampsiteAvailabilityResponse # Bases: CamplyModel https://ridb.recreation.gov/api/v1/campsites/ Source code in camply/containers/api_responses.py 98 99 100 101 102 103 class CampsiteAvailabilityResponse ( CamplyModel ): \"\"\" https://ridb.recreation.gov/api/v1/campsites/<CAMPSITE ID> \"\"\" campsites : Dict [ int , _CampsiteAvailabilityCampsiteResponse ] CampsiteResponse # Bases: CamplyModel https://ridb.recreation.gov/api/v1/campsites/ Source code in camply/containers/api_responses.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class CampsiteResponse ( CamplyModel ): \"\"\" https://ridb.recreation.gov/api/v1/campsites/<CAMPSITE ID> \"\"\" CampsiteID : int FacilityID : int CampsiteName : str CampsiteType : str TypeOfUse : str Loop : str CampsiteAccessible : bool CampsiteReservable : bool CampsiteLongitude : float CampsiteLatitude : float CreatedDate : datetime . date LastUpdatedDate : datetime . date PERMITTEDEQUIPMENT : List [ _CampsiteEquipment ] ATTRIBUTES : List [ _CampsiteAttribute ] FacilityResponse # Bases: CamplyModel /api/v1/facilities/ Source code in camply/containers/api_responses.py 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 class FacilityResponse ( CamplyModel ): \"\"\" /api/v1/facilities/<Facility ID> \"\"\" FacilityID : Union [ int , str ] FacilityName : str FacilityTypeDescription : str Enabled : bool Reservable : bool FACILITYADDRESS : Optional [ List [ _FacilityAddress ]] RECAREA : Optional [ List [ _FacilityRecArea ]] ORGANIZATION : Optional [ List [ _FacilityOrganization ]] ParentRecAreaID : Optional [ int ] @validator ( \"ParentRecAreaID\" , pre = True , always = False ) def validate_parentrecid ( cls , val : Any ) -> Optional [ int ]: \"\"\" Validate Empty Strings as Null \"\"\" if val == \"\" : return None return val validate_parentrecid ( val ) # Validate Empty Strings as Null Source code in camply/containers/api_responses.py 163 164 165 166 167 168 169 170 @validator ( \"ParentRecAreaID\" , pre = True , always = False ) def validate_parentrecid ( cls , val : Any ) -> Optional [ int ]: \"\"\" Validate Empty Strings as Null \"\"\" if val == \"\" : return None return val GenericResponse # Bases: CamplyModel Generic Response to Be Paginated Source code in camply/containers/api_responses.py 190 191 192 193 194 195 196 class GenericResponse ( CamplyModel ): \"\"\" Generic Response to Be Paginated \"\"\" RECDATA : Any METADATA : _PaginationMetadataResponse RecDotGovCampsite # Bases: CamplyModel Recreation.gov Campsite Object Source code in camply/containers/api_responses.py 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 class RecDotGovCampsite ( CamplyModel ): \"\"\" Recreation.gov Campsite Object \"\"\" accessible : bool asset_id : int asset_type = str attributes : List [ RecDotGovAttribute ] average_rating : Optional [ int ] campsite_id : int campsite_reserve_type : str city : Optional [ str ] country_code : Optional [ str ] fee_templates : Dict [ str , Any ] latitude : Optional [ float ] longitude : Optional [ float ] loop : str name : str number_of_ratings = int org_id : int org_name : str parent_asset_id : int parent_asset_name : str parent_asset_type : str permitted_equipment : List [ RecDotGovEquipment ] preview_image_url : Optional [ str ] reservable : bool state_code : Optional [ str ] type : str type_of_use : str RecDotGovCampsiteResponse # Bases: CamplyModel Parent Response from Campsite Metadata Source code in camply/containers/api_responses.py 303 304 305 306 307 308 309 310 311 312 class RecDotGovCampsiteResponse ( CamplyModel ): \"\"\" Parent Response from Campsite Metadata \"\"\" campsites : List [ RecDotGovCampsite ] size : int spelling_autocorrected : Any start : int total : int RecreationAreaResponse # Bases: CamplyModel https://ridb.recreation.gov/api/v1/campsites/ Source code in camply/containers/api_responses.py 114 115 116 117 118 119 120 121 class RecreationAreaResponse ( CamplyModel ): \"\"\" https://ridb.recreation.gov/api/v1/campsites/<CAMPSITE ID> \"\"\" RecAreaID : int RecAreaName : str RECAREAADDRESS : List [ _RecAreaAddress ] UnawareDatetime # Bases: datetime . datetime Datetime Unaware Timestamp Parsing Source code in camply/containers/api_responses.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 class UnawareDatetime ( datetime . datetime ): \"\"\" Datetime Unaware Timestamp Parsing \"\"\" @classmethod def __get_validators__ ( cls ) -> Iterator : \"\"\" Generate Validators \"\"\" yield cls . validate @classmethod def validate ( cls , v : Union [ str , datetime . datetime ]) -> datetime . datetime : \"\"\" Validate Date Strings Into Parameters ---------- v: Union[str, datetime.datetime] Returns ------- datetime.datetime \"\"\" if isinstance ( v , str ): return datetime . datetime . strptime ( v , \"%Y-%m- %d T%H:%M:%SZ\" ) elif isinstance ( v , datetime . datetime ): return v . replace ( tzinfo = None ) else : raise ValueError ( \"You Must Provide a Parsable Datetime String or Object\" ) __get_validators__ () classmethod # Generate Validators Source code in camply/containers/api_responses.py 56 57 58 59 60 61 @classmethod def __get_validators__ ( cls ) -> Iterator : \"\"\" Generate Validators \"\"\" yield cls . validate validate ( v ) classmethod # Validate Date Strings Into Parameters # v: Union[str, datetime.datetime] Returns # datetime.datetime Source code in camply/containers/api_responses.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 @classmethod def validate ( cls , v : Union [ str , datetime . datetime ]) -> datetime . datetime : \"\"\" Validate Date Strings Into Parameters ---------- v: Union[str, datetime.datetime] Returns ------- datetime.datetime \"\"\" if isinstance ( v , str ): return datetime . datetime . strptime ( v , \"%Y-%m- %d T%H:%M:%SZ\" ) elif isinstance ( v , datetime . datetime ): return v . replace ( tzinfo = None ) else : raise ValueError ( \"You Must Provide a Parsable Datetime String or Object\" ) XantCampgroundDetails # Bases: CamplyModel Yellowstone Campground Details OBject Source code in camply/containers/api_responses.py 237 238 239 240 241 242 243 244 245 246 247 248 249 class XantCampgroundDetails ( CamplyModel ): \"\"\" Yellowstone Campground Details OBject \"\"\" hotelCode : str status : str message : str min : str max : str perGuests : Dict [ int , XantPerGuest ] rates : Dict [ str , XantRates ] rates2 : Optional [ Dict [ str , XantRates ]] XantPerGuest # Bases: CamplyModel PerGuest Objects Source code in camply/containers/api_responses.py 199 200 201 202 203 204 205 206 207 208 209 210 211 class XantPerGuest ( CamplyModel ): \"\"\" PerGuest Objects \"\"\" a2 : Optional [ Union [ int , str ]] b : Optional [ Union [ int , str ]] b2 : Optional [ Union [ int , str ]] m : Optional [ Union [ int , str ]] m2 : Optional [ Union [ int , str ]] r : Optional [ Union [ int , str ]] r2 : Optional [ Union [ int , str ]] s : Optional [ Union [ int , str ]] XantRates # Bases: CamplyModel Yellowstone Rates Object Source code in camply/containers/api_responses.py 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 class XantRates ( CamplyModel ): \"\"\" Yellowstone Rates Object \"\"\" code : str title : str description : str category : str minstay : int start : datetime . date available : Dict [ int , int ] mins : Dict [ int , int ] min : int @validator ( \"start\" , pre = True ) def parse_datetime ( cls , value ): \"\"\" Parse Poorly Formatted Date Strings \"\"\" return datetime . datetime . strptime ( value , \"%m/ %d /%Y\" ) . date () parse_datetime ( value ) # Parse Poorly Formatted Date Strings Source code in camply/containers/api_responses.py 229 230 231 232 233 234 @validator ( \"start\" , pre = True ) def parse_datetime ( cls , value ): \"\"\" Parse Poorly Formatted Date Strings \"\"\" return datetime . datetime . strptime ( value , \"%m/ %d /%Y\" ) . date () XantResortData # Bases: CamplyModel Main Yellowstone API Response Wrapper Source code in camply/containers/api_responses.py 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 class XantResortData ( CamplyModel ): \"\"\" Main Yellowstone API Response Wrapper \"\"\" availability : Dict [ datetime . date , Dict [ str , XantCampgroundDetails ]] @validator ( \"availability\" , pre = True ) def parse_datetime ( cls , value ): \"\"\" Parse Poorly Formatted Date Strings \"\"\" return { datetime . datetime . strptime ( x , \"%m/ %d /%Y\" ) . date (): y for x , y in value . items () } parse_datetime ( value ) # Parse Poorly Formatted Date Strings Source code in camply/containers/api_responses.py 259 260 261 262 263 264 265 266 267 @validator ( \"availability\" , pre = True ) def parse_datetime ( cls , value ): \"\"\" Parse Poorly Formatted Date Strings \"\"\" return { datetime . datetime . strptime ( x , \"%m/ %d /%Y\" ) . date (): y for x , y in value . items () }","title":"api_responses"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.CampsiteAvailabilityResponse","text":"Bases: CamplyModel https://ridb.recreation.gov/api/v1/campsites/ Source code in camply/containers/api_responses.py 98 99 100 101 102 103 class CampsiteAvailabilityResponse ( CamplyModel ): \"\"\" https://ridb.recreation.gov/api/v1/campsites/<CAMPSITE ID> \"\"\" campsites : Dict [ int , _CampsiteAvailabilityCampsiteResponse ]","title":"CampsiteAvailabilityResponse"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.CampsiteResponse","text":"Bases: CamplyModel https://ridb.recreation.gov/api/v1/campsites/ Source code in camply/containers/api_responses.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class CampsiteResponse ( CamplyModel ): \"\"\" https://ridb.recreation.gov/api/v1/campsites/<CAMPSITE ID> \"\"\" CampsiteID : int FacilityID : int CampsiteName : str CampsiteType : str TypeOfUse : str Loop : str CampsiteAccessible : bool CampsiteReservable : bool CampsiteLongitude : float CampsiteLatitude : float CreatedDate : datetime . date LastUpdatedDate : datetime . date PERMITTEDEQUIPMENT : List [ _CampsiteEquipment ] ATTRIBUTES : List [ _CampsiteAttribute ]","title":"CampsiteResponse"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.FacilityResponse","text":"Bases: CamplyModel /api/v1/facilities/ Source code in camply/containers/api_responses.py 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 class FacilityResponse ( CamplyModel ): \"\"\" /api/v1/facilities/<Facility ID> \"\"\" FacilityID : Union [ int , str ] FacilityName : str FacilityTypeDescription : str Enabled : bool Reservable : bool FACILITYADDRESS : Optional [ List [ _FacilityAddress ]] RECAREA : Optional [ List [ _FacilityRecArea ]] ORGANIZATION : Optional [ List [ _FacilityOrganization ]] ParentRecAreaID : Optional [ int ] @validator ( \"ParentRecAreaID\" , pre = True , always = False ) def validate_parentrecid ( cls , val : Any ) -> Optional [ int ]: \"\"\" Validate Empty Strings as Null \"\"\" if val == \"\" : return None return val","title":"FacilityResponse"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.FacilityResponse.validate_parentrecid","text":"Validate Empty Strings as Null Source code in camply/containers/api_responses.py 163 164 165 166 167 168 169 170 @validator ( \"ParentRecAreaID\" , pre = True , always = False ) def validate_parentrecid ( cls , val : Any ) -> Optional [ int ]: \"\"\" Validate Empty Strings as Null \"\"\" if val == \"\" : return None return val","title":"validate_parentrecid()"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.GenericResponse","text":"Bases: CamplyModel Generic Response to Be Paginated Source code in camply/containers/api_responses.py 190 191 192 193 194 195 196 class GenericResponse ( CamplyModel ): \"\"\" Generic Response to Be Paginated \"\"\" RECDATA : Any METADATA : _PaginationMetadataResponse","title":"GenericResponse"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.RecDotGovCampsite","text":"Bases: CamplyModel Recreation.gov Campsite Object Source code in camply/containers/api_responses.py 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 class RecDotGovCampsite ( CamplyModel ): \"\"\" Recreation.gov Campsite Object \"\"\" accessible : bool asset_id : int asset_type = str attributes : List [ RecDotGovAttribute ] average_rating : Optional [ int ] campsite_id : int campsite_reserve_type : str city : Optional [ str ] country_code : Optional [ str ] fee_templates : Dict [ str , Any ] latitude : Optional [ float ] longitude : Optional [ float ] loop : str name : str number_of_ratings = int org_id : int org_name : str parent_asset_id : int parent_asset_name : str parent_asset_type : str permitted_equipment : List [ RecDotGovEquipment ] preview_image_url : Optional [ str ] reservable : bool state_code : Optional [ str ] type : str type_of_use : str","title":"RecDotGovCampsite"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.RecDotGovCampsiteResponse","text":"Bases: CamplyModel Parent Response from Campsite Metadata Source code in camply/containers/api_responses.py 303 304 305 306 307 308 309 310 311 312 class RecDotGovCampsiteResponse ( CamplyModel ): \"\"\" Parent Response from Campsite Metadata \"\"\" campsites : List [ RecDotGovCampsite ] size : int spelling_autocorrected : Any start : int total : int","title":"RecDotGovCampsiteResponse"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.RecreationAreaResponse","text":"Bases: CamplyModel https://ridb.recreation.gov/api/v1/campsites/ Source code in camply/containers/api_responses.py 114 115 116 117 118 119 120 121 class RecreationAreaResponse ( CamplyModel ): \"\"\" https://ridb.recreation.gov/api/v1/campsites/<CAMPSITE ID> \"\"\" RecAreaID : int RecAreaName : str RECAREAADDRESS : List [ _RecAreaAddress ]","title":"RecreationAreaResponse"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.UnawareDatetime","text":"Bases: datetime . datetime Datetime Unaware Timestamp Parsing Source code in camply/containers/api_responses.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 class UnawareDatetime ( datetime . datetime ): \"\"\" Datetime Unaware Timestamp Parsing \"\"\" @classmethod def __get_validators__ ( cls ) -> Iterator : \"\"\" Generate Validators \"\"\" yield cls . validate @classmethod def validate ( cls , v : Union [ str , datetime . datetime ]) -> datetime . datetime : \"\"\" Validate Date Strings Into Parameters ---------- v: Union[str, datetime.datetime] Returns ------- datetime.datetime \"\"\" if isinstance ( v , str ): return datetime . datetime . strptime ( v , \"%Y-%m- %d T%H:%M:%SZ\" ) elif isinstance ( v , datetime . datetime ): return v . replace ( tzinfo = None ) else : raise ValueError ( \"You Must Provide a Parsable Datetime String or Object\" )","title":"UnawareDatetime"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.UnawareDatetime.__get_validators__","text":"Generate Validators Source code in camply/containers/api_responses.py 56 57 58 59 60 61 @classmethod def __get_validators__ ( cls ) -> Iterator : \"\"\" Generate Validators \"\"\" yield cls . validate","title":"__get_validators__()"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.UnawareDatetime.validate","text":"Validate Date Strings Into","title":"validate()"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.UnawareDatetime.validate--parameters","text":"v: Union[str, datetime.datetime]","title":"Parameters"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.UnawareDatetime.validate--returns","text":"datetime.datetime Source code in camply/containers/api_responses.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 @classmethod def validate ( cls , v : Union [ str , datetime . datetime ]) -> datetime . datetime : \"\"\" Validate Date Strings Into Parameters ---------- v: Union[str, datetime.datetime] Returns ------- datetime.datetime \"\"\" if isinstance ( v , str ): return datetime . datetime . strptime ( v , \"%Y-%m- %d T%H:%M:%SZ\" ) elif isinstance ( v , datetime . datetime ): return v . replace ( tzinfo = None ) else : raise ValueError ( \"You Must Provide a Parsable Datetime String or Object\" )","title":"Returns"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.XantCampgroundDetails","text":"Bases: CamplyModel Yellowstone Campground Details OBject Source code in camply/containers/api_responses.py 237 238 239 240 241 242 243 244 245 246 247 248 249 class XantCampgroundDetails ( CamplyModel ): \"\"\" Yellowstone Campground Details OBject \"\"\" hotelCode : str status : str message : str min : str max : str perGuests : Dict [ int , XantPerGuest ] rates : Dict [ str , XantRates ] rates2 : Optional [ Dict [ str , XantRates ]]","title":"XantCampgroundDetails"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.XantPerGuest","text":"Bases: CamplyModel PerGuest Objects Source code in camply/containers/api_responses.py 199 200 201 202 203 204 205 206 207 208 209 210 211 class XantPerGuest ( CamplyModel ): \"\"\" PerGuest Objects \"\"\" a2 : Optional [ Union [ int , str ]] b : Optional [ Union [ int , str ]] b2 : Optional [ Union [ int , str ]] m : Optional [ Union [ int , str ]] m2 : Optional [ Union [ int , str ]] r : Optional [ Union [ int , str ]] r2 : Optional [ Union [ int , str ]] s : Optional [ Union [ int , str ]]","title":"XantPerGuest"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.XantRates","text":"Bases: CamplyModel Yellowstone Rates Object Source code in camply/containers/api_responses.py 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 class XantRates ( CamplyModel ): \"\"\" Yellowstone Rates Object \"\"\" code : str title : str description : str category : str minstay : int start : datetime . date available : Dict [ int , int ] mins : Dict [ int , int ] min : int @validator ( \"start\" , pre = True ) def parse_datetime ( cls , value ): \"\"\" Parse Poorly Formatted Date Strings \"\"\" return datetime . datetime . strptime ( value , \"%m/ %d /%Y\" ) . date ()","title":"XantRates"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.XantRates.parse_datetime","text":"Parse Poorly Formatted Date Strings Source code in camply/containers/api_responses.py 229 230 231 232 233 234 @validator ( \"start\" , pre = True ) def parse_datetime ( cls , value ): \"\"\" Parse Poorly Formatted Date Strings \"\"\" return datetime . datetime . strptime ( value , \"%m/ %d /%Y\" ) . date ()","title":"parse_datetime()"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.XantResortData","text":"Bases: CamplyModel Main Yellowstone API Response Wrapper Source code in camply/containers/api_responses.py 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 class XantResortData ( CamplyModel ): \"\"\" Main Yellowstone API Response Wrapper \"\"\" availability : Dict [ datetime . date , Dict [ str , XantCampgroundDetails ]] @validator ( \"availability\" , pre = True ) def parse_datetime ( cls , value ): \"\"\" Parse Poorly Formatted Date Strings \"\"\" return { datetime . datetime . strptime ( x , \"%m/ %d /%Y\" ) . date (): y for x , y in value . items () }","title":"XantResortData"},{"location":"reference/containers/api_responses/#camply.containers.api_responses.XantResortData.parse_datetime","text":"Parse Poorly Formatted Date Strings Source code in camply/containers/api_responses.py 259 260 261 262 263 264 265 266 267 @validator ( \"availability\" , pre = True ) def parse_datetime ( cls , value ): \"\"\" Parse Poorly Formatted Date Strings \"\"\" return { datetime . datetime . strptime ( x , \"%m/ %d /%Y\" ) . date (): y for x , y in value . items () }","title":"parse_datetime()"},{"location":"reference/containers/base_container/","text":"Base Pydantic Object for Containers CamplyModel # Bases: BaseModel Hashable Pydantic Model Source code in camply/containers/base_container.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class CamplyModel ( BaseModel ): \"\"\" Hashable Pydantic Model \"\"\" __unhashable__ : Set [ str ] = set () def __hash__ ( self ): \"\"\" Hash Method for Pydantic BaseModels \"\"\" return hash ( self . __class__ ) + hash ( tuple ( value for key , value in self . __dict__ . items () if key not in self . __unhashable__ ) ) def __eq__ ( self , other : Any ) -> bool : \"\"\" Exclude Unhashable Fields When Evaluating Equality \"\"\" if isinstance ( other , CamplyModel ): return self . dict ( exclude = self . __unhashable__ ) == other . dict ( exclude = other . __unhashable__ ) else : return self . dict ( exclude = self . __unhashable__ ) == other __eq__ ( other ) # Exclude Unhashable Fields When Evaluating Equality Source code in camply/containers/base_container.py 29 30 31 32 33 34 35 36 37 38 def __eq__ ( self , other : Any ) -> bool : \"\"\" Exclude Unhashable Fields When Evaluating Equality \"\"\" if isinstance ( other , CamplyModel ): return self . dict ( exclude = self . __unhashable__ ) == other . dict ( exclude = other . __unhashable__ ) else : return self . dict ( exclude = self . __unhashable__ ) == other __hash__ () # Hash Method for Pydantic BaseModels Source code in camply/containers/base_container.py 17 18 19 20 21 22 23 24 25 26 27 def __hash__ ( self ): \"\"\" Hash Method for Pydantic BaseModels \"\"\" return hash ( self . __class__ ) + hash ( tuple ( value for key , value in self . __dict__ . items () if key not in self . __unhashable__ ) ) RecDotGovAttribute # Bases: CamplyModel Attribute Object on the Recreation.gov Campsite Source code in camply/containers/base_container.py 46 47 48 49 50 51 52 53 54 class RecDotGovAttribute ( CamplyModel ): \"\"\" Attribute Object on the Recreation.gov Campsite \"\"\" attribute_category : str attribute_id : int attribute_name : str attribute_value : Any RecDotGovEquipment # Bases: CamplyModel Equipment Object on the Recreation.gov Campsite Source code in camply/containers/base_container.py 57 58 59 60 61 62 63 class RecDotGovEquipment ( CamplyModel ): \"\"\" Equipment Object on the Recreation.gov Campsite \"\"\" equipment_name : str max_length : float","title":"base_container"},{"location":"reference/containers/base_container/#camply.containers.base_container.CamplyModel","text":"Bases: BaseModel Hashable Pydantic Model Source code in camply/containers/base_container.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class CamplyModel ( BaseModel ): \"\"\" Hashable Pydantic Model \"\"\" __unhashable__ : Set [ str ] = set () def __hash__ ( self ): \"\"\" Hash Method for Pydantic BaseModels \"\"\" return hash ( self . __class__ ) + hash ( tuple ( value for key , value in self . __dict__ . items () if key not in self . __unhashable__ ) ) def __eq__ ( self , other : Any ) -> bool : \"\"\" Exclude Unhashable Fields When Evaluating Equality \"\"\" if isinstance ( other , CamplyModel ): return self . dict ( exclude = self . __unhashable__ ) == other . dict ( exclude = other . __unhashable__ ) else : return self . dict ( exclude = self . __unhashable__ ) == other","title":"CamplyModel"},{"location":"reference/containers/base_container/#camply.containers.base_container.CamplyModel.__eq__","text":"Exclude Unhashable Fields When Evaluating Equality Source code in camply/containers/base_container.py 29 30 31 32 33 34 35 36 37 38 def __eq__ ( self , other : Any ) -> bool : \"\"\" Exclude Unhashable Fields When Evaluating Equality \"\"\" if isinstance ( other , CamplyModel ): return self . dict ( exclude = self . __unhashable__ ) == other . dict ( exclude = other . __unhashable__ ) else : return self . dict ( exclude = self . __unhashable__ ) == other","title":"__eq__()"},{"location":"reference/containers/base_container/#camply.containers.base_container.CamplyModel.__hash__","text":"Hash Method for Pydantic BaseModels Source code in camply/containers/base_container.py 17 18 19 20 21 22 23 24 25 26 27 def __hash__ ( self ): \"\"\" Hash Method for Pydantic BaseModels \"\"\" return hash ( self . __class__ ) + hash ( tuple ( value for key , value in self . __dict__ . items () if key not in self . __unhashable__ ) )","title":"__hash__()"},{"location":"reference/containers/base_container/#camply.containers.base_container.RecDotGovAttribute","text":"Bases: CamplyModel Attribute Object on the Recreation.gov Campsite Source code in camply/containers/base_container.py 46 47 48 49 50 51 52 53 54 class RecDotGovAttribute ( CamplyModel ): \"\"\" Attribute Object on the Recreation.gov Campsite \"\"\" attribute_category : str attribute_id : int attribute_name : str attribute_value : Any","title":"RecDotGovAttribute"},{"location":"reference/containers/base_container/#camply.containers.base_container.RecDotGovEquipment","text":"Bases: CamplyModel Equipment Object on the Recreation.gov Campsite Source code in camply/containers/base_container.py 57 58 59 60 61 62 63 class RecDotGovEquipment ( CamplyModel ): \"\"\" Equipment Object on the Recreation.gov Campsite \"\"\" equipment_name : str max_length : float","title":"RecDotGovEquipment"},{"location":"reference/containers/data_containers/","text":"Storage Containers for the Application AvailableCampsite # Bases: CamplyModel Campsite Storage This container should be universal regardless of API Provider Source code in camply/containers/data_containers.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class AvailableCampsite ( CamplyModel ): \"\"\" Campsite Storage This container should be universal regardless of API Provider \"\"\" campsite_id : Union [ int , str ] booking_date : datetime . datetime booking_end_date : datetime . datetime booking_nights : int campsite_site_name : str campsite_loop_name : str campsite_type : str campsite_occupancy : Tuple [ int , int ] campsite_use_type : str availability_status : str recreation_area : str recreation_area_id : int facility_name : str facility_id : Union [ int , str ] booking_url : str permitted_equipment : Optional [ List [ RecDotGovEquipment ]] campsite_attributes : Optional [ List [ RecDotGovAttribute ]] __unhashable__ = { \"permitted_equipment\" , \"campsite_attributes\" } CampgroundFacility # Bases: CamplyModel Campground Facility Data Storage Source code in camply/containers/data_containers.py 69 70 71 72 73 74 75 76 77 class CampgroundFacility ( CamplyModel ): \"\"\" Campground Facility Data Storage \"\"\" facility_name : str recreation_area : str facility_id : Union [ int , str ] recreation_area_id : int RecreationArea # Bases: CamplyModel Recreation Area Data Storage Source code in camply/containers/data_containers.py 80 81 82 83 84 85 86 87 class RecreationArea ( CamplyModel ): \"\"\" Recreation Area Data Storage \"\"\" recreation_area : str recreation_area_id : int recreation_area_location : str SearchWindow # Bases: CamplyModel Search Window for Campsite Search Source code in camply/containers/data_containers.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class SearchWindow ( CamplyModel ): \"\"\" Search Window for Campsite Search \"\"\" start_date : datetime . date end_date : datetime . date def get_date_range ( self ) -> List [ datetime . date ]: \"\"\" Generate a List of Dates Between two Dates Returns ------- List[datetime.date] \"\"\" return [ self . start_date + datetime . timedelta ( days = x ) for x in range (( self . end_date - self . start_date ) . days ) ] get_date_range () # Generate a List of Dates Between two Dates Returns # List[datetime.date] Source code in camply/containers/data_containers.py 26 27 28 29 30 31 32 33 34 35 36 37 def get_date_range ( self ) -> List [ datetime . date ]: \"\"\" Generate a List of Dates Between two Dates Returns ------- List[datetime.date] \"\"\" return [ self . start_date + datetime . timedelta ( days = x ) for x in range (( self . end_date - self . start_date ) . days ) ]","title":"data_containers"},{"location":"reference/containers/data_containers/#camply.containers.data_containers.AvailableCampsite","text":"Bases: CamplyModel Campsite Storage This container should be universal regardless of API Provider Source code in camply/containers/data_containers.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class AvailableCampsite ( CamplyModel ): \"\"\" Campsite Storage This container should be universal regardless of API Provider \"\"\" campsite_id : Union [ int , str ] booking_date : datetime . datetime booking_end_date : datetime . datetime booking_nights : int campsite_site_name : str campsite_loop_name : str campsite_type : str campsite_occupancy : Tuple [ int , int ] campsite_use_type : str availability_status : str recreation_area : str recreation_area_id : int facility_name : str facility_id : Union [ int , str ] booking_url : str permitted_equipment : Optional [ List [ RecDotGovEquipment ]] campsite_attributes : Optional [ List [ RecDotGovAttribute ]] __unhashable__ = { \"permitted_equipment\" , \"campsite_attributes\" }","title":"AvailableCampsite"},{"location":"reference/containers/data_containers/#camply.containers.data_containers.CampgroundFacility","text":"Bases: CamplyModel Campground Facility Data Storage Source code in camply/containers/data_containers.py 69 70 71 72 73 74 75 76 77 class CampgroundFacility ( CamplyModel ): \"\"\" Campground Facility Data Storage \"\"\" facility_name : str recreation_area : str facility_id : Union [ int , str ] recreation_area_id : int","title":"CampgroundFacility"},{"location":"reference/containers/data_containers/#camply.containers.data_containers.RecreationArea","text":"Bases: CamplyModel Recreation Area Data Storage Source code in camply/containers/data_containers.py 80 81 82 83 84 85 86 87 class RecreationArea ( CamplyModel ): \"\"\" Recreation Area Data Storage \"\"\" recreation_area : str recreation_area_id : int recreation_area_location : str","title":"RecreationArea"},{"location":"reference/containers/data_containers/#camply.containers.data_containers.SearchWindow","text":"Bases: CamplyModel Search Window for Campsite Search Source code in camply/containers/data_containers.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class SearchWindow ( CamplyModel ): \"\"\" Search Window for Campsite Search \"\"\" start_date : datetime . date end_date : datetime . date def get_date_range ( self ) -> List [ datetime . date ]: \"\"\" Generate a List of Dates Between two Dates Returns ------- List[datetime.date] \"\"\" return [ self . start_date + datetime . timedelta ( days = x ) for x in range (( self . end_date - self . start_date ) . days ) ]","title":"SearchWindow"},{"location":"reference/containers/data_containers/#camply.containers.data_containers.SearchWindow.get_date_range","text":"Generate a List of Dates Between two Dates","title":"get_date_range()"},{"location":"reference/containers/data_containers/#camply.containers.data_containers.SearchWindow.get_date_range--returns","text":"List[datetime.date] Source code in camply/containers/data_containers.py 26 27 28 29 30 31 32 33 34 35 36 37 def get_date_range ( self ) -> List [ datetime . date ]: \"\"\" Generate a List of Dates Between two Dates Returns ------- List[datetime.date] \"\"\" return [ self . start_date + datetime . timedelta ( days = x ) for x in range (( self . end_date - self . start_date ) . days ) ]","title":"Returns"},{"location":"reference/notifications/","text":"Notifications init file EmailNotifications # Bases: BaseNotifications Notifications via Email Source code in camply/notifications/email_notifications.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 class EmailNotifications ( BaseNotifications ): \"\"\" Notifications via Email \"\"\" email_subject = EmailConfig . EMAIL_SUBJECT_LINE email_from = EmailConfig . EMAIL_FROM_ADDRESS email_to = EmailConfig . EMAIL_TO_ADDRESS email_username = EmailConfig . EMAIL_USERNAME _email_password = EmailConfig . EMAIL_PASSWORD email_smtp_server = EmailConfig . EMAIL_SMTP_SERVER email_smtp_server_port = EmailConfig . EMAIL_SMTP_PORT def __init__ ( self ): \"\"\" Data Validation **kwargs Accepts: from, to, subject, username, password, server, port \"\"\" super () . __init__ () # PERFORM SOME VALIDATION if any ( [ EmailConfig . EMAIL_TO_ADDRESS in [ None , \"\" ], EmailConfig . EMAIL_USERNAME in [ None , \"\" ], EmailConfig . EMAIL_PASSWORD in [ None , \"\" ], ] ): variable_names = \" \\n\\t \" . join ( EmailConfig . ENVIRONMENT_VARIABLE_NAMES ) optional_variable_names = \" \\n\\t \" . join ( EmailConfig . OPTIONAL_ENVIRONMENT_VARIABLE ) error_message = ( \"Email Notification Auth Parameters not set. Run `camply configure` \" f \"or set the following Environment Variables: \\n\\t { variable_names } \" \" \\n Optional Environment Variables: \\n\\t \" f \" { optional_variable_names } \" ) logger . error ( error_message ) raise EnvironmentError ( error_message ) # ATTEMPT AN EMAIL LOGIN AT INIT TO THROW ERRORS EARLY _email_server = SMTP_SSL ( self . email_smtp_server , self . email_smtp_server_port , ) _email_server . ehlo () _email_server . login ( user = self . email_username , password = self . _email_password , ) _email_server . quit () def send_message ( self , message : str , ** kwargs ) -> None : \"\"\" Send a message via Email Parameters ---------- message: str Email Body **kwargs Accepts: from, to, subject, username, password, server, port Returns ------- object \"\"\" email = EmailMessage () email . set_content ( message ) email [ \"Subject\" ] = kwargs . get ( \"subject\" , self . email_subject ) email [ \"From\" ] = kwargs . get ( \"from\" , self . email_from ) email [ \"To\" ] = kwargs . get ( \"to\" , self . email_to ) email_server_user = kwargs . get ( \"username\" , self . email_username ) email_server_password = kwargs . get ( \"password\" , self . _email_password ) email_server_smtp_server = kwargs . get ( \"server\" , self . email_smtp_server ) email_server_smtp_server_port = kwargs . get ( \"port\" , self . email_smtp_server_port ) email_server = SMTP_SSL ( email_server_smtp_server , email_server_smtp_server_port ) email_server . ehlo () email_server . login ( user = email_server_user , password = email_server_password ) logger . info ( f \"Sending Email to { email [ 'To' ] } : { email [ 'Subject' ] } \" ) email_server . send_message ( email ) logger . info ( \"Email sent successfully\" ) email_server . quit () def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ) -> None : \"\"\" Send a message with a campsite object Parameters ---------- campsites: List[AvailableCampsite] \"\"\" master_email_body_list = list () for campsite in campsites : message_title , formatted_dict = self . format_standard_campsites ( campsite = campsite , ) fields = [ message_title ] for key , value in formatted_dict . items (): if key == \"Permitted Equipment\" : value = value . replace ( \" \\n - \" , \" \\n \\t - \" ) fields . append ( f \" \\t { key } : { value } \" ) composed_message = \" \\n \" . join ( fields ) + \" \\n\\n \" master_email_body_list . append ( composed_message ) master_email_body = \" \\n \" . join ( master_email_body_list ) if len ( campsites ) > 0 : self . send_message ( message = master_email_body ) __init__ () # Data Validation **kwargs Accepts: from, to, subject, username, password, server, port Source code in camply/notifications/email_notifications.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def __init__ ( self ): \"\"\" Data Validation **kwargs Accepts: from, to, subject, username, password, server, port \"\"\" super () . __init__ () # PERFORM SOME VALIDATION if any ( [ EmailConfig . EMAIL_TO_ADDRESS in [ None , \"\" ], EmailConfig . EMAIL_USERNAME in [ None , \"\" ], EmailConfig . EMAIL_PASSWORD in [ None , \"\" ], ] ): variable_names = \" \\n\\t \" . join ( EmailConfig . ENVIRONMENT_VARIABLE_NAMES ) optional_variable_names = \" \\n\\t \" . join ( EmailConfig . OPTIONAL_ENVIRONMENT_VARIABLE ) error_message = ( \"Email Notification Auth Parameters not set. Run `camply configure` \" f \"or set the following Environment Variables: \\n\\t { variable_names } \" \" \\n Optional Environment Variables: \\n\\t \" f \" { optional_variable_names } \" ) logger . error ( error_message ) raise EnvironmentError ( error_message ) # ATTEMPT AN EMAIL LOGIN AT INIT TO THROW ERRORS EARLY _email_server = SMTP_SSL ( self . email_smtp_server , self . email_smtp_server_port , ) _email_server . ehlo () _email_server . login ( user = self . email_username , password = self . _email_password , ) _email_server . quit () send_campsites ( campsites , ** kwargs ) # Send a message with a campsite object Parameters # campsites: List[AvailableCampsite] Source code in camply/notifications/email_notifications.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ) -> None : \"\"\" Send a message with a campsite object Parameters ---------- campsites: List[AvailableCampsite] \"\"\" master_email_body_list = list () for campsite in campsites : message_title , formatted_dict = self . format_standard_campsites ( campsite = campsite , ) fields = [ message_title ] for key , value in formatted_dict . items (): if key == \"Permitted Equipment\" : value = value . replace ( \" \\n - \" , \" \\n \\t - \" ) fields . append ( f \" \\t { key } : { value } \" ) composed_message = \" \\n \" . join ( fields ) + \" \\n\\n \" master_email_body_list . append ( composed_message ) master_email_body = \" \\n \" . join ( master_email_body_list ) if len ( campsites ) > 0 : self . send_message ( message = master_email_body ) send_message ( message , ** kwargs ) # Send a message via Email Parameters # str Email Body **kwargs Accepts: from, to, subject, username, password, server, port Returns # object Source code in camply/notifications/email_notifications.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def send_message ( self , message : str , ** kwargs ) -> None : \"\"\" Send a message via Email Parameters ---------- message: str Email Body **kwargs Accepts: from, to, subject, username, password, server, port Returns ------- object \"\"\" email = EmailMessage () email . set_content ( message ) email [ \"Subject\" ] = kwargs . get ( \"subject\" , self . email_subject ) email [ \"From\" ] = kwargs . get ( \"from\" , self . email_from ) email [ \"To\" ] = kwargs . get ( \"to\" , self . email_to ) email_server_user = kwargs . get ( \"username\" , self . email_username ) email_server_password = kwargs . get ( \"password\" , self . _email_password ) email_server_smtp_server = kwargs . get ( \"server\" , self . email_smtp_server ) email_server_smtp_server_port = kwargs . get ( \"port\" , self . email_smtp_server_port ) email_server = SMTP_SSL ( email_server_smtp_server , email_server_smtp_server_port ) email_server . ehlo () email_server . login ( user = email_server_user , password = email_server_password ) logger . info ( f \"Sending Email to { email [ 'To' ] } : { email [ 'Subject' ] } \" ) email_server . send_message ( email ) logger . info ( \"Email sent successfully\" ) email_server . quit () MultiNotifierProvider # Bases: BaseNotifications Notifications Supported from Multiple Providers Source code in camply/notifications/multi_provider_notifications.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 class MultiNotifierProvider ( BaseNotifications ): \"\"\" Notifications Supported from Multiple Providers \"\"\" def __init__ ( self , provider : Union [ str , List [ str ], BaseNotifications , None ]): \"\"\" Initialize with a Notifier Class Object, a string or list of strings Parameters ---------- provider: Union[str, List[str], BaseNotifications, None] Provider String, Comma Separated Provider String, or list of provider strings \"\"\" super () . __init__ () self . providers = [ SilentNotifications ()] if isinstance ( provider , str ): provider = [ prov_string . strip () for prov_string in provider . split ( \",\" )] for notifier_object in provider : if isinstance ( notifier_object , BaseNotifications ): notifier = notifier_object elif isinstance ( notifier_object , str ): notifier = CAMPSITE_NOTIFICATIONS . get ( notifier_object . lower (), None )() elif notifier_object is None : notifier = None else : raise NotificationError ( \"You must provide a proper Notification Identifier\" ) if notifier is not None and not isinstance ( notifier , SilentNotifications ): self . providers . append ( notifier ) def send_message ( self , message : str , ** kwargs ): \"\"\" Send a message Parameters ---------- message: str Message Text **kwargs All kwargs passed to underlying notification method \"\"\" for provider in self . providers : provider . send_message ( message = message , ** kwargs ) def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: List[AvailableCampsite] \"\"\" for provider in self . providers : provider . send_campsites ( campsites = campsites , ** kwargs ) def log_providers ( self ) -> None : \"\"\" Log All Providers Returns ------- None \"\"\" provider_names = [ str ( provider ) for provider in self . providers ] logger . info ( f \"Notifications active via: { ', ' . join ( provider_names ) } \" ) if len ( self . providers ) == 1 : logger . info ( f \"Only { self . providers [ 0 ] } enabled. \" \"I hope you're watching these logs.\" ) __init__ ( provider ) # Initialize with a Notifier Class Object, a string or list of strings Parameters # Union[str, List[str], BaseNotifications, None] Provider String, Comma Separated Provider String, or list of provider strings Source code in camply/notifications/multi_provider_notifications.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def __init__ ( self , provider : Union [ str , List [ str ], BaseNotifications , None ]): \"\"\" Initialize with a Notifier Class Object, a string or list of strings Parameters ---------- provider: Union[str, List[str], BaseNotifications, None] Provider String, Comma Separated Provider String, or list of provider strings \"\"\" super () . __init__ () self . providers = [ SilentNotifications ()] if isinstance ( provider , str ): provider = [ prov_string . strip () for prov_string in provider . split ( \",\" )] for notifier_object in provider : if isinstance ( notifier_object , BaseNotifications ): notifier = notifier_object elif isinstance ( notifier_object , str ): notifier = CAMPSITE_NOTIFICATIONS . get ( notifier_object . lower (), None )() elif notifier_object is None : notifier = None else : raise NotificationError ( \"You must provide a proper Notification Identifier\" ) if notifier is not None and not isinstance ( notifier , SilentNotifications ): self . providers . append ( notifier ) log_providers () # Log All Providers Returns # None Source code in camply/notifications/multi_provider_notifications.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def log_providers ( self ) -> None : \"\"\" Log All Providers Returns ------- None \"\"\" provider_names = [ str ( provider ) for provider in self . providers ] logger . info ( f \"Notifications active via: { ', ' . join ( provider_names ) } \" ) if len ( self . providers ) == 1 : logger . info ( f \"Only { self . providers [ 0 ] } enabled. \" \"I hope you're watching these logs.\" ) send_campsites ( campsites , ** kwargs ) # Send a message with a campsite object Parameters # campsites: List[AvailableCampsite] Source code in camply/notifications/multi_provider_notifications.py 78 79 80 81 82 83 84 85 86 87 def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: List[AvailableCampsite] \"\"\" for provider in self . providers : provider . send_campsites ( campsites = campsites , ** kwargs ) send_message ( message , ** kwargs ) # Send a message Parameters # str Message Text **kwargs All kwargs passed to underlying notification method Source code in camply/notifications/multi_provider_notifications.py 64 65 66 67 68 69 70 71 72 73 74 75 76 def send_message ( self , message : str , ** kwargs ): \"\"\" Send a message Parameters ---------- message: str Message Text **kwargs All kwargs passed to underlying notification method \"\"\" for provider in self . providers : provider . send_message ( message = message , ** kwargs ) PushbulletNotifications # Bases: BaseNotifications Push Notifications via PushBullet Source code in camply/notifications/pushbullet.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 class PushbulletNotifications ( BaseNotifications ): \"\"\" Push Notifications via PushBullet \"\"\" def __init__ ( self ): super () . __init__ () pushbullet_headers = PushbulletConfig . API_HEADERS . copy () pushbullet_headers . update ({ \"Access-Token\" : PushbulletConfig . API_TOKEN }) self . session . headers . update ( pushbullet_headers ) if any ([ PushbulletConfig . API_TOKEN is None , PushbulletConfig . API_TOKEN == \"\" ]): warning_message = ( \"Pushbullet is not configured properly. To send Pushbullet messages \" \"make sure to run `camply configure` or set the \" \"proper environment variable: `PUSHBULLET_API_TOKEN`.\" ) logger . error ( warning_message ) raise EnvironmentError ( warning_message ) def send_message ( self , message : str , ** kwargs ) -> requests . Response : \"\"\" Send a message via PushBullet - if environment variables are configured Parameters ---------- message: str Returns ------- requests.Response \"\"\" message_type = kwargs . pop ( \"type\" , \"note\" ) message_title = kwargs . pop ( \"title\" , \"Camply Notification\" ) message_json = dict ( type = message_type , title = message_title , body = message , ** kwargs ) logger . debug ( message_json ) response = self . session . post ( url = PushbulletConfig . PUSHBULLET_API_ENDPOINT , json = message_json , ) try : response . raise_for_status () except requests . HTTPError as he : logger . warning ( \"Notifications weren't able to be sent to Pushbullet. \" \"Your configuration might be incorrect.\" ) raise ConnectionError ( response . text ) from he return response def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: AvailableCampsite \"\"\" for campsite in campsites : message_title , formatted_dict = self . format_standard_campsites ( campsite = campsite , ) fields = [] for key , value in formatted_dict . items (): fields . append ( f \" { key } : { value } \" ) composed_message = \" \\n \" . join ( fields ) self . send_message ( message = composed_message , title = message_title , type = \"note\" ) send_campsites ( campsites , ** kwargs ) # Send a message with a campsite object Parameters # campsites: AvailableCampsite Source code in camply/notifications/pushbullet.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: AvailableCampsite \"\"\" for campsite in campsites : message_title , formatted_dict = self . format_standard_campsites ( campsite = campsite , ) fields = [] for key , value in formatted_dict . items (): fields . append ( f \" { key } : { value } \" ) composed_message = \" \\n \" . join ( fields ) self . send_message ( message = composed_message , title = message_title , type = \"note\" ) send_message ( message , ** kwargs ) # Send a message via PushBullet - if environment variables are configured Parameters # message: str Returns # requests.Response Source code in camply/notifications/pushbullet.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def send_message ( self , message : str , ** kwargs ) -> requests . Response : \"\"\" Send a message via PushBullet - if environment variables are configured Parameters ---------- message: str Returns ------- requests.Response \"\"\" message_type = kwargs . pop ( \"type\" , \"note\" ) message_title = kwargs . pop ( \"title\" , \"Camply Notification\" ) message_json = dict ( type = message_type , title = message_title , body = message , ** kwargs ) logger . debug ( message_json ) response = self . session . post ( url = PushbulletConfig . PUSHBULLET_API_ENDPOINT , json = message_json , ) try : response . raise_for_status () except requests . HTTPError as he : logger . warning ( \"Notifications weren't able to be sent to Pushbullet. \" \"Your configuration might be incorrect.\" ) raise ConnectionError ( response . text ) from he return response PushoverNotifications # Bases: BaseNotifications , logging . StreamHandler Push Notifications via Pushover + a Logging Handler Source code in camply/notifications/pushover.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 class PushoverNotifications ( BaseNotifications , logging . StreamHandler ): \"\"\" Push Notifications via Pushover + a Logging Handler \"\"\" def __init__ ( self , level : Optional [ int ] = logging . INFO ): super () . __init__ () self . session . headers . update ( PushoverConfig . API_HEADERS ) logging . StreamHandler . __init__ ( self ) self . setLevel ( level = level ) if any ([ PushoverConfig . PUSH_USER is None , PushoverConfig . PUSH_USER == \"\" ]): warning_message = ( \"Pushover is not configured properly. To send pushover messages \" \"make sure to run `camply configure` or set the \" \"proper environment variables: `PUSHOVER_PUSH_USER`, \" \"`PUSHOVER_PUSH_TOKEN`.\" ) logger . error ( warning_message ) raise EnvironmentError ( warning_message ) def send_message ( self , message : str , ** kwargs ) -> requests . Response : \"\"\" Send a message via Pushover - if environment variables are configured Parameters ---------- message: str Returns ------- requests.Response \"\"\" token = ( PushoverConfig . PUSH_TOKEN if PushoverConfig . PUSH_TOKEN not in [ None , \"\" ] else base64 . b64decode ( PushoverConfig . PUSHOVER_DEFAULT_API_TOKEN ) . decode ( \"utf-8\" ) ) response = self . session . post ( url = PushoverConfig . PUSHOVER_API_ENDPOINT , params = dict ( token = token , user = PushoverConfig . PUSH_USER , message = message , ** kwargs ), ) try : response . raise_for_status () except requests . HTTPError as he : logger . warning ( \"Notifications weren't able to be sent to Pushover. \" \"Your configuration might be incorrect.\" ) raise ConnectionError ( response . text ) from he return response def emit ( self , record : logging . LogRecord ): \"\"\" Produce a logging record Parameters ---------- record: str Message to log \"\"\" log_formatted_message = \"[ {:>10} ]: {} \" . format ( record . levelname . upper (), record . msg ) title = f \"Pushover { record . levelname . title () } Message\" self . send_message ( message = log_formatted_message , title = title ) def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: AvailableCampsite \"\"\" for campsite in campsites : message_title , formatted_dict = self . format_standard_campsites ( campsite = campsite , ) fields = [] for key , value in formatted_dict . items (): if key == \"Booking Link\" : value = f \"<a href=' { value } '> { value } </a>\" fields . append ( f \"<b> { key } :</b> { value } \" ) composed_message = \" \\n \" . join ( fields ) self . send_message ( message = composed_message , title = message_title , html = 1 ) emit ( record ) # Produce a logging record Parameters # str Message to log Source code in camply/notifications/pushover.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def emit ( self , record : logging . LogRecord ): \"\"\" Produce a logging record Parameters ---------- record: str Message to log \"\"\" log_formatted_message = \"[ {:>10} ]: {} \" . format ( record . levelname . upper (), record . msg ) title = f \"Pushover { record . levelname . title () } Message\" self . send_message ( message = log_formatted_message , title = title ) send_campsites ( campsites , ** kwargs ) # Send a message with a campsite object Parameters # campsites: AvailableCampsite Source code in camply/notifications/pushover.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: AvailableCampsite \"\"\" for campsite in campsites : message_title , formatted_dict = self . format_standard_campsites ( campsite = campsite , ) fields = [] for key , value in formatted_dict . items (): if key == \"Booking Link\" : value = f \"<a href=' { value } '> { value } </a>\" fields . append ( f \"<b> { key } :</b> { value } \" ) composed_message = \" \\n \" . join ( fields ) self . send_message ( message = composed_message , title = message_title , html = 1 ) send_message ( message , ** kwargs ) # Send a message via Pushover - if environment variables are configured Parameters # message: str Returns # requests.Response Source code in camply/notifications/pushover.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 def send_message ( self , message : str , ** kwargs ) -> requests . Response : \"\"\" Send a message via Pushover - if environment variables are configured Parameters ---------- message: str Returns ------- requests.Response \"\"\" token = ( PushoverConfig . PUSH_TOKEN if PushoverConfig . PUSH_TOKEN not in [ None , \"\" ] else base64 . b64decode ( PushoverConfig . PUSHOVER_DEFAULT_API_TOKEN ) . decode ( \"utf-8\" ) ) response = self . session . post ( url = PushoverConfig . PUSHOVER_API_ENDPOINT , params = dict ( token = token , user = PushoverConfig . PUSH_USER , message = message , ** kwargs ), ) try : response . raise_for_status () except requests . HTTPError as he : logger . warning ( \"Notifications weren't able to be sent to Pushover. \" \"Your configuration might be incorrect.\" ) raise ConnectionError ( response . text ) from he return response SilentNotifications # Bases: BaseNotifications Silent Notifications Source code in camply/notifications/silent_notifications.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class SilentNotifications ( BaseNotifications ): \"\"\" Silent Notifications \"\"\" def send_message ( self , message : Iterable , ** kwargs ) -> None : \"\"\" Send a message via Email Parameters ---------- message: Iterable Email Body **kwargs kwargs are disregarded Returns ------- None \"\"\" message_string = \" \\n\\t \u2022 \" + \" \\n\\t \u2022 \" . join ( list ( message )) logger . debug ( f \"SilentNotification: { message_string } \" ) def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: List[AvailableCampsite] \"\"\" for campsite in campsites : campsite_tuple = ( ( f \" { campsite . booking_date . strftime ( '%Y-%m- %d ' ) } - \" f \" { campsite . booking_end_date . strftime ( '%Y-%m- %d ' ) } \" ), campsite . campsite_type , campsite . campsite_site_name , campsite . recreation_area , campsite . facility_name , campsite . booking_url , ) self . send_message ( campsite_tuple ) campsite_formatted = pformat ( campsite . dict ()) logger . debug ( \"Campsite Info: \" + campsite_formatted ) send_campsites ( campsites , ** kwargs ) # Send a message with a campsite object Parameters # campsites: List[AvailableCampsite] Source code in camply/notifications/silent_notifications.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: List[AvailableCampsite] \"\"\" for campsite in campsites : campsite_tuple = ( ( f \" { campsite . booking_date . strftime ( '%Y-%m- %d ' ) } - \" f \" { campsite . booking_end_date . strftime ( '%Y-%m- %d ' ) } \" ), campsite . campsite_type , campsite . campsite_site_name , campsite . recreation_area , campsite . facility_name , campsite . booking_url , ) self . send_message ( campsite_tuple ) campsite_formatted = pformat ( campsite . dict ()) logger . debug ( \"Campsite Info: \" + campsite_formatted ) send_message ( message , ** kwargs ) # Send a message via Email Parameters # Iterable Email Body **kwargs kwargs are disregarded Returns # None Source code in camply/notifications/silent_notifications.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def send_message ( self , message : Iterable , ** kwargs ) -> None : \"\"\" Send a message via Email Parameters ---------- message: Iterable Email Body **kwargs kwargs are disregarded Returns ------- None \"\"\" message_string = \" \\n\\t \u2022 \" + \" \\n\\t \u2022 \" . join ( list ( message )) logger . debug ( f \"SilentNotification: { message_string } \" ) SlackNotifications # Bases: BaseNotifications Push Notifications via Slack Source code in camply/notifications/slack.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 class SlackNotifications ( BaseNotifications ): \"\"\" Push Notifications via Slack \"\"\" def __init__ ( self ): super () . __init__ () self . session . headers . update ({ \"Content-Type\" : \"application/json\" }) if any ([ SlackConfig . SLACK_WEBHOOK is None , SlackConfig . SLACK_WEBHOOK == \"\" ]): warning_message = ( \"Slack is not configured properly. To send Slack messages \" \"make sure to run `camply configure` or set the \" \"proper environment variable: `SLACK_WEBHOOK`.\" ) logger . error ( warning_message ) raise EnvironmentError ( warning_message ) def send_message ( self , message : str , ** kwargs ) -> requests . Response : \"\"\" Send a message via Slack - if environment variables are configured. Parameters ---------- message: str blocks: List Returns ------- requests.Response \"\"\" message_blocks = kwargs . pop ( \"blocks\" , []) message_json = { \"text\" : message , } if message_blocks : message_json = { \"blocks\" : message_blocks , } logger . debug ( message_json ) response = self . session . post ( url = SlackConfig . SLACK_WEBHOOK , json = message_json , ) try : response . raise_for_status () except requests . HTTPError as he : logger . warning ( \"Notifications weren't able to be sent to Slack. \" \"Your configuration might be incorrect.\" ) raise ConnectionError ( response . text ) from he return response def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: AvailableCampsite \"\"\" for campsite in campsites : message_title , formatted_dict = self . format_standard_campsites ( campsite = campsite , ) fields = [] for key , value in formatted_dict . items (): fields . append ( { \"type\" : \"mrkdwn\" , \"text\" : f \"* { key } *\" , } ) if key in [ \"Permitted Equipment\" , \"Booking Link\" ]: data_type = \"mrkdwn\" else : data_type = \"plain_text\" fields . append ( { \"type\" : data_type , \"text\" : str ( value ), } ) blocks = [] blocks . append ( { \"type\" : \"header\" , \"text\" : { \"type\" : \"plain_text\" , \"text\" : message_title , }, } ) # Slack only allows 10 fields (k+v) per section for chunk in range ( 0 , len ( fields ) + 1 , 10 ): chunk_max = chunk + 10 blocks . append ( { \"type\" : \"section\" , \"fields\" : fields [ chunk : chunk_max ], } ) self . send_message ( message = message_title , blocks = blocks , ) send_campsites ( campsites , ** kwargs ) # Send a message with a campsite object Parameters # campsites: AvailableCampsite Source code in camply/notifications/slack.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: AvailableCampsite \"\"\" for campsite in campsites : message_title , formatted_dict = self . format_standard_campsites ( campsite = campsite , ) fields = [] for key , value in formatted_dict . items (): fields . append ( { \"type\" : \"mrkdwn\" , \"text\" : f \"* { key } *\" , } ) if key in [ \"Permitted Equipment\" , \"Booking Link\" ]: data_type = \"mrkdwn\" else : data_type = \"plain_text\" fields . append ( { \"type\" : data_type , \"text\" : str ( value ), } ) blocks = [] blocks . append ( { \"type\" : \"header\" , \"text\" : { \"type\" : \"plain_text\" , \"text\" : message_title , }, } ) # Slack only allows 10 fields (k+v) per section for chunk in range ( 0 , len ( fields ) + 1 , 10 ): chunk_max = chunk + 10 blocks . append ( { \"type\" : \"section\" , \"fields\" : fields [ chunk : chunk_max ], } ) self . send_message ( message = message_title , blocks = blocks , ) send_message ( message , ** kwargs ) # Send a message via Slack - if environment variables are configured. Parameters # message: str blocks: List Returns # requests.Response Source code in camply/notifications/slack.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def send_message ( self , message : str , ** kwargs ) -> requests . Response : \"\"\" Send a message via Slack - if environment variables are configured. Parameters ---------- message: str blocks: List Returns ------- requests.Response \"\"\" message_blocks = kwargs . pop ( \"blocks\" , []) message_json = { \"text\" : message , } if message_blocks : message_json = { \"blocks\" : message_blocks , } logger . debug ( message_json ) response = self . session . post ( url = SlackConfig . SLACK_WEBHOOK , json = message_json , ) try : response . raise_for_status () except requests . HTTPError as he : logger . warning ( \"Notifications weren't able to be sent to Slack. \" \"Your configuration might be incorrect.\" ) raise ConnectionError ( response . text ) from he return response TelegramNotifications # Bases: BaseNotifications Push Notifications via Telegram Source code in camply/notifications/telegram.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 class TelegramNotifications ( BaseNotifications ): \"\"\" Push Notifications via Telegram \"\"\" def __init__ ( self ): super () . __init__ () self . session . headers . update ( TelegramConfig . API_HEADERS ) if any ( [ TelegramConfig . BOT_TOKEN is None , TelegramConfig . BOT_TOKEN == \"\" , TelegramConfig . CHAT_ID is None , TelegramConfig . CHAT_ID == \"\" , ] ): warning_message = ( \"Telegram is not configured properly. To send Telegram messages \" \"make sure to run `camply configure` or set the \" \"proper environment variables: `TELEGRAM_BOT_TOKEN` and `TELEGRAM_CHAT_ID`.\" ) logger . error ( warning_message ) raise EnvironmentError ( warning_message ) def send_message ( self , message : str , escaped = False , ** kwargs ) -> requests . Response : \"\"\" Send a message via Telegram - if environment variables are configured Parameters ---------- message: str escaped: bool Returns ------- requests.Response \"\"\" if not escaped : message = self . escape_text ( message ) message_json = TelegramConfig . API_CONTENT . copy () message_json . update ({ \"text\" : message }) logger . debug ( message_json ) response = self . session . post ( url = TelegramConfig . API_ENDPOINT , json = message_json ) try : response . raise_for_status () except requests . HTTPError as he : logger . warning ( \"Notifications weren't able to be sent to Telegram. \" \"Your configuration might be incorrect.\" ) raise ConnectionError ( response . text ) from he return response @staticmethod def escape_text ( message : str ) -> str : \"\"\" Escape a message for use in Telegram Parameters ---------- message: str Returns ------- String \"\"\" fields = [ \"_\" , \"*\" , \"[\" , \"]\" , \"(\" , \")\" , \"~\" , \"`\" , \">\" , \"#\" , \"+\" , \"-\" , \"=\" , \"|\" , \"{\" , \"}\" , \".\" , \"!\" , ] for f in fields : message = message . replace ( f , f \" \\\\ { f } \" ) return message def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: AvailableCampsite \"\"\" for campsite in campsites : message_title , formatted_dict = self . format_standard_campsites ( campsite = campsite , ) fields = [] for key , value in formatted_dict . items (): fields . append ( self . escape_text ( f \" { key } : { value } \" )) message_fields = \" \\n \" . join ( fields ) message = f \"* { self . escape_text ( message_title ) } * \\n { message_fields } \" self . send_message ( message , escaped = True ) escape_text ( message ) staticmethod # Escape a message for use in Telegram Parameters # message: str Returns # String Source code in camply/notifications/telegram.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 @staticmethod def escape_text ( message : str ) -> str : \"\"\" Escape a message for use in Telegram Parameters ---------- message: str Returns ------- String \"\"\" fields = [ \"_\" , \"*\" , \"[\" , \"]\" , \"(\" , \")\" , \"~\" , \"`\" , \">\" , \"#\" , \"+\" , \"-\" , \"=\" , \"|\" , \"{\" , \"}\" , \".\" , \"!\" , ] for f in fields : message = message . replace ( f , f \" \\\\ { f } \" ) return message send_campsites ( campsites , ** kwargs ) # Send a message with a campsite object Parameters # campsites: AvailableCampsite Source code in camply/notifications/telegram.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: AvailableCampsite \"\"\" for campsite in campsites : message_title , formatted_dict = self . format_standard_campsites ( campsite = campsite , ) fields = [] for key , value in formatted_dict . items (): fields . append ( self . escape_text ( f \" { key } : { value } \" )) message_fields = \" \\n \" . join ( fields ) message = f \"* { self . escape_text ( message_title ) } * \\n { message_fields } \" self . send_message ( message , escaped = True ) send_message ( message , escaped = False , ** kwargs ) # Send a message via Telegram - if environment variables are configured Parameters # message: str escaped: bool Returns # requests.Response Source code in camply/notifications/telegram.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def send_message ( self , message : str , escaped = False , ** kwargs ) -> requests . Response : \"\"\" Send a message via Telegram - if environment variables are configured Parameters ---------- message: str escaped: bool Returns ------- requests.Response \"\"\" if not escaped : message = self . escape_text ( message ) message_json = TelegramConfig . API_CONTENT . copy () message_json . update ({ \"text\" : message }) logger . debug ( message_json ) response = self . session . post ( url = TelegramConfig . API_ENDPOINT , json = message_json ) try : response . raise_for_status () except requests . HTTPError as he : logger . warning ( \"Notifications weren't able to be sent to Telegram. \" \"Your configuration might be incorrect.\" ) raise ConnectionError ( response . text ) from he return response TwilioNotifications # Bases: BaseNotifications Push Notifications via Twilio Source code in camply/notifications/twilio.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 class TwilioNotifications ( BaseNotifications ): \"\"\" Push Notifications via Twilio \"\"\" def __init__ ( self ): super () . __init__ () try : from twilio.rest import Client except ImportError : raise RuntimeError ( \"Looks like `twilio` isn't installed. Install it with `pip install camply[twilio]`\" ) if any ( [ TwilioConfig . ACCOUNT_SID is None , TwilioConfig . ACCOUNT_SID == \"\" , TwilioConfig . AUTH_TOKEN is None , TwilioConfig . AUTH_TOKEN == \"\" , ] ): warning_message = ( \"Twilio is not configured properly. To send Twilio messages \" \"make sure to run `camply configure` or set the \" \"proper environment variable: `TWILIO_ACCOUNT_SID`, `TWILIO_AUTH_TOKEN`.\" ) logger . error ( warning_message ) raise EnvironmentError ( warning_message ) self . client = Client ( TwilioConfig . ACCOUNT_SID , TwilioConfig . AUTH_TOKEN ) self . phone_nums = TwilioConfig . DEST_NUMBERS . split ( \",\" ) logger . info ( \"Twilio: will notify these phone numbers: \" + \", \" . join ( self . phone_nums ) ) def send_message ( self , message : str , ** kwargs ): \"\"\" Send a message via Twilio - if environment variables are configured Parameters ---------- message: str \"\"\" for phone_num in self . phone_nums : self . client . messages . create ( to = phone_num , from_ = TwilioConfig . SOURCE_NUMBER , body = message ) def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: AvailableCampsite \"\"\" for campsite in campsites : message_title , formatted_dict = self . format_standard_campsites ( campsite = campsite , ) fields = [ f \"\ud83c\udfd5 { message_title } \" , \"\" ] for key , value in formatted_dict . items (): fields . append ( f \" { key } : { value } \" ) fields . append ( \"\" ) fields . append ( \"camply, the campsite finder \u26fa\ufe0f\" ) composed_message = \" \\n \" . join ( fields ) self . send_message ( message = composed_message ) send_campsites ( campsites , ** kwargs ) # Send a message with a campsite object Parameters # campsites: AvailableCampsite Source code in camply/notifications/twilio.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: AvailableCampsite \"\"\" for campsite in campsites : message_title , formatted_dict = self . format_standard_campsites ( campsite = campsite , ) fields = [ f \"\ud83c\udfd5 { message_title } \" , \"\" ] for key , value in formatted_dict . items (): fields . append ( f \" { key } : { value } \" ) fields . append ( \"\" ) fields . append ( \"camply, the campsite finder \u26fa\ufe0f\" ) composed_message = \" \\n \" . join ( fields ) self . send_message ( message = composed_message ) send_message ( message , ** kwargs ) # Send a message via Twilio - if environment variables are configured Parameters # message: str Source code in camply/notifications/twilio.py 51 52 53 54 55 56 57 58 59 60 61 62 def send_message ( self , message : str , ** kwargs ): \"\"\" Send a message via Twilio - if environment variables are configured Parameters ---------- message: str \"\"\" for phone_num in self . phone_nums : self . client . messages . create ( to = phone_num , from_ = TwilioConfig . SOURCE_NUMBER , body = message )","title":"notifications"},{"location":"reference/notifications/#camply.notifications.EmailNotifications","text":"Bases: BaseNotifications Notifications via Email Source code in camply/notifications/email_notifications.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 class EmailNotifications ( BaseNotifications ): \"\"\" Notifications via Email \"\"\" email_subject = EmailConfig . EMAIL_SUBJECT_LINE email_from = EmailConfig . EMAIL_FROM_ADDRESS email_to = EmailConfig . EMAIL_TO_ADDRESS email_username = EmailConfig . EMAIL_USERNAME _email_password = EmailConfig . EMAIL_PASSWORD email_smtp_server = EmailConfig . EMAIL_SMTP_SERVER email_smtp_server_port = EmailConfig . EMAIL_SMTP_PORT def __init__ ( self ): \"\"\" Data Validation **kwargs Accepts: from, to, subject, username, password, server, port \"\"\" super () . __init__ () # PERFORM SOME VALIDATION if any ( [ EmailConfig . EMAIL_TO_ADDRESS in [ None , \"\" ], EmailConfig . EMAIL_USERNAME in [ None , \"\" ], EmailConfig . EMAIL_PASSWORD in [ None , \"\" ], ] ): variable_names = \" \\n\\t \" . join ( EmailConfig . ENVIRONMENT_VARIABLE_NAMES ) optional_variable_names = \" \\n\\t \" . join ( EmailConfig . OPTIONAL_ENVIRONMENT_VARIABLE ) error_message = ( \"Email Notification Auth Parameters not set. Run `camply configure` \" f \"or set the following Environment Variables: \\n\\t { variable_names } \" \" \\n Optional Environment Variables: \\n\\t \" f \" { optional_variable_names } \" ) logger . error ( error_message ) raise EnvironmentError ( error_message ) # ATTEMPT AN EMAIL LOGIN AT INIT TO THROW ERRORS EARLY _email_server = SMTP_SSL ( self . email_smtp_server , self . email_smtp_server_port , ) _email_server . ehlo () _email_server . login ( user = self . email_username , password = self . _email_password , ) _email_server . quit () def send_message ( self , message : str , ** kwargs ) -> None : \"\"\" Send a message via Email Parameters ---------- message: str Email Body **kwargs Accepts: from, to, subject, username, password, server, port Returns ------- object \"\"\" email = EmailMessage () email . set_content ( message ) email [ \"Subject\" ] = kwargs . get ( \"subject\" , self . email_subject ) email [ \"From\" ] = kwargs . get ( \"from\" , self . email_from ) email [ \"To\" ] = kwargs . get ( \"to\" , self . email_to ) email_server_user = kwargs . get ( \"username\" , self . email_username ) email_server_password = kwargs . get ( \"password\" , self . _email_password ) email_server_smtp_server = kwargs . get ( \"server\" , self . email_smtp_server ) email_server_smtp_server_port = kwargs . get ( \"port\" , self . email_smtp_server_port ) email_server = SMTP_SSL ( email_server_smtp_server , email_server_smtp_server_port ) email_server . ehlo () email_server . login ( user = email_server_user , password = email_server_password ) logger . info ( f \"Sending Email to { email [ 'To' ] } : { email [ 'Subject' ] } \" ) email_server . send_message ( email ) logger . info ( \"Email sent successfully\" ) email_server . quit () def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ) -> None : \"\"\" Send a message with a campsite object Parameters ---------- campsites: List[AvailableCampsite] \"\"\" master_email_body_list = list () for campsite in campsites : message_title , formatted_dict = self . format_standard_campsites ( campsite = campsite , ) fields = [ message_title ] for key , value in formatted_dict . items (): if key == \"Permitted Equipment\" : value = value . replace ( \" \\n - \" , \" \\n \\t - \" ) fields . append ( f \" \\t { key } : { value } \" ) composed_message = \" \\n \" . join ( fields ) + \" \\n\\n \" master_email_body_list . append ( composed_message ) master_email_body = \" \\n \" . join ( master_email_body_list ) if len ( campsites ) > 0 : self . send_message ( message = master_email_body )","title":"EmailNotifications"},{"location":"reference/notifications/#camply.notifications.email_notifications.EmailNotifications.__init__","text":"Data Validation **kwargs Accepts: from, to, subject, username, password, server, port Source code in camply/notifications/email_notifications.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def __init__ ( self ): \"\"\" Data Validation **kwargs Accepts: from, to, subject, username, password, server, port \"\"\" super () . __init__ () # PERFORM SOME VALIDATION if any ( [ EmailConfig . EMAIL_TO_ADDRESS in [ None , \"\" ], EmailConfig . EMAIL_USERNAME in [ None , \"\" ], EmailConfig . EMAIL_PASSWORD in [ None , \"\" ], ] ): variable_names = \" \\n\\t \" . join ( EmailConfig . ENVIRONMENT_VARIABLE_NAMES ) optional_variable_names = \" \\n\\t \" . join ( EmailConfig . OPTIONAL_ENVIRONMENT_VARIABLE ) error_message = ( \"Email Notification Auth Parameters not set. Run `camply configure` \" f \"or set the following Environment Variables: \\n\\t { variable_names } \" \" \\n Optional Environment Variables: \\n\\t \" f \" { optional_variable_names } \" ) logger . error ( error_message ) raise EnvironmentError ( error_message ) # ATTEMPT AN EMAIL LOGIN AT INIT TO THROW ERRORS EARLY _email_server = SMTP_SSL ( self . email_smtp_server , self . email_smtp_server_port , ) _email_server . ehlo () _email_server . login ( user = self . email_username , password = self . _email_password , ) _email_server . quit ()","title":"__init__()"},{"location":"reference/notifications/#camply.notifications.email_notifications.EmailNotifications.send_campsites","text":"Send a message with a campsite object","title":"send_campsites()"},{"location":"reference/notifications/#camply.notifications.email_notifications.EmailNotifications.send_campsites--parameters","text":"campsites: List[AvailableCampsite] Source code in camply/notifications/email_notifications.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ) -> None : \"\"\" Send a message with a campsite object Parameters ---------- campsites: List[AvailableCampsite] \"\"\" master_email_body_list = list () for campsite in campsites : message_title , formatted_dict = self . format_standard_campsites ( campsite = campsite , ) fields = [ message_title ] for key , value in formatted_dict . items (): if key == \"Permitted Equipment\" : value = value . replace ( \" \\n - \" , \" \\n \\t - \" ) fields . append ( f \" \\t { key } : { value } \" ) composed_message = \" \\n \" . join ( fields ) + \" \\n\\n \" master_email_body_list . append ( composed_message ) master_email_body = \" \\n \" . join ( master_email_body_list ) if len ( campsites ) > 0 : self . send_message ( message = master_email_body )","title":"Parameters"},{"location":"reference/notifications/#camply.notifications.email_notifications.EmailNotifications.send_message","text":"Send a message via Email","title":"send_message()"},{"location":"reference/notifications/#camply.notifications.email_notifications.EmailNotifications.send_message--parameters","text":"str Email Body **kwargs Accepts: from, to, subject, username, password, server, port","title":"Parameters"},{"location":"reference/notifications/#camply.notifications.email_notifications.EmailNotifications.send_message--returns","text":"object Source code in camply/notifications/email_notifications.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def send_message ( self , message : str , ** kwargs ) -> None : \"\"\" Send a message via Email Parameters ---------- message: str Email Body **kwargs Accepts: from, to, subject, username, password, server, port Returns ------- object \"\"\" email = EmailMessage () email . set_content ( message ) email [ \"Subject\" ] = kwargs . get ( \"subject\" , self . email_subject ) email [ \"From\" ] = kwargs . get ( \"from\" , self . email_from ) email [ \"To\" ] = kwargs . get ( \"to\" , self . email_to ) email_server_user = kwargs . get ( \"username\" , self . email_username ) email_server_password = kwargs . get ( \"password\" , self . _email_password ) email_server_smtp_server = kwargs . get ( \"server\" , self . email_smtp_server ) email_server_smtp_server_port = kwargs . get ( \"port\" , self . email_smtp_server_port ) email_server = SMTP_SSL ( email_server_smtp_server , email_server_smtp_server_port ) email_server . ehlo () email_server . login ( user = email_server_user , password = email_server_password ) logger . info ( f \"Sending Email to { email [ 'To' ] } : { email [ 'Subject' ] } \" ) email_server . send_message ( email ) logger . info ( \"Email sent successfully\" ) email_server . quit ()","title":"Returns"},{"location":"reference/notifications/#camply.notifications.MultiNotifierProvider","text":"Bases: BaseNotifications Notifications Supported from Multiple Providers Source code in camply/notifications/multi_provider_notifications.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 class MultiNotifierProvider ( BaseNotifications ): \"\"\" Notifications Supported from Multiple Providers \"\"\" def __init__ ( self , provider : Union [ str , List [ str ], BaseNotifications , None ]): \"\"\" Initialize with a Notifier Class Object, a string or list of strings Parameters ---------- provider: Union[str, List[str], BaseNotifications, None] Provider String, Comma Separated Provider String, or list of provider strings \"\"\" super () . __init__ () self . providers = [ SilentNotifications ()] if isinstance ( provider , str ): provider = [ prov_string . strip () for prov_string in provider . split ( \",\" )] for notifier_object in provider : if isinstance ( notifier_object , BaseNotifications ): notifier = notifier_object elif isinstance ( notifier_object , str ): notifier = CAMPSITE_NOTIFICATIONS . get ( notifier_object . lower (), None )() elif notifier_object is None : notifier = None else : raise NotificationError ( \"You must provide a proper Notification Identifier\" ) if notifier is not None and not isinstance ( notifier , SilentNotifications ): self . providers . append ( notifier ) def send_message ( self , message : str , ** kwargs ): \"\"\" Send a message Parameters ---------- message: str Message Text **kwargs All kwargs passed to underlying notification method \"\"\" for provider in self . providers : provider . send_message ( message = message , ** kwargs ) def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: List[AvailableCampsite] \"\"\" for provider in self . providers : provider . send_campsites ( campsites = campsites , ** kwargs ) def log_providers ( self ) -> None : \"\"\" Log All Providers Returns ------- None \"\"\" provider_names = [ str ( provider ) for provider in self . providers ] logger . info ( f \"Notifications active via: { ', ' . join ( provider_names ) } \" ) if len ( self . providers ) == 1 : logger . info ( f \"Only { self . providers [ 0 ] } enabled. \" \"I hope you're watching these logs.\" )","title":"MultiNotifierProvider"},{"location":"reference/notifications/#camply.notifications.multi_provider_notifications.MultiNotifierProvider.__init__","text":"Initialize with a Notifier Class Object, a string or list of strings","title":"__init__()"},{"location":"reference/notifications/#camply.notifications.multi_provider_notifications.MultiNotifierProvider.__init__--parameters","text":"Union[str, List[str], BaseNotifications, None] Provider String, Comma Separated Provider String, or list of provider strings Source code in camply/notifications/multi_provider_notifications.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def __init__ ( self , provider : Union [ str , List [ str ], BaseNotifications , None ]): \"\"\" Initialize with a Notifier Class Object, a string or list of strings Parameters ---------- provider: Union[str, List[str], BaseNotifications, None] Provider String, Comma Separated Provider String, or list of provider strings \"\"\" super () . __init__ () self . providers = [ SilentNotifications ()] if isinstance ( provider , str ): provider = [ prov_string . strip () for prov_string in provider . split ( \",\" )] for notifier_object in provider : if isinstance ( notifier_object , BaseNotifications ): notifier = notifier_object elif isinstance ( notifier_object , str ): notifier = CAMPSITE_NOTIFICATIONS . get ( notifier_object . lower (), None )() elif notifier_object is None : notifier = None else : raise NotificationError ( \"You must provide a proper Notification Identifier\" ) if notifier is not None and not isinstance ( notifier , SilentNotifications ): self . providers . append ( notifier )","title":"Parameters"},{"location":"reference/notifications/#camply.notifications.multi_provider_notifications.MultiNotifierProvider.log_providers","text":"Log All Providers","title":"log_providers()"},{"location":"reference/notifications/#camply.notifications.multi_provider_notifications.MultiNotifierProvider.log_providers--returns","text":"None Source code in camply/notifications/multi_provider_notifications.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def log_providers ( self ) -> None : \"\"\" Log All Providers Returns ------- None \"\"\" provider_names = [ str ( provider ) for provider in self . providers ] logger . info ( f \"Notifications active via: { ', ' . join ( provider_names ) } \" ) if len ( self . providers ) == 1 : logger . info ( f \"Only { self . providers [ 0 ] } enabled. \" \"I hope you're watching these logs.\" )","title":"Returns"},{"location":"reference/notifications/#camply.notifications.multi_provider_notifications.MultiNotifierProvider.send_campsites","text":"Send a message with a campsite object","title":"send_campsites()"},{"location":"reference/notifications/#camply.notifications.multi_provider_notifications.MultiNotifierProvider.send_campsites--parameters","text":"campsites: List[AvailableCampsite] Source code in camply/notifications/multi_provider_notifications.py 78 79 80 81 82 83 84 85 86 87 def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: List[AvailableCampsite] \"\"\" for provider in self . providers : provider . send_campsites ( campsites = campsites , ** kwargs )","title":"Parameters"},{"location":"reference/notifications/#camply.notifications.multi_provider_notifications.MultiNotifierProvider.send_message","text":"Send a message","title":"send_message()"},{"location":"reference/notifications/#camply.notifications.multi_provider_notifications.MultiNotifierProvider.send_message--parameters","text":"str Message Text **kwargs All kwargs passed to underlying notification method Source code in camply/notifications/multi_provider_notifications.py 64 65 66 67 68 69 70 71 72 73 74 75 76 def send_message ( self , message : str , ** kwargs ): \"\"\" Send a message Parameters ---------- message: str Message Text **kwargs All kwargs passed to underlying notification method \"\"\" for provider in self . providers : provider . send_message ( message = message , ** kwargs )","title":"Parameters"},{"location":"reference/notifications/#camply.notifications.PushbulletNotifications","text":"Bases: BaseNotifications Push Notifications via PushBullet Source code in camply/notifications/pushbullet.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 class PushbulletNotifications ( BaseNotifications ): \"\"\" Push Notifications via PushBullet \"\"\" def __init__ ( self ): super () . __init__ () pushbullet_headers = PushbulletConfig . API_HEADERS . copy () pushbullet_headers . update ({ \"Access-Token\" : PushbulletConfig . API_TOKEN }) self . session . headers . update ( pushbullet_headers ) if any ([ PushbulletConfig . API_TOKEN is None , PushbulletConfig . API_TOKEN == \"\" ]): warning_message = ( \"Pushbullet is not configured properly. To send Pushbullet messages \" \"make sure to run `camply configure` or set the \" \"proper environment variable: `PUSHBULLET_API_TOKEN`.\" ) logger . error ( warning_message ) raise EnvironmentError ( warning_message ) def send_message ( self , message : str , ** kwargs ) -> requests . Response : \"\"\" Send a message via PushBullet - if environment variables are configured Parameters ---------- message: str Returns ------- requests.Response \"\"\" message_type = kwargs . pop ( \"type\" , \"note\" ) message_title = kwargs . pop ( \"title\" , \"Camply Notification\" ) message_json = dict ( type = message_type , title = message_title , body = message , ** kwargs ) logger . debug ( message_json ) response = self . session . post ( url = PushbulletConfig . PUSHBULLET_API_ENDPOINT , json = message_json , ) try : response . raise_for_status () except requests . HTTPError as he : logger . warning ( \"Notifications weren't able to be sent to Pushbullet. \" \"Your configuration might be incorrect.\" ) raise ConnectionError ( response . text ) from he return response def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: AvailableCampsite \"\"\" for campsite in campsites : message_title , formatted_dict = self . format_standard_campsites ( campsite = campsite , ) fields = [] for key , value in formatted_dict . items (): fields . append ( f \" { key } : { value } \" ) composed_message = \" \\n \" . join ( fields ) self . send_message ( message = composed_message , title = message_title , type = \"note\" )","title":"PushbulletNotifications"},{"location":"reference/notifications/#camply.notifications.pushbullet.PushbulletNotifications.send_campsites","text":"Send a message with a campsite object","title":"send_campsites()"},{"location":"reference/notifications/#camply.notifications.pushbullet.PushbulletNotifications.send_campsites--parameters","text":"campsites: AvailableCampsite Source code in camply/notifications/pushbullet.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: AvailableCampsite \"\"\" for campsite in campsites : message_title , formatted_dict = self . format_standard_campsites ( campsite = campsite , ) fields = [] for key , value in formatted_dict . items (): fields . append ( f \" { key } : { value } \" ) composed_message = \" \\n \" . join ( fields ) self . send_message ( message = composed_message , title = message_title , type = \"note\" )","title":"Parameters"},{"location":"reference/notifications/#camply.notifications.pushbullet.PushbulletNotifications.send_message","text":"Send a message via PushBullet - if environment variables are configured","title":"send_message()"},{"location":"reference/notifications/#camply.notifications.pushbullet.PushbulletNotifications.send_message--parameters","text":"message: str","title":"Parameters"},{"location":"reference/notifications/#camply.notifications.pushbullet.PushbulletNotifications.send_message--returns","text":"requests.Response Source code in camply/notifications/pushbullet.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def send_message ( self , message : str , ** kwargs ) -> requests . Response : \"\"\" Send a message via PushBullet - if environment variables are configured Parameters ---------- message: str Returns ------- requests.Response \"\"\" message_type = kwargs . pop ( \"type\" , \"note\" ) message_title = kwargs . pop ( \"title\" , \"Camply Notification\" ) message_json = dict ( type = message_type , title = message_title , body = message , ** kwargs ) logger . debug ( message_json ) response = self . session . post ( url = PushbulletConfig . PUSHBULLET_API_ENDPOINT , json = message_json , ) try : response . raise_for_status () except requests . HTTPError as he : logger . warning ( \"Notifications weren't able to be sent to Pushbullet. \" \"Your configuration might be incorrect.\" ) raise ConnectionError ( response . text ) from he return response","title":"Returns"},{"location":"reference/notifications/#camply.notifications.PushoverNotifications","text":"Bases: BaseNotifications , logging . StreamHandler Push Notifications via Pushover + a Logging Handler Source code in camply/notifications/pushover.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 class PushoverNotifications ( BaseNotifications , logging . StreamHandler ): \"\"\" Push Notifications via Pushover + a Logging Handler \"\"\" def __init__ ( self , level : Optional [ int ] = logging . INFO ): super () . __init__ () self . session . headers . update ( PushoverConfig . API_HEADERS ) logging . StreamHandler . __init__ ( self ) self . setLevel ( level = level ) if any ([ PushoverConfig . PUSH_USER is None , PushoverConfig . PUSH_USER == \"\" ]): warning_message = ( \"Pushover is not configured properly. To send pushover messages \" \"make sure to run `camply configure` or set the \" \"proper environment variables: `PUSHOVER_PUSH_USER`, \" \"`PUSHOVER_PUSH_TOKEN`.\" ) logger . error ( warning_message ) raise EnvironmentError ( warning_message ) def send_message ( self , message : str , ** kwargs ) -> requests . Response : \"\"\" Send a message via Pushover - if environment variables are configured Parameters ---------- message: str Returns ------- requests.Response \"\"\" token = ( PushoverConfig . PUSH_TOKEN if PushoverConfig . PUSH_TOKEN not in [ None , \"\" ] else base64 . b64decode ( PushoverConfig . PUSHOVER_DEFAULT_API_TOKEN ) . decode ( \"utf-8\" ) ) response = self . session . post ( url = PushoverConfig . PUSHOVER_API_ENDPOINT , params = dict ( token = token , user = PushoverConfig . PUSH_USER , message = message , ** kwargs ), ) try : response . raise_for_status () except requests . HTTPError as he : logger . warning ( \"Notifications weren't able to be sent to Pushover. \" \"Your configuration might be incorrect.\" ) raise ConnectionError ( response . text ) from he return response def emit ( self , record : logging . LogRecord ): \"\"\" Produce a logging record Parameters ---------- record: str Message to log \"\"\" log_formatted_message = \"[ {:>10} ]: {} \" . format ( record . levelname . upper (), record . msg ) title = f \"Pushover { record . levelname . title () } Message\" self . send_message ( message = log_formatted_message , title = title ) def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: AvailableCampsite \"\"\" for campsite in campsites : message_title , formatted_dict = self . format_standard_campsites ( campsite = campsite , ) fields = [] for key , value in formatted_dict . items (): if key == \"Booking Link\" : value = f \"<a href=' { value } '> { value } </a>\" fields . append ( f \"<b> { key } :</b> { value } \" ) composed_message = \" \\n \" . join ( fields ) self . send_message ( message = composed_message , title = message_title , html = 1 )","title":"PushoverNotifications"},{"location":"reference/notifications/#camply.notifications.pushover.PushoverNotifications.emit","text":"Produce a logging record","title":"emit()"},{"location":"reference/notifications/#camply.notifications.pushover.PushoverNotifications.emit--parameters","text":"str Message to log Source code in camply/notifications/pushover.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def emit ( self , record : logging . LogRecord ): \"\"\" Produce a logging record Parameters ---------- record: str Message to log \"\"\" log_formatted_message = \"[ {:>10} ]: {} \" . format ( record . levelname . upper (), record . msg ) title = f \"Pushover { record . levelname . title () } Message\" self . send_message ( message = log_formatted_message , title = title )","title":"Parameters"},{"location":"reference/notifications/#camply.notifications.pushover.PushoverNotifications.send_campsites","text":"Send a message with a campsite object","title":"send_campsites()"},{"location":"reference/notifications/#camply.notifications.pushover.PushoverNotifications.send_campsites--parameters","text":"campsites: AvailableCampsite Source code in camply/notifications/pushover.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: AvailableCampsite \"\"\" for campsite in campsites : message_title , formatted_dict = self . format_standard_campsites ( campsite = campsite , ) fields = [] for key , value in formatted_dict . items (): if key == \"Booking Link\" : value = f \"<a href=' { value } '> { value } </a>\" fields . append ( f \"<b> { key } :</b> { value } \" ) composed_message = \" \\n \" . join ( fields ) self . send_message ( message = composed_message , title = message_title , html = 1 )","title":"Parameters"},{"location":"reference/notifications/#camply.notifications.pushover.PushoverNotifications.send_message","text":"Send a message via Pushover - if environment variables are configured","title":"send_message()"},{"location":"reference/notifications/#camply.notifications.pushover.PushoverNotifications.send_message--parameters","text":"message: str","title":"Parameters"},{"location":"reference/notifications/#camply.notifications.pushover.PushoverNotifications.send_message--returns","text":"requests.Response Source code in camply/notifications/pushover.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 def send_message ( self , message : str , ** kwargs ) -> requests . Response : \"\"\" Send a message via Pushover - if environment variables are configured Parameters ---------- message: str Returns ------- requests.Response \"\"\" token = ( PushoverConfig . PUSH_TOKEN if PushoverConfig . PUSH_TOKEN not in [ None , \"\" ] else base64 . b64decode ( PushoverConfig . PUSHOVER_DEFAULT_API_TOKEN ) . decode ( \"utf-8\" ) ) response = self . session . post ( url = PushoverConfig . PUSHOVER_API_ENDPOINT , params = dict ( token = token , user = PushoverConfig . PUSH_USER , message = message , ** kwargs ), ) try : response . raise_for_status () except requests . HTTPError as he : logger . warning ( \"Notifications weren't able to be sent to Pushover. \" \"Your configuration might be incorrect.\" ) raise ConnectionError ( response . text ) from he return response","title":"Returns"},{"location":"reference/notifications/#camply.notifications.SilentNotifications","text":"Bases: BaseNotifications Silent Notifications Source code in camply/notifications/silent_notifications.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class SilentNotifications ( BaseNotifications ): \"\"\" Silent Notifications \"\"\" def send_message ( self , message : Iterable , ** kwargs ) -> None : \"\"\" Send a message via Email Parameters ---------- message: Iterable Email Body **kwargs kwargs are disregarded Returns ------- None \"\"\" message_string = \" \\n\\t \u2022 \" + \" \\n\\t \u2022 \" . join ( list ( message )) logger . debug ( f \"SilentNotification: { message_string } \" ) def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: List[AvailableCampsite] \"\"\" for campsite in campsites : campsite_tuple = ( ( f \" { campsite . booking_date . strftime ( '%Y-%m- %d ' ) } - \" f \" { campsite . booking_end_date . strftime ( '%Y-%m- %d ' ) } \" ), campsite . campsite_type , campsite . campsite_site_name , campsite . recreation_area , campsite . facility_name , campsite . booking_url , ) self . send_message ( campsite_tuple ) campsite_formatted = pformat ( campsite . dict ()) logger . debug ( \"Campsite Info: \" + campsite_formatted )","title":"SilentNotifications"},{"location":"reference/notifications/#camply.notifications.silent_notifications.SilentNotifications.send_campsites","text":"Send a message with a campsite object","title":"send_campsites()"},{"location":"reference/notifications/#camply.notifications.silent_notifications.SilentNotifications.send_campsites--parameters","text":"campsites: List[AvailableCampsite] Source code in camply/notifications/silent_notifications.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: List[AvailableCampsite] \"\"\" for campsite in campsites : campsite_tuple = ( ( f \" { campsite . booking_date . strftime ( '%Y-%m- %d ' ) } - \" f \" { campsite . booking_end_date . strftime ( '%Y-%m- %d ' ) } \" ), campsite . campsite_type , campsite . campsite_site_name , campsite . recreation_area , campsite . facility_name , campsite . booking_url , ) self . send_message ( campsite_tuple ) campsite_formatted = pformat ( campsite . dict ()) logger . debug ( \"Campsite Info: \" + campsite_formatted )","title":"Parameters"},{"location":"reference/notifications/#camply.notifications.silent_notifications.SilentNotifications.send_message","text":"Send a message via Email","title":"send_message()"},{"location":"reference/notifications/#camply.notifications.silent_notifications.SilentNotifications.send_message--parameters","text":"Iterable Email Body **kwargs kwargs are disregarded","title":"Parameters"},{"location":"reference/notifications/#camply.notifications.silent_notifications.SilentNotifications.send_message--returns","text":"None Source code in camply/notifications/silent_notifications.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def send_message ( self , message : Iterable , ** kwargs ) -> None : \"\"\" Send a message via Email Parameters ---------- message: Iterable Email Body **kwargs kwargs are disregarded Returns ------- None \"\"\" message_string = \" \\n\\t \u2022 \" + \" \\n\\t \u2022 \" . join ( list ( message )) logger . debug ( f \"SilentNotification: { message_string } \" )","title":"Returns"},{"location":"reference/notifications/#camply.notifications.SlackNotifications","text":"Bases: BaseNotifications Push Notifications via Slack Source code in camply/notifications/slack.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 class SlackNotifications ( BaseNotifications ): \"\"\" Push Notifications via Slack \"\"\" def __init__ ( self ): super () . __init__ () self . session . headers . update ({ \"Content-Type\" : \"application/json\" }) if any ([ SlackConfig . SLACK_WEBHOOK is None , SlackConfig . SLACK_WEBHOOK == \"\" ]): warning_message = ( \"Slack is not configured properly. To send Slack messages \" \"make sure to run `camply configure` or set the \" \"proper environment variable: `SLACK_WEBHOOK`.\" ) logger . error ( warning_message ) raise EnvironmentError ( warning_message ) def send_message ( self , message : str , ** kwargs ) -> requests . Response : \"\"\" Send a message via Slack - if environment variables are configured. Parameters ---------- message: str blocks: List Returns ------- requests.Response \"\"\" message_blocks = kwargs . pop ( \"blocks\" , []) message_json = { \"text\" : message , } if message_blocks : message_json = { \"blocks\" : message_blocks , } logger . debug ( message_json ) response = self . session . post ( url = SlackConfig . SLACK_WEBHOOK , json = message_json , ) try : response . raise_for_status () except requests . HTTPError as he : logger . warning ( \"Notifications weren't able to be sent to Slack. \" \"Your configuration might be incorrect.\" ) raise ConnectionError ( response . text ) from he return response def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: AvailableCampsite \"\"\" for campsite in campsites : message_title , formatted_dict = self . format_standard_campsites ( campsite = campsite , ) fields = [] for key , value in formatted_dict . items (): fields . append ( { \"type\" : \"mrkdwn\" , \"text\" : f \"* { key } *\" , } ) if key in [ \"Permitted Equipment\" , \"Booking Link\" ]: data_type = \"mrkdwn\" else : data_type = \"plain_text\" fields . append ( { \"type\" : data_type , \"text\" : str ( value ), } ) blocks = [] blocks . append ( { \"type\" : \"header\" , \"text\" : { \"type\" : \"plain_text\" , \"text\" : message_title , }, } ) # Slack only allows 10 fields (k+v) per section for chunk in range ( 0 , len ( fields ) + 1 , 10 ): chunk_max = chunk + 10 blocks . append ( { \"type\" : \"section\" , \"fields\" : fields [ chunk : chunk_max ], } ) self . send_message ( message = message_title , blocks = blocks , )","title":"SlackNotifications"},{"location":"reference/notifications/#camply.notifications.slack.SlackNotifications.send_campsites","text":"Send a message with a campsite object","title":"send_campsites()"},{"location":"reference/notifications/#camply.notifications.slack.SlackNotifications.send_campsites--parameters","text":"campsites: AvailableCampsite Source code in camply/notifications/slack.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: AvailableCampsite \"\"\" for campsite in campsites : message_title , formatted_dict = self . format_standard_campsites ( campsite = campsite , ) fields = [] for key , value in formatted_dict . items (): fields . append ( { \"type\" : \"mrkdwn\" , \"text\" : f \"* { key } *\" , } ) if key in [ \"Permitted Equipment\" , \"Booking Link\" ]: data_type = \"mrkdwn\" else : data_type = \"plain_text\" fields . append ( { \"type\" : data_type , \"text\" : str ( value ), } ) blocks = [] blocks . append ( { \"type\" : \"header\" , \"text\" : { \"type\" : \"plain_text\" , \"text\" : message_title , }, } ) # Slack only allows 10 fields (k+v) per section for chunk in range ( 0 , len ( fields ) + 1 , 10 ): chunk_max = chunk + 10 blocks . append ( { \"type\" : \"section\" , \"fields\" : fields [ chunk : chunk_max ], } ) self . send_message ( message = message_title , blocks = blocks , )","title":"Parameters"},{"location":"reference/notifications/#camply.notifications.slack.SlackNotifications.send_message","text":"Send a message via Slack - if environment variables are configured.","title":"send_message()"},{"location":"reference/notifications/#camply.notifications.slack.SlackNotifications.send_message--parameters","text":"message: str blocks: List","title":"Parameters"},{"location":"reference/notifications/#camply.notifications.slack.SlackNotifications.send_message--returns","text":"requests.Response Source code in camply/notifications/slack.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def send_message ( self , message : str , ** kwargs ) -> requests . Response : \"\"\" Send a message via Slack - if environment variables are configured. Parameters ---------- message: str blocks: List Returns ------- requests.Response \"\"\" message_blocks = kwargs . pop ( \"blocks\" , []) message_json = { \"text\" : message , } if message_blocks : message_json = { \"blocks\" : message_blocks , } logger . debug ( message_json ) response = self . session . post ( url = SlackConfig . SLACK_WEBHOOK , json = message_json , ) try : response . raise_for_status () except requests . HTTPError as he : logger . warning ( \"Notifications weren't able to be sent to Slack. \" \"Your configuration might be incorrect.\" ) raise ConnectionError ( response . text ) from he return response","title":"Returns"},{"location":"reference/notifications/#camply.notifications.TelegramNotifications","text":"Bases: BaseNotifications Push Notifications via Telegram Source code in camply/notifications/telegram.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 class TelegramNotifications ( BaseNotifications ): \"\"\" Push Notifications via Telegram \"\"\" def __init__ ( self ): super () . __init__ () self . session . headers . update ( TelegramConfig . API_HEADERS ) if any ( [ TelegramConfig . BOT_TOKEN is None , TelegramConfig . BOT_TOKEN == \"\" , TelegramConfig . CHAT_ID is None , TelegramConfig . CHAT_ID == \"\" , ] ): warning_message = ( \"Telegram is not configured properly. To send Telegram messages \" \"make sure to run `camply configure` or set the \" \"proper environment variables: `TELEGRAM_BOT_TOKEN` and `TELEGRAM_CHAT_ID`.\" ) logger . error ( warning_message ) raise EnvironmentError ( warning_message ) def send_message ( self , message : str , escaped = False , ** kwargs ) -> requests . Response : \"\"\" Send a message via Telegram - if environment variables are configured Parameters ---------- message: str escaped: bool Returns ------- requests.Response \"\"\" if not escaped : message = self . escape_text ( message ) message_json = TelegramConfig . API_CONTENT . copy () message_json . update ({ \"text\" : message }) logger . debug ( message_json ) response = self . session . post ( url = TelegramConfig . API_ENDPOINT , json = message_json ) try : response . raise_for_status () except requests . HTTPError as he : logger . warning ( \"Notifications weren't able to be sent to Telegram. \" \"Your configuration might be incorrect.\" ) raise ConnectionError ( response . text ) from he return response @staticmethod def escape_text ( message : str ) -> str : \"\"\" Escape a message for use in Telegram Parameters ---------- message: str Returns ------- String \"\"\" fields = [ \"_\" , \"*\" , \"[\" , \"]\" , \"(\" , \")\" , \"~\" , \"`\" , \">\" , \"#\" , \"+\" , \"-\" , \"=\" , \"|\" , \"{\" , \"}\" , \".\" , \"!\" , ] for f in fields : message = message . replace ( f , f \" \\\\ { f } \" ) return message def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: AvailableCampsite \"\"\" for campsite in campsites : message_title , formatted_dict = self . format_standard_campsites ( campsite = campsite , ) fields = [] for key , value in formatted_dict . items (): fields . append ( self . escape_text ( f \" { key } : { value } \" )) message_fields = \" \\n \" . join ( fields ) message = f \"* { self . escape_text ( message_title ) } * \\n { message_fields } \" self . send_message ( message , escaped = True )","title":"TelegramNotifications"},{"location":"reference/notifications/#camply.notifications.telegram.TelegramNotifications.escape_text","text":"Escape a message for use in Telegram","title":"escape_text()"},{"location":"reference/notifications/#camply.notifications.telegram.TelegramNotifications.escape_text--parameters","text":"message: str","title":"Parameters"},{"location":"reference/notifications/#camply.notifications.telegram.TelegramNotifications.escape_text--returns","text":"String Source code in camply/notifications/telegram.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 @staticmethod def escape_text ( message : str ) -> str : \"\"\" Escape a message for use in Telegram Parameters ---------- message: str Returns ------- String \"\"\" fields = [ \"_\" , \"*\" , \"[\" , \"]\" , \"(\" , \")\" , \"~\" , \"`\" , \">\" , \"#\" , \"+\" , \"-\" , \"=\" , \"|\" , \"{\" , \"}\" , \".\" , \"!\" , ] for f in fields : message = message . replace ( f , f \" \\\\ { f } \" ) return message","title":"Returns"},{"location":"reference/notifications/#camply.notifications.telegram.TelegramNotifications.send_campsites","text":"Send a message with a campsite object","title":"send_campsites()"},{"location":"reference/notifications/#camply.notifications.telegram.TelegramNotifications.send_campsites--parameters","text":"campsites: AvailableCampsite Source code in camply/notifications/telegram.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: AvailableCampsite \"\"\" for campsite in campsites : message_title , formatted_dict = self . format_standard_campsites ( campsite = campsite , ) fields = [] for key , value in formatted_dict . items (): fields . append ( self . escape_text ( f \" { key } : { value } \" )) message_fields = \" \\n \" . join ( fields ) message = f \"* { self . escape_text ( message_title ) } * \\n { message_fields } \" self . send_message ( message , escaped = True )","title":"Parameters"},{"location":"reference/notifications/#camply.notifications.telegram.TelegramNotifications.send_message","text":"Send a message via Telegram - if environment variables are configured","title":"send_message()"},{"location":"reference/notifications/#camply.notifications.telegram.TelegramNotifications.send_message--parameters","text":"message: str escaped: bool","title":"Parameters"},{"location":"reference/notifications/#camply.notifications.telegram.TelegramNotifications.send_message--returns","text":"requests.Response Source code in camply/notifications/telegram.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def send_message ( self , message : str , escaped = False , ** kwargs ) -> requests . Response : \"\"\" Send a message via Telegram - if environment variables are configured Parameters ---------- message: str escaped: bool Returns ------- requests.Response \"\"\" if not escaped : message = self . escape_text ( message ) message_json = TelegramConfig . API_CONTENT . copy () message_json . update ({ \"text\" : message }) logger . debug ( message_json ) response = self . session . post ( url = TelegramConfig . API_ENDPOINT , json = message_json ) try : response . raise_for_status () except requests . HTTPError as he : logger . warning ( \"Notifications weren't able to be sent to Telegram. \" \"Your configuration might be incorrect.\" ) raise ConnectionError ( response . text ) from he return response","title":"Returns"},{"location":"reference/notifications/#camply.notifications.TwilioNotifications","text":"Bases: BaseNotifications Push Notifications via Twilio Source code in camply/notifications/twilio.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 class TwilioNotifications ( BaseNotifications ): \"\"\" Push Notifications via Twilio \"\"\" def __init__ ( self ): super () . __init__ () try : from twilio.rest import Client except ImportError : raise RuntimeError ( \"Looks like `twilio` isn't installed. Install it with `pip install camply[twilio]`\" ) if any ( [ TwilioConfig . ACCOUNT_SID is None , TwilioConfig . ACCOUNT_SID == \"\" , TwilioConfig . AUTH_TOKEN is None , TwilioConfig . AUTH_TOKEN == \"\" , ] ): warning_message = ( \"Twilio is not configured properly. To send Twilio messages \" \"make sure to run `camply configure` or set the \" \"proper environment variable: `TWILIO_ACCOUNT_SID`, `TWILIO_AUTH_TOKEN`.\" ) logger . error ( warning_message ) raise EnvironmentError ( warning_message ) self . client = Client ( TwilioConfig . ACCOUNT_SID , TwilioConfig . AUTH_TOKEN ) self . phone_nums = TwilioConfig . DEST_NUMBERS . split ( \",\" ) logger . info ( \"Twilio: will notify these phone numbers: \" + \", \" . join ( self . phone_nums ) ) def send_message ( self , message : str , ** kwargs ): \"\"\" Send a message via Twilio - if environment variables are configured Parameters ---------- message: str \"\"\" for phone_num in self . phone_nums : self . client . messages . create ( to = phone_num , from_ = TwilioConfig . SOURCE_NUMBER , body = message ) def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: AvailableCampsite \"\"\" for campsite in campsites : message_title , formatted_dict = self . format_standard_campsites ( campsite = campsite , ) fields = [ f \"\ud83c\udfd5 { message_title } \" , \"\" ] for key , value in formatted_dict . items (): fields . append ( f \" { key } : { value } \" ) fields . append ( \"\" ) fields . append ( \"camply, the campsite finder \u26fa\ufe0f\" ) composed_message = \" \\n \" . join ( fields ) self . send_message ( message = composed_message )","title":"TwilioNotifications"},{"location":"reference/notifications/#camply.notifications.twilio.TwilioNotifications.send_campsites","text":"Send a message with a campsite object","title":"send_campsites()"},{"location":"reference/notifications/#camply.notifications.twilio.TwilioNotifications.send_campsites--parameters","text":"campsites: AvailableCampsite Source code in camply/notifications/twilio.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: AvailableCampsite \"\"\" for campsite in campsites : message_title , formatted_dict = self . format_standard_campsites ( campsite = campsite , ) fields = [ f \"\ud83c\udfd5 { message_title } \" , \"\" ] for key , value in formatted_dict . items (): fields . append ( f \" { key } : { value } \" ) fields . append ( \"\" ) fields . append ( \"camply, the campsite finder \u26fa\ufe0f\" ) composed_message = \" \\n \" . join ( fields ) self . send_message ( message = composed_message )","title":"Parameters"},{"location":"reference/notifications/#camply.notifications.twilio.TwilioNotifications.send_message","text":"Send a message via Twilio - if environment variables are configured","title":"send_message()"},{"location":"reference/notifications/#camply.notifications.twilio.TwilioNotifications.send_message--parameters","text":"message: str Source code in camply/notifications/twilio.py 51 52 53 54 55 56 57 58 59 60 61 62 def send_message ( self , message : str , ** kwargs ): \"\"\" Send a message via Twilio - if environment variables are configured Parameters ---------- message: str \"\"\" for phone_num in self . phone_nums : self . client . messages . create ( to = phone_num , from_ = TwilioConfig . SOURCE_NUMBER , body = message )","title":"Parameters"},{"location":"reference/notifications/base_notifications/","text":"Push Notifications Template BaseNotifications # Bases: ABC Base Notifications Source code in camply/notifications/base_notifications.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 class BaseNotifications ( ABC ): \"\"\" Base Notifications \"\"\" def __init__ ( self ) -> None : \"\"\" Instantiate with a Requests Session \"\"\" self . session = requests . Session () def __repr__ ( self ) -> str : \"\"\" String Representation \"\"\" return f \"< { self . __class__ . __name__ } >\" @abstractmethod def send_message ( self , message : str , ** kwargs ): \"\"\" Send a message Parameters ---------- message: str Message Text **kwargs All kwargs passed to underlying notification method \"\"\" pass @abstractmethod def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: List[AvailableCampsite] \"\"\" pass @classmethod def format_standard_campsites ( cls , campsite : AvailableCampsite ) -> Tuple [ str , Dict [ str , str ]]: \"\"\" Format Standard Message \"\"\" fields = dict () message_title = \" | \" . join ( [ campsite . recreation_area , campsite . facility_name , campsite . booking_date . strftime ( \"%Y-%m- %d \" ), ] ) for key , value in campsite . dict () . items (): if key in [ CampsiteContainerFields . BOOKING_DATE , CampsiteContainerFields . BOOKING_END_DATE , ]: value : datetime . date value : str = value . strftime ( \"%Y-%m- %d \" ) elif key == CampsiteContainerFields . BOOKING_URL : key = \"booking_link\" elif key == CampsiteContainerFields . PERMITTED_EQUIPMENT : equipment = ( [] if campsite . permitted_equipment is None else campsite . permitted_equipment ) value = \" \\n - \" + \" \\n - \" . join ( set ( item . equipment_name for item in equipment ) ) if key not in [ CampsiteContainerFields . CAMPSITE_ATTRIBUTES ]: formatted_key = key . replace ( \"_\" , \" \" ) . title () fields [ formatted_key ] = value return message_title , fields __init__ () # Instantiate with a Requests Session Source code in camply/notifications/base_notifications.py 28 29 30 31 32 def __init__ ( self ) -> None : \"\"\" Instantiate with a Requests Session \"\"\" self . session = requests . Session () __repr__ () # String Representation Source code in camply/notifications/base_notifications.py 34 35 36 37 38 def __repr__ ( self ) -> str : \"\"\" String Representation \"\"\" return f \"< { self . __class__ . __name__ } >\" format_standard_campsites ( campsite ) classmethod # Format Standard Message Source code in camply/notifications/base_notifications.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 @classmethod def format_standard_campsites ( cls , campsite : AvailableCampsite ) -> Tuple [ str , Dict [ str , str ]]: \"\"\" Format Standard Message \"\"\" fields = dict () message_title = \" | \" . join ( [ campsite . recreation_area , campsite . facility_name , campsite . booking_date . strftime ( \"%Y-%m- %d \" ), ] ) for key , value in campsite . dict () . items (): if key in [ CampsiteContainerFields . BOOKING_DATE , CampsiteContainerFields . BOOKING_END_DATE , ]: value : datetime . date value : str = value . strftime ( \"%Y-%m- %d \" ) elif key == CampsiteContainerFields . BOOKING_URL : key = \"booking_link\" elif key == CampsiteContainerFields . PERMITTED_EQUIPMENT : equipment = ( [] if campsite . permitted_equipment is None else campsite . permitted_equipment ) value = \" \\n - \" + \" \\n - \" . join ( set ( item . equipment_name for item in equipment ) ) if key not in [ CampsiteContainerFields . CAMPSITE_ATTRIBUTES ]: formatted_key = key . replace ( \"_\" , \" \" ) . title () fields [ formatted_key ] = value return message_title , fields send_campsites ( campsites , ** kwargs ) abstractmethod # Send a message with a campsite object Parameters # campsites: List[AvailableCampsite] Source code in camply/notifications/base_notifications.py 54 55 56 57 58 59 60 61 62 63 @abstractmethod def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: List[AvailableCampsite] \"\"\" pass send_message ( message , ** kwargs ) abstractmethod # Send a message Parameters # str Message Text **kwargs All kwargs passed to underlying notification method Source code in camply/notifications/base_notifications.py 40 41 42 43 44 45 46 47 48 49 50 51 52 @abstractmethod def send_message ( self , message : str , ** kwargs ): \"\"\" Send a message Parameters ---------- message: str Message Text **kwargs All kwargs passed to underlying notification method \"\"\" pass NotificationError # Bases: Exception Notification Exceptions Source code in camply/notifications/base_notifications.py 17 18 19 20 class NotificationError ( Exception ): \"\"\" Notification Exceptions \"\"\"","title":"base_notifications"},{"location":"reference/notifications/base_notifications/#camply.notifications.base_notifications.BaseNotifications","text":"Bases: ABC Base Notifications Source code in camply/notifications/base_notifications.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 class BaseNotifications ( ABC ): \"\"\" Base Notifications \"\"\" def __init__ ( self ) -> None : \"\"\" Instantiate with a Requests Session \"\"\" self . session = requests . Session () def __repr__ ( self ) -> str : \"\"\" String Representation \"\"\" return f \"< { self . __class__ . __name__ } >\" @abstractmethod def send_message ( self , message : str , ** kwargs ): \"\"\" Send a message Parameters ---------- message: str Message Text **kwargs All kwargs passed to underlying notification method \"\"\" pass @abstractmethod def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: List[AvailableCampsite] \"\"\" pass @classmethod def format_standard_campsites ( cls , campsite : AvailableCampsite ) -> Tuple [ str , Dict [ str , str ]]: \"\"\" Format Standard Message \"\"\" fields = dict () message_title = \" | \" . join ( [ campsite . recreation_area , campsite . facility_name , campsite . booking_date . strftime ( \"%Y-%m- %d \" ), ] ) for key , value in campsite . dict () . items (): if key in [ CampsiteContainerFields . BOOKING_DATE , CampsiteContainerFields . BOOKING_END_DATE , ]: value : datetime . date value : str = value . strftime ( \"%Y-%m- %d \" ) elif key == CampsiteContainerFields . BOOKING_URL : key = \"booking_link\" elif key == CampsiteContainerFields . PERMITTED_EQUIPMENT : equipment = ( [] if campsite . permitted_equipment is None else campsite . permitted_equipment ) value = \" \\n - \" + \" \\n - \" . join ( set ( item . equipment_name for item in equipment ) ) if key not in [ CampsiteContainerFields . CAMPSITE_ATTRIBUTES ]: formatted_key = key . replace ( \"_\" , \" \" ) . title () fields [ formatted_key ] = value return message_title , fields","title":"BaseNotifications"},{"location":"reference/notifications/base_notifications/#camply.notifications.base_notifications.BaseNotifications.__init__","text":"Instantiate with a Requests Session Source code in camply/notifications/base_notifications.py 28 29 30 31 32 def __init__ ( self ) -> None : \"\"\" Instantiate with a Requests Session \"\"\" self . session = requests . Session ()","title":"__init__()"},{"location":"reference/notifications/base_notifications/#camply.notifications.base_notifications.BaseNotifications.__repr__","text":"String Representation Source code in camply/notifications/base_notifications.py 34 35 36 37 38 def __repr__ ( self ) -> str : \"\"\" String Representation \"\"\" return f \"< { self . __class__ . __name__ } >\"","title":"__repr__()"},{"location":"reference/notifications/base_notifications/#camply.notifications.base_notifications.BaseNotifications.format_standard_campsites","text":"Format Standard Message Source code in camply/notifications/base_notifications.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 @classmethod def format_standard_campsites ( cls , campsite : AvailableCampsite ) -> Tuple [ str , Dict [ str , str ]]: \"\"\" Format Standard Message \"\"\" fields = dict () message_title = \" | \" . join ( [ campsite . recreation_area , campsite . facility_name , campsite . booking_date . strftime ( \"%Y-%m- %d \" ), ] ) for key , value in campsite . dict () . items (): if key in [ CampsiteContainerFields . BOOKING_DATE , CampsiteContainerFields . BOOKING_END_DATE , ]: value : datetime . date value : str = value . strftime ( \"%Y-%m- %d \" ) elif key == CampsiteContainerFields . BOOKING_URL : key = \"booking_link\" elif key == CampsiteContainerFields . PERMITTED_EQUIPMENT : equipment = ( [] if campsite . permitted_equipment is None else campsite . permitted_equipment ) value = \" \\n - \" + \" \\n - \" . join ( set ( item . equipment_name for item in equipment ) ) if key not in [ CampsiteContainerFields . CAMPSITE_ATTRIBUTES ]: formatted_key = key . replace ( \"_\" , \" \" ) . title () fields [ formatted_key ] = value return message_title , fields","title":"format_standard_campsites()"},{"location":"reference/notifications/base_notifications/#camply.notifications.base_notifications.BaseNotifications.send_campsites","text":"Send a message with a campsite object","title":"send_campsites()"},{"location":"reference/notifications/base_notifications/#camply.notifications.base_notifications.BaseNotifications.send_campsites--parameters","text":"campsites: List[AvailableCampsite] Source code in camply/notifications/base_notifications.py 54 55 56 57 58 59 60 61 62 63 @abstractmethod def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: List[AvailableCampsite] \"\"\" pass","title":"Parameters"},{"location":"reference/notifications/base_notifications/#camply.notifications.base_notifications.BaseNotifications.send_message","text":"Send a message","title":"send_message()"},{"location":"reference/notifications/base_notifications/#camply.notifications.base_notifications.BaseNotifications.send_message--parameters","text":"str Message Text **kwargs All kwargs passed to underlying notification method Source code in camply/notifications/base_notifications.py 40 41 42 43 44 45 46 47 48 49 50 51 52 @abstractmethod def send_message ( self , message : str , ** kwargs ): \"\"\" Send a message Parameters ---------- message: str Message Text **kwargs All kwargs passed to underlying notification method \"\"\" pass","title":"Parameters"},{"location":"reference/notifications/base_notifications/#camply.notifications.base_notifications.NotificationError","text":"Bases: Exception Notification Exceptions Source code in camply/notifications/base_notifications.py 17 18 19 20 class NotificationError ( Exception ): \"\"\" Notification Exceptions \"\"\"","title":"NotificationError"},{"location":"reference/notifications/email_notifications/","text":"Push Notifications via Pushover EmailNotifications # Bases: BaseNotifications Notifications via Email Source code in camply/notifications/email_notifications.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 class EmailNotifications ( BaseNotifications ): \"\"\" Notifications via Email \"\"\" email_subject = EmailConfig . EMAIL_SUBJECT_LINE email_from = EmailConfig . EMAIL_FROM_ADDRESS email_to = EmailConfig . EMAIL_TO_ADDRESS email_username = EmailConfig . EMAIL_USERNAME _email_password = EmailConfig . EMAIL_PASSWORD email_smtp_server = EmailConfig . EMAIL_SMTP_SERVER email_smtp_server_port = EmailConfig . EMAIL_SMTP_PORT def __init__ ( self ): \"\"\" Data Validation **kwargs Accepts: from, to, subject, username, password, server, port \"\"\" super () . __init__ () # PERFORM SOME VALIDATION if any ( [ EmailConfig . EMAIL_TO_ADDRESS in [ None , \"\" ], EmailConfig . EMAIL_USERNAME in [ None , \"\" ], EmailConfig . EMAIL_PASSWORD in [ None , \"\" ], ] ): variable_names = \" \\n\\t \" . join ( EmailConfig . ENVIRONMENT_VARIABLE_NAMES ) optional_variable_names = \" \\n\\t \" . join ( EmailConfig . OPTIONAL_ENVIRONMENT_VARIABLE ) error_message = ( \"Email Notification Auth Parameters not set. Run `camply configure` \" f \"or set the following Environment Variables: \\n\\t { variable_names } \" \" \\n Optional Environment Variables: \\n\\t \" f \" { optional_variable_names } \" ) logger . error ( error_message ) raise EnvironmentError ( error_message ) # ATTEMPT AN EMAIL LOGIN AT INIT TO THROW ERRORS EARLY _email_server = SMTP_SSL ( self . email_smtp_server , self . email_smtp_server_port , ) _email_server . ehlo () _email_server . login ( user = self . email_username , password = self . _email_password , ) _email_server . quit () def send_message ( self , message : str , ** kwargs ) -> None : \"\"\" Send a message via Email Parameters ---------- message: str Email Body **kwargs Accepts: from, to, subject, username, password, server, port Returns ------- object \"\"\" email = EmailMessage () email . set_content ( message ) email [ \"Subject\" ] = kwargs . get ( \"subject\" , self . email_subject ) email [ \"From\" ] = kwargs . get ( \"from\" , self . email_from ) email [ \"To\" ] = kwargs . get ( \"to\" , self . email_to ) email_server_user = kwargs . get ( \"username\" , self . email_username ) email_server_password = kwargs . get ( \"password\" , self . _email_password ) email_server_smtp_server = kwargs . get ( \"server\" , self . email_smtp_server ) email_server_smtp_server_port = kwargs . get ( \"port\" , self . email_smtp_server_port ) email_server = SMTP_SSL ( email_server_smtp_server , email_server_smtp_server_port ) email_server . ehlo () email_server . login ( user = email_server_user , password = email_server_password ) logger . info ( f \"Sending Email to { email [ 'To' ] } : { email [ 'Subject' ] } \" ) email_server . send_message ( email ) logger . info ( \"Email sent successfully\" ) email_server . quit () def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ) -> None : \"\"\" Send a message with a campsite object Parameters ---------- campsites: List[AvailableCampsite] \"\"\" master_email_body_list = list () for campsite in campsites : message_title , formatted_dict = self . format_standard_campsites ( campsite = campsite , ) fields = [ message_title ] for key , value in formatted_dict . items (): if key == \"Permitted Equipment\" : value = value . replace ( \" \\n - \" , \" \\n \\t - \" ) fields . append ( f \" \\t { key } : { value } \" ) composed_message = \" \\n \" . join ( fields ) + \" \\n\\n \" master_email_body_list . append ( composed_message ) master_email_body = \" \\n \" . join ( master_email_body_list ) if len ( campsites ) > 0 : self . send_message ( message = master_email_body ) __init__ () # Data Validation **kwargs Accepts: from, to, subject, username, password, server, port Source code in camply/notifications/email_notifications.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def __init__ ( self ): \"\"\" Data Validation **kwargs Accepts: from, to, subject, username, password, server, port \"\"\" super () . __init__ () # PERFORM SOME VALIDATION if any ( [ EmailConfig . EMAIL_TO_ADDRESS in [ None , \"\" ], EmailConfig . EMAIL_USERNAME in [ None , \"\" ], EmailConfig . EMAIL_PASSWORD in [ None , \"\" ], ] ): variable_names = \" \\n\\t \" . join ( EmailConfig . ENVIRONMENT_VARIABLE_NAMES ) optional_variable_names = \" \\n\\t \" . join ( EmailConfig . OPTIONAL_ENVIRONMENT_VARIABLE ) error_message = ( \"Email Notification Auth Parameters not set. Run `camply configure` \" f \"or set the following Environment Variables: \\n\\t { variable_names } \" \" \\n Optional Environment Variables: \\n\\t \" f \" { optional_variable_names } \" ) logger . error ( error_message ) raise EnvironmentError ( error_message ) # ATTEMPT AN EMAIL LOGIN AT INIT TO THROW ERRORS EARLY _email_server = SMTP_SSL ( self . email_smtp_server , self . email_smtp_server_port , ) _email_server . ehlo () _email_server . login ( user = self . email_username , password = self . _email_password , ) _email_server . quit () send_campsites ( campsites , ** kwargs ) # Send a message with a campsite object Parameters # campsites: List[AvailableCampsite] Source code in camply/notifications/email_notifications.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ) -> None : \"\"\" Send a message with a campsite object Parameters ---------- campsites: List[AvailableCampsite] \"\"\" master_email_body_list = list () for campsite in campsites : message_title , formatted_dict = self . format_standard_campsites ( campsite = campsite , ) fields = [ message_title ] for key , value in formatted_dict . items (): if key == \"Permitted Equipment\" : value = value . replace ( \" \\n - \" , \" \\n \\t - \" ) fields . append ( f \" \\t { key } : { value } \" ) composed_message = \" \\n \" . join ( fields ) + \" \\n\\n \" master_email_body_list . append ( composed_message ) master_email_body = \" \\n \" . join ( master_email_body_list ) if len ( campsites ) > 0 : self . send_message ( message = master_email_body ) send_message ( message , ** kwargs ) # Send a message via Email Parameters # str Email Body **kwargs Accepts: from, to, subject, username, password, server, port Returns # object Source code in camply/notifications/email_notifications.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def send_message ( self , message : str , ** kwargs ) -> None : \"\"\" Send a message via Email Parameters ---------- message: str Email Body **kwargs Accepts: from, to, subject, username, password, server, port Returns ------- object \"\"\" email = EmailMessage () email . set_content ( message ) email [ \"Subject\" ] = kwargs . get ( \"subject\" , self . email_subject ) email [ \"From\" ] = kwargs . get ( \"from\" , self . email_from ) email [ \"To\" ] = kwargs . get ( \"to\" , self . email_to ) email_server_user = kwargs . get ( \"username\" , self . email_username ) email_server_password = kwargs . get ( \"password\" , self . _email_password ) email_server_smtp_server = kwargs . get ( \"server\" , self . email_smtp_server ) email_server_smtp_server_port = kwargs . get ( \"port\" , self . email_smtp_server_port ) email_server = SMTP_SSL ( email_server_smtp_server , email_server_smtp_server_port ) email_server . ehlo () email_server . login ( user = email_server_user , password = email_server_password ) logger . info ( f \"Sending Email to { email [ 'To' ] } : { email [ 'Subject' ] } \" ) email_server . send_message ( email ) logger . info ( \"Email sent successfully\" ) email_server . quit ()","title":"email_notifications"},{"location":"reference/notifications/email_notifications/#camply.notifications.email_notifications.EmailNotifications","text":"Bases: BaseNotifications Notifications via Email Source code in camply/notifications/email_notifications.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 class EmailNotifications ( BaseNotifications ): \"\"\" Notifications via Email \"\"\" email_subject = EmailConfig . EMAIL_SUBJECT_LINE email_from = EmailConfig . EMAIL_FROM_ADDRESS email_to = EmailConfig . EMAIL_TO_ADDRESS email_username = EmailConfig . EMAIL_USERNAME _email_password = EmailConfig . EMAIL_PASSWORD email_smtp_server = EmailConfig . EMAIL_SMTP_SERVER email_smtp_server_port = EmailConfig . EMAIL_SMTP_PORT def __init__ ( self ): \"\"\" Data Validation **kwargs Accepts: from, to, subject, username, password, server, port \"\"\" super () . __init__ () # PERFORM SOME VALIDATION if any ( [ EmailConfig . EMAIL_TO_ADDRESS in [ None , \"\" ], EmailConfig . EMAIL_USERNAME in [ None , \"\" ], EmailConfig . EMAIL_PASSWORD in [ None , \"\" ], ] ): variable_names = \" \\n\\t \" . join ( EmailConfig . ENVIRONMENT_VARIABLE_NAMES ) optional_variable_names = \" \\n\\t \" . join ( EmailConfig . OPTIONAL_ENVIRONMENT_VARIABLE ) error_message = ( \"Email Notification Auth Parameters not set. Run `camply configure` \" f \"or set the following Environment Variables: \\n\\t { variable_names } \" \" \\n Optional Environment Variables: \\n\\t \" f \" { optional_variable_names } \" ) logger . error ( error_message ) raise EnvironmentError ( error_message ) # ATTEMPT AN EMAIL LOGIN AT INIT TO THROW ERRORS EARLY _email_server = SMTP_SSL ( self . email_smtp_server , self . email_smtp_server_port , ) _email_server . ehlo () _email_server . login ( user = self . email_username , password = self . _email_password , ) _email_server . quit () def send_message ( self , message : str , ** kwargs ) -> None : \"\"\" Send a message via Email Parameters ---------- message: str Email Body **kwargs Accepts: from, to, subject, username, password, server, port Returns ------- object \"\"\" email = EmailMessage () email . set_content ( message ) email [ \"Subject\" ] = kwargs . get ( \"subject\" , self . email_subject ) email [ \"From\" ] = kwargs . get ( \"from\" , self . email_from ) email [ \"To\" ] = kwargs . get ( \"to\" , self . email_to ) email_server_user = kwargs . get ( \"username\" , self . email_username ) email_server_password = kwargs . get ( \"password\" , self . _email_password ) email_server_smtp_server = kwargs . get ( \"server\" , self . email_smtp_server ) email_server_smtp_server_port = kwargs . get ( \"port\" , self . email_smtp_server_port ) email_server = SMTP_SSL ( email_server_smtp_server , email_server_smtp_server_port ) email_server . ehlo () email_server . login ( user = email_server_user , password = email_server_password ) logger . info ( f \"Sending Email to { email [ 'To' ] } : { email [ 'Subject' ] } \" ) email_server . send_message ( email ) logger . info ( \"Email sent successfully\" ) email_server . quit () def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ) -> None : \"\"\" Send a message with a campsite object Parameters ---------- campsites: List[AvailableCampsite] \"\"\" master_email_body_list = list () for campsite in campsites : message_title , formatted_dict = self . format_standard_campsites ( campsite = campsite , ) fields = [ message_title ] for key , value in formatted_dict . items (): if key == \"Permitted Equipment\" : value = value . replace ( \" \\n - \" , \" \\n \\t - \" ) fields . append ( f \" \\t { key } : { value } \" ) composed_message = \" \\n \" . join ( fields ) + \" \\n\\n \" master_email_body_list . append ( composed_message ) master_email_body = \" \\n \" . join ( master_email_body_list ) if len ( campsites ) > 0 : self . send_message ( message = master_email_body )","title":"EmailNotifications"},{"location":"reference/notifications/email_notifications/#camply.notifications.email_notifications.EmailNotifications.__init__","text":"Data Validation **kwargs Accepts: from, to, subject, username, password, server, port Source code in camply/notifications/email_notifications.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def __init__ ( self ): \"\"\" Data Validation **kwargs Accepts: from, to, subject, username, password, server, port \"\"\" super () . __init__ () # PERFORM SOME VALIDATION if any ( [ EmailConfig . EMAIL_TO_ADDRESS in [ None , \"\" ], EmailConfig . EMAIL_USERNAME in [ None , \"\" ], EmailConfig . EMAIL_PASSWORD in [ None , \"\" ], ] ): variable_names = \" \\n\\t \" . join ( EmailConfig . ENVIRONMENT_VARIABLE_NAMES ) optional_variable_names = \" \\n\\t \" . join ( EmailConfig . OPTIONAL_ENVIRONMENT_VARIABLE ) error_message = ( \"Email Notification Auth Parameters not set. Run `camply configure` \" f \"or set the following Environment Variables: \\n\\t { variable_names } \" \" \\n Optional Environment Variables: \\n\\t \" f \" { optional_variable_names } \" ) logger . error ( error_message ) raise EnvironmentError ( error_message ) # ATTEMPT AN EMAIL LOGIN AT INIT TO THROW ERRORS EARLY _email_server = SMTP_SSL ( self . email_smtp_server , self . email_smtp_server_port , ) _email_server . ehlo () _email_server . login ( user = self . email_username , password = self . _email_password , ) _email_server . quit ()","title":"__init__()"},{"location":"reference/notifications/email_notifications/#camply.notifications.email_notifications.EmailNotifications.send_campsites","text":"Send a message with a campsite object","title":"send_campsites()"},{"location":"reference/notifications/email_notifications/#camply.notifications.email_notifications.EmailNotifications.send_campsites--parameters","text":"campsites: List[AvailableCampsite] Source code in camply/notifications/email_notifications.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ) -> None : \"\"\" Send a message with a campsite object Parameters ---------- campsites: List[AvailableCampsite] \"\"\" master_email_body_list = list () for campsite in campsites : message_title , formatted_dict = self . format_standard_campsites ( campsite = campsite , ) fields = [ message_title ] for key , value in formatted_dict . items (): if key == \"Permitted Equipment\" : value = value . replace ( \" \\n - \" , \" \\n \\t - \" ) fields . append ( f \" \\t { key } : { value } \" ) composed_message = \" \\n \" . join ( fields ) + \" \\n\\n \" master_email_body_list . append ( composed_message ) master_email_body = \" \\n \" . join ( master_email_body_list ) if len ( campsites ) > 0 : self . send_message ( message = master_email_body )","title":"Parameters"},{"location":"reference/notifications/email_notifications/#camply.notifications.email_notifications.EmailNotifications.send_message","text":"Send a message via Email","title":"send_message()"},{"location":"reference/notifications/email_notifications/#camply.notifications.email_notifications.EmailNotifications.send_message--parameters","text":"str Email Body **kwargs Accepts: from, to, subject, username, password, server, port","title":"Parameters"},{"location":"reference/notifications/email_notifications/#camply.notifications.email_notifications.EmailNotifications.send_message--returns","text":"object Source code in camply/notifications/email_notifications.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def send_message ( self , message : str , ** kwargs ) -> None : \"\"\" Send a message via Email Parameters ---------- message: str Email Body **kwargs Accepts: from, to, subject, username, password, server, port Returns ------- object \"\"\" email = EmailMessage () email . set_content ( message ) email [ \"Subject\" ] = kwargs . get ( \"subject\" , self . email_subject ) email [ \"From\" ] = kwargs . get ( \"from\" , self . email_from ) email [ \"To\" ] = kwargs . get ( \"to\" , self . email_to ) email_server_user = kwargs . get ( \"username\" , self . email_username ) email_server_password = kwargs . get ( \"password\" , self . _email_password ) email_server_smtp_server = kwargs . get ( \"server\" , self . email_smtp_server ) email_server_smtp_server_port = kwargs . get ( \"port\" , self . email_smtp_server_port ) email_server = SMTP_SSL ( email_server_smtp_server , email_server_smtp_server_port ) email_server . ehlo () email_server . login ( user = email_server_user , password = email_server_password ) logger . info ( f \"Sending Email to { email [ 'To' ] } : { email [ 'Subject' ] } \" ) email_server . send_message ( email ) logger . info ( \"Email sent successfully\" ) email_server . quit ()","title":"Returns"},{"location":"reference/notifications/multi_provider_notifications/","text":"Default Notifier: Silent + Extras MultiNotifierProvider # Bases: BaseNotifications Notifications Supported from Multiple Providers Source code in camply/notifications/multi_provider_notifications.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 class MultiNotifierProvider ( BaseNotifications ): \"\"\" Notifications Supported from Multiple Providers \"\"\" def __init__ ( self , provider : Union [ str , List [ str ], BaseNotifications , None ]): \"\"\" Initialize with a Notifier Class Object, a string or list of strings Parameters ---------- provider: Union[str, List[str], BaseNotifications, None] Provider String, Comma Separated Provider String, or list of provider strings \"\"\" super () . __init__ () self . providers = [ SilentNotifications ()] if isinstance ( provider , str ): provider = [ prov_string . strip () for prov_string in provider . split ( \",\" )] for notifier_object in provider : if isinstance ( notifier_object , BaseNotifications ): notifier = notifier_object elif isinstance ( notifier_object , str ): notifier = CAMPSITE_NOTIFICATIONS . get ( notifier_object . lower (), None )() elif notifier_object is None : notifier = None else : raise NotificationError ( \"You must provide a proper Notification Identifier\" ) if notifier is not None and not isinstance ( notifier , SilentNotifications ): self . providers . append ( notifier ) def send_message ( self , message : str , ** kwargs ): \"\"\" Send a message Parameters ---------- message: str Message Text **kwargs All kwargs passed to underlying notification method \"\"\" for provider in self . providers : provider . send_message ( message = message , ** kwargs ) def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: List[AvailableCampsite] \"\"\" for provider in self . providers : provider . send_campsites ( campsites = campsites , ** kwargs ) def log_providers ( self ) -> None : \"\"\" Log All Providers Returns ------- None \"\"\" provider_names = [ str ( provider ) for provider in self . providers ] logger . info ( f \"Notifications active via: { ', ' . join ( provider_names ) } \" ) if len ( self . providers ) == 1 : logger . info ( f \"Only { self . providers [ 0 ] } enabled. \" \"I hope you're watching these logs.\" ) __init__ ( provider ) # Initialize with a Notifier Class Object, a string or list of strings Parameters # Union[str, List[str], BaseNotifications, None] Provider String, Comma Separated Provider String, or list of provider strings Source code in camply/notifications/multi_provider_notifications.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def __init__ ( self , provider : Union [ str , List [ str ], BaseNotifications , None ]): \"\"\" Initialize with a Notifier Class Object, a string or list of strings Parameters ---------- provider: Union[str, List[str], BaseNotifications, None] Provider String, Comma Separated Provider String, or list of provider strings \"\"\" super () . __init__ () self . providers = [ SilentNotifications ()] if isinstance ( provider , str ): provider = [ prov_string . strip () for prov_string in provider . split ( \",\" )] for notifier_object in provider : if isinstance ( notifier_object , BaseNotifications ): notifier = notifier_object elif isinstance ( notifier_object , str ): notifier = CAMPSITE_NOTIFICATIONS . get ( notifier_object . lower (), None )() elif notifier_object is None : notifier = None else : raise NotificationError ( \"You must provide a proper Notification Identifier\" ) if notifier is not None and not isinstance ( notifier , SilentNotifications ): self . providers . append ( notifier ) log_providers () # Log All Providers Returns # None Source code in camply/notifications/multi_provider_notifications.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def log_providers ( self ) -> None : \"\"\" Log All Providers Returns ------- None \"\"\" provider_names = [ str ( provider ) for provider in self . providers ] logger . info ( f \"Notifications active via: { ', ' . join ( provider_names ) } \" ) if len ( self . providers ) == 1 : logger . info ( f \"Only { self . providers [ 0 ] } enabled. \" \"I hope you're watching these logs.\" ) send_campsites ( campsites , ** kwargs ) # Send a message with a campsite object Parameters # campsites: List[AvailableCampsite] Source code in camply/notifications/multi_provider_notifications.py 78 79 80 81 82 83 84 85 86 87 def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: List[AvailableCampsite] \"\"\" for provider in self . providers : provider . send_campsites ( campsites = campsites , ** kwargs ) send_message ( message , ** kwargs ) # Send a message Parameters # str Message Text **kwargs All kwargs passed to underlying notification method Source code in camply/notifications/multi_provider_notifications.py 64 65 66 67 68 69 70 71 72 73 74 75 76 def send_message ( self , message : str , ** kwargs ): \"\"\" Send a message Parameters ---------- message: str Message Text **kwargs All kwargs passed to underlying notification method \"\"\" for provider in self . providers : provider . send_message ( message = message , ** kwargs )","title":"multi_provider_notifications"},{"location":"reference/notifications/multi_provider_notifications/#camply.notifications.multi_provider_notifications.MultiNotifierProvider","text":"Bases: BaseNotifications Notifications Supported from Multiple Providers Source code in camply/notifications/multi_provider_notifications.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 class MultiNotifierProvider ( BaseNotifications ): \"\"\" Notifications Supported from Multiple Providers \"\"\" def __init__ ( self , provider : Union [ str , List [ str ], BaseNotifications , None ]): \"\"\" Initialize with a Notifier Class Object, a string or list of strings Parameters ---------- provider: Union[str, List[str], BaseNotifications, None] Provider String, Comma Separated Provider String, or list of provider strings \"\"\" super () . __init__ () self . providers = [ SilentNotifications ()] if isinstance ( provider , str ): provider = [ prov_string . strip () for prov_string in provider . split ( \",\" )] for notifier_object in provider : if isinstance ( notifier_object , BaseNotifications ): notifier = notifier_object elif isinstance ( notifier_object , str ): notifier = CAMPSITE_NOTIFICATIONS . get ( notifier_object . lower (), None )() elif notifier_object is None : notifier = None else : raise NotificationError ( \"You must provide a proper Notification Identifier\" ) if notifier is not None and not isinstance ( notifier , SilentNotifications ): self . providers . append ( notifier ) def send_message ( self , message : str , ** kwargs ): \"\"\" Send a message Parameters ---------- message: str Message Text **kwargs All kwargs passed to underlying notification method \"\"\" for provider in self . providers : provider . send_message ( message = message , ** kwargs ) def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: List[AvailableCampsite] \"\"\" for provider in self . providers : provider . send_campsites ( campsites = campsites , ** kwargs ) def log_providers ( self ) -> None : \"\"\" Log All Providers Returns ------- None \"\"\" provider_names = [ str ( provider ) for provider in self . providers ] logger . info ( f \"Notifications active via: { ', ' . join ( provider_names ) } \" ) if len ( self . providers ) == 1 : logger . info ( f \"Only { self . providers [ 0 ] } enabled. \" \"I hope you're watching these logs.\" )","title":"MultiNotifierProvider"},{"location":"reference/notifications/multi_provider_notifications/#camply.notifications.multi_provider_notifications.MultiNotifierProvider.__init__","text":"Initialize with a Notifier Class Object, a string or list of strings","title":"__init__()"},{"location":"reference/notifications/multi_provider_notifications/#camply.notifications.multi_provider_notifications.MultiNotifierProvider.__init__--parameters","text":"Union[str, List[str], BaseNotifications, None] Provider String, Comma Separated Provider String, or list of provider strings Source code in camply/notifications/multi_provider_notifications.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def __init__ ( self , provider : Union [ str , List [ str ], BaseNotifications , None ]): \"\"\" Initialize with a Notifier Class Object, a string or list of strings Parameters ---------- provider: Union[str, List[str], BaseNotifications, None] Provider String, Comma Separated Provider String, or list of provider strings \"\"\" super () . __init__ () self . providers = [ SilentNotifications ()] if isinstance ( provider , str ): provider = [ prov_string . strip () for prov_string in provider . split ( \",\" )] for notifier_object in provider : if isinstance ( notifier_object , BaseNotifications ): notifier = notifier_object elif isinstance ( notifier_object , str ): notifier = CAMPSITE_NOTIFICATIONS . get ( notifier_object . lower (), None )() elif notifier_object is None : notifier = None else : raise NotificationError ( \"You must provide a proper Notification Identifier\" ) if notifier is not None and not isinstance ( notifier , SilentNotifications ): self . providers . append ( notifier )","title":"Parameters"},{"location":"reference/notifications/multi_provider_notifications/#camply.notifications.multi_provider_notifications.MultiNotifierProvider.log_providers","text":"Log All Providers","title":"log_providers()"},{"location":"reference/notifications/multi_provider_notifications/#camply.notifications.multi_provider_notifications.MultiNotifierProvider.log_providers--returns","text":"None Source code in camply/notifications/multi_provider_notifications.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def log_providers ( self ) -> None : \"\"\" Log All Providers Returns ------- None \"\"\" provider_names = [ str ( provider ) for provider in self . providers ] logger . info ( f \"Notifications active via: { ', ' . join ( provider_names ) } \" ) if len ( self . providers ) == 1 : logger . info ( f \"Only { self . providers [ 0 ] } enabled. \" \"I hope you're watching these logs.\" )","title":"Returns"},{"location":"reference/notifications/multi_provider_notifications/#camply.notifications.multi_provider_notifications.MultiNotifierProvider.send_campsites","text":"Send a message with a campsite object","title":"send_campsites()"},{"location":"reference/notifications/multi_provider_notifications/#camply.notifications.multi_provider_notifications.MultiNotifierProvider.send_campsites--parameters","text":"campsites: List[AvailableCampsite] Source code in camply/notifications/multi_provider_notifications.py 78 79 80 81 82 83 84 85 86 87 def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: List[AvailableCampsite] \"\"\" for provider in self . providers : provider . send_campsites ( campsites = campsites , ** kwargs )","title":"Parameters"},{"location":"reference/notifications/multi_provider_notifications/#camply.notifications.multi_provider_notifications.MultiNotifierProvider.send_message","text":"Send a message","title":"send_message()"},{"location":"reference/notifications/multi_provider_notifications/#camply.notifications.multi_provider_notifications.MultiNotifierProvider.send_message--parameters","text":"str Message Text **kwargs All kwargs passed to underlying notification method Source code in camply/notifications/multi_provider_notifications.py 64 65 66 67 68 69 70 71 72 73 74 75 76 def send_message ( self , message : str , ** kwargs ): \"\"\" Send a message Parameters ---------- message: str Message Text **kwargs All kwargs passed to underlying notification method \"\"\" for provider in self . providers : provider . send_message ( message = message , ** kwargs )","title":"Parameters"},{"location":"reference/notifications/pushbullet/","text":"Push Notifications via Pushbullet PushbulletNotifications # Bases: BaseNotifications Push Notifications via PushBullet Source code in camply/notifications/pushbullet.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 class PushbulletNotifications ( BaseNotifications ): \"\"\" Push Notifications via PushBullet \"\"\" def __init__ ( self ): super () . __init__ () pushbullet_headers = PushbulletConfig . API_HEADERS . copy () pushbullet_headers . update ({ \"Access-Token\" : PushbulletConfig . API_TOKEN }) self . session . headers . update ( pushbullet_headers ) if any ([ PushbulletConfig . API_TOKEN is None , PushbulletConfig . API_TOKEN == \"\" ]): warning_message = ( \"Pushbullet is not configured properly. To send Pushbullet messages \" \"make sure to run `camply configure` or set the \" \"proper environment variable: `PUSHBULLET_API_TOKEN`.\" ) logger . error ( warning_message ) raise EnvironmentError ( warning_message ) def send_message ( self , message : str , ** kwargs ) -> requests . Response : \"\"\" Send a message via PushBullet - if environment variables are configured Parameters ---------- message: str Returns ------- requests.Response \"\"\" message_type = kwargs . pop ( \"type\" , \"note\" ) message_title = kwargs . pop ( \"title\" , \"Camply Notification\" ) message_json = dict ( type = message_type , title = message_title , body = message , ** kwargs ) logger . debug ( message_json ) response = self . session . post ( url = PushbulletConfig . PUSHBULLET_API_ENDPOINT , json = message_json , ) try : response . raise_for_status () except requests . HTTPError as he : logger . warning ( \"Notifications weren't able to be sent to Pushbullet. \" \"Your configuration might be incorrect.\" ) raise ConnectionError ( response . text ) from he return response def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: AvailableCampsite \"\"\" for campsite in campsites : message_title , formatted_dict = self . format_standard_campsites ( campsite = campsite , ) fields = [] for key , value in formatted_dict . items (): fields . append ( f \" { key } : { value } \" ) composed_message = \" \\n \" . join ( fields ) self . send_message ( message = composed_message , title = message_title , type = \"note\" ) send_campsites ( campsites , ** kwargs ) # Send a message with a campsite object Parameters # campsites: AvailableCampsite Source code in camply/notifications/pushbullet.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: AvailableCampsite \"\"\" for campsite in campsites : message_title , formatted_dict = self . format_standard_campsites ( campsite = campsite , ) fields = [] for key , value in formatted_dict . items (): fields . append ( f \" { key } : { value } \" ) composed_message = \" \\n \" . join ( fields ) self . send_message ( message = composed_message , title = message_title , type = \"note\" ) send_message ( message , ** kwargs ) # Send a message via PushBullet - if environment variables are configured Parameters # message: str Returns # requests.Response Source code in camply/notifications/pushbullet.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def send_message ( self , message : str , ** kwargs ) -> requests . Response : \"\"\" Send a message via PushBullet - if environment variables are configured Parameters ---------- message: str Returns ------- requests.Response \"\"\" message_type = kwargs . pop ( \"type\" , \"note\" ) message_title = kwargs . pop ( \"title\" , \"Camply Notification\" ) message_json = dict ( type = message_type , title = message_title , body = message , ** kwargs ) logger . debug ( message_json ) response = self . session . post ( url = PushbulletConfig . PUSHBULLET_API_ENDPOINT , json = message_json , ) try : response . raise_for_status () except requests . HTTPError as he : logger . warning ( \"Notifications weren't able to be sent to Pushbullet. \" \"Your configuration might be incorrect.\" ) raise ConnectionError ( response . text ) from he return response","title":"pushbullet"},{"location":"reference/notifications/pushbullet/#camply.notifications.pushbullet.PushbulletNotifications","text":"Bases: BaseNotifications Push Notifications via PushBullet Source code in camply/notifications/pushbullet.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 class PushbulletNotifications ( BaseNotifications ): \"\"\" Push Notifications via PushBullet \"\"\" def __init__ ( self ): super () . __init__ () pushbullet_headers = PushbulletConfig . API_HEADERS . copy () pushbullet_headers . update ({ \"Access-Token\" : PushbulletConfig . API_TOKEN }) self . session . headers . update ( pushbullet_headers ) if any ([ PushbulletConfig . API_TOKEN is None , PushbulletConfig . API_TOKEN == \"\" ]): warning_message = ( \"Pushbullet is not configured properly. To send Pushbullet messages \" \"make sure to run `camply configure` or set the \" \"proper environment variable: `PUSHBULLET_API_TOKEN`.\" ) logger . error ( warning_message ) raise EnvironmentError ( warning_message ) def send_message ( self , message : str , ** kwargs ) -> requests . Response : \"\"\" Send a message via PushBullet - if environment variables are configured Parameters ---------- message: str Returns ------- requests.Response \"\"\" message_type = kwargs . pop ( \"type\" , \"note\" ) message_title = kwargs . pop ( \"title\" , \"Camply Notification\" ) message_json = dict ( type = message_type , title = message_title , body = message , ** kwargs ) logger . debug ( message_json ) response = self . session . post ( url = PushbulletConfig . PUSHBULLET_API_ENDPOINT , json = message_json , ) try : response . raise_for_status () except requests . HTTPError as he : logger . warning ( \"Notifications weren't able to be sent to Pushbullet. \" \"Your configuration might be incorrect.\" ) raise ConnectionError ( response . text ) from he return response def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: AvailableCampsite \"\"\" for campsite in campsites : message_title , formatted_dict = self . format_standard_campsites ( campsite = campsite , ) fields = [] for key , value in formatted_dict . items (): fields . append ( f \" { key } : { value } \" ) composed_message = \" \\n \" . join ( fields ) self . send_message ( message = composed_message , title = message_title , type = \"note\" )","title":"PushbulletNotifications"},{"location":"reference/notifications/pushbullet/#camply.notifications.pushbullet.PushbulletNotifications.send_campsites","text":"Send a message with a campsite object","title":"send_campsites()"},{"location":"reference/notifications/pushbullet/#camply.notifications.pushbullet.PushbulletNotifications.send_campsites--parameters","text":"campsites: AvailableCampsite Source code in camply/notifications/pushbullet.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: AvailableCampsite \"\"\" for campsite in campsites : message_title , formatted_dict = self . format_standard_campsites ( campsite = campsite , ) fields = [] for key , value in formatted_dict . items (): fields . append ( f \" { key } : { value } \" ) composed_message = \" \\n \" . join ( fields ) self . send_message ( message = composed_message , title = message_title , type = \"note\" )","title":"Parameters"},{"location":"reference/notifications/pushbullet/#camply.notifications.pushbullet.PushbulletNotifications.send_message","text":"Send a message via PushBullet - if environment variables are configured","title":"send_message()"},{"location":"reference/notifications/pushbullet/#camply.notifications.pushbullet.PushbulletNotifications.send_message--parameters","text":"message: str","title":"Parameters"},{"location":"reference/notifications/pushbullet/#camply.notifications.pushbullet.PushbulletNotifications.send_message--returns","text":"requests.Response Source code in camply/notifications/pushbullet.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def send_message ( self , message : str , ** kwargs ) -> requests . Response : \"\"\" Send a message via PushBullet - if environment variables are configured Parameters ---------- message: str Returns ------- requests.Response \"\"\" message_type = kwargs . pop ( \"type\" , \"note\" ) message_title = kwargs . pop ( \"title\" , \"Camply Notification\" ) message_json = dict ( type = message_type , title = message_title , body = message , ** kwargs ) logger . debug ( message_json ) response = self . session . post ( url = PushbulletConfig . PUSHBULLET_API_ENDPOINT , json = message_json , ) try : response . raise_for_status () except requests . HTTPError as he : logger . warning ( \"Notifications weren't able to be sent to Pushbullet. \" \"Your configuration might be incorrect.\" ) raise ConnectionError ( response . text ) from he return response","title":"Returns"},{"location":"reference/notifications/pushover/","text":"Push Notifications via Pushover PushoverNotifications # Bases: BaseNotifications , logging . StreamHandler Push Notifications via Pushover + a Logging Handler Source code in camply/notifications/pushover.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 class PushoverNotifications ( BaseNotifications , logging . StreamHandler ): \"\"\" Push Notifications via Pushover + a Logging Handler \"\"\" def __init__ ( self , level : Optional [ int ] = logging . INFO ): super () . __init__ () self . session . headers . update ( PushoverConfig . API_HEADERS ) logging . StreamHandler . __init__ ( self ) self . setLevel ( level = level ) if any ([ PushoverConfig . PUSH_USER is None , PushoverConfig . PUSH_USER == \"\" ]): warning_message = ( \"Pushover is not configured properly. To send pushover messages \" \"make sure to run `camply configure` or set the \" \"proper environment variables: `PUSHOVER_PUSH_USER`, \" \"`PUSHOVER_PUSH_TOKEN`.\" ) logger . error ( warning_message ) raise EnvironmentError ( warning_message ) def send_message ( self , message : str , ** kwargs ) -> requests . Response : \"\"\" Send a message via Pushover - if environment variables are configured Parameters ---------- message: str Returns ------- requests.Response \"\"\" token = ( PushoverConfig . PUSH_TOKEN if PushoverConfig . PUSH_TOKEN not in [ None , \"\" ] else base64 . b64decode ( PushoverConfig . PUSHOVER_DEFAULT_API_TOKEN ) . decode ( \"utf-8\" ) ) response = self . session . post ( url = PushoverConfig . PUSHOVER_API_ENDPOINT , params = dict ( token = token , user = PushoverConfig . PUSH_USER , message = message , ** kwargs ), ) try : response . raise_for_status () except requests . HTTPError as he : logger . warning ( \"Notifications weren't able to be sent to Pushover. \" \"Your configuration might be incorrect.\" ) raise ConnectionError ( response . text ) from he return response def emit ( self , record : logging . LogRecord ): \"\"\" Produce a logging record Parameters ---------- record: str Message to log \"\"\" log_formatted_message = \"[ {:>10} ]: {} \" . format ( record . levelname . upper (), record . msg ) title = f \"Pushover { record . levelname . title () } Message\" self . send_message ( message = log_formatted_message , title = title ) def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: AvailableCampsite \"\"\" for campsite in campsites : message_title , formatted_dict = self . format_standard_campsites ( campsite = campsite , ) fields = [] for key , value in formatted_dict . items (): if key == \"Booking Link\" : value = f \"<a href=' { value } '> { value } </a>\" fields . append ( f \"<b> { key } :</b> { value } \" ) composed_message = \" \\n \" . join ( fields ) self . send_message ( message = composed_message , title = message_title , html = 1 ) emit ( record ) # Produce a logging record Parameters # str Message to log Source code in camply/notifications/pushover.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def emit ( self , record : logging . LogRecord ): \"\"\" Produce a logging record Parameters ---------- record: str Message to log \"\"\" log_formatted_message = \"[ {:>10} ]: {} \" . format ( record . levelname . upper (), record . msg ) title = f \"Pushover { record . levelname . title () } Message\" self . send_message ( message = log_formatted_message , title = title ) send_campsites ( campsites , ** kwargs ) # Send a message with a campsite object Parameters # campsites: AvailableCampsite Source code in camply/notifications/pushover.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: AvailableCampsite \"\"\" for campsite in campsites : message_title , formatted_dict = self . format_standard_campsites ( campsite = campsite , ) fields = [] for key , value in formatted_dict . items (): if key == \"Booking Link\" : value = f \"<a href=' { value } '> { value } </a>\" fields . append ( f \"<b> { key } :</b> { value } \" ) composed_message = \" \\n \" . join ( fields ) self . send_message ( message = composed_message , title = message_title , html = 1 ) send_message ( message , ** kwargs ) # Send a message via Pushover - if environment variables are configured Parameters # message: str Returns # requests.Response Source code in camply/notifications/pushover.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 def send_message ( self , message : str , ** kwargs ) -> requests . Response : \"\"\" Send a message via Pushover - if environment variables are configured Parameters ---------- message: str Returns ------- requests.Response \"\"\" token = ( PushoverConfig . PUSH_TOKEN if PushoverConfig . PUSH_TOKEN not in [ None , \"\" ] else base64 . b64decode ( PushoverConfig . PUSHOVER_DEFAULT_API_TOKEN ) . decode ( \"utf-8\" ) ) response = self . session . post ( url = PushoverConfig . PUSHOVER_API_ENDPOINT , params = dict ( token = token , user = PushoverConfig . PUSH_USER , message = message , ** kwargs ), ) try : response . raise_for_status () except requests . HTTPError as he : logger . warning ( \"Notifications weren't able to be sent to Pushover. \" \"Your configuration might be incorrect.\" ) raise ConnectionError ( response . text ) from he return response","title":"pushover"},{"location":"reference/notifications/pushover/#camply.notifications.pushover.PushoverNotifications","text":"Bases: BaseNotifications , logging . StreamHandler Push Notifications via Pushover + a Logging Handler Source code in camply/notifications/pushover.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 class PushoverNotifications ( BaseNotifications , logging . StreamHandler ): \"\"\" Push Notifications via Pushover + a Logging Handler \"\"\" def __init__ ( self , level : Optional [ int ] = logging . INFO ): super () . __init__ () self . session . headers . update ( PushoverConfig . API_HEADERS ) logging . StreamHandler . __init__ ( self ) self . setLevel ( level = level ) if any ([ PushoverConfig . PUSH_USER is None , PushoverConfig . PUSH_USER == \"\" ]): warning_message = ( \"Pushover is not configured properly. To send pushover messages \" \"make sure to run `camply configure` or set the \" \"proper environment variables: `PUSHOVER_PUSH_USER`, \" \"`PUSHOVER_PUSH_TOKEN`.\" ) logger . error ( warning_message ) raise EnvironmentError ( warning_message ) def send_message ( self , message : str , ** kwargs ) -> requests . Response : \"\"\" Send a message via Pushover - if environment variables are configured Parameters ---------- message: str Returns ------- requests.Response \"\"\" token = ( PushoverConfig . PUSH_TOKEN if PushoverConfig . PUSH_TOKEN not in [ None , \"\" ] else base64 . b64decode ( PushoverConfig . PUSHOVER_DEFAULT_API_TOKEN ) . decode ( \"utf-8\" ) ) response = self . session . post ( url = PushoverConfig . PUSHOVER_API_ENDPOINT , params = dict ( token = token , user = PushoverConfig . PUSH_USER , message = message , ** kwargs ), ) try : response . raise_for_status () except requests . HTTPError as he : logger . warning ( \"Notifications weren't able to be sent to Pushover. \" \"Your configuration might be incorrect.\" ) raise ConnectionError ( response . text ) from he return response def emit ( self , record : logging . LogRecord ): \"\"\" Produce a logging record Parameters ---------- record: str Message to log \"\"\" log_formatted_message = \"[ {:>10} ]: {} \" . format ( record . levelname . upper (), record . msg ) title = f \"Pushover { record . levelname . title () } Message\" self . send_message ( message = log_formatted_message , title = title ) def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: AvailableCampsite \"\"\" for campsite in campsites : message_title , formatted_dict = self . format_standard_campsites ( campsite = campsite , ) fields = [] for key , value in formatted_dict . items (): if key == \"Booking Link\" : value = f \"<a href=' { value } '> { value } </a>\" fields . append ( f \"<b> { key } :</b> { value } \" ) composed_message = \" \\n \" . join ( fields ) self . send_message ( message = composed_message , title = message_title , html = 1 )","title":"PushoverNotifications"},{"location":"reference/notifications/pushover/#camply.notifications.pushover.PushoverNotifications.emit","text":"Produce a logging record","title":"emit()"},{"location":"reference/notifications/pushover/#camply.notifications.pushover.PushoverNotifications.emit--parameters","text":"str Message to log Source code in camply/notifications/pushover.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def emit ( self , record : logging . LogRecord ): \"\"\" Produce a logging record Parameters ---------- record: str Message to log \"\"\" log_formatted_message = \"[ {:>10} ]: {} \" . format ( record . levelname . upper (), record . msg ) title = f \"Pushover { record . levelname . title () } Message\" self . send_message ( message = log_formatted_message , title = title )","title":"Parameters"},{"location":"reference/notifications/pushover/#camply.notifications.pushover.PushoverNotifications.send_campsites","text":"Send a message with a campsite object","title":"send_campsites()"},{"location":"reference/notifications/pushover/#camply.notifications.pushover.PushoverNotifications.send_campsites--parameters","text":"campsites: AvailableCampsite Source code in camply/notifications/pushover.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: AvailableCampsite \"\"\" for campsite in campsites : message_title , formatted_dict = self . format_standard_campsites ( campsite = campsite , ) fields = [] for key , value in formatted_dict . items (): if key == \"Booking Link\" : value = f \"<a href=' { value } '> { value } </a>\" fields . append ( f \"<b> { key } :</b> { value } \" ) composed_message = \" \\n \" . join ( fields ) self . send_message ( message = composed_message , title = message_title , html = 1 )","title":"Parameters"},{"location":"reference/notifications/pushover/#camply.notifications.pushover.PushoverNotifications.send_message","text":"Send a message via Pushover - if environment variables are configured","title":"send_message()"},{"location":"reference/notifications/pushover/#camply.notifications.pushover.PushoverNotifications.send_message--parameters","text":"message: str","title":"Parameters"},{"location":"reference/notifications/pushover/#camply.notifications.pushover.PushoverNotifications.send_message--returns","text":"requests.Response Source code in camply/notifications/pushover.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 def send_message ( self , message : str , ** kwargs ) -> requests . Response : \"\"\" Send a message via Pushover - if environment variables are configured Parameters ---------- message: str Returns ------- requests.Response \"\"\" token = ( PushoverConfig . PUSH_TOKEN if PushoverConfig . PUSH_TOKEN not in [ None , \"\" ] else base64 . b64decode ( PushoverConfig . PUSHOVER_DEFAULT_API_TOKEN ) . decode ( \"utf-8\" ) ) response = self . session . post ( url = PushoverConfig . PUSHOVER_API_ENDPOINT , params = dict ( token = token , user = PushoverConfig . PUSH_USER , message = message , ** kwargs ), ) try : response . raise_for_status () except requests . HTTPError as he : logger . warning ( \"Notifications weren't able to be sent to Pushover. \" \"Your configuration might be incorrect.\" ) raise ConnectionError ( response . text ) from he return response","title":"Returns"},{"location":"reference/notifications/silent_notifications/","text":"Silent Notifications SilentNotifications # Bases: BaseNotifications Silent Notifications Source code in camply/notifications/silent_notifications.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class SilentNotifications ( BaseNotifications ): \"\"\" Silent Notifications \"\"\" def send_message ( self , message : Iterable , ** kwargs ) -> None : \"\"\" Send a message via Email Parameters ---------- message: Iterable Email Body **kwargs kwargs are disregarded Returns ------- None \"\"\" message_string = \" \\n\\t \u2022 \" + \" \\n\\t \u2022 \" . join ( list ( message )) logger . debug ( f \"SilentNotification: { message_string } \" ) def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: List[AvailableCampsite] \"\"\" for campsite in campsites : campsite_tuple = ( ( f \" { campsite . booking_date . strftime ( '%Y-%m- %d ' ) } - \" f \" { campsite . booking_end_date . strftime ( '%Y-%m- %d ' ) } \" ), campsite . campsite_type , campsite . campsite_site_name , campsite . recreation_area , campsite . facility_name , campsite . booking_url , ) self . send_message ( campsite_tuple ) campsite_formatted = pformat ( campsite . dict ()) logger . debug ( \"Campsite Info: \" + campsite_formatted ) send_campsites ( campsites , ** kwargs ) # Send a message with a campsite object Parameters # campsites: List[AvailableCampsite] Source code in camply/notifications/silent_notifications.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: List[AvailableCampsite] \"\"\" for campsite in campsites : campsite_tuple = ( ( f \" { campsite . booking_date . strftime ( '%Y-%m- %d ' ) } - \" f \" { campsite . booking_end_date . strftime ( '%Y-%m- %d ' ) } \" ), campsite . campsite_type , campsite . campsite_site_name , campsite . recreation_area , campsite . facility_name , campsite . booking_url , ) self . send_message ( campsite_tuple ) campsite_formatted = pformat ( campsite . dict ()) logger . debug ( \"Campsite Info: \" + campsite_formatted ) send_message ( message , ** kwargs ) # Send a message via Email Parameters # Iterable Email Body **kwargs kwargs are disregarded Returns # None Source code in camply/notifications/silent_notifications.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def send_message ( self , message : Iterable , ** kwargs ) -> None : \"\"\" Send a message via Email Parameters ---------- message: Iterable Email Body **kwargs kwargs are disregarded Returns ------- None \"\"\" message_string = \" \\n\\t \u2022 \" + \" \\n\\t \u2022 \" . join ( list ( message )) logger . debug ( f \"SilentNotification: { message_string } \" )","title":"silent_notifications"},{"location":"reference/notifications/silent_notifications/#camply.notifications.silent_notifications.SilentNotifications","text":"Bases: BaseNotifications Silent Notifications Source code in camply/notifications/silent_notifications.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class SilentNotifications ( BaseNotifications ): \"\"\" Silent Notifications \"\"\" def send_message ( self , message : Iterable , ** kwargs ) -> None : \"\"\" Send a message via Email Parameters ---------- message: Iterable Email Body **kwargs kwargs are disregarded Returns ------- None \"\"\" message_string = \" \\n\\t \u2022 \" + \" \\n\\t \u2022 \" . join ( list ( message )) logger . debug ( f \"SilentNotification: { message_string } \" ) def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: List[AvailableCampsite] \"\"\" for campsite in campsites : campsite_tuple = ( ( f \" { campsite . booking_date . strftime ( '%Y-%m- %d ' ) } - \" f \" { campsite . booking_end_date . strftime ( '%Y-%m- %d ' ) } \" ), campsite . campsite_type , campsite . campsite_site_name , campsite . recreation_area , campsite . facility_name , campsite . booking_url , ) self . send_message ( campsite_tuple ) campsite_formatted = pformat ( campsite . dict ()) logger . debug ( \"Campsite Info: \" + campsite_formatted )","title":"SilentNotifications"},{"location":"reference/notifications/silent_notifications/#camply.notifications.silent_notifications.SilentNotifications.send_campsites","text":"Send a message with a campsite object","title":"send_campsites()"},{"location":"reference/notifications/silent_notifications/#camply.notifications.silent_notifications.SilentNotifications.send_campsites--parameters","text":"campsites: List[AvailableCampsite] Source code in camply/notifications/silent_notifications.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: List[AvailableCampsite] \"\"\" for campsite in campsites : campsite_tuple = ( ( f \" { campsite . booking_date . strftime ( '%Y-%m- %d ' ) } - \" f \" { campsite . booking_end_date . strftime ( '%Y-%m- %d ' ) } \" ), campsite . campsite_type , campsite . campsite_site_name , campsite . recreation_area , campsite . facility_name , campsite . booking_url , ) self . send_message ( campsite_tuple ) campsite_formatted = pformat ( campsite . dict ()) logger . debug ( \"Campsite Info: \" + campsite_formatted )","title":"Parameters"},{"location":"reference/notifications/silent_notifications/#camply.notifications.silent_notifications.SilentNotifications.send_message","text":"Send a message via Email","title":"send_message()"},{"location":"reference/notifications/silent_notifications/#camply.notifications.silent_notifications.SilentNotifications.send_message--parameters","text":"Iterable Email Body **kwargs kwargs are disregarded","title":"Parameters"},{"location":"reference/notifications/silent_notifications/#camply.notifications.silent_notifications.SilentNotifications.send_message--returns","text":"None Source code in camply/notifications/silent_notifications.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def send_message ( self , message : Iterable , ** kwargs ) -> None : \"\"\" Send a message via Email Parameters ---------- message: Iterable Email Body **kwargs kwargs are disregarded Returns ------- None \"\"\" message_string = \" \\n\\t \u2022 \" + \" \\n\\t \u2022 \" . join ( list ( message )) logger . debug ( f \"SilentNotification: { message_string } \" )","title":"Returns"},{"location":"reference/notifications/slack/","text":"Push Notifications via Slack SlackNotifications # Bases: BaseNotifications Push Notifications via Slack Source code in camply/notifications/slack.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 class SlackNotifications ( BaseNotifications ): \"\"\" Push Notifications via Slack \"\"\" def __init__ ( self ): super () . __init__ () self . session . headers . update ({ \"Content-Type\" : \"application/json\" }) if any ([ SlackConfig . SLACK_WEBHOOK is None , SlackConfig . SLACK_WEBHOOK == \"\" ]): warning_message = ( \"Slack is not configured properly. To send Slack messages \" \"make sure to run `camply configure` or set the \" \"proper environment variable: `SLACK_WEBHOOK`.\" ) logger . error ( warning_message ) raise EnvironmentError ( warning_message ) def send_message ( self , message : str , ** kwargs ) -> requests . Response : \"\"\" Send a message via Slack - if environment variables are configured. Parameters ---------- message: str blocks: List Returns ------- requests.Response \"\"\" message_blocks = kwargs . pop ( \"blocks\" , []) message_json = { \"text\" : message , } if message_blocks : message_json = { \"blocks\" : message_blocks , } logger . debug ( message_json ) response = self . session . post ( url = SlackConfig . SLACK_WEBHOOK , json = message_json , ) try : response . raise_for_status () except requests . HTTPError as he : logger . warning ( \"Notifications weren't able to be sent to Slack. \" \"Your configuration might be incorrect.\" ) raise ConnectionError ( response . text ) from he return response def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: AvailableCampsite \"\"\" for campsite in campsites : message_title , formatted_dict = self . format_standard_campsites ( campsite = campsite , ) fields = [] for key , value in formatted_dict . items (): fields . append ( { \"type\" : \"mrkdwn\" , \"text\" : f \"* { key } *\" , } ) if key in [ \"Permitted Equipment\" , \"Booking Link\" ]: data_type = \"mrkdwn\" else : data_type = \"plain_text\" fields . append ( { \"type\" : data_type , \"text\" : str ( value ), } ) blocks = [] blocks . append ( { \"type\" : \"header\" , \"text\" : { \"type\" : \"plain_text\" , \"text\" : message_title , }, } ) # Slack only allows 10 fields (k+v) per section for chunk in range ( 0 , len ( fields ) + 1 , 10 ): chunk_max = chunk + 10 blocks . append ( { \"type\" : \"section\" , \"fields\" : fields [ chunk : chunk_max ], } ) self . send_message ( message = message_title , blocks = blocks , ) send_campsites ( campsites , ** kwargs ) # Send a message with a campsite object Parameters # campsites: AvailableCampsite Source code in camply/notifications/slack.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: AvailableCampsite \"\"\" for campsite in campsites : message_title , formatted_dict = self . format_standard_campsites ( campsite = campsite , ) fields = [] for key , value in formatted_dict . items (): fields . append ( { \"type\" : \"mrkdwn\" , \"text\" : f \"* { key } *\" , } ) if key in [ \"Permitted Equipment\" , \"Booking Link\" ]: data_type = \"mrkdwn\" else : data_type = \"plain_text\" fields . append ( { \"type\" : data_type , \"text\" : str ( value ), } ) blocks = [] blocks . append ( { \"type\" : \"header\" , \"text\" : { \"type\" : \"plain_text\" , \"text\" : message_title , }, } ) # Slack only allows 10 fields (k+v) per section for chunk in range ( 0 , len ( fields ) + 1 , 10 ): chunk_max = chunk + 10 blocks . append ( { \"type\" : \"section\" , \"fields\" : fields [ chunk : chunk_max ], } ) self . send_message ( message = message_title , blocks = blocks , ) send_message ( message , ** kwargs ) # Send a message via Slack - if environment variables are configured. Parameters # message: str blocks: List Returns # requests.Response Source code in camply/notifications/slack.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def send_message ( self , message : str , ** kwargs ) -> requests . Response : \"\"\" Send a message via Slack - if environment variables are configured. Parameters ---------- message: str blocks: List Returns ------- requests.Response \"\"\" message_blocks = kwargs . pop ( \"blocks\" , []) message_json = { \"text\" : message , } if message_blocks : message_json = { \"blocks\" : message_blocks , } logger . debug ( message_json ) response = self . session . post ( url = SlackConfig . SLACK_WEBHOOK , json = message_json , ) try : response . raise_for_status () except requests . HTTPError as he : logger . warning ( \"Notifications weren't able to be sent to Slack. \" \"Your configuration might be incorrect.\" ) raise ConnectionError ( response . text ) from he return response","title":"slack"},{"location":"reference/notifications/slack/#camply.notifications.slack.SlackNotifications","text":"Bases: BaseNotifications Push Notifications via Slack Source code in camply/notifications/slack.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 class SlackNotifications ( BaseNotifications ): \"\"\" Push Notifications via Slack \"\"\" def __init__ ( self ): super () . __init__ () self . session . headers . update ({ \"Content-Type\" : \"application/json\" }) if any ([ SlackConfig . SLACK_WEBHOOK is None , SlackConfig . SLACK_WEBHOOK == \"\" ]): warning_message = ( \"Slack is not configured properly. To send Slack messages \" \"make sure to run `camply configure` or set the \" \"proper environment variable: `SLACK_WEBHOOK`.\" ) logger . error ( warning_message ) raise EnvironmentError ( warning_message ) def send_message ( self , message : str , ** kwargs ) -> requests . Response : \"\"\" Send a message via Slack - if environment variables are configured. Parameters ---------- message: str blocks: List Returns ------- requests.Response \"\"\" message_blocks = kwargs . pop ( \"blocks\" , []) message_json = { \"text\" : message , } if message_blocks : message_json = { \"blocks\" : message_blocks , } logger . debug ( message_json ) response = self . session . post ( url = SlackConfig . SLACK_WEBHOOK , json = message_json , ) try : response . raise_for_status () except requests . HTTPError as he : logger . warning ( \"Notifications weren't able to be sent to Slack. \" \"Your configuration might be incorrect.\" ) raise ConnectionError ( response . text ) from he return response def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: AvailableCampsite \"\"\" for campsite in campsites : message_title , formatted_dict = self . format_standard_campsites ( campsite = campsite , ) fields = [] for key , value in formatted_dict . items (): fields . append ( { \"type\" : \"mrkdwn\" , \"text\" : f \"* { key } *\" , } ) if key in [ \"Permitted Equipment\" , \"Booking Link\" ]: data_type = \"mrkdwn\" else : data_type = \"plain_text\" fields . append ( { \"type\" : data_type , \"text\" : str ( value ), } ) blocks = [] blocks . append ( { \"type\" : \"header\" , \"text\" : { \"type\" : \"plain_text\" , \"text\" : message_title , }, } ) # Slack only allows 10 fields (k+v) per section for chunk in range ( 0 , len ( fields ) + 1 , 10 ): chunk_max = chunk + 10 blocks . append ( { \"type\" : \"section\" , \"fields\" : fields [ chunk : chunk_max ], } ) self . send_message ( message = message_title , blocks = blocks , )","title":"SlackNotifications"},{"location":"reference/notifications/slack/#camply.notifications.slack.SlackNotifications.send_campsites","text":"Send a message with a campsite object","title":"send_campsites()"},{"location":"reference/notifications/slack/#camply.notifications.slack.SlackNotifications.send_campsites--parameters","text":"campsites: AvailableCampsite Source code in camply/notifications/slack.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: AvailableCampsite \"\"\" for campsite in campsites : message_title , formatted_dict = self . format_standard_campsites ( campsite = campsite , ) fields = [] for key , value in formatted_dict . items (): fields . append ( { \"type\" : \"mrkdwn\" , \"text\" : f \"* { key } *\" , } ) if key in [ \"Permitted Equipment\" , \"Booking Link\" ]: data_type = \"mrkdwn\" else : data_type = \"plain_text\" fields . append ( { \"type\" : data_type , \"text\" : str ( value ), } ) blocks = [] blocks . append ( { \"type\" : \"header\" , \"text\" : { \"type\" : \"plain_text\" , \"text\" : message_title , }, } ) # Slack only allows 10 fields (k+v) per section for chunk in range ( 0 , len ( fields ) + 1 , 10 ): chunk_max = chunk + 10 blocks . append ( { \"type\" : \"section\" , \"fields\" : fields [ chunk : chunk_max ], } ) self . send_message ( message = message_title , blocks = blocks , )","title":"Parameters"},{"location":"reference/notifications/slack/#camply.notifications.slack.SlackNotifications.send_message","text":"Send a message via Slack - if environment variables are configured.","title":"send_message()"},{"location":"reference/notifications/slack/#camply.notifications.slack.SlackNotifications.send_message--parameters","text":"message: str blocks: List","title":"Parameters"},{"location":"reference/notifications/slack/#camply.notifications.slack.SlackNotifications.send_message--returns","text":"requests.Response Source code in camply/notifications/slack.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def send_message ( self , message : str , ** kwargs ) -> requests . Response : \"\"\" Send a message via Slack - if environment variables are configured. Parameters ---------- message: str blocks: List Returns ------- requests.Response \"\"\" message_blocks = kwargs . pop ( \"blocks\" , []) message_json = { \"text\" : message , } if message_blocks : message_json = { \"blocks\" : message_blocks , } logger . debug ( message_json ) response = self . session . post ( url = SlackConfig . SLACK_WEBHOOK , json = message_json , ) try : response . raise_for_status () except requests . HTTPError as he : logger . warning ( \"Notifications weren't able to be sent to Slack. \" \"Your configuration might be incorrect.\" ) raise ConnectionError ( response . text ) from he return response","title":"Returns"},{"location":"reference/notifications/telegram/","text":"Push Notifications via Telegram TelegramNotifications # Bases: BaseNotifications Push Notifications via Telegram Source code in camply/notifications/telegram.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 class TelegramNotifications ( BaseNotifications ): \"\"\" Push Notifications via Telegram \"\"\" def __init__ ( self ): super () . __init__ () self . session . headers . update ( TelegramConfig . API_HEADERS ) if any ( [ TelegramConfig . BOT_TOKEN is None , TelegramConfig . BOT_TOKEN == \"\" , TelegramConfig . CHAT_ID is None , TelegramConfig . CHAT_ID == \"\" , ] ): warning_message = ( \"Telegram is not configured properly. To send Telegram messages \" \"make sure to run `camply configure` or set the \" \"proper environment variables: `TELEGRAM_BOT_TOKEN` and `TELEGRAM_CHAT_ID`.\" ) logger . error ( warning_message ) raise EnvironmentError ( warning_message ) def send_message ( self , message : str , escaped = False , ** kwargs ) -> requests . Response : \"\"\" Send a message via Telegram - if environment variables are configured Parameters ---------- message: str escaped: bool Returns ------- requests.Response \"\"\" if not escaped : message = self . escape_text ( message ) message_json = TelegramConfig . API_CONTENT . copy () message_json . update ({ \"text\" : message }) logger . debug ( message_json ) response = self . session . post ( url = TelegramConfig . API_ENDPOINT , json = message_json ) try : response . raise_for_status () except requests . HTTPError as he : logger . warning ( \"Notifications weren't able to be sent to Telegram. \" \"Your configuration might be incorrect.\" ) raise ConnectionError ( response . text ) from he return response @staticmethod def escape_text ( message : str ) -> str : \"\"\" Escape a message for use in Telegram Parameters ---------- message: str Returns ------- String \"\"\" fields = [ \"_\" , \"*\" , \"[\" , \"]\" , \"(\" , \")\" , \"~\" , \"`\" , \">\" , \"#\" , \"+\" , \"-\" , \"=\" , \"|\" , \"{\" , \"}\" , \".\" , \"!\" , ] for f in fields : message = message . replace ( f , f \" \\\\ { f } \" ) return message def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: AvailableCampsite \"\"\" for campsite in campsites : message_title , formatted_dict = self . format_standard_campsites ( campsite = campsite , ) fields = [] for key , value in formatted_dict . items (): fields . append ( self . escape_text ( f \" { key } : { value } \" )) message_fields = \" \\n \" . join ( fields ) message = f \"* { self . escape_text ( message_title ) } * \\n { message_fields } \" self . send_message ( message , escaped = True ) escape_text ( message ) staticmethod # Escape a message for use in Telegram Parameters # message: str Returns # String Source code in camply/notifications/telegram.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 @staticmethod def escape_text ( message : str ) -> str : \"\"\" Escape a message for use in Telegram Parameters ---------- message: str Returns ------- String \"\"\" fields = [ \"_\" , \"*\" , \"[\" , \"]\" , \"(\" , \")\" , \"~\" , \"`\" , \">\" , \"#\" , \"+\" , \"-\" , \"=\" , \"|\" , \"{\" , \"}\" , \".\" , \"!\" , ] for f in fields : message = message . replace ( f , f \" \\\\ { f } \" ) return message send_campsites ( campsites , ** kwargs ) # Send a message with a campsite object Parameters # campsites: AvailableCampsite Source code in camply/notifications/telegram.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: AvailableCampsite \"\"\" for campsite in campsites : message_title , formatted_dict = self . format_standard_campsites ( campsite = campsite , ) fields = [] for key , value in formatted_dict . items (): fields . append ( self . escape_text ( f \" { key } : { value } \" )) message_fields = \" \\n \" . join ( fields ) message = f \"* { self . escape_text ( message_title ) } * \\n { message_fields } \" self . send_message ( message , escaped = True ) send_message ( message , escaped = False , ** kwargs ) # Send a message via Telegram - if environment variables are configured Parameters # message: str escaped: bool Returns # requests.Response Source code in camply/notifications/telegram.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def send_message ( self , message : str , escaped = False , ** kwargs ) -> requests . Response : \"\"\" Send a message via Telegram - if environment variables are configured Parameters ---------- message: str escaped: bool Returns ------- requests.Response \"\"\" if not escaped : message = self . escape_text ( message ) message_json = TelegramConfig . API_CONTENT . copy () message_json . update ({ \"text\" : message }) logger . debug ( message_json ) response = self . session . post ( url = TelegramConfig . API_ENDPOINT , json = message_json ) try : response . raise_for_status () except requests . HTTPError as he : logger . warning ( \"Notifications weren't able to be sent to Telegram. \" \"Your configuration might be incorrect.\" ) raise ConnectionError ( response . text ) from he return response","title":"telegram"},{"location":"reference/notifications/telegram/#camply.notifications.telegram.TelegramNotifications","text":"Bases: BaseNotifications Push Notifications via Telegram Source code in camply/notifications/telegram.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 class TelegramNotifications ( BaseNotifications ): \"\"\" Push Notifications via Telegram \"\"\" def __init__ ( self ): super () . __init__ () self . session . headers . update ( TelegramConfig . API_HEADERS ) if any ( [ TelegramConfig . BOT_TOKEN is None , TelegramConfig . BOT_TOKEN == \"\" , TelegramConfig . CHAT_ID is None , TelegramConfig . CHAT_ID == \"\" , ] ): warning_message = ( \"Telegram is not configured properly. To send Telegram messages \" \"make sure to run `camply configure` or set the \" \"proper environment variables: `TELEGRAM_BOT_TOKEN` and `TELEGRAM_CHAT_ID`.\" ) logger . error ( warning_message ) raise EnvironmentError ( warning_message ) def send_message ( self , message : str , escaped = False , ** kwargs ) -> requests . Response : \"\"\" Send a message via Telegram - if environment variables are configured Parameters ---------- message: str escaped: bool Returns ------- requests.Response \"\"\" if not escaped : message = self . escape_text ( message ) message_json = TelegramConfig . API_CONTENT . copy () message_json . update ({ \"text\" : message }) logger . debug ( message_json ) response = self . session . post ( url = TelegramConfig . API_ENDPOINT , json = message_json ) try : response . raise_for_status () except requests . HTTPError as he : logger . warning ( \"Notifications weren't able to be sent to Telegram. \" \"Your configuration might be incorrect.\" ) raise ConnectionError ( response . text ) from he return response @staticmethod def escape_text ( message : str ) -> str : \"\"\" Escape a message for use in Telegram Parameters ---------- message: str Returns ------- String \"\"\" fields = [ \"_\" , \"*\" , \"[\" , \"]\" , \"(\" , \")\" , \"~\" , \"`\" , \">\" , \"#\" , \"+\" , \"-\" , \"=\" , \"|\" , \"{\" , \"}\" , \".\" , \"!\" , ] for f in fields : message = message . replace ( f , f \" \\\\ { f } \" ) return message def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: AvailableCampsite \"\"\" for campsite in campsites : message_title , formatted_dict = self . format_standard_campsites ( campsite = campsite , ) fields = [] for key , value in formatted_dict . items (): fields . append ( self . escape_text ( f \" { key } : { value } \" )) message_fields = \" \\n \" . join ( fields ) message = f \"* { self . escape_text ( message_title ) } * \\n { message_fields } \" self . send_message ( message , escaped = True )","title":"TelegramNotifications"},{"location":"reference/notifications/telegram/#camply.notifications.telegram.TelegramNotifications.escape_text","text":"Escape a message for use in Telegram","title":"escape_text()"},{"location":"reference/notifications/telegram/#camply.notifications.telegram.TelegramNotifications.escape_text--parameters","text":"message: str","title":"Parameters"},{"location":"reference/notifications/telegram/#camply.notifications.telegram.TelegramNotifications.escape_text--returns","text":"String Source code in camply/notifications/telegram.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 @staticmethod def escape_text ( message : str ) -> str : \"\"\" Escape a message for use in Telegram Parameters ---------- message: str Returns ------- String \"\"\" fields = [ \"_\" , \"*\" , \"[\" , \"]\" , \"(\" , \")\" , \"~\" , \"`\" , \">\" , \"#\" , \"+\" , \"-\" , \"=\" , \"|\" , \"{\" , \"}\" , \".\" , \"!\" , ] for f in fields : message = message . replace ( f , f \" \\\\ { f } \" ) return message","title":"Returns"},{"location":"reference/notifications/telegram/#camply.notifications.telegram.TelegramNotifications.send_campsites","text":"Send a message with a campsite object","title":"send_campsites()"},{"location":"reference/notifications/telegram/#camply.notifications.telegram.TelegramNotifications.send_campsites--parameters","text":"campsites: AvailableCampsite Source code in camply/notifications/telegram.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: AvailableCampsite \"\"\" for campsite in campsites : message_title , formatted_dict = self . format_standard_campsites ( campsite = campsite , ) fields = [] for key , value in formatted_dict . items (): fields . append ( self . escape_text ( f \" { key } : { value } \" )) message_fields = \" \\n \" . join ( fields ) message = f \"* { self . escape_text ( message_title ) } * \\n { message_fields } \" self . send_message ( message , escaped = True )","title":"Parameters"},{"location":"reference/notifications/telegram/#camply.notifications.telegram.TelegramNotifications.send_message","text":"Send a message via Telegram - if environment variables are configured","title":"send_message()"},{"location":"reference/notifications/telegram/#camply.notifications.telegram.TelegramNotifications.send_message--parameters","text":"message: str escaped: bool","title":"Parameters"},{"location":"reference/notifications/telegram/#camply.notifications.telegram.TelegramNotifications.send_message--returns","text":"requests.Response Source code in camply/notifications/telegram.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def send_message ( self , message : str , escaped = False , ** kwargs ) -> requests . Response : \"\"\" Send a message via Telegram - if environment variables are configured Parameters ---------- message: str escaped: bool Returns ------- requests.Response \"\"\" if not escaped : message = self . escape_text ( message ) message_json = TelegramConfig . API_CONTENT . copy () message_json . update ({ \"text\" : message }) logger . debug ( message_json ) response = self . session . post ( url = TelegramConfig . API_ENDPOINT , json = message_json ) try : response . raise_for_status () except requests . HTTPError as he : logger . warning ( \"Notifications weren't able to be sent to Telegram. \" \"Your configuration might be incorrect.\" ) raise ConnectionError ( response . text ) from he return response","title":"Returns"},{"location":"reference/notifications/twilio/","text":"Push Notifications via Twilio TwilioNotifications # Bases: BaseNotifications Push Notifications via Twilio Source code in camply/notifications/twilio.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 class TwilioNotifications ( BaseNotifications ): \"\"\" Push Notifications via Twilio \"\"\" def __init__ ( self ): super () . __init__ () try : from twilio.rest import Client except ImportError : raise RuntimeError ( \"Looks like `twilio` isn't installed. Install it with `pip install camply[twilio]`\" ) if any ( [ TwilioConfig . ACCOUNT_SID is None , TwilioConfig . ACCOUNT_SID == \"\" , TwilioConfig . AUTH_TOKEN is None , TwilioConfig . AUTH_TOKEN == \"\" , ] ): warning_message = ( \"Twilio is not configured properly. To send Twilio messages \" \"make sure to run `camply configure` or set the \" \"proper environment variable: `TWILIO_ACCOUNT_SID`, `TWILIO_AUTH_TOKEN`.\" ) logger . error ( warning_message ) raise EnvironmentError ( warning_message ) self . client = Client ( TwilioConfig . ACCOUNT_SID , TwilioConfig . AUTH_TOKEN ) self . phone_nums = TwilioConfig . DEST_NUMBERS . split ( \",\" ) logger . info ( \"Twilio: will notify these phone numbers: \" + \", \" . join ( self . phone_nums ) ) def send_message ( self , message : str , ** kwargs ): \"\"\" Send a message via Twilio - if environment variables are configured Parameters ---------- message: str \"\"\" for phone_num in self . phone_nums : self . client . messages . create ( to = phone_num , from_ = TwilioConfig . SOURCE_NUMBER , body = message ) def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: AvailableCampsite \"\"\" for campsite in campsites : message_title , formatted_dict = self . format_standard_campsites ( campsite = campsite , ) fields = [ f \"\ud83c\udfd5 { message_title } \" , \"\" ] for key , value in formatted_dict . items (): fields . append ( f \" { key } : { value } \" ) fields . append ( \"\" ) fields . append ( \"camply, the campsite finder \u26fa\ufe0f\" ) composed_message = \" \\n \" . join ( fields ) self . send_message ( message = composed_message ) send_campsites ( campsites , ** kwargs ) # Send a message with a campsite object Parameters # campsites: AvailableCampsite Source code in camply/notifications/twilio.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: AvailableCampsite \"\"\" for campsite in campsites : message_title , formatted_dict = self . format_standard_campsites ( campsite = campsite , ) fields = [ f \"\ud83c\udfd5 { message_title } \" , \"\" ] for key , value in formatted_dict . items (): fields . append ( f \" { key } : { value } \" ) fields . append ( \"\" ) fields . append ( \"camply, the campsite finder \u26fa\ufe0f\" ) composed_message = \" \\n \" . join ( fields ) self . send_message ( message = composed_message ) send_message ( message , ** kwargs ) # Send a message via Twilio - if environment variables are configured Parameters # message: str Source code in camply/notifications/twilio.py 51 52 53 54 55 56 57 58 59 60 61 62 def send_message ( self , message : str , ** kwargs ): \"\"\" Send a message via Twilio - if environment variables are configured Parameters ---------- message: str \"\"\" for phone_num in self . phone_nums : self . client . messages . create ( to = phone_num , from_ = TwilioConfig . SOURCE_NUMBER , body = message )","title":"twilio"},{"location":"reference/notifications/twilio/#camply.notifications.twilio.TwilioNotifications","text":"Bases: BaseNotifications Push Notifications via Twilio Source code in camply/notifications/twilio.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 class TwilioNotifications ( BaseNotifications ): \"\"\" Push Notifications via Twilio \"\"\" def __init__ ( self ): super () . __init__ () try : from twilio.rest import Client except ImportError : raise RuntimeError ( \"Looks like `twilio` isn't installed. Install it with `pip install camply[twilio]`\" ) if any ( [ TwilioConfig . ACCOUNT_SID is None , TwilioConfig . ACCOUNT_SID == \"\" , TwilioConfig . AUTH_TOKEN is None , TwilioConfig . AUTH_TOKEN == \"\" , ] ): warning_message = ( \"Twilio is not configured properly. To send Twilio messages \" \"make sure to run `camply configure` or set the \" \"proper environment variable: `TWILIO_ACCOUNT_SID`, `TWILIO_AUTH_TOKEN`.\" ) logger . error ( warning_message ) raise EnvironmentError ( warning_message ) self . client = Client ( TwilioConfig . ACCOUNT_SID , TwilioConfig . AUTH_TOKEN ) self . phone_nums = TwilioConfig . DEST_NUMBERS . split ( \",\" ) logger . info ( \"Twilio: will notify these phone numbers: \" + \", \" . join ( self . phone_nums ) ) def send_message ( self , message : str , ** kwargs ): \"\"\" Send a message via Twilio - if environment variables are configured Parameters ---------- message: str \"\"\" for phone_num in self . phone_nums : self . client . messages . create ( to = phone_num , from_ = TwilioConfig . SOURCE_NUMBER , body = message ) def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: AvailableCampsite \"\"\" for campsite in campsites : message_title , formatted_dict = self . format_standard_campsites ( campsite = campsite , ) fields = [ f \"\ud83c\udfd5 { message_title } \" , \"\" ] for key , value in formatted_dict . items (): fields . append ( f \" { key } : { value } \" ) fields . append ( \"\" ) fields . append ( \"camply, the campsite finder \u26fa\ufe0f\" ) composed_message = \" \\n \" . join ( fields ) self . send_message ( message = composed_message )","title":"TwilioNotifications"},{"location":"reference/notifications/twilio/#camply.notifications.twilio.TwilioNotifications.send_campsites","text":"Send a message with a campsite object","title":"send_campsites()"},{"location":"reference/notifications/twilio/#camply.notifications.twilio.TwilioNotifications.send_campsites--parameters","text":"campsites: AvailableCampsite Source code in camply/notifications/twilio.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 def send_campsites ( self , campsites : List [ AvailableCampsite ], ** kwargs ): \"\"\" Send a message with a campsite object Parameters ---------- campsites: AvailableCampsite \"\"\" for campsite in campsites : message_title , formatted_dict = self . format_standard_campsites ( campsite = campsite , ) fields = [ f \"\ud83c\udfd5 { message_title } \" , \"\" ] for key , value in formatted_dict . items (): fields . append ( f \" { key } : { value } \" ) fields . append ( \"\" ) fields . append ( \"camply, the campsite finder \u26fa\ufe0f\" ) composed_message = \" \\n \" . join ( fields ) self . send_message ( message = composed_message )","title":"Parameters"},{"location":"reference/notifications/twilio/#camply.notifications.twilio.TwilioNotifications.send_message","text":"Send a message via Twilio - if environment variables are configured","title":"send_message()"},{"location":"reference/notifications/twilio/#camply.notifications.twilio.TwilioNotifications.send_message--parameters","text":"message: str Source code in camply/notifications/twilio.py 51 52 53 54 55 56 57 58 59 60 61 62 def send_message ( self , message : str , ** kwargs ): \"\"\" Send a message via Twilio - if environment variables are configured Parameters ---------- message: str \"\"\" for phone_num in self . phone_nums : self . client . messages . create ( to = phone_num , from_ = TwilioConfig . SOURCE_NUMBER , body = message )","title":"Parameters"},{"location":"reference/providers/","text":"providers init file BaseProvider # Base Provider Class This should ideally be an AbstractBaseClass Source code in camply/providers/base_provider.py 10 11 12 13 14 15 class BaseProvider : \"\"\" Base Provider Class This should ideally be an AbstractBaseClass \"\"\" RecreationDotGov # Bases: BaseProvider Python Class for Working with Recreation.gov API / NPS APIs Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 class RecreationDotGov ( BaseProvider ): \"\"\" Python Class for Working with Recreation.gov API / NPS APIs \"\"\" def __init__ ( self , api_key : str = None ): \"\"\" Initialize with Search Dates \"\"\" if api_key is None : _api_key = RIDBConfig . API_KEY if isinstance ( _api_key , bytes ): _api_key : str = b64decode ( RIDBConfig . API_KEY ) . decode ( \"utf-8\" ) else : _api_key : str = api_key self . _ridb_api_headers : dict = dict ( accept = \"application/json\" , apikey = _api_key ) def __repr__ ( self ): \"\"\" String Representation Returns ------- str \"\"\" return \"<RecreationDotGov>\" def find_recreation_areas ( self , search_string : str = None , ** kwargs ) -> List [ dict ]: \"\"\" Find Matching Campsites Based on Search String Parameters ---------- search_string: str Search Keyword(s) Returns ------- filtered_responses: List[dict] Array of Matching Campsites \"\"\" try : assert any ( [ kwargs . get ( \"state\" , None ) is not None , search_string is not None and search_string != \"\" , ] ) except AssertionError : raise RuntimeError ( \"You must provide a search query or state(s) \" \"to find Recreation Areas\" ) logger . info ( f 'Searching for Recreation Areas: \" { search_string } \"' ) state_arg = kwargs . get ( \"state\" , None ) if state_arg is not None : kwargs . update ({ \"state\" : state_arg . upper ()}) params = dict ( query = search_string , sort = \"Name\" , full = \"true\" , ** kwargs ) if search_string is None : params . pop ( \"query\" ) api_response = self . _ridb_get_paginate ( path = RIDBConfig . REC_AREA_API_PATH , params = params ) logger . info ( f \" { len ( api_response ) } recreation areas found.\" ) logging_messages = list () for recreation_area_object in api_response : _ , recreation_area = self . _process_rec_area_response ( recreation_area = recreation_area_object ) if recreation_area is not None : logging_messages . append ( recreation_area ) log_sorted_response ( response_array = logging_messages ) return api_response def find_campgrounds ( self , search_string : str = None , rec_area_id : Optional [ List [ int ]] = None , campground_id : Optional [ List [ int ]] = None , campsite_id : Optional [ List [ int ]] = None , ** kwargs , ) -> List [ CampgroundFacility ]: \"\"\" Find Bookable Campgrounds Given a Set of Search Criteria Parameters ---------- search_string: str Search Keyword(s) rec_area_id: Optional[List[int]] Recreation Area ID to filter with campground_id: Optional[List[int]] ID of the Campground campsite_id: Optional[List[int]] ID of the Campsite Returns ------- facilities: List[CampgroundFacility] Array of Matching Campsites \"\"\" if campsite_id not in ( None , [], ()): facilities = self . _process_specific_campsites_provided ( campsite_id = campsite_id ) elif campground_id not in ( None , [], ()): facilities = self . _find_facilities_from_campgrounds ( campground_id = campground_id ) elif rec_area_id not in ( None , [], ()): facilities = list () for recreation_area in rec_area_id : facilities += self . find_facilities_per_recreation_area ( rec_area_id = recreation_area ) else : state_arg = kwargs . get ( \"state\" , None ) if state_arg is not None : kwargs . update ({ \"state\" : state_arg . upper ()}) if search_string in [ \"\" , None ] and state_arg is None : raise RuntimeError ( \"You must provide a search query or state to find campsites\" ) facilities = self . _find_facilities_from_search ( search = search_string , ** kwargs ) return facilities def find_facilities_per_recreation_area ( self , rec_area_id : int = None , ** kwargs ) -> List [ CampgroundFacility ]: \"\"\" Find Matching Campsites Based from Recreation Area Parameters ---------- rec_area_id: int Recreation Area ID Returns ------- campgrounds: List[CampgroundFacility] Array of Matching Campsites \"\"\" logger . info ( f \"Retrieving Facility Information for Recreation Area ID: ` { rec_area_id } `.\" ) api_path = f \" { RIDBConfig . REC_AREA_API_PATH } / { rec_area_id } / { RIDBConfig . FACILITIES_API_PATH } \" api_response = self . _ridb_get_paginate ( path = api_path , params = dict ( full = \"true\" , ** kwargs ) ) filtered_facilities = self . _filter_facilities_responses ( responses = api_response ) campgrounds = list () logger . info ( f \" { len ( filtered_facilities ) } Matching Campgrounds Found\" ) for facility in filtered_facilities : _ , campground_facility = self . process_facilities_responses ( facility = facility ) if campground_facility is not None : campgrounds . append ( campground_facility ) log_sorted_response ( response_array = campgrounds ) return campgrounds def _find_facilities_from_campgrounds ( self , campground_id : Union [ int , List [ int ]] ) -> List [ CampgroundFacility ]: \"\"\" Find Matching Campsites from Campground ID Parameters ---------- campground_id: Union[int, List[int]] ID of the Campsite Returns ------- filtered_responses: List[CampgroundFacility] Array of Matching Campsites \"\"\" campgrounds = list () for campground_identifier in campground_id : facility_data = self . get_ridb_data ( path = f \" { RIDBConfig . FACILITIES_API_PATH } / { campground_identifier } \" , params = dict ( full = True ), ) filtered_facility = self . _filter_facilities_responses ( responses = [ facility_data ] ) _ , campground_facility = self . process_facilities_responses ( facility = filtered_facility [ 0 ] ) if campground_facility is not None : campgrounds . append ( campground_facility ) logger . info ( f \" { len ( campgrounds ) } Matching Campgrounds Found\" ) log_sorted_response ( response_array = campgrounds ) return campgrounds def _find_facilities_from_search ( self , search : str , ** kwargs ) -> List [ dict ]: \"\"\" Find Matching Campgrounds Based on Search String Parameters ---------- search: str Search String Returns ------- campgrounds: List[dict] Array of Matching Campsites \"\"\" facilities_response = self . _ridb_get_paginate ( path = RIDBConfig . FACILITIES_API_PATH , params = dict ( query = search , activity = \"CAMPING\" , full = \"true\" , ** kwargs ), ) filtered_responses = self . _filter_facilities_responses ( responses = facilities_response ) logger . info ( f \" { len ( filtered_responses ) } Matching Campgrounds Found\" ) campgrounds = list () for facility in filtered_responses : _ , campground_facility = self . process_facilities_responses ( facility = facility ) if campground_facility is not None : campgrounds . append ( campground_facility ) log_sorted_response ( response_array = campgrounds ) return campgrounds @classmethod def _ridb_get_endpoint ( cls , path : str ) -> str : \"\"\" Return an API Endpoint for the RIDP Parameters ---------- path: str URL Endpoint, see https://ridb.recreation.gov/docs Returns ------- endpoint_url: str URL for the API Endpoint \"\"\" assert RIDBConfig . RIDB_BASE_PATH . endswith ( \"/\" ) base_url = api_utils . generate_url ( scheme = RIDBConfig . RIDB_SCHEME , netloc = RIDBConfig . RIDB_NET_LOC , path = RIDBConfig . RIDB_BASE_PATH , ) endpoint_url = parse . urljoin ( base_url , path ) return endpoint_url @tenacity . retry ( wait = tenacity . wait_random_exponential ( multiplier = 2 , max = 10 ), stop = tenacity . stop . stop_after_delay ( 15 ), ) def get_ridb_data ( self , path : str , params : Optional [ dict ] = None ) -> Union [ dict , list ]: \"\"\" Find Matching Campsites Based on Search String Parameters ---------- path: str URL Endpoint, see https://ridb.recreation.gov/docs params: Optional[dict] API Call Parameters Returns ------- Union[dict, list] \"\"\" api_endpoint = self . _ridb_get_endpoint ( path = path ) headers = self . _ridb_api_headers . copy () headers . update ( choice ( USER_AGENTS )) response = requests . get ( url = api_endpoint , headers = headers , params = params , timeout = 30 ) try : assert response . status_code == 200 except AssertionError : error_message = ( f \"Receiving bad data from Recreation.gov API: { response . text } \" ) logger . error ( error_message ) raise ConnectionError ( error_message ) return loads ( response . content ) def _ridb_get_paginate ( self , path : str , params : Optional [ dict ] = None , ) -> List [ dict ]: \"\"\" Return the Paginated Response from the RIDP Parameters ---------- path: str URL Endpoint, see https://ridb.recreation.gov/docs params: Optional[dict] API Call Parameters Returns ------- paginated_response: list Concatted Response \"\"\" if params is None : params = {} paginated_response = list () data_incomplete = True offset : int = 0 historical_results = 0 while data_incomplete is True : params . update ( offset = offset ) data_response = self . get_ridb_data ( path = path , params = params ) response_object = GenericResponse ( ** data_response ) paginated_response += response_object . RECDATA result_count = response_object . METADATA . RESULTS . CURRENT_COUNT historical_results += result_count total_count = response_object . METADATA . RESULTS . TOTAL_COUNT if offset >= 500 : logger . info ( f \"Too Many Results returned ( { total_count } ), \" \"try performing a more specific search\" ) data_incomplete = False elif historical_results < total_count : offset = historical_results else : data_incomplete = False return paginated_response @classmethod def _filter_facilities_responses ( cls , responses = List [ dict ]) -> List [ dict ]: \"\"\" Filter Facilities to Actual Reservable Campsites Parameters ---------- responses Returns ------- List[dict] \"\"\" filtered_responses = list () for possible_match in responses : try : facility = FacilityResponse ( ** possible_match ) except ValidationError as e : logger . error ( \"That doesn't look like a valid Campground Facility\" ) logger . error ( json . dumps ( possible_match )) logger . exception ( e ) raise ProviderSearchError ( \"Invalid Campground Facility Returned\" ) if all ( [ facility . FacilityTypeDescription == RIDBConfig . CAMPGROUND_FACILITY_FIELD_QUALIFIER , facility . Enabled is True , facility . Reservable is True , ] ): filtered_responses . append ( possible_match ) return filtered_responses @classmethod def process_facilities_responses ( cls , facility : dict ) -> Tuple [ dict , Optional [ CampgroundFacility ]]: \"\"\" Process Facilities Responses to be More Usable Parameters ---------- facility: dict Returns ------- Tuple[dict, CampgroundFacility] \"\"\" facility_object = FacilityResponse ( ** facility ) try : facility_state = facility_object . FACILITYADDRESS [ 0 ] . AddressStateCode . upper () except ( KeyError , IndexError ): facility_state = \"USA\" try : if len ( facility_object . RECAREA ) == 0 : recreation_area_id = facility_object . ParentRecAreaID formatted_recreation_area = ( f \" { facility_object . ORGANIZATION [ 0 ] . OrgName } , { facility_state } \" ) else : recreation_area = facility_object . RECAREA [ 0 ] . RecAreaName recreation_area_id = facility_object . RECAREA [ 0 ] . RecAreaID formatted_recreation_area = f \" { recreation_area } , { facility_state } \" campground_facility = CampgroundFacility ( facility_name = facility_object . FacilityName . title (), recreation_area = formatted_recreation_area , facility_id = facility_object . FacilityID , recreation_area_id = recreation_area_id , ) return facility , campground_facility except ( KeyError , IndexError ): return facility , None @classmethod def _process_rec_area_response ( cls , recreation_area = dict ) -> Tuple [ dict , Optional [ RecreationArea ]]: \"\"\" Process Rec Area Responses to be More Usable Parameters ---------- recreation_area: dict Returns ------- Tuple[dict, RecreationArea] \"\"\" rec_area_response = RecreationAreaResponse ( ** recreation_area ) try : recreation_area_location = rec_area_response . RECAREAADDRESS [ 0 ] . AddressStateCode recreation_area_tuple = RecreationArea ( recreation_area = rec_area_response . RecAreaName , recreation_area_id = rec_area_response . RecAreaID , recreation_area_location = recreation_area_location , ) return recreation_area , recreation_area_tuple except IndexError : return recreation_area , None @classmethod def _rec_availability_get_endpoint ( cls , path : str ) -> str : \"\"\" Return an API Endpoint for the Recreation.gov Campground Availability API Parameters ---------- path: str URL Endpoint Path Returns ------- endpoint_url: str URL for the API Endpoint \"\"\" base_url = api_utils . generate_url ( scheme = RecreationBookingConfig . API_SCHEME , netloc = RecreationBookingConfig . API_NET_LOC , path = RecreationBookingConfig . API_BASE_PATH , ) endpoint_url = parse . urljoin ( base_url , path ) return endpoint_url @classmethod def make_recdotgov_request ( cls , url : str , method : str = \"GET\" , params : Optional [ Dict [ str , Any ]] = None , ** kwargs , ) -> requests . Response : \"\"\" Make a Raw Request to RecreationDotGov Parameters ---------- url: str method: str params: Optional[Dict[str, Any]] Returns ------- requests.Response \"\"\" # BUILD THE HEADERS EXPECTED FROM THE API headers = STANDARD_HEADERS . copy () headers . update ( choice ( USER_AGENTS )) headers . update ( RecreationBookingConfig . API_REFERRERS ) response = requests . request ( method = method , url = url , headers = headers , params = params , timeout = 30 , ** kwargs ) return response @classmethod @tenacity . retry ( wait = tenacity . wait_random_exponential ( multiplier = 2 , max = 10 ), stop = tenacity . stop . stop_after_delay ( 15 ), ) def make_recdotgov_request_retry ( cls , url : str , method : str = \"GET\" , params : Optional [ Dict [ str , Any ]] = None , ** kwargs , ) -> requests . Response : \"\"\" Make a Raw Request to RecreationDotGov - But Handle 404 Parameters ---------- url: str method: str params: Optional[Dict[str, Any]] Returns ------- requests.Response \"\"\" response = cls . make_recdotgov_request ( url = url , method = method , params = params , ** kwargs ) response . raise_for_status () return response def paginate_recdotgov_campsites ( self , facility_id : int , equipment : Optional [ List [ str ]] = None ) -> List [ RecDotGovCampsite ]: \"\"\" Paginate through the RecDotGov Campsite Metadata \"\"\" results = 0 continue_paginate = True endpoint_url = api_utils . generate_url ( scheme = RecreationBookingConfig . API_SCHEME , netloc = RecreationBookingConfig . API_NET_LOC , path = \"api/search/campsites\" , ) fq_list = [ f \"asset_id: { facility_id } \" ] if isinstance ( equipment , list ) and len ( equipment ) > 0 : for item in equipment : fq_list . append ( f \"campsite_equipment_name: { item } \" ) params = dict ( start = 0 , size = 1000 , fq = fq_list , include_non_site_specific_campsites = True , ) campsites = [] while continue_paginate is True : response = self . make_recdotgov_request_retry ( method = \"GET\" , url = endpoint_url , params = params , ) returned_data = json . loads ( response . content ) campsite_response = RecDotGovCampsiteResponse ( ** returned_data ) campsites += campsite_response . campsites results += campsite_response . size params . update ( start = results ) if results == campsite_response . total : continue_paginate = False return campsites @tenacity . retry ( wait = tenacity . wait_random_exponential ( multiplier = 3 , max = 1800 ), stop = tenacity . stop . stop_after_delay ( 6000 ), ) def _make_recdotgov_availability_request ( self , campground_id : int , month : datetime , ) -> requests . Response : \"\"\" Make a request to the RecreationDotGov API - Handle Exponential Backoff Parameters ---------- campground_id month Returns ------- requests.Response \"\"\" try : api_endpoint = self . _rec_availability_get_endpoint ( path = f \" { campground_id } / { RecreationBookingConfig . API_MONTH_PATH } \" ) formatted_month = month . strftime ( \"%Y-%m-01T00:00:00.000Z\" ) query_params = dict ( start_date = formatted_month ) response = self . make_recdotgov_request ( method = \"GET\" , url = api_endpoint , params = query_params , ) assert response . status_code == 200 except AssertionError : response_error = response . text error_message = \"Bad Data Returned from the RecreationDotGov API\" logger . debug ( f \" { error_message } , will continue to retry\" ) logger . debug ( f \"Error Details: { response_error } \" ) raise ConnectionError ( f \" { error_message } : { response_error } \" ) return response def get_recdotgov_data ( self , campground_id : int , month : datetime ) -> Union [ dict , list ]: \"\"\" Find Campsite Availability Data Parameters ---------- campground_id: int Campground ID from the RIDB API. Can also be pulled of URLs on Recreation.gov month: datetime datetime object, results will be filtered to month Returns ------- Union[dict, list] \"\"\" try : response = self . _make_recdotgov_availability_request ( campground_id = campground_id , month = month ) except tenacity . RetryError : raise RuntimeError ( \"Something went wrong in fetching data from the \" \"RecreationDotGov API.\" ) return loads ( response . content ) @classmethod def _items_to_unique_dicts ( cls , item : Union [ List [ Dict [ str , Any ]], pd . Series ] ) -> List [ Dict [ str , Any ]]: \"\"\" Ensure the proper items are parsed for equipment and attributes \"\"\" if isinstance ( item , pd . Series ): list_of_dicts = list ( chain . from_iterable ( item . tolist ())) unique_list_of_dicts = [ dict ( s ) for s in set ( frozenset ( d . items ()) for d in list_of_dicts ) ] return unique_list_of_dicts else : return item @classmethod def _get_equipment_and_attributes ( cls , campsite_id : int , campsite_metadata : pd . DataFrame , ) -> Tuple [ List [ Dict [ str , Any ]], List [ Dict [ str , Any ]]]: \"\"\" Index a DataFrame in a Complicated Way \"\"\" try : equipment = campsite_metadata . at [ campsite_id , \"permitted_equipment\" ] except LookupError : equipment = None try : attributes = campsite_metadata . at [ campsite_id , \"attributes\" ] except LookupError : attributes = None equipment = cls . _items_to_unique_dicts ( item = equipment ) attributes = cls . _items_to_unique_dicts ( item = attributes ) return equipment , attributes @classmethod def process_campsite_availability ( cls , availability : dict , recreation_area : str , recreation_area_id : int , facility_name : str , facility_id : int , month : datetime , campsite_metadata : pd . DataFrame , ) -> List [ Optional [ AvailableCampsite ]]: \"\"\" Parse the JSON Response and return availabilities Parameters ---------- availability: dict API Response recreation_area: str Name of Recreation Area recreation_area_id: int ID of Recreation Area facility_name: str Campground Facility Name facility_id: int Campground Facility ID month: datetime Month to Process campsite_metadata: pd.DataFrame Metadata Fetched from the Recreation.gov API about the Campsites Returns ------- total_campsite_availability: List[Optional[AvailableCampsite]] Any monthly availabilities \"\"\" total_campsite_availability : List [ Optional [ AvailableCampsite ]] = list () campsite_data = CampsiteAvailabilityResponse ( ** availability ) for campsite_id , site_related_data in campsite_data . campsites . items (): for ( matching_date , availability_status , ) in site_related_data . availabilities . items (): if ( availability_status not in RecreationBookingConfig . CAMPSITE_UNAVAILABLE_STRINGS ): booking_url = ( f \" { RecreationBookingConfig . CAMPSITE_BOOKING_URL } / { campsite_id } \" ) equipment , attributes = cls . _get_equipment_and_attributes ( campsite_id = campsite_id , campsite_metadata = campsite_metadata ) available_campsite = AvailableCampsite ( campsite_id = campsite_id , booking_date = matching_date , booking_end_date = matching_date + timedelta ( days = 1 ), booking_nights = 1 , campsite_site_name = site_related_data . site , campsite_loop_name = site_related_data . loop , campsite_type = site_related_data . campsite_type , campsite_occupancy = ( site_related_data . min_num_people , site_related_data . max_num_people , ), campsite_use_type = site_related_data . type_of_use , availability_status = availability_status , recreation_area = recreation_area , recreation_area_id = recreation_area_id , facility_name = facility_name , facility_id = facility_id , booking_url = booking_url , permitted_equipment = equipment , campsite_attributes = attributes , ) total_campsite_availability . append ( available_campsite ) logger . info ( f \" \\t { logging_utils . get_emoji ( total_campsite_availability ) } \\t \" f \" { len ( total_campsite_availability ) } total sites found in month of \" f \" { month . strftime ( '%B' ) } \" ) return total_campsite_availability def get_campsite_by_id ( self , campsite_id : int ) -> CampsiteResponse : \"\"\" Get a Campsite's Details Parameters ---------- campsite_id: int Returns ------- CampsiteResponse \"\"\" data = self . get_ridb_data ( path = f \" { RIDBConfig . CAMPSITE_API_PATH } / { campsite_id } \" ) try : response = CampsiteResponse ( ** data [ 0 ]) except IndexError : raise ProviderSearchError ( f \"Campsite with ID # { campsite_id } not found.\" ) return response def get_campground_ids_by_campsites ( self , campsite_ids : List [ int ] ) -> Tuple [ List [ int ], List [ CampsiteResponse ]]: \"\"\" Retrieve a list of FacilityIDs, and Facilities from a Campsite ID List Parameters ---------- campsite_ids: List[int] List of Campsite IDs Returns ------- Tuple[List[int], List[CampsiteResponse]] \"\"\" campground_ids = list () campgrounds = list () for campsite_id in campsite_ids : campsite = self . get_campsite_by_id ( campsite_id = campsite_id ) campgrounds . append ( campsite ) campground_ids . append ( campsite . FacilityID ) return list ( set ( campground_ids )), list ( campgrounds ) def _process_specific_campsites_provided ( self , campsite_id : List [ int ] = None ) -> List [ CampgroundFacility ]: \"\"\" Process Requests for Campgrounds into Facilities Parameters ---------- campsite_id: Optional[List[int]] Returns ------- List[CampgroundFacility] \"\"\" facility_ids , campsites = self . get_campground_ids_by_campsites ( campsite_ids = campsite_id ) facilities = list () for campsite in campsites : facility = self . _find_facilities_from_campgrounds ( campground_id = [ campsite . FacilityID ] )[ 0 ] facilities . append ( facility ) logger . info ( \"Searching Specific Campsite: \u26fa\ufe0f \" f \" { campsite . CampsiteName } (# { campsite . CampsiteID } ) - \" f \" { facility . facility_name } , { facility . recreation_area } \" ) return facilities def get_internal_campsite_metadata ( self , facility_ids : List [ int ]) -> pd . DataFrame : \"\"\" Retrieve Metadata About all of the underlying Campsites to Search \"\"\" all_campsites : List [ RecDotGovCampsite ] = [] for facility_id in facility_ids : all_campsites += self . paginate_recdotgov_campsites ( facility_id = facility_id ) all_campsite_df = pd . DataFrame ( [ item . dict () for item in all_campsites ], columns = RecDotGovCampsite . __fields__ , ) all_campsite_df . set_index ( \"campsite_id\" , inplace = True ) return all_campsite_df __init__ ( api_key = None ) # Initialize with Search Dates Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 48 49 50 51 52 53 54 55 56 57 58 def __init__ ( self , api_key : str = None ): \"\"\" Initialize with Search Dates \"\"\" if api_key is None : _api_key = RIDBConfig . API_KEY if isinstance ( _api_key , bytes ): _api_key : str = b64decode ( RIDBConfig . API_KEY ) . decode ( \"utf-8\" ) else : _api_key : str = api_key self . _ridb_api_headers : dict = dict ( accept = \"application/json\" , apikey = _api_key ) __repr__ () # String Representation Returns # str Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 60 61 62 63 64 65 66 67 68 def __repr__ ( self ): \"\"\" String Representation Returns ------- str \"\"\" return \"<RecreationDotGov>\" find_campgrounds ( search_string = None , rec_area_id = None , campground_id = None , campsite_id = None , ** kwargs ) # Find Bookable Campgrounds Given a Set of Search Criteria Parameters # str Search Keyword(s) Optional[List[int]] Recreation Area ID to filter with Optional[List[int]] ID of the Campground Optional[List[int]] ID of the Campsite Returns # List[CampgroundFacility] Array of Matching Campsites Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def find_campgrounds ( self , search_string : str = None , rec_area_id : Optional [ List [ int ]] = None , campground_id : Optional [ List [ int ]] = None , campsite_id : Optional [ List [ int ]] = None , ** kwargs , ) -> List [ CampgroundFacility ]: \"\"\" Find Bookable Campgrounds Given a Set of Search Criteria Parameters ---------- search_string: str Search Keyword(s) rec_area_id: Optional[List[int]] Recreation Area ID to filter with campground_id: Optional[List[int]] ID of the Campground campsite_id: Optional[List[int]] ID of the Campsite Returns ------- facilities: List[CampgroundFacility] Array of Matching Campsites \"\"\" if campsite_id not in ( None , [], ()): facilities = self . _process_specific_campsites_provided ( campsite_id = campsite_id ) elif campground_id not in ( None , [], ()): facilities = self . _find_facilities_from_campgrounds ( campground_id = campground_id ) elif rec_area_id not in ( None , [], ()): facilities = list () for recreation_area in rec_area_id : facilities += self . find_facilities_per_recreation_area ( rec_area_id = recreation_area ) else : state_arg = kwargs . get ( \"state\" , None ) if state_arg is not None : kwargs . update ({ \"state\" : state_arg . upper ()}) if search_string in [ \"\" , None ] and state_arg is None : raise RuntimeError ( \"You must provide a search query or state to find campsites\" ) facilities = self . _find_facilities_from_search ( search = search_string , ** kwargs ) return facilities find_facilities_per_recreation_area ( rec_area_id = None , ** kwargs ) # Find Matching Campsites Based from Recreation Area Parameters # int Recreation Area ID Returns # List[CampgroundFacility] Array of Matching Campsites Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 def find_facilities_per_recreation_area ( self , rec_area_id : int = None , ** kwargs ) -> List [ CampgroundFacility ]: \"\"\" Find Matching Campsites Based from Recreation Area Parameters ---------- rec_area_id: int Recreation Area ID Returns ------- campgrounds: List[CampgroundFacility] Array of Matching Campsites \"\"\" logger . info ( f \"Retrieving Facility Information for Recreation Area ID: ` { rec_area_id } `.\" ) api_path = f \" { RIDBConfig . REC_AREA_API_PATH } / { rec_area_id } / { RIDBConfig . FACILITIES_API_PATH } \" api_response = self . _ridb_get_paginate ( path = api_path , params = dict ( full = \"true\" , ** kwargs ) ) filtered_facilities = self . _filter_facilities_responses ( responses = api_response ) campgrounds = list () logger . info ( f \" { len ( filtered_facilities ) } Matching Campgrounds Found\" ) for facility in filtered_facilities : _ , campground_facility = self . process_facilities_responses ( facility = facility ) if campground_facility is not None : campgrounds . append ( campground_facility ) log_sorted_response ( response_array = campgrounds ) return campgrounds find_recreation_areas ( search_string = None , ** kwargs ) # Find Matching Campsites Based on Search String Parameters # str Search Keyword(s) Returns # List[dict] Array of Matching Campsites Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def find_recreation_areas ( self , search_string : str = None , ** kwargs ) -> List [ dict ]: \"\"\" Find Matching Campsites Based on Search String Parameters ---------- search_string: str Search Keyword(s) Returns ------- filtered_responses: List[dict] Array of Matching Campsites \"\"\" try : assert any ( [ kwargs . get ( \"state\" , None ) is not None , search_string is not None and search_string != \"\" , ] ) except AssertionError : raise RuntimeError ( \"You must provide a search query or state(s) \" \"to find Recreation Areas\" ) logger . info ( f 'Searching for Recreation Areas: \" { search_string } \"' ) state_arg = kwargs . get ( \"state\" , None ) if state_arg is not None : kwargs . update ({ \"state\" : state_arg . upper ()}) params = dict ( query = search_string , sort = \"Name\" , full = \"true\" , ** kwargs ) if search_string is None : params . pop ( \"query\" ) api_response = self . _ridb_get_paginate ( path = RIDBConfig . REC_AREA_API_PATH , params = params ) logger . info ( f \" { len ( api_response ) } recreation areas found.\" ) logging_messages = list () for recreation_area_object in api_response : _ , recreation_area = self . _process_rec_area_response ( recreation_area = recreation_area_object ) if recreation_area is not None : logging_messages . append ( recreation_area ) log_sorted_response ( response_array = logging_messages ) return api_response get_campground_ids_by_campsites ( campsite_ids ) # Retrieve a list of FacilityIDs, and Facilities from a Campsite ID List Parameters # List[int] List of Campsite IDs Returns # Tuple[List[int], List[CampsiteResponse]] Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 def get_campground_ids_by_campsites ( self , campsite_ids : List [ int ] ) -> Tuple [ List [ int ], List [ CampsiteResponse ]]: \"\"\" Retrieve a list of FacilityIDs, and Facilities from a Campsite ID List Parameters ---------- campsite_ids: List[int] List of Campsite IDs Returns ------- Tuple[List[int], List[CampsiteResponse]] \"\"\" campground_ids = list () campgrounds = list () for campsite_id in campsite_ids : campsite = self . get_campsite_by_id ( campsite_id = campsite_id ) campgrounds . append ( campsite ) campground_ids . append ( campsite . FacilityID ) return list ( set ( campground_ids )), list ( campgrounds ) get_campsite_by_id ( campsite_id ) # Get a Campsite's Details Parameters # campsite_id: int Returns # CampsiteResponse Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 def get_campsite_by_id ( self , campsite_id : int ) -> CampsiteResponse : \"\"\" Get a Campsite's Details Parameters ---------- campsite_id: int Returns ------- CampsiteResponse \"\"\" data = self . get_ridb_data ( path = f \" { RIDBConfig . CAMPSITE_API_PATH } / { campsite_id } \" ) try : response = CampsiteResponse ( ** data [ 0 ]) except IndexError : raise ProviderSearchError ( f \"Campsite with ID # { campsite_id } not found.\" ) return response get_internal_campsite_metadata ( facility_ids ) # Retrieve Metadata About all of the underlying Campsites to Search Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 866 867 868 869 870 871 872 873 874 875 876 877 878 def get_internal_campsite_metadata ( self , facility_ids : List [ int ]) -> pd . DataFrame : \"\"\" Retrieve Metadata About all of the underlying Campsites to Search \"\"\" all_campsites : List [ RecDotGovCampsite ] = [] for facility_id in facility_ids : all_campsites += self . paginate_recdotgov_campsites ( facility_id = facility_id ) all_campsite_df = pd . DataFrame ( [ item . dict () for item in all_campsites ], columns = RecDotGovCampsite . __fields__ , ) all_campsite_df . set_index ( \"campsite_id\" , inplace = True ) return all_campsite_df get_recdotgov_data ( campground_id , month ) # Find Campsite Availability Data Parameters # int Campground ID from the RIDB API. Can also be pulled of URLs on Recreation.gov datetime datetime object, results will be filtered to month Returns # Union[dict, list] Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 def get_recdotgov_data ( self , campground_id : int , month : datetime ) -> Union [ dict , list ]: \"\"\" Find Campsite Availability Data Parameters ---------- campground_id: int Campground ID from the RIDB API. Can also be pulled of URLs on Recreation.gov month: datetime datetime object, results will be filtered to month Returns ------- Union[dict, list] \"\"\" try : response = self . _make_recdotgov_availability_request ( campground_id = campground_id , month = month ) except tenacity . RetryError : raise RuntimeError ( \"Something went wrong in fetching data from the \" \"RecreationDotGov API.\" ) return loads ( response . content ) get_ridb_data ( path , params = None ) # Find Matching Campsites Based on Search String Parameters # str URL Endpoint, see https://ridb.recreation.gov/docs Returns # Union[dict, list] Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 @tenacity . retry ( wait = tenacity . wait_random_exponential ( multiplier = 2 , max = 10 ), stop = tenacity . stop . stop_after_delay ( 15 ), ) def get_ridb_data ( self , path : str , params : Optional [ dict ] = None ) -> Union [ dict , list ]: \"\"\" Find Matching Campsites Based on Search String Parameters ---------- path: str URL Endpoint, see https://ridb.recreation.gov/docs params: Optional[dict] API Call Parameters Returns ------- Union[dict, list] \"\"\" api_endpoint = self . _ridb_get_endpoint ( path = path ) headers = self . _ridb_api_headers . copy () headers . update ( choice ( USER_AGENTS )) response = requests . get ( url = api_endpoint , headers = headers , params = params , timeout = 30 ) try : assert response . status_code == 200 except AssertionError : error_message = ( f \"Receiving bad data from Recreation.gov API: { response . text } \" ) logger . error ( error_message ) raise ConnectionError ( error_message ) return loads ( response . content ) make_recdotgov_request ( url , method = 'GET' , params = None , ** kwargs ) classmethod # Make a Raw Request to RecreationDotGov Parameters # url: str method: str Returns # requests.Response Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 @classmethod def make_recdotgov_request ( cls , url : str , method : str = \"GET\" , params : Optional [ Dict [ str , Any ]] = None , ** kwargs , ) -> requests . Response : \"\"\" Make a Raw Request to RecreationDotGov Parameters ---------- url: str method: str params: Optional[Dict[str, Any]] Returns ------- requests.Response \"\"\" # BUILD THE HEADERS EXPECTED FROM THE API headers = STANDARD_HEADERS . copy () headers . update ( choice ( USER_AGENTS )) headers . update ( RecreationBookingConfig . API_REFERRERS ) response = requests . request ( method = method , url = url , headers = headers , params = params , timeout = 30 , ** kwargs ) return response make_recdotgov_request_retry ( url , method = 'GET' , params = None , ** kwargs ) classmethod # Make a Raw Request to RecreationDotGov - But Handle 404 Parameters # url: str method: str Returns # requests.Response Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 @classmethod @tenacity . retry ( wait = tenacity . wait_random_exponential ( multiplier = 2 , max = 10 ), stop = tenacity . stop . stop_after_delay ( 15 ), ) def make_recdotgov_request_retry ( cls , url : str , method : str = \"GET\" , params : Optional [ Dict [ str , Any ]] = None , ** kwargs , ) -> requests . Response : \"\"\" Make a Raw Request to RecreationDotGov - But Handle 404 Parameters ---------- url: str method: str params: Optional[Dict[str, Any]] Returns ------- requests.Response \"\"\" response = cls . make_recdotgov_request ( url = url , method = method , params = params , ** kwargs ) response . raise_for_status () return response paginate_recdotgov_campsites ( facility_id , equipment = None ) # Paginate through the RecDotGov Campsite Metadata Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 def paginate_recdotgov_campsites ( self , facility_id : int , equipment : Optional [ List [ str ]] = None ) -> List [ RecDotGovCampsite ]: \"\"\" Paginate through the RecDotGov Campsite Metadata \"\"\" results = 0 continue_paginate = True endpoint_url = api_utils . generate_url ( scheme = RecreationBookingConfig . API_SCHEME , netloc = RecreationBookingConfig . API_NET_LOC , path = \"api/search/campsites\" , ) fq_list = [ f \"asset_id: { facility_id } \" ] if isinstance ( equipment , list ) and len ( equipment ) > 0 : for item in equipment : fq_list . append ( f \"campsite_equipment_name: { item } \" ) params = dict ( start = 0 , size = 1000 , fq = fq_list , include_non_site_specific_campsites = True , ) campsites = [] while continue_paginate is True : response = self . make_recdotgov_request_retry ( method = \"GET\" , url = endpoint_url , params = params , ) returned_data = json . loads ( response . content ) campsite_response = RecDotGovCampsiteResponse ( ** returned_data ) campsites += campsite_response . campsites results += campsite_response . size params . update ( start = results ) if results == campsite_response . total : continue_paginate = False return campsites process_campsite_availability ( availability , recreation_area , recreation_area_id , facility_name , facility_id , month , campsite_metadata ) classmethod # Parse the JSON Response and return availabilities Parameters # dict API Response str Name of Recreation Area int ID of Recreation Area str Campground Facility Name int Campground Facility ID datetime Month to Process pd.DataFrame Metadata Fetched from the Recreation.gov API about the Campsites Returns # List[Optional[AvailableCampsite]] Any monthly availabilities Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 @classmethod def process_campsite_availability ( cls , availability : dict , recreation_area : str , recreation_area_id : int , facility_name : str , facility_id : int , month : datetime , campsite_metadata : pd . DataFrame , ) -> List [ Optional [ AvailableCampsite ]]: \"\"\" Parse the JSON Response and return availabilities Parameters ---------- availability: dict API Response recreation_area: str Name of Recreation Area recreation_area_id: int ID of Recreation Area facility_name: str Campground Facility Name facility_id: int Campground Facility ID month: datetime Month to Process campsite_metadata: pd.DataFrame Metadata Fetched from the Recreation.gov API about the Campsites Returns ------- total_campsite_availability: List[Optional[AvailableCampsite]] Any monthly availabilities \"\"\" total_campsite_availability : List [ Optional [ AvailableCampsite ]] = list () campsite_data = CampsiteAvailabilityResponse ( ** availability ) for campsite_id , site_related_data in campsite_data . campsites . items (): for ( matching_date , availability_status , ) in site_related_data . availabilities . items (): if ( availability_status not in RecreationBookingConfig . CAMPSITE_UNAVAILABLE_STRINGS ): booking_url = ( f \" { RecreationBookingConfig . CAMPSITE_BOOKING_URL } / { campsite_id } \" ) equipment , attributes = cls . _get_equipment_and_attributes ( campsite_id = campsite_id , campsite_metadata = campsite_metadata ) available_campsite = AvailableCampsite ( campsite_id = campsite_id , booking_date = matching_date , booking_end_date = matching_date + timedelta ( days = 1 ), booking_nights = 1 , campsite_site_name = site_related_data . site , campsite_loop_name = site_related_data . loop , campsite_type = site_related_data . campsite_type , campsite_occupancy = ( site_related_data . min_num_people , site_related_data . max_num_people , ), campsite_use_type = site_related_data . type_of_use , availability_status = availability_status , recreation_area = recreation_area , recreation_area_id = recreation_area_id , facility_name = facility_name , facility_id = facility_id , booking_url = booking_url , permitted_equipment = equipment , campsite_attributes = attributes , ) total_campsite_availability . append ( available_campsite ) logger . info ( f \" \\t { logging_utils . get_emoji ( total_campsite_availability ) } \\t \" f \" { len ( total_campsite_availability ) } total sites found in month of \" f \" { month . strftime ( '%B' ) } \" ) return total_campsite_availability process_facilities_responses ( facility ) classmethod # Process Facilities Responses to be More Usable Parameters # facility: dict Returns # Tuple[dict, CampgroundFacility] Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 @classmethod def process_facilities_responses ( cls , facility : dict ) -> Tuple [ dict , Optional [ CampgroundFacility ]]: \"\"\" Process Facilities Responses to be More Usable Parameters ---------- facility: dict Returns ------- Tuple[dict, CampgroundFacility] \"\"\" facility_object = FacilityResponse ( ** facility ) try : facility_state = facility_object . FACILITYADDRESS [ 0 ] . AddressStateCode . upper () except ( KeyError , IndexError ): facility_state = \"USA\" try : if len ( facility_object . RECAREA ) == 0 : recreation_area_id = facility_object . ParentRecAreaID formatted_recreation_area = ( f \" { facility_object . ORGANIZATION [ 0 ] . OrgName } , { facility_state } \" ) else : recreation_area = facility_object . RECAREA [ 0 ] . RecAreaName recreation_area_id = facility_object . RECAREA [ 0 ] . RecAreaID formatted_recreation_area = f \" { recreation_area } , { facility_state } \" campground_facility = CampgroundFacility ( facility_name = facility_object . FacilityName . title (), recreation_area = formatted_recreation_area , facility_id = facility_object . FacilityID , recreation_area_id = recreation_area_id , ) return facility , campground_facility except ( KeyError , IndexError ): return facility , None YellowstoneLodging # Bases: BaseProvider Scanner for Lodging in Yellowstone Source code in camply/providers/xanterra/yellowstone_lodging.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 class YellowstoneLodging ( BaseProvider ): \"\"\" Scanner for Lodging in Yellowstone \"\"\" def __repr__ ( self ): \"\"\" String Representation Returns ------- str \"\"\" return \"<YellowstoneLodging>\" def _get_monthly_availability ( self , month : datetime , nights : int = None ) -> dict : \"\"\" Check All Lodging in Yellowstone for Campground Data Returns ------- data_availability: dict Data Availability Dictionary \"\"\" query_dict = dict ( date = self . _ensure_current_month ( month = month ), limit = 31 , rate_code = YellowstoneConfig . RATE_CODE , ) if nights is not None : query_dict . update ( dict ( nights = nights )) api_endpoint = self . _get_api_endpoint ( url_path = YellowstoneConfig . YELLOWSTONE_LODGING_PATH , query = None ) logger . info ( f \"Searching for Yellowstone Lodging Availability: { month . strftime ( '%B, %Y' ) } \" ) all_resort_availability_data = self . make_yellowstone_request ( endpoint = api_endpoint , params = query_dict ) return all_resort_availability_data @staticmethod @tenacity . retry ( wait = tenacity . wait_random_exponential ( multiplier = 3 , max = 1800 ), stop = tenacity . stop . stop_after_delay ( 6000 ), ) def _try_retry_get_data ( endpoint : str , params : Optional [ dict ] = None ) -> dict : \"\"\" Try and Retry Fetching Data from the Yellowstone API. Unfortunately this is a required method to request the data since the Yellowstone API doesn't always return data. Parameters ---------- endpoint: str API Endpoint params Returns ------- dict \"\"\" yellowstone_headers = choice ( USER_AGENTS ) yellowstone_headers . update ( STANDARD_HEADERS ) yellowstone_headers . update ( YellowstoneConfig . API_REFERRERS ) response = requests . get ( url = endpoint , headers = yellowstone_headers , params = params , timeout = 30 ) if response . status_code == 200 and response . text . strip () != \"\" : return loads ( response . content ) else : error_message = ( \"Something went wrong with checking the \" \"Yellowstone Booking API. Will continue retrying.\" ) logger . warning ( error_message ) raise RuntimeError ( error_message ) @staticmethod def make_yellowstone_request ( endpoint : str , params : Optional [ dict ] = None ) -> dict : \"\"\" Try and Retry Fetching Data from the Yellowstone API. Unfortunately this is a required method to request the data since the Yellowstone API doesn't always return data. Parameters ---------- endpoint: str API Endpoint params Returns ------- dict \"\"\" try : content = YellowstoneLodging . _try_retry_get_data ( endpoint = endpoint , params = params ) except RuntimeError as re : raise RuntimeError ( f \"error_message: { re } \" ) return content @classmethod def _get_api_endpoint ( cls , url_path : str , query : Optional [ dict ] = None ) -> str : \"\"\" Build the API Endpoint for All Yellowstone Lodging \"\"\" if query is not None : query_string = parse . urlencode ( query = query ) else : query_string = \"\" url_components = dict ( scheme = YellowstoneConfig . API_SCHEME , netloc = YellowstoneConfig . API_BASE_ENDPOINT , url = url_path , params = \"\" , query = query_string , fragment = \"\" , ) api_endpoint = parse . urlunparse ( tuple ( url_components . values ())) return api_endpoint @classmethod def _return_lodging_url ( cls , lodging_code : str , month : datetime , params : Optional [ dict ] = \"\" ) -> str : \"\"\" Return a Browser Loadable URL to book from Parameters ---------- lodging_code: str Lodging Code from API month: datetime Month to return bookings filtered to params: Optional[dict] Optional URL Parameters Returns ------- str URL String \"\"\" query = dict ( dateFrom = month . strftime ( \"%m- %d -%Y\" ), adults = 1 , destination = lodging_code , children = 0 , ) if params is not None : query . update ( params ) query_string = parse . urlencode ( query = query ) url_components = dict ( scheme = YellowstoneConfig . API_SCHEME , netloc = YellowstoneConfig . WEBUI_BASE_ENDPOINT , url = YellowstoneConfig . WEBUI_BOOKING_PATH , params = \"\" , query = query_string , fragment = \"\" , ) webui_endpoint = parse . urlunparse ( tuple ( url_components . values ())) return webui_endpoint @classmethod def _compile_campground_availabilities ( cls , availability : XantResortData ) -> List [ dict ]: \"\"\" Gather Data about campground availabilities within a JSON Availability Objet Parameters ---------- availability: ResortData JSON Availability Object Returns ------- available_campsites: List[dict] List of Availabilities as JSON \"\"\" available_campsites = list () for booking_date , daily_data in availability . availability . items (): camping_keys = [ key for key in daily_data . keys () if YellowstoneConfig . LODGING_CAMPGROUND_QUALIFIER in key ] for hotel_code in camping_keys : hotel_data = daily_data [ hotel_code ] try : hotel_title = hotel_data . rates [ YellowstoneConfig . RATE_CODE ] . title hotel_rate_mins = hotel_data . rates [ YellowstoneConfig . RATE_CODE ] . mins if hotel_rate_mins != { 1 : 0 }: min_capacity = min ( hotel_rate_mins . keys ()) max_capacity = max ( hotel_rate_mins . keys ()) capacity = ( min_capacity , max_capacity ) campsite = dict ( campsite_id = None , booking_date = booking_date , campsite_occupancy = capacity , recreation_area = YellowstoneConfig . YELLOWSTONE_RECREATION_AREA_NAME , recreation_area_id = YellowstoneConfig . YELLOWSTONE_RECREATION_AREA_ID , facility_name = hotel_title . replace ( * YellowstoneConfig . YELLOWSTONE_CAMPGROUND_NAME_REPLACE ), facility_id = hotel_code , ) available_campsites . append ( campsite ) except KeyError : pass logger . info ( f \" \\t { logging_utils . get_emoji ( available_campsites ) } \\t \" f \" { len ( available_campsites ) } sites found.\" ) return available_campsites def _gather_campsite_specific_availability ( self , available_campsites : List [ dict ], month : datetime , nights : Optional [ int ] = None , ) -> List [ dict ]: \"\"\" Get campsite extra information Given a DataFrame of campsite availability, return updated Data with details about the actual campsites that are available (i.e Tent Size, RV Length, Etc) Parameters ---------- available_campsites: List[dict] List of Available Campsites as JSON objects month: datetime Month object Returns ------- List[dict] \"\"\" available_room_array = list () availability_df = DataFrame ( data = available_campsites ) if availability_df . empty is True : return available_room_array for facility_id , _facility_df in availability_df . groupby ( YellowstoneConfig . FACILITY_ID ): api_endpoint = self . _get_api_endpoint ( url_path = YellowstoneConfig . YELLOWSTONE_CAMPSITE_AVAILABILITY , query = None ) params = dict ( date = self . _ensure_current_month ( month = month ), limit = 31 ) if nights is not None : params . update ( dict ( nights = nights )) campsite_data = self . make_yellowstone_request ( endpoint = f \" { api_endpoint } / { facility_id } \" , params = params ) campsite_availability = campsite_data [ YellowstoneConfig . BOOKING_AVAILABILITY ] booking_dates = campsite_availability . keys () availabilities = self . _process_daily_availability ( booking_dates = booking_dates , campsite_availability = campsite_availability , facility_id = facility_id , ) available_room_array += availabilities return available_room_array @classmethod def _process_daily_availability ( cls , booking_dates : List [ str ], campsite_availability : dict , facility_id : str ) -> List [ dict ]: \"\"\" Process Monthly Availability Parameters ---------- booking_dates: List[str] List of booking dates to process campsite_availability: dict Campsite availability dict facility_id: str Identification of the Facility Returns ------- List[dict] \"\"\" daily_availabilities = list () for booking_date_str in booking_dates : daily_availability = campsite_availability [ booking_date_str ] if ( daily_availability [ YellowstoneConfig . FACILITY_STATUS ] == YellowstoneConfig . FACILITY_STATUS_QUALIFIER ): available_rooms = daily_availability [ YellowstoneConfig . FACILITY_ROOMS ] for room in available_rooms : if room [ YellowstoneConfig . FACILITY_AVAILABLE_QUALIFIER ] > 0 : daily_availabilities . append ( dict ( booking_date = booking_date_str , facility_id = facility_id , campsite_code = room [ YellowstoneConfig . FACILITY_ROOM_CODE ], available = room [ YellowstoneConfig . FACILITY_AVAILABLE_QUALIFIER ], price = room [ YellowstoneConfig . FACILITY_PRICE ], ) ) return daily_availabilities def _get_property_information ( self , available_rooms : List [ dict ]) -> List [ dict ]: \"\"\" Gather Information About All Campgrounds / Hotels within Yellowstone Parameters ---------- available_rooms: List[dict] Returns ------- List[dict] \"\"\" property_info_array = list () availability_df = DataFrame ( data = available_rooms ) if availability_df . empty is True : return property_info_array facility_identifiers = availability_df [ YellowstoneConfig . FACILITY_ID ] . unique () for facility_id in facility_identifiers : api_endpoint = self . _get_api_endpoint ( url_path = YellowstoneConfig . YELLOWSTONE_PROPERTY_INFO , query = None ) campsite_info = self . make_yellowstone_request ( endpoint = f \" { api_endpoint } / { facility_id } \" ) campsite_codes = campsite_info . keys () for campsite_code in campsite_codes : campsite_data = campsite_info [ campsite_code ] property_info_array . append ( dict ( facility_id = facility_id , campsite_code = campsite_code , campsite_title = campsite_data [ YellowstoneConfig . LODGING_TITLE ], campsite_type = campsite_data [ YellowstoneConfig . FACILITY_TYPE ] . upper (), capacity = ( campsite_data [ YellowstoneConfig . LODGING_OCCUPANCY_BASE ], campsite_data [ YellowstoneConfig . LODGING_OCCUPANCY_MAX ], ), ) ) return property_info_array def get_monthly_campsites ( self , month : datetime , nights : Optional [ int ] = None ) -> List [ AvailableCampsite ]: \"\"\" Return All Campsites Available in a Given Month Parameters ---------- month: datetime Month to Search nights: Optional[int] Search for consecutive nights Returns ------- List[AvailableCampsite] \"\"\" now = datetime . now () . date () search_date = month . replace ( day = 1 ) if month <= now : logger . info ( \"Cannot input search dates before today, adjusting search parameters.\" ) search_date = search_date . replace ( year = now . year , month = now . month , day = now . day ) availability_found = self . _get_monthly_availability ( month = search_date , nights = nights ) availability = XantResortData ( ** availability_found ) monthly_campsites = self . _compile_campground_availabilities ( availability = availability ) campsite_data = DataFrame ( monthly_campsites , columns = YellowstoneConfig . CAMPSITE_DATA_COLUMNS ) . drop_duplicates () if campsite_data . empty is True : return list () available_room_array = self . _gather_campsite_specific_availability ( available_campsites = monthly_campsites , month = month , nights = nights ) available_rooms = DataFrame ( available_room_array ) property_info = self . _get_property_information ( available_rooms = available_room_array ) properties = DataFrame ( property_info ) merged_campsites = available_rooms . merge ( properties , on = [ YellowstoneConfig . FACILITY_ID_COLUMN , YellowstoneConfig . CAMPSITE_ID_COLUMN , ], ) merged_campsites [ YellowstoneConfig . BOOKING_DATE_COLUMN ] = to_datetime ( merged_campsites [ YellowstoneConfig . BOOKING_DATE_COLUMN ] ) if nights is not None : nights_param = dict ( nights = nights ) else : nights_param = dict ( nights = 1 ) booking_nights = nights_param . get ( \"nights\" ) merged_campsites [ YellowstoneConfig . BOOKING_END_DATE_COLUMN ] = merged_campsites [ YellowstoneConfig . BOOKING_DATE_COLUMN ] + timedelta ( days = booking_nights ) merged_campsites [ YellowstoneConfig . BOOKING_NIGHTS_COLUMN ] = booking_nights final_campsites = merged_campsites . merge ( campsite_data , on = YellowstoneConfig . FACILITY_ID_COLUMN ) . sort_values ( by = YellowstoneConfig . BOOKING_DATE_COLUMN ) final_campsites [ YellowstoneConfig . BOOKING_URL_COLUMN ] = final_campsites . apply ( lambda x : self . _return_lodging_url ( lodging_code = x . facility_id , month = x . booking_date , params = nights_param ), axis = 1 , ) all_monthly_campsite_array = self . _df_to_campsites ( campsite_df = final_campsites ) return all_monthly_campsite_array @classmethod def _df_to_campsites ( cls , campsite_df : DataFrame ) -> List [ AvailableCampsite ]: \"\"\" Transform a DataFrame into an array of AvailableCampsites Parameters ---------- campsite_df: DataFrame Returns ------- List[AvailableCampsite] \"\"\" all_monthly_campsite_array = list () for _ , row in campsite_df . iterrows (): campsite = AvailableCampsite ( campsite_id = row [ YellowstoneConfig . CAMPSITE_ID_COLUMN ], booking_date = row [ YellowstoneConfig . BOOKING_DATE_COLUMN ], booking_end_date = row [ YellowstoneConfig . BOOKING_END_DATE_COLUMN ], booking_nights = row [ YellowstoneConfig . BOOKING_NIGHTS_COLUMN ], campsite_site_name = row [ YellowstoneConfig . CAMPSITE_SITE_NAME_COLUMN ], campsite_loop_name = YellowstoneConfig . YELLOWSTONE_LOOP_NAME , campsite_type = row [ YellowstoneConfig . CAMPSITE_TYPE_COLUMN ], campsite_occupancy = row [ YellowstoneConfig . CAMPSITE_OCCUPANCY_COLUMN ], campsite_use_type = row [ YellowstoneConfig . CAMPSITE_USE_TYPE_COLUMN ], availability_status = YellowstoneConfig . CAMPSITE_AVAILABILITY_STATUS , recreation_area = YellowstoneConfig . YELLOWSTONE_RECREATION_AREA_NAME , recreation_area_id = YellowstoneConfig . YELLOWSTONE_RECREATION_AREA_ID , facility_name = row [ YellowstoneConfig . FACILITY_NAME_COLUMN ], facility_id = row [ YellowstoneConfig . FACILITY_ID_COLUMN ], booking_url = row [ YellowstoneConfig . BOOKING_URL_COLUMN ], ) all_monthly_campsite_array . append ( campsite ) return all_monthly_campsite_array @classmethod def _ensure_current_month ( cls , month : datetime ) -> datetime : \"\"\" Ensure That We Never Give the Yellowstone API Dates in the past. Parameters ---------- month: datetime Returns ------- datetime \"\"\" yellowstone_timezone = timezone ( YellowstoneConfig . YELLOWSTONE_TIMEZONE ) yellowstone_current_time = datetime . now ( yellowstone_timezone ) . date () today = datetime ( year = yellowstone_current_time . year , month = yellowstone_current_time . month , day = yellowstone_current_time . day , ) . date () if today > month : month = today return month __repr__ () # String Representation Returns # str Source code in camply/providers/xanterra/yellowstone_lodging.py 31 32 33 34 35 36 37 38 39 def __repr__ ( self ): \"\"\" String Representation Returns ------- str \"\"\" return \"<YellowstoneLodging>\" get_monthly_campsites ( month , nights = None ) # Return All Campsites Available in a Given Month Parameters # datetime Month to Search Optional[int] Search for consecutive nights Returns # List[AvailableCampsite] Source code in camply/providers/xanterra/yellowstone_lodging.py 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 def get_monthly_campsites ( self , month : datetime , nights : Optional [ int ] = None ) -> List [ AvailableCampsite ]: \"\"\" Return All Campsites Available in a Given Month Parameters ---------- month: datetime Month to Search nights: Optional[int] Search for consecutive nights Returns ------- List[AvailableCampsite] \"\"\" now = datetime . now () . date () search_date = month . replace ( day = 1 ) if month <= now : logger . info ( \"Cannot input search dates before today, adjusting search parameters.\" ) search_date = search_date . replace ( year = now . year , month = now . month , day = now . day ) availability_found = self . _get_monthly_availability ( month = search_date , nights = nights ) availability = XantResortData ( ** availability_found ) monthly_campsites = self . _compile_campground_availabilities ( availability = availability ) campsite_data = DataFrame ( monthly_campsites , columns = YellowstoneConfig . CAMPSITE_DATA_COLUMNS ) . drop_duplicates () if campsite_data . empty is True : return list () available_room_array = self . _gather_campsite_specific_availability ( available_campsites = monthly_campsites , month = month , nights = nights ) available_rooms = DataFrame ( available_room_array ) property_info = self . _get_property_information ( available_rooms = available_room_array ) properties = DataFrame ( property_info ) merged_campsites = available_rooms . merge ( properties , on = [ YellowstoneConfig . FACILITY_ID_COLUMN , YellowstoneConfig . CAMPSITE_ID_COLUMN , ], ) merged_campsites [ YellowstoneConfig . BOOKING_DATE_COLUMN ] = to_datetime ( merged_campsites [ YellowstoneConfig . BOOKING_DATE_COLUMN ] ) if nights is not None : nights_param = dict ( nights = nights ) else : nights_param = dict ( nights = 1 ) booking_nights = nights_param . get ( \"nights\" ) merged_campsites [ YellowstoneConfig . BOOKING_END_DATE_COLUMN ] = merged_campsites [ YellowstoneConfig . BOOKING_DATE_COLUMN ] + timedelta ( days = booking_nights ) merged_campsites [ YellowstoneConfig . BOOKING_NIGHTS_COLUMN ] = booking_nights final_campsites = merged_campsites . merge ( campsite_data , on = YellowstoneConfig . FACILITY_ID_COLUMN ) . sort_values ( by = YellowstoneConfig . BOOKING_DATE_COLUMN ) final_campsites [ YellowstoneConfig . BOOKING_URL_COLUMN ] = final_campsites . apply ( lambda x : self . _return_lodging_url ( lodging_code = x . facility_id , month = x . booking_date , params = nights_param ), axis = 1 , ) all_monthly_campsite_array = self . _df_to_campsites ( campsite_df = final_campsites ) return all_monthly_campsite_array make_yellowstone_request ( endpoint , params = None ) staticmethod # Try and Retry Fetching Data from the Yellowstone API. Unfortunately this is a required method to request the data since the Yellowstone API doesn't always return data. Parameters # str API Endpoint params Returns # dict Source code in camply/providers/xanterra/yellowstone_lodging.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 @staticmethod def make_yellowstone_request ( endpoint : str , params : Optional [ dict ] = None ) -> dict : \"\"\" Try and Retry Fetching Data from the Yellowstone API. Unfortunately this is a required method to request the data since the Yellowstone API doesn't always return data. Parameters ---------- endpoint: str API Endpoint params Returns ------- dict \"\"\" try : content = YellowstoneLodging . _try_retry_get_data ( endpoint = endpoint , params = params ) except RuntimeError as re : raise RuntimeError ( f \"error_message: { re } \" ) return content","title":"providers"},{"location":"reference/providers/#camply.providers.BaseProvider","text":"Base Provider Class This should ideally be an AbstractBaseClass Source code in camply/providers/base_provider.py 10 11 12 13 14 15 class BaseProvider : \"\"\" Base Provider Class This should ideally be an AbstractBaseClass \"\"\"","title":"BaseProvider"},{"location":"reference/providers/#camply.providers.RecreationDotGov","text":"Bases: BaseProvider Python Class for Working with Recreation.gov API / NPS APIs Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 class RecreationDotGov ( BaseProvider ): \"\"\" Python Class for Working with Recreation.gov API / NPS APIs \"\"\" def __init__ ( self , api_key : str = None ): \"\"\" Initialize with Search Dates \"\"\" if api_key is None : _api_key = RIDBConfig . API_KEY if isinstance ( _api_key , bytes ): _api_key : str = b64decode ( RIDBConfig . API_KEY ) . decode ( \"utf-8\" ) else : _api_key : str = api_key self . _ridb_api_headers : dict = dict ( accept = \"application/json\" , apikey = _api_key ) def __repr__ ( self ): \"\"\" String Representation Returns ------- str \"\"\" return \"<RecreationDotGov>\" def find_recreation_areas ( self , search_string : str = None , ** kwargs ) -> List [ dict ]: \"\"\" Find Matching Campsites Based on Search String Parameters ---------- search_string: str Search Keyword(s) Returns ------- filtered_responses: List[dict] Array of Matching Campsites \"\"\" try : assert any ( [ kwargs . get ( \"state\" , None ) is not None , search_string is not None and search_string != \"\" , ] ) except AssertionError : raise RuntimeError ( \"You must provide a search query or state(s) \" \"to find Recreation Areas\" ) logger . info ( f 'Searching for Recreation Areas: \" { search_string } \"' ) state_arg = kwargs . get ( \"state\" , None ) if state_arg is not None : kwargs . update ({ \"state\" : state_arg . upper ()}) params = dict ( query = search_string , sort = \"Name\" , full = \"true\" , ** kwargs ) if search_string is None : params . pop ( \"query\" ) api_response = self . _ridb_get_paginate ( path = RIDBConfig . REC_AREA_API_PATH , params = params ) logger . info ( f \" { len ( api_response ) } recreation areas found.\" ) logging_messages = list () for recreation_area_object in api_response : _ , recreation_area = self . _process_rec_area_response ( recreation_area = recreation_area_object ) if recreation_area is not None : logging_messages . append ( recreation_area ) log_sorted_response ( response_array = logging_messages ) return api_response def find_campgrounds ( self , search_string : str = None , rec_area_id : Optional [ List [ int ]] = None , campground_id : Optional [ List [ int ]] = None , campsite_id : Optional [ List [ int ]] = None , ** kwargs , ) -> List [ CampgroundFacility ]: \"\"\" Find Bookable Campgrounds Given a Set of Search Criteria Parameters ---------- search_string: str Search Keyword(s) rec_area_id: Optional[List[int]] Recreation Area ID to filter with campground_id: Optional[List[int]] ID of the Campground campsite_id: Optional[List[int]] ID of the Campsite Returns ------- facilities: List[CampgroundFacility] Array of Matching Campsites \"\"\" if campsite_id not in ( None , [], ()): facilities = self . _process_specific_campsites_provided ( campsite_id = campsite_id ) elif campground_id not in ( None , [], ()): facilities = self . _find_facilities_from_campgrounds ( campground_id = campground_id ) elif rec_area_id not in ( None , [], ()): facilities = list () for recreation_area in rec_area_id : facilities += self . find_facilities_per_recreation_area ( rec_area_id = recreation_area ) else : state_arg = kwargs . get ( \"state\" , None ) if state_arg is not None : kwargs . update ({ \"state\" : state_arg . upper ()}) if search_string in [ \"\" , None ] and state_arg is None : raise RuntimeError ( \"You must provide a search query or state to find campsites\" ) facilities = self . _find_facilities_from_search ( search = search_string , ** kwargs ) return facilities def find_facilities_per_recreation_area ( self , rec_area_id : int = None , ** kwargs ) -> List [ CampgroundFacility ]: \"\"\" Find Matching Campsites Based from Recreation Area Parameters ---------- rec_area_id: int Recreation Area ID Returns ------- campgrounds: List[CampgroundFacility] Array of Matching Campsites \"\"\" logger . info ( f \"Retrieving Facility Information for Recreation Area ID: ` { rec_area_id } `.\" ) api_path = f \" { RIDBConfig . REC_AREA_API_PATH } / { rec_area_id } / { RIDBConfig . FACILITIES_API_PATH } \" api_response = self . _ridb_get_paginate ( path = api_path , params = dict ( full = \"true\" , ** kwargs ) ) filtered_facilities = self . _filter_facilities_responses ( responses = api_response ) campgrounds = list () logger . info ( f \" { len ( filtered_facilities ) } Matching Campgrounds Found\" ) for facility in filtered_facilities : _ , campground_facility = self . process_facilities_responses ( facility = facility ) if campground_facility is not None : campgrounds . append ( campground_facility ) log_sorted_response ( response_array = campgrounds ) return campgrounds def _find_facilities_from_campgrounds ( self , campground_id : Union [ int , List [ int ]] ) -> List [ CampgroundFacility ]: \"\"\" Find Matching Campsites from Campground ID Parameters ---------- campground_id: Union[int, List[int]] ID of the Campsite Returns ------- filtered_responses: List[CampgroundFacility] Array of Matching Campsites \"\"\" campgrounds = list () for campground_identifier in campground_id : facility_data = self . get_ridb_data ( path = f \" { RIDBConfig . FACILITIES_API_PATH } / { campground_identifier } \" , params = dict ( full = True ), ) filtered_facility = self . _filter_facilities_responses ( responses = [ facility_data ] ) _ , campground_facility = self . process_facilities_responses ( facility = filtered_facility [ 0 ] ) if campground_facility is not None : campgrounds . append ( campground_facility ) logger . info ( f \" { len ( campgrounds ) } Matching Campgrounds Found\" ) log_sorted_response ( response_array = campgrounds ) return campgrounds def _find_facilities_from_search ( self , search : str , ** kwargs ) -> List [ dict ]: \"\"\" Find Matching Campgrounds Based on Search String Parameters ---------- search: str Search String Returns ------- campgrounds: List[dict] Array of Matching Campsites \"\"\" facilities_response = self . _ridb_get_paginate ( path = RIDBConfig . FACILITIES_API_PATH , params = dict ( query = search , activity = \"CAMPING\" , full = \"true\" , ** kwargs ), ) filtered_responses = self . _filter_facilities_responses ( responses = facilities_response ) logger . info ( f \" { len ( filtered_responses ) } Matching Campgrounds Found\" ) campgrounds = list () for facility in filtered_responses : _ , campground_facility = self . process_facilities_responses ( facility = facility ) if campground_facility is not None : campgrounds . append ( campground_facility ) log_sorted_response ( response_array = campgrounds ) return campgrounds @classmethod def _ridb_get_endpoint ( cls , path : str ) -> str : \"\"\" Return an API Endpoint for the RIDP Parameters ---------- path: str URL Endpoint, see https://ridb.recreation.gov/docs Returns ------- endpoint_url: str URL for the API Endpoint \"\"\" assert RIDBConfig . RIDB_BASE_PATH . endswith ( \"/\" ) base_url = api_utils . generate_url ( scheme = RIDBConfig . RIDB_SCHEME , netloc = RIDBConfig . RIDB_NET_LOC , path = RIDBConfig . RIDB_BASE_PATH , ) endpoint_url = parse . urljoin ( base_url , path ) return endpoint_url @tenacity . retry ( wait = tenacity . wait_random_exponential ( multiplier = 2 , max = 10 ), stop = tenacity . stop . stop_after_delay ( 15 ), ) def get_ridb_data ( self , path : str , params : Optional [ dict ] = None ) -> Union [ dict , list ]: \"\"\" Find Matching Campsites Based on Search String Parameters ---------- path: str URL Endpoint, see https://ridb.recreation.gov/docs params: Optional[dict] API Call Parameters Returns ------- Union[dict, list] \"\"\" api_endpoint = self . _ridb_get_endpoint ( path = path ) headers = self . _ridb_api_headers . copy () headers . update ( choice ( USER_AGENTS )) response = requests . get ( url = api_endpoint , headers = headers , params = params , timeout = 30 ) try : assert response . status_code == 200 except AssertionError : error_message = ( f \"Receiving bad data from Recreation.gov API: { response . text } \" ) logger . error ( error_message ) raise ConnectionError ( error_message ) return loads ( response . content ) def _ridb_get_paginate ( self , path : str , params : Optional [ dict ] = None , ) -> List [ dict ]: \"\"\" Return the Paginated Response from the RIDP Parameters ---------- path: str URL Endpoint, see https://ridb.recreation.gov/docs params: Optional[dict] API Call Parameters Returns ------- paginated_response: list Concatted Response \"\"\" if params is None : params = {} paginated_response = list () data_incomplete = True offset : int = 0 historical_results = 0 while data_incomplete is True : params . update ( offset = offset ) data_response = self . get_ridb_data ( path = path , params = params ) response_object = GenericResponse ( ** data_response ) paginated_response += response_object . RECDATA result_count = response_object . METADATA . RESULTS . CURRENT_COUNT historical_results += result_count total_count = response_object . METADATA . RESULTS . TOTAL_COUNT if offset >= 500 : logger . info ( f \"Too Many Results returned ( { total_count } ), \" \"try performing a more specific search\" ) data_incomplete = False elif historical_results < total_count : offset = historical_results else : data_incomplete = False return paginated_response @classmethod def _filter_facilities_responses ( cls , responses = List [ dict ]) -> List [ dict ]: \"\"\" Filter Facilities to Actual Reservable Campsites Parameters ---------- responses Returns ------- List[dict] \"\"\" filtered_responses = list () for possible_match in responses : try : facility = FacilityResponse ( ** possible_match ) except ValidationError as e : logger . error ( \"That doesn't look like a valid Campground Facility\" ) logger . error ( json . dumps ( possible_match )) logger . exception ( e ) raise ProviderSearchError ( \"Invalid Campground Facility Returned\" ) if all ( [ facility . FacilityTypeDescription == RIDBConfig . CAMPGROUND_FACILITY_FIELD_QUALIFIER , facility . Enabled is True , facility . Reservable is True , ] ): filtered_responses . append ( possible_match ) return filtered_responses @classmethod def process_facilities_responses ( cls , facility : dict ) -> Tuple [ dict , Optional [ CampgroundFacility ]]: \"\"\" Process Facilities Responses to be More Usable Parameters ---------- facility: dict Returns ------- Tuple[dict, CampgroundFacility] \"\"\" facility_object = FacilityResponse ( ** facility ) try : facility_state = facility_object . FACILITYADDRESS [ 0 ] . AddressStateCode . upper () except ( KeyError , IndexError ): facility_state = \"USA\" try : if len ( facility_object . RECAREA ) == 0 : recreation_area_id = facility_object . ParentRecAreaID formatted_recreation_area = ( f \" { facility_object . ORGANIZATION [ 0 ] . OrgName } , { facility_state } \" ) else : recreation_area = facility_object . RECAREA [ 0 ] . RecAreaName recreation_area_id = facility_object . RECAREA [ 0 ] . RecAreaID formatted_recreation_area = f \" { recreation_area } , { facility_state } \" campground_facility = CampgroundFacility ( facility_name = facility_object . FacilityName . title (), recreation_area = formatted_recreation_area , facility_id = facility_object . FacilityID , recreation_area_id = recreation_area_id , ) return facility , campground_facility except ( KeyError , IndexError ): return facility , None @classmethod def _process_rec_area_response ( cls , recreation_area = dict ) -> Tuple [ dict , Optional [ RecreationArea ]]: \"\"\" Process Rec Area Responses to be More Usable Parameters ---------- recreation_area: dict Returns ------- Tuple[dict, RecreationArea] \"\"\" rec_area_response = RecreationAreaResponse ( ** recreation_area ) try : recreation_area_location = rec_area_response . RECAREAADDRESS [ 0 ] . AddressStateCode recreation_area_tuple = RecreationArea ( recreation_area = rec_area_response . RecAreaName , recreation_area_id = rec_area_response . RecAreaID , recreation_area_location = recreation_area_location , ) return recreation_area , recreation_area_tuple except IndexError : return recreation_area , None @classmethod def _rec_availability_get_endpoint ( cls , path : str ) -> str : \"\"\" Return an API Endpoint for the Recreation.gov Campground Availability API Parameters ---------- path: str URL Endpoint Path Returns ------- endpoint_url: str URL for the API Endpoint \"\"\" base_url = api_utils . generate_url ( scheme = RecreationBookingConfig . API_SCHEME , netloc = RecreationBookingConfig . API_NET_LOC , path = RecreationBookingConfig . API_BASE_PATH , ) endpoint_url = parse . urljoin ( base_url , path ) return endpoint_url @classmethod def make_recdotgov_request ( cls , url : str , method : str = \"GET\" , params : Optional [ Dict [ str , Any ]] = None , ** kwargs , ) -> requests . Response : \"\"\" Make a Raw Request to RecreationDotGov Parameters ---------- url: str method: str params: Optional[Dict[str, Any]] Returns ------- requests.Response \"\"\" # BUILD THE HEADERS EXPECTED FROM THE API headers = STANDARD_HEADERS . copy () headers . update ( choice ( USER_AGENTS )) headers . update ( RecreationBookingConfig . API_REFERRERS ) response = requests . request ( method = method , url = url , headers = headers , params = params , timeout = 30 , ** kwargs ) return response @classmethod @tenacity . retry ( wait = tenacity . wait_random_exponential ( multiplier = 2 , max = 10 ), stop = tenacity . stop . stop_after_delay ( 15 ), ) def make_recdotgov_request_retry ( cls , url : str , method : str = \"GET\" , params : Optional [ Dict [ str , Any ]] = None , ** kwargs , ) -> requests . Response : \"\"\" Make a Raw Request to RecreationDotGov - But Handle 404 Parameters ---------- url: str method: str params: Optional[Dict[str, Any]] Returns ------- requests.Response \"\"\" response = cls . make_recdotgov_request ( url = url , method = method , params = params , ** kwargs ) response . raise_for_status () return response def paginate_recdotgov_campsites ( self , facility_id : int , equipment : Optional [ List [ str ]] = None ) -> List [ RecDotGovCampsite ]: \"\"\" Paginate through the RecDotGov Campsite Metadata \"\"\" results = 0 continue_paginate = True endpoint_url = api_utils . generate_url ( scheme = RecreationBookingConfig . API_SCHEME , netloc = RecreationBookingConfig . API_NET_LOC , path = \"api/search/campsites\" , ) fq_list = [ f \"asset_id: { facility_id } \" ] if isinstance ( equipment , list ) and len ( equipment ) > 0 : for item in equipment : fq_list . append ( f \"campsite_equipment_name: { item } \" ) params = dict ( start = 0 , size = 1000 , fq = fq_list , include_non_site_specific_campsites = True , ) campsites = [] while continue_paginate is True : response = self . make_recdotgov_request_retry ( method = \"GET\" , url = endpoint_url , params = params , ) returned_data = json . loads ( response . content ) campsite_response = RecDotGovCampsiteResponse ( ** returned_data ) campsites += campsite_response . campsites results += campsite_response . size params . update ( start = results ) if results == campsite_response . total : continue_paginate = False return campsites @tenacity . retry ( wait = tenacity . wait_random_exponential ( multiplier = 3 , max = 1800 ), stop = tenacity . stop . stop_after_delay ( 6000 ), ) def _make_recdotgov_availability_request ( self , campground_id : int , month : datetime , ) -> requests . Response : \"\"\" Make a request to the RecreationDotGov API - Handle Exponential Backoff Parameters ---------- campground_id month Returns ------- requests.Response \"\"\" try : api_endpoint = self . _rec_availability_get_endpoint ( path = f \" { campground_id } / { RecreationBookingConfig . API_MONTH_PATH } \" ) formatted_month = month . strftime ( \"%Y-%m-01T00:00:00.000Z\" ) query_params = dict ( start_date = formatted_month ) response = self . make_recdotgov_request ( method = \"GET\" , url = api_endpoint , params = query_params , ) assert response . status_code == 200 except AssertionError : response_error = response . text error_message = \"Bad Data Returned from the RecreationDotGov API\" logger . debug ( f \" { error_message } , will continue to retry\" ) logger . debug ( f \"Error Details: { response_error } \" ) raise ConnectionError ( f \" { error_message } : { response_error } \" ) return response def get_recdotgov_data ( self , campground_id : int , month : datetime ) -> Union [ dict , list ]: \"\"\" Find Campsite Availability Data Parameters ---------- campground_id: int Campground ID from the RIDB API. Can also be pulled of URLs on Recreation.gov month: datetime datetime object, results will be filtered to month Returns ------- Union[dict, list] \"\"\" try : response = self . _make_recdotgov_availability_request ( campground_id = campground_id , month = month ) except tenacity . RetryError : raise RuntimeError ( \"Something went wrong in fetching data from the \" \"RecreationDotGov API.\" ) return loads ( response . content ) @classmethod def _items_to_unique_dicts ( cls , item : Union [ List [ Dict [ str , Any ]], pd . Series ] ) -> List [ Dict [ str , Any ]]: \"\"\" Ensure the proper items are parsed for equipment and attributes \"\"\" if isinstance ( item , pd . Series ): list_of_dicts = list ( chain . from_iterable ( item . tolist ())) unique_list_of_dicts = [ dict ( s ) for s in set ( frozenset ( d . items ()) for d in list_of_dicts ) ] return unique_list_of_dicts else : return item @classmethod def _get_equipment_and_attributes ( cls , campsite_id : int , campsite_metadata : pd . DataFrame , ) -> Tuple [ List [ Dict [ str , Any ]], List [ Dict [ str , Any ]]]: \"\"\" Index a DataFrame in a Complicated Way \"\"\" try : equipment = campsite_metadata . at [ campsite_id , \"permitted_equipment\" ] except LookupError : equipment = None try : attributes = campsite_metadata . at [ campsite_id , \"attributes\" ] except LookupError : attributes = None equipment = cls . _items_to_unique_dicts ( item = equipment ) attributes = cls . _items_to_unique_dicts ( item = attributes ) return equipment , attributes @classmethod def process_campsite_availability ( cls , availability : dict , recreation_area : str , recreation_area_id : int , facility_name : str , facility_id : int , month : datetime , campsite_metadata : pd . DataFrame , ) -> List [ Optional [ AvailableCampsite ]]: \"\"\" Parse the JSON Response and return availabilities Parameters ---------- availability: dict API Response recreation_area: str Name of Recreation Area recreation_area_id: int ID of Recreation Area facility_name: str Campground Facility Name facility_id: int Campground Facility ID month: datetime Month to Process campsite_metadata: pd.DataFrame Metadata Fetched from the Recreation.gov API about the Campsites Returns ------- total_campsite_availability: List[Optional[AvailableCampsite]] Any monthly availabilities \"\"\" total_campsite_availability : List [ Optional [ AvailableCampsite ]] = list () campsite_data = CampsiteAvailabilityResponse ( ** availability ) for campsite_id , site_related_data in campsite_data . campsites . items (): for ( matching_date , availability_status , ) in site_related_data . availabilities . items (): if ( availability_status not in RecreationBookingConfig . CAMPSITE_UNAVAILABLE_STRINGS ): booking_url = ( f \" { RecreationBookingConfig . CAMPSITE_BOOKING_URL } / { campsite_id } \" ) equipment , attributes = cls . _get_equipment_and_attributes ( campsite_id = campsite_id , campsite_metadata = campsite_metadata ) available_campsite = AvailableCampsite ( campsite_id = campsite_id , booking_date = matching_date , booking_end_date = matching_date + timedelta ( days = 1 ), booking_nights = 1 , campsite_site_name = site_related_data . site , campsite_loop_name = site_related_data . loop , campsite_type = site_related_data . campsite_type , campsite_occupancy = ( site_related_data . min_num_people , site_related_data . max_num_people , ), campsite_use_type = site_related_data . type_of_use , availability_status = availability_status , recreation_area = recreation_area , recreation_area_id = recreation_area_id , facility_name = facility_name , facility_id = facility_id , booking_url = booking_url , permitted_equipment = equipment , campsite_attributes = attributes , ) total_campsite_availability . append ( available_campsite ) logger . info ( f \" \\t { logging_utils . get_emoji ( total_campsite_availability ) } \\t \" f \" { len ( total_campsite_availability ) } total sites found in month of \" f \" { month . strftime ( '%B' ) } \" ) return total_campsite_availability def get_campsite_by_id ( self , campsite_id : int ) -> CampsiteResponse : \"\"\" Get a Campsite's Details Parameters ---------- campsite_id: int Returns ------- CampsiteResponse \"\"\" data = self . get_ridb_data ( path = f \" { RIDBConfig . CAMPSITE_API_PATH } / { campsite_id } \" ) try : response = CampsiteResponse ( ** data [ 0 ]) except IndexError : raise ProviderSearchError ( f \"Campsite with ID # { campsite_id } not found.\" ) return response def get_campground_ids_by_campsites ( self , campsite_ids : List [ int ] ) -> Tuple [ List [ int ], List [ CampsiteResponse ]]: \"\"\" Retrieve a list of FacilityIDs, and Facilities from a Campsite ID List Parameters ---------- campsite_ids: List[int] List of Campsite IDs Returns ------- Tuple[List[int], List[CampsiteResponse]] \"\"\" campground_ids = list () campgrounds = list () for campsite_id in campsite_ids : campsite = self . get_campsite_by_id ( campsite_id = campsite_id ) campgrounds . append ( campsite ) campground_ids . append ( campsite . FacilityID ) return list ( set ( campground_ids )), list ( campgrounds ) def _process_specific_campsites_provided ( self , campsite_id : List [ int ] = None ) -> List [ CampgroundFacility ]: \"\"\" Process Requests for Campgrounds into Facilities Parameters ---------- campsite_id: Optional[List[int]] Returns ------- List[CampgroundFacility] \"\"\" facility_ids , campsites = self . get_campground_ids_by_campsites ( campsite_ids = campsite_id ) facilities = list () for campsite in campsites : facility = self . _find_facilities_from_campgrounds ( campground_id = [ campsite . FacilityID ] )[ 0 ] facilities . append ( facility ) logger . info ( \"Searching Specific Campsite: \u26fa\ufe0f \" f \" { campsite . CampsiteName } (# { campsite . CampsiteID } ) - \" f \" { facility . facility_name } , { facility . recreation_area } \" ) return facilities def get_internal_campsite_metadata ( self , facility_ids : List [ int ]) -> pd . DataFrame : \"\"\" Retrieve Metadata About all of the underlying Campsites to Search \"\"\" all_campsites : List [ RecDotGovCampsite ] = [] for facility_id in facility_ids : all_campsites += self . paginate_recdotgov_campsites ( facility_id = facility_id ) all_campsite_df = pd . DataFrame ( [ item . dict () for item in all_campsites ], columns = RecDotGovCampsite . __fields__ , ) all_campsite_df . set_index ( \"campsite_id\" , inplace = True ) return all_campsite_df","title":"RecreationDotGov"},{"location":"reference/providers/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.__init__","text":"Initialize with Search Dates Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 48 49 50 51 52 53 54 55 56 57 58 def __init__ ( self , api_key : str = None ): \"\"\" Initialize with Search Dates \"\"\" if api_key is None : _api_key = RIDBConfig . API_KEY if isinstance ( _api_key , bytes ): _api_key : str = b64decode ( RIDBConfig . API_KEY ) . decode ( \"utf-8\" ) else : _api_key : str = api_key self . _ridb_api_headers : dict = dict ( accept = \"application/json\" , apikey = _api_key )","title":"__init__()"},{"location":"reference/providers/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.__repr__","text":"String Representation","title":"__repr__()"},{"location":"reference/providers/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.__repr__--returns","text":"str Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 60 61 62 63 64 65 66 67 68 def __repr__ ( self ): \"\"\" String Representation Returns ------- str \"\"\" return \"<RecreationDotGov>\"","title":"Returns"},{"location":"reference/providers/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.find_campgrounds","text":"Find Bookable Campgrounds Given a Set of Search Criteria","title":"find_campgrounds()"},{"location":"reference/providers/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.find_campgrounds--parameters","text":"str Search Keyword(s) Optional[List[int]] Recreation Area ID to filter with Optional[List[int]] ID of the Campground Optional[List[int]] ID of the Campsite","title":"Parameters"},{"location":"reference/providers/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.find_campgrounds--returns","text":"List[CampgroundFacility] Array of Matching Campsites Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def find_campgrounds ( self , search_string : str = None , rec_area_id : Optional [ List [ int ]] = None , campground_id : Optional [ List [ int ]] = None , campsite_id : Optional [ List [ int ]] = None , ** kwargs , ) -> List [ CampgroundFacility ]: \"\"\" Find Bookable Campgrounds Given a Set of Search Criteria Parameters ---------- search_string: str Search Keyword(s) rec_area_id: Optional[List[int]] Recreation Area ID to filter with campground_id: Optional[List[int]] ID of the Campground campsite_id: Optional[List[int]] ID of the Campsite Returns ------- facilities: List[CampgroundFacility] Array of Matching Campsites \"\"\" if campsite_id not in ( None , [], ()): facilities = self . _process_specific_campsites_provided ( campsite_id = campsite_id ) elif campground_id not in ( None , [], ()): facilities = self . _find_facilities_from_campgrounds ( campground_id = campground_id ) elif rec_area_id not in ( None , [], ()): facilities = list () for recreation_area in rec_area_id : facilities += self . find_facilities_per_recreation_area ( rec_area_id = recreation_area ) else : state_arg = kwargs . get ( \"state\" , None ) if state_arg is not None : kwargs . update ({ \"state\" : state_arg . upper ()}) if search_string in [ \"\" , None ] and state_arg is None : raise RuntimeError ( \"You must provide a search query or state to find campsites\" ) facilities = self . _find_facilities_from_search ( search = search_string , ** kwargs ) return facilities","title":"Returns"},{"location":"reference/providers/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.find_facilities_per_recreation_area","text":"Find Matching Campsites Based from Recreation Area","title":"find_facilities_per_recreation_area()"},{"location":"reference/providers/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.find_facilities_per_recreation_area--parameters","text":"int Recreation Area ID","title":"Parameters"},{"location":"reference/providers/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.find_facilities_per_recreation_area--returns","text":"List[CampgroundFacility] Array of Matching Campsites Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 def find_facilities_per_recreation_area ( self , rec_area_id : int = None , ** kwargs ) -> List [ CampgroundFacility ]: \"\"\" Find Matching Campsites Based from Recreation Area Parameters ---------- rec_area_id: int Recreation Area ID Returns ------- campgrounds: List[CampgroundFacility] Array of Matching Campsites \"\"\" logger . info ( f \"Retrieving Facility Information for Recreation Area ID: ` { rec_area_id } `.\" ) api_path = f \" { RIDBConfig . REC_AREA_API_PATH } / { rec_area_id } / { RIDBConfig . FACILITIES_API_PATH } \" api_response = self . _ridb_get_paginate ( path = api_path , params = dict ( full = \"true\" , ** kwargs ) ) filtered_facilities = self . _filter_facilities_responses ( responses = api_response ) campgrounds = list () logger . info ( f \" { len ( filtered_facilities ) } Matching Campgrounds Found\" ) for facility in filtered_facilities : _ , campground_facility = self . process_facilities_responses ( facility = facility ) if campground_facility is not None : campgrounds . append ( campground_facility ) log_sorted_response ( response_array = campgrounds ) return campgrounds","title":"Returns"},{"location":"reference/providers/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.find_recreation_areas","text":"Find Matching Campsites Based on Search String","title":"find_recreation_areas()"},{"location":"reference/providers/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.find_recreation_areas--parameters","text":"str Search Keyword(s)","title":"Parameters"},{"location":"reference/providers/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.find_recreation_areas--returns","text":"List[dict] Array of Matching Campsites Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def find_recreation_areas ( self , search_string : str = None , ** kwargs ) -> List [ dict ]: \"\"\" Find Matching Campsites Based on Search String Parameters ---------- search_string: str Search Keyword(s) Returns ------- filtered_responses: List[dict] Array of Matching Campsites \"\"\" try : assert any ( [ kwargs . get ( \"state\" , None ) is not None , search_string is not None and search_string != \"\" , ] ) except AssertionError : raise RuntimeError ( \"You must provide a search query or state(s) \" \"to find Recreation Areas\" ) logger . info ( f 'Searching for Recreation Areas: \" { search_string } \"' ) state_arg = kwargs . get ( \"state\" , None ) if state_arg is not None : kwargs . update ({ \"state\" : state_arg . upper ()}) params = dict ( query = search_string , sort = \"Name\" , full = \"true\" , ** kwargs ) if search_string is None : params . pop ( \"query\" ) api_response = self . _ridb_get_paginate ( path = RIDBConfig . REC_AREA_API_PATH , params = params ) logger . info ( f \" { len ( api_response ) } recreation areas found.\" ) logging_messages = list () for recreation_area_object in api_response : _ , recreation_area = self . _process_rec_area_response ( recreation_area = recreation_area_object ) if recreation_area is not None : logging_messages . append ( recreation_area ) log_sorted_response ( response_array = logging_messages ) return api_response","title":"Returns"},{"location":"reference/providers/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.get_campground_ids_by_campsites","text":"Retrieve a list of FacilityIDs, and Facilities from a Campsite ID List","title":"get_campground_ids_by_campsites()"},{"location":"reference/providers/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.get_campground_ids_by_campsites--parameters","text":"List[int] List of Campsite IDs","title":"Parameters"},{"location":"reference/providers/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.get_campground_ids_by_campsites--returns","text":"Tuple[List[int], List[CampsiteResponse]] Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 def get_campground_ids_by_campsites ( self , campsite_ids : List [ int ] ) -> Tuple [ List [ int ], List [ CampsiteResponse ]]: \"\"\" Retrieve a list of FacilityIDs, and Facilities from a Campsite ID List Parameters ---------- campsite_ids: List[int] List of Campsite IDs Returns ------- Tuple[List[int], List[CampsiteResponse]] \"\"\" campground_ids = list () campgrounds = list () for campsite_id in campsite_ids : campsite = self . get_campsite_by_id ( campsite_id = campsite_id ) campgrounds . append ( campsite ) campground_ids . append ( campsite . FacilityID ) return list ( set ( campground_ids )), list ( campgrounds )","title":"Returns"},{"location":"reference/providers/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.get_campsite_by_id","text":"Get a Campsite's Details","title":"get_campsite_by_id()"},{"location":"reference/providers/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.get_campsite_by_id--parameters","text":"campsite_id: int","title":"Parameters"},{"location":"reference/providers/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.get_campsite_by_id--returns","text":"CampsiteResponse Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 def get_campsite_by_id ( self , campsite_id : int ) -> CampsiteResponse : \"\"\" Get a Campsite's Details Parameters ---------- campsite_id: int Returns ------- CampsiteResponse \"\"\" data = self . get_ridb_data ( path = f \" { RIDBConfig . CAMPSITE_API_PATH } / { campsite_id } \" ) try : response = CampsiteResponse ( ** data [ 0 ]) except IndexError : raise ProviderSearchError ( f \"Campsite with ID # { campsite_id } not found.\" ) return response","title":"Returns"},{"location":"reference/providers/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.get_internal_campsite_metadata","text":"Retrieve Metadata About all of the underlying Campsites to Search Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 866 867 868 869 870 871 872 873 874 875 876 877 878 def get_internal_campsite_metadata ( self , facility_ids : List [ int ]) -> pd . DataFrame : \"\"\" Retrieve Metadata About all of the underlying Campsites to Search \"\"\" all_campsites : List [ RecDotGovCampsite ] = [] for facility_id in facility_ids : all_campsites += self . paginate_recdotgov_campsites ( facility_id = facility_id ) all_campsite_df = pd . DataFrame ( [ item . dict () for item in all_campsites ], columns = RecDotGovCampsite . __fields__ , ) all_campsite_df . set_index ( \"campsite_id\" , inplace = True ) return all_campsite_df","title":"get_internal_campsite_metadata()"},{"location":"reference/providers/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.get_recdotgov_data","text":"Find Campsite Availability Data","title":"get_recdotgov_data()"},{"location":"reference/providers/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.get_recdotgov_data--parameters","text":"int Campground ID from the RIDB API. Can also be pulled of URLs on Recreation.gov datetime datetime object, results will be filtered to month","title":"Parameters"},{"location":"reference/providers/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.get_recdotgov_data--returns","text":"Union[dict, list] Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 def get_recdotgov_data ( self , campground_id : int , month : datetime ) -> Union [ dict , list ]: \"\"\" Find Campsite Availability Data Parameters ---------- campground_id: int Campground ID from the RIDB API. Can also be pulled of URLs on Recreation.gov month: datetime datetime object, results will be filtered to month Returns ------- Union[dict, list] \"\"\" try : response = self . _make_recdotgov_availability_request ( campground_id = campground_id , month = month ) except tenacity . RetryError : raise RuntimeError ( \"Something went wrong in fetching data from the \" \"RecreationDotGov API.\" ) return loads ( response . content )","title":"Returns"},{"location":"reference/providers/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.get_ridb_data","text":"Find Matching Campsites Based on Search String","title":"get_ridb_data()"},{"location":"reference/providers/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.get_ridb_data--parameters","text":"str URL Endpoint, see https://ridb.recreation.gov/docs","title":"Parameters"},{"location":"reference/providers/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.get_ridb_data--returns","text":"Union[dict, list] Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 @tenacity . retry ( wait = tenacity . wait_random_exponential ( multiplier = 2 , max = 10 ), stop = tenacity . stop . stop_after_delay ( 15 ), ) def get_ridb_data ( self , path : str , params : Optional [ dict ] = None ) -> Union [ dict , list ]: \"\"\" Find Matching Campsites Based on Search String Parameters ---------- path: str URL Endpoint, see https://ridb.recreation.gov/docs params: Optional[dict] API Call Parameters Returns ------- Union[dict, list] \"\"\" api_endpoint = self . _ridb_get_endpoint ( path = path ) headers = self . _ridb_api_headers . copy () headers . update ( choice ( USER_AGENTS )) response = requests . get ( url = api_endpoint , headers = headers , params = params , timeout = 30 ) try : assert response . status_code == 200 except AssertionError : error_message = ( f \"Receiving bad data from Recreation.gov API: { response . text } \" ) logger . error ( error_message ) raise ConnectionError ( error_message ) return loads ( response . content )","title":"Returns"},{"location":"reference/providers/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.make_recdotgov_request","text":"Make a Raw Request to RecreationDotGov","title":"make_recdotgov_request()"},{"location":"reference/providers/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.make_recdotgov_request--parameters","text":"url: str method: str","title":"Parameters"},{"location":"reference/providers/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.make_recdotgov_request--returns","text":"requests.Response Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 @classmethod def make_recdotgov_request ( cls , url : str , method : str = \"GET\" , params : Optional [ Dict [ str , Any ]] = None , ** kwargs , ) -> requests . Response : \"\"\" Make a Raw Request to RecreationDotGov Parameters ---------- url: str method: str params: Optional[Dict[str, Any]] Returns ------- requests.Response \"\"\" # BUILD THE HEADERS EXPECTED FROM THE API headers = STANDARD_HEADERS . copy () headers . update ( choice ( USER_AGENTS )) headers . update ( RecreationBookingConfig . API_REFERRERS ) response = requests . request ( method = method , url = url , headers = headers , params = params , timeout = 30 , ** kwargs ) return response","title":"Returns"},{"location":"reference/providers/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.make_recdotgov_request_retry","text":"Make a Raw Request to RecreationDotGov - But Handle 404","title":"make_recdotgov_request_retry()"},{"location":"reference/providers/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.make_recdotgov_request_retry--parameters","text":"url: str method: str","title":"Parameters"},{"location":"reference/providers/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.make_recdotgov_request_retry--returns","text":"requests.Response Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 @classmethod @tenacity . retry ( wait = tenacity . wait_random_exponential ( multiplier = 2 , max = 10 ), stop = tenacity . stop . stop_after_delay ( 15 ), ) def make_recdotgov_request_retry ( cls , url : str , method : str = \"GET\" , params : Optional [ Dict [ str , Any ]] = None , ** kwargs , ) -> requests . Response : \"\"\" Make a Raw Request to RecreationDotGov - But Handle 404 Parameters ---------- url: str method: str params: Optional[Dict[str, Any]] Returns ------- requests.Response \"\"\" response = cls . make_recdotgov_request ( url = url , method = method , params = params , ** kwargs ) response . raise_for_status () return response","title":"Returns"},{"location":"reference/providers/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.paginate_recdotgov_campsites","text":"Paginate through the RecDotGov Campsite Metadata Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 def paginate_recdotgov_campsites ( self , facility_id : int , equipment : Optional [ List [ str ]] = None ) -> List [ RecDotGovCampsite ]: \"\"\" Paginate through the RecDotGov Campsite Metadata \"\"\" results = 0 continue_paginate = True endpoint_url = api_utils . generate_url ( scheme = RecreationBookingConfig . API_SCHEME , netloc = RecreationBookingConfig . API_NET_LOC , path = \"api/search/campsites\" , ) fq_list = [ f \"asset_id: { facility_id } \" ] if isinstance ( equipment , list ) and len ( equipment ) > 0 : for item in equipment : fq_list . append ( f \"campsite_equipment_name: { item } \" ) params = dict ( start = 0 , size = 1000 , fq = fq_list , include_non_site_specific_campsites = True , ) campsites = [] while continue_paginate is True : response = self . make_recdotgov_request_retry ( method = \"GET\" , url = endpoint_url , params = params , ) returned_data = json . loads ( response . content ) campsite_response = RecDotGovCampsiteResponse ( ** returned_data ) campsites += campsite_response . campsites results += campsite_response . size params . update ( start = results ) if results == campsite_response . total : continue_paginate = False return campsites","title":"paginate_recdotgov_campsites()"},{"location":"reference/providers/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.process_campsite_availability","text":"Parse the JSON Response and return availabilities","title":"process_campsite_availability()"},{"location":"reference/providers/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.process_campsite_availability--parameters","text":"dict API Response str Name of Recreation Area int ID of Recreation Area str Campground Facility Name int Campground Facility ID datetime Month to Process pd.DataFrame Metadata Fetched from the Recreation.gov API about the Campsites","title":"Parameters"},{"location":"reference/providers/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.process_campsite_availability--returns","text":"List[Optional[AvailableCampsite]] Any monthly availabilities Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 @classmethod def process_campsite_availability ( cls , availability : dict , recreation_area : str , recreation_area_id : int , facility_name : str , facility_id : int , month : datetime , campsite_metadata : pd . DataFrame , ) -> List [ Optional [ AvailableCampsite ]]: \"\"\" Parse the JSON Response and return availabilities Parameters ---------- availability: dict API Response recreation_area: str Name of Recreation Area recreation_area_id: int ID of Recreation Area facility_name: str Campground Facility Name facility_id: int Campground Facility ID month: datetime Month to Process campsite_metadata: pd.DataFrame Metadata Fetched from the Recreation.gov API about the Campsites Returns ------- total_campsite_availability: List[Optional[AvailableCampsite]] Any monthly availabilities \"\"\" total_campsite_availability : List [ Optional [ AvailableCampsite ]] = list () campsite_data = CampsiteAvailabilityResponse ( ** availability ) for campsite_id , site_related_data in campsite_data . campsites . items (): for ( matching_date , availability_status , ) in site_related_data . availabilities . items (): if ( availability_status not in RecreationBookingConfig . CAMPSITE_UNAVAILABLE_STRINGS ): booking_url = ( f \" { RecreationBookingConfig . CAMPSITE_BOOKING_URL } / { campsite_id } \" ) equipment , attributes = cls . _get_equipment_and_attributes ( campsite_id = campsite_id , campsite_metadata = campsite_metadata ) available_campsite = AvailableCampsite ( campsite_id = campsite_id , booking_date = matching_date , booking_end_date = matching_date + timedelta ( days = 1 ), booking_nights = 1 , campsite_site_name = site_related_data . site , campsite_loop_name = site_related_data . loop , campsite_type = site_related_data . campsite_type , campsite_occupancy = ( site_related_data . min_num_people , site_related_data . max_num_people , ), campsite_use_type = site_related_data . type_of_use , availability_status = availability_status , recreation_area = recreation_area , recreation_area_id = recreation_area_id , facility_name = facility_name , facility_id = facility_id , booking_url = booking_url , permitted_equipment = equipment , campsite_attributes = attributes , ) total_campsite_availability . append ( available_campsite ) logger . info ( f \" \\t { logging_utils . get_emoji ( total_campsite_availability ) } \\t \" f \" { len ( total_campsite_availability ) } total sites found in month of \" f \" { month . strftime ( '%B' ) } \" ) return total_campsite_availability","title":"Returns"},{"location":"reference/providers/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.process_facilities_responses","text":"Process Facilities Responses to be More Usable","title":"process_facilities_responses()"},{"location":"reference/providers/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.process_facilities_responses--parameters","text":"facility: dict","title":"Parameters"},{"location":"reference/providers/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.process_facilities_responses--returns","text":"Tuple[dict, CampgroundFacility] Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 @classmethod def process_facilities_responses ( cls , facility : dict ) -> Tuple [ dict , Optional [ CampgroundFacility ]]: \"\"\" Process Facilities Responses to be More Usable Parameters ---------- facility: dict Returns ------- Tuple[dict, CampgroundFacility] \"\"\" facility_object = FacilityResponse ( ** facility ) try : facility_state = facility_object . FACILITYADDRESS [ 0 ] . AddressStateCode . upper () except ( KeyError , IndexError ): facility_state = \"USA\" try : if len ( facility_object . RECAREA ) == 0 : recreation_area_id = facility_object . ParentRecAreaID formatted_recreation_area = ( f \" { facility_object . ORGANIZATION [ 0 ] . OrgName } , { facility_state } \" ) else : recreation_area = facility_object . RECAREA [ 0 ] . RecAreaName recreation_area_id = facility_object . RECAREA [ 0 ] . RecAreaID formatted_recreation_area = f \" { recreation_area } , { facility_state } \" campground_facility = CampgroundFacility ( facility_name = facility_object . FacilityName . title (), recreation_area = formatted_recreation_area , facility_id = facility_object . FacilityID , recreation_area_id = recreation_area_id , ) return facility , campground_facility except ( KeyError , IndexError ): return facility , None","title":"Returns"},{"location":"reference/providers/#camply.providers.YellowstoneLodging","text":"Bases: BaseProvider Scanner for Lodging in Yellowstone Source code in camply/providers/xanterra/yellowstone_lodging.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 class YellowstoneLodging ( BaseProvider ): \"\"\" Scanner for Lodging in Yellowstone \"\"\" def __repr__ ( self ): \"\"\" String Representation Returns ------- str \"\"\" return \"<YellowstoneLodging>\" def _get_monthly_availability ( self , month : datetime , nights : int = None ) -> dict : \"\"\" Check All Lodging in Yellowstone for Campground Data Returns ------- data_availability: dict Data Availability Dictionary \"\"\" query_dict = dict ( date = self . _ensure_current_month ( month = month ), limit = 31 , rate_code = YellowstoneConfig . RATE_CODE , ) if nights is not None : query_dict . update ( dict ( nights = nights )) api_endpoint = self . _get_api_endpoint ( url_path = YellowstoneConfig . YELLOWSTONE_LODGING_PATH , query = None ) logger . info ( f \"Searching for Yellowstone Lodging Availability: { month . strftime ( '%B, %Y' ) } \" ) all_resort_availability_data = self . make_yellowstone_request ( endpoint = api_endpoint , params = query_dict ) return all_resort_availability_data @staticmethod @tenacity . retry ( wait = tenacity . wait_random_exponential ( multiplier = 3 , max = 1800 ), stop = tenacity . stop . stop_after_delay ( 6000 ), ) def _try_retry_get_data ( endpoint : str , params : Optional [ dict ] = None ) -> dict : \"\"\" Try and Retry Fetching Data from the Yellowstone API. Unfortunately this is a required method to request the data since the Yellowstone API doesn't always return data. Parameters ---------- endpoint: str API Endpoint params Returns ------- dict \"\"\" yellowstone_headers = choice ( USER_AGENTS ) yellowstone_headers . update ( STANDARD_HEADERS ) yellowstone_headers . update ( YellowstoneConfig . API_REFERRERS ) response = requests . get ( url = endpoint , headers = yellowstone_headers , params = params , timeout = 30 ) if response . status_code == 200 and response . text . strip () != \"\" : return loads ( response . content ) else : error_message = ( \"Something went wrong with checking the \" \"Yellowstone Booking API. Will continue retrying.\" ) logger . warning ( error_message ) raise RuntimeError ( error_message ) @staticmethod def make_yellowstone_request ( endpoint : str , params : Optional [ dict ] = None ) -> dict : \"\"\" Try and Retry Fetching Data from the Yellowstone API. Unfortunately this is a required method to request the data since the Yellowstone API doesn't always return data. Parameters ---------- endpoint: str API Endpoint params Returns ------- dict \"\"\" try : content = YellowstoneLodging . _try_retry_get_data ( endpoint = endpoint , params = params ) except RuntimeError as re : raise RuntimeError ( f \"error_message: { re } \" ) return content @classmethod def _get_api_endpoint ( cls , url_path : str , query : Optional [ dict ] = None ) -> str : \"\"\" Build the API Endpoint for All Yellowstone Lodging \"\"\" if query is not None : query_string = parse . urlencode ( query = query ) else : query_string = \"\" url_components = dict ( scheme = YellowstoneConfig . API_SCHEME , netloc = YellowstoneConfig . API_BASE_ENDPOINT , url = url_path , params = \"\" , query = query_string , fragment = \"\" , ) api_endpoint = parse . urlunparse ( tuple ( url_components . values ())) return api_endpoint @classmethod def _return_lodging_url ( cls , lodging_code : str , month : datetime , params : Optional [ dict ] = \"\" ) -> str : \"\"\" Return a Browser Loadable URL to book from Parameters ---------- lodging_code: str Lodging Code from API month: datetime Month to return bookings filtered to params: Optional[dict] Optional URL Parameters Returns ------- str URL String \"\"\" query = dict ( dateFrom = month . strftime ( \"%m- %d -%Y\" ), adults = 1 , destination = lodging_code , children = 0 , ) if params is not None : query . update ( params ) query_string = parse . urlencode ( query = query ) url_components = dict ( scheme = YellowstoneConfig . API_SCHEME , netloc = YellowstoneConfig . WEBUI_BASE_ENDPOINT , url = YellowstoneConfig . WEBUI_BOOKING_PATH , params = \"\" , query = query_string , fragment = \"\" , ) webui_endpoint = parse . urlunparse ( tuple ( url_components . values ())) return webui_endpoint @classmethod def _compile_campground_availabilities ( cls , availability : XantResortData ) -> List [ dict ]: \"\"\" Gather Data about campground availabilities within a JSON Availability Objet Parameters ---------- availability: ResortData JSON Availability Object Returns ------- available_campsites: List[dict] List of Availabilities as JSON \"\"\" available_campsites = list () for booking_date , daily_data in availability . availability . items (): camping_keys = [ key for key in daily_data . keys () if YellowstoneConfig . LODGING_CAMPGROUND_QUALIFIER in key ] for hotel_code in camping_keys : hotel_data = daily_data [ hotel_code ] try : hotel_title = hotel_data . rates [ YellowstoneConfig . RATE_CODE ] . title hotel_rate_mins = hotel_data . rates [ YellowstoneConfig . RATE_CODE ] . mins if hotel_rate_mins != { 1 : 0 }: min_capacity = min ( hotel_rate_mins . keys ()) max_capacity = max ( hotel_rate_mins . keys ()) capacity = ( min_capacity , max_capacity ) campsite = dict ( campsite_id = None , booking_date = booking_date , campsite_occupancy = capacity , recreation_area = YellowstoneConfig . YELLOWSTONE_RECREATION_AREA_NAME , recreation_area_id = YellowstoneConfig . YELLOWSTONE_RECREATION_AREA_ID , facility_name = hotel_title . replace ( * YellowstoneConfig . YELLOWSTONE_CAMPGROUND_NAME_REPLACE ), facility_id = hotel_code , ) available_campsites . append ( campsite ) except KeyError : pass logger . info ( f \" \\t { logging_utils . get_emoji ( available_campsites ) } \\t \" f \" { len ( available_campsites ) } sites found.\" ) return available_campsites def _gather_campsite_specific_availability ( self , available_campsites : List [ dict ], month : datetime , nights : Optional [ int ] = None , ) -> List [ dict ]: \"\"\" Get campsite extra information Given a DataFrame of campsite availability, return updated Data with details about the actual campsites that are available (i.e Tent Size, RV Length, Etc) Parameters ---------- available_campsites: List[dict] List of Available Campsites as JSON objects month: datetime Month object Returns ------- List[dict] \"\"\" available_room_array = list () availability_df = DataFrame ( data = available_campsites ) if availability_df . empty is True : return available_room_array for facility_id , _facility_df in availability_df . groupby ( YellowstoneConfig . FACILITY_ID ): api_endpoint = self . _get_api_endpoint ( url_path = YellowstoneConfig . YELLOWSTONE_CAMPSITE_AVAILABILITY , query = None ) params = dict ( date = self . _ensure_current_month ( month = month ), limit = 31 ) if nights is not None : params . update ( dict ( nights = nights )) campsite_data = self . make_yellowstone_request ( endpoint = f \" { api_endpoint } / { facility_id } \" , params = params ) campsite_availability = campsite_data [ YellowstoneConfig . BOOKING_AVAILABILITY ] booking_dates = campsite_availability . keys () availabilities = self . _process_daily_availability ( booking_dates = booking_dates , campsite_availability = campsite_availability , facility_id = facility_id , ) available_room_array += availabilities return available_room_array @classmethod def _process_daily_availability ( cls , booking_dates : List [ str ], campsite_availability : dict , facility_id : str ) -> List [ dict ]: \"\"\" Process Monthly Availability Parameters ---------- booking_dates: List[str] List of booking dates to process campsite_availability: dict Campsite availability dict facility_id: str Identification of the Facility Returns ------- List[dict] \"\"\" daily_availabilities = list () for booking_date_str in booking_dates : daily_availability = campsite_availability [ booking_date_str ] if ( daily_availability [ YellowstoneConfig . FACILITY_STATUS ] == YellowstoneConfig . FACILITY_STATUS_QUALIFIER ): available_rooms = daily_availability [ YellowstoneConfig . FACILITY_ROOMS ] for room in available_rooms : if room [ YellowstoneConfig . FACILITY_AVAILABLE_QUALIFIER ] > 0 : daily_availabilities . append ( dict ( booking_date = booking_date_str , facility_id = facility_id , campsite_code = room [ YellowstoneConfig . FACILITY_ROOM_CODE ], available = room [ YellowstoneConfig . FACILITY_AVAILABLE_QUALIFIER ], price = room [ YellowstoneConfig . FACILITY_PRICE ], ) ) return daily_availabilities def _get_property_information ( self , available_rooms : List [ dict ]) -> List [ dict ]: \"\"\" Gather Information About All Campgrounds / Hotels within Yellowstone Parameters ---------- available_rooms: List[dict] Returns ------- List[dict] \"\"\" property_info_array = list () availability_df = DataFrame ( data = available_rooms ) if availability_df . empty is True : return property_info_array facility_identifiers = availability_df [ YellowstoneConfig . FACILITY_ID ] . unique () for facility_id in facility_identifiers : api_endpoint = self . _get_api_endpoint ( url_path = YellowstoneConfig . YELLOWSTONE_PROPERTY_INFO , query = None ) campsite_info = self . make_yellowstone_request ( endpoint = f \" { api_endpoint } / { facility_id } \" ) campsite_codes = campsite_info . keys () for campsite_code in campsite_codes : campsite_data = campsite_info [ campsite_code ] property_info_array . append ( dict ( facility_id = facility_id , campsite_code = campsite_code , campsite_title = campsite_data [ YellowstoneConfig . LODGING_TITLE ], campsite_type = campsite_data [ YellowstoneConfig . FACILITY_TYPE ] . upper (), capacity = ( campsite_data [ YellowstoneConfig . LODGING_OCCUPANCY_BASE ], campsite_data [ YellowstoneConfig . LODGING_OCCUPANCY_MAX ], ), ) ) return property_info_array def get_monthly_campsites ( self , month : datetime , nights : Optional [ int ] = None ) -> List [ AvailableCampsite ]: \"\"\" Return All Campsites Available in a Given Month Parameters ---------- month: datetime Month to Search nights: Optional[int] Search for consecutive nights Returns ------- List[AvailableCampsite] \"\"\" now = datetime . now () . date () search_date = month . replace ( day = 1 ) if month <= now : logger . info ( \"Cannot input search dates before today, adjusting search parameters.\" ) search_date = search_date . replace ( year = now . year , month = now . month , day = now . day ) availability_found = self . _get_monthly_availability ( month = search_date , nights = nights ) availability = XantResortData ( ** availability_found ) monthly_campsites = self . _compile_campground_availabilities ( availability = availability ) campsite_data = DataFrame ( monthly_campsites , columns = YellowstoneConfig . CAMPSITE_DATA_COLUMNS ) . drop_duplicates () if campsite_data . empty is True : return list () available_room_array = self . _gather_campsite_specific_availability ( available_campsites = monthly_campsites , month = month , nights = nights ) available_rooms = DataFrame ( available_room_array ) property_info = self . _get_property_information ( available_rooms = available_room_array ) properties = DataFrame ( property_info ) merged_campsites = available_rooms . merge ( properties , on = [ YellowstoneConfig . FACILITY_ID_COLUMN , YellowstoneConfig . CAMPSITE_ID_COLUMN , ], ) merged_campsites [ YellowstoneConfig . BOOKING_DATE_COLUMN ] = to_datetime ( merged_campsites [ YellowstoneConfig . BOOKING_DATE_COLUMN ] ) if nights is not None : nights_param = dict ( nights = nights ) else : nights_param = dict ( nights = 1 ) booking_nights = nights_param . get ( \"nights\" ) merged_campsites [ YellowstoneConfig . BOOKING_END_DATE_COLUMN ] = merged_campsites [ YellowstoneConfig . BOOKING_DATE_COLUMN ] + timedelta ( days = booking_nights ) merged_campsites [ YellowstoneConfig . BOOKING_NIGHTS_COLUMN ] = booking_nights final_campsites = merged_campsites . merge ( campsite_data , on = YellowstoneConfig . FACILITY_ID_COLUMN ) . sort_values ( by = YellowstoneConfig . BOOKING_DATE_COLUMN ) final_campsites [ YellowstoneConfig . BOOKING_URL_COLUMN ] = final_campsites . apply ( lambda x : self . _return_lodging_url ( lodging_code = x . facility_id , month = x . booking_date , params = nights_param ), axis = 1 , ) all_monthly_campsite_array = self . _df_to_campsites ( campsite_df = final_campsites ) return all_monthly_campsite_array @classmethod def _df_to_campsites ( cls , campsite_df : DataFrame ) -> List [ AvailableCampsite ]: \"\"\" Transform a DataFrame into an array of AvailableCampsites Parameters ---------- campsite_df: DataFrame Returns ------- List[AvailableCampsite] \"\"\" all_monthly_campsite_array = list () for _ , row in campsite_df . iterrows (): campsite = AvailableCampsite ( campsite_id = row [ YellowstoneConfig . CAMPSITE_ID_COLUMN ], booking_date = row [ YellowstoneConfig . BOOKING_DATE_COLUMN ], booking_end_date = row [ YellowstoneConfig . BOOKING_END_DATE_COLUMN ], booking_nights = row [ YellowstoneConfig . BOOKING_NIGHTS_COLUMN ], campsite_site_name = row [ YellowstoneConfig . CAMPSITE_SITE_NAME_COLUMN ], campsite_loop_name = YellowstoneConfig . YELLOWSTONE_LOOP_NAME , campsite_type = row [ YellowstoneConfig . CAMPSITE_TYPE_COLUMN ], campsite_occupancy = row [ YellowstoneConfig . CAMPSITE_OCCUPANCY_COLUMN ], campsite_use_type = row [ YellowstoneConfig . CAMPSITE_USE_TYPE_COLUMN ], availability_status = YellowstoneConfig . CAMPSITE_AVAILABILITY_STATUS , recreation_area = YellowstoneConfig . YELLOWSTONE_RECREATION_AREA_NAME , recreation_area_id = YellowstoneConfig . YELLOWSTONE_RECREATION_AREA_ID , facility_name = row [ YellowstoneConfig . FACILITY_NAME_COLUMN ], facility_id = row [ YellowstoneConfig . FACILITY_ID_COLUMN ], booking_url = row [ YellowstoneConfig . BOOKING_URL_COLUMN ], ) all_monthly_campsite_array . append ( campsite ) return all_monthly_campsite_array @classmethod def _ensure_current_month ( cls , month : datetime ) -> datetime : \"\"\" Ensure That We Never Give the Yellowstone API Dates in the past. Parameters ---------- month: datetime Returns ------- datetime \"\"\" yellowstone_timezone = timezone ( YellowstoneConfig . YELLOWSTONE_TIMEZONE ) yellowstone_current_time = datetime . now ( yellowstone_timezone ) . date () today = datetime ( year = yellowstone_current_time . year , month = yellowstone_current_time . month , day = yellowstone_current_time . day , ) . date () if today > month : month = today return month","title":"YellowstoneLodging"},{"location":"reference/providers/#camply.providers.xanterra.yellowstone_lodging.YellowstoneLodging.__repr__","text":"String Representation","title":"__repr__()"},{"location":"reference/providers/#camply.providers.xanterra.yellowstone_lodging.YellowstoneLodging.__repr__--returns","text":"str Source code in camply/providers/xanterra/yellowstone_lodging.py 31 32 33 34 35 36 37 38 39 def __repr__ ( self ): \"\"\" String Representation Returns ------- str \"\"\" return \"<YellowstoneLodging>\"","title":"Returns"},{"location":"reference/providers/#camply.providers.xanterra.yellowstone_lodging.YellowstoneLodging.get_monthly_campsites","text":"Return All Campsites Available in a Given Month","title":"get_monthly_campsites()"},{"location":"reference/providers/#camply.providers.xanterra.yellowstone_lodging.YellowstoneLodging.get_monthly_campsites--parameters","text":"datetime Month to Search Optional[int] Search for consecutive nights","title":"Parameters"},{"location":"reference/providers/#camply.providers.xanterra.yellowstone_lodging.YellowstoneLodging.get_monthly_campsites--returns","text":"List[AvailableCampsite] Source code in camply/providers/xanterra/yellowstone_lodging.py 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 def get_monthly_campsites ( self , month : datetime , nights : Optional [ int ] = None ) -> List [ AvailableCampsite ]: \"\"\" Return All Campsites Available in a Given Month Parameters ---------- month: datetime Month to Search nights: Optional[int] Search for consecutive nights Returns ------- List[AvailableCampsite] \"\"\" now = datetime . now () . date () search_date = month . replace ( day = 1 ) if month <= now : logger . info ( \"Cannot input search dates before today, adjusting search parameters.\" ) search_date = search_date . replace ( year = now . year , month = now . month , day = now . day ) availability_found = self . _get_monthly_availability ( month = search_date , nights = nights ) availability = XantResortData ( ** availability_found ) monthly_campsites = self . _compile_campground_availabilities ( availability = availability ) campsite_data = DataFrame ( monthly_campsites , columns = YellowstoneConfig . CAMPSITE_DATA_COLUMNS ) . drop_duplicates () if campsite_data . empty is True : return list () available_room_array = self . _gather_campsite_specific_availability ( available_campsites = monthly_campsites , month = month , nights = nights ) available_rooms = DataFrame ( available_room_array ) property_info = self . _get_property_information ( available_rooms = available_room_array ) properties = DataFrame ( property_info ) merged_campsites = available_rooms . merge ( properties , on = [ YellowstoneConfig . FACILITY_ID_COLUMN , YellowstoneConfig . CAMPSITE_ID_COLUMN , ], ) merged_campsites [ YellowstoneConfig . BOOKING_DATE_COLUMN ] = to_datetime ( merged_campsites [ YellowstoneConfig . BOOKING_DATE_COLUMN ] ) if nights is not None : nights_param = dict ( nights = nights ) else : nights_param = dict ( nights = 1 ) booking_nights = nights_param . get ( \"nights\" ) merged_campsites [ YellowstoneConfig . BOOKING_END_DATE_COLUMN ] = merged_campsites [ YellowstoneConfig . BOOKING_DATE_COLUMN ] + timedelta ( days = booking_nights ) merged_campsites [ YellowstoneConfig . BOOKING_NIGHTS_COLUMN ] = booking_nights final_campsites = merged_campsites . merge ( campsite_data , on = YellowstoneConfig . FACILITY_ID_COLUMN ) . sort_values ( by = YellowstoneConfig . BOOKING_DATE_COLUMN ) final_campsites [ YellowstoneConfig . BOOKING_URL_COLUMN ] = final_campsites . apply ( lambda x : self . _return_lodging_url ( lodging_code = x . facility_id , month = x . booking_date , params = nights_param ), axis = 1 , ) all_monthly_campsite_array = self . _df_to_campsites ( campsite_df = final_campsites ) return all_monthly_campsite_array","title":"Returns"},{"location":"reference/providers/#camply.providers.xanterra.yellowstone_lodging.YellowstoneLodging.make_yellowstone_request","text":"Try and Retry Fetching Data from the Yellowstone API. Unfortunately this is a required method to request the data since the Yellowstone API doesn't always return data.","title":"make_yellowstone_request()"},{"location":"reference/providers/#camply.providers.xanterra.yellowstone_lodging.YellowstoneLodging.make_yellowstone_request--parameters","text":"str API Endpoint params","title":"Parameters"},{"location":"reference/providers/#camply.providers.xanterra.yellowstone_lodging.YellowstoneLodging.make_yellowstone_request--returns","text":"dict Source code in camply/providers/xanterra/yellowstone_lodging.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 @staticmethod def make_yellowstone_request ( endpoint : str , params : Optional [ dict ] = None ) -> dict : \"\"\" Try and Retry Fetching Data from the Yellowstone API. Unfortunately this is a required method to request the data since the Yellowstone API doesn't always return data. Parameters ---------- endpoint: str API Endpoint params Returns ------- dict \"\"\" try : content = YellowstoneLodging . _try_retry_get_data ( endpoint = endpoint , params = params ) except RuntimeError as re : raise RuntimeError ( f \"error_message: { re } \" ) return content","title":"Returns"},{"location":"reference/providers/base_provider/","text":"BaseProvider Base Class BaseProvider # Base Provider Class This should ideally be an AbstractBaseClass Source code in camply/providers/base_provider.py 10 11 12 13 14 15 class BaseProvider : \"\"\" Base Provider Class This should ideally be an AbstractBaseClass \"\"\" ProviderError # Bases: Exception General Provider Error Source code in camply/providers/base_provider.py 18 19 20 21 class ProviderError ( Exception ): \"\"\" General Provider Error \"\"\" ProviderSearchError # Bases: ProviderError Searching Error Source code in camply/providers/base_provider.py 24 25 26 27 class ProviderSearchError ( ProviderError ): \"\"\" Searching Error \"\"\"","title":"base_provider"},{"location":"reference/providers/base_provider/#camply.providers.base_provider.BaseProvider","text":"Base Provider Class This should ideally be an AbstractBaseClass Source code in camply/providers/base_provider.py 10 11 12 13 14 15 class BaseProvider : \"\"\" Base Provider Class This should ideally be an AbstractBaseClass \"\"\"","title":"BaseProvider"},{"location":"reference/providers/base_provider/#camply.providers.base_provider.ProviderError","text":"Bases: Exception General Provider Error Source code in camply/providers/base_provider.py 18 19 20 21 class ProviderError ( Exception ): \"\"\" General Provider Error \"\"\"","title":"ProviderError"},{"location":"reference/providers/base_provider/#camply.providers.base_provider.ProviderSearchError","text":"Bases: ProviderError Searching Error Source code in camply/providers/base_provider.py 24 25 26 27 class ProviderSearchError ( ProviderError ): \"\"\" Searching Error \"\"\"","title":"ProviderSearchError"},{"location":"reference/providers/recreation_dot_gov/","text":"RecreationDotGov init","title":"recreation_dot_gov"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/","text":"Recreation.gov Web Searching Utilities RecreationDotGov # Bases: BaseProvider Python Class for Working with Recreation.gov API / NPS APIs Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 class RecreationDotGov ( BaseProvider ): \"\"\" Python Class for Working with Recreation.gov API / NPS APIs \"\"\" def __init__ ( self , api_key : str = None ): \"\"\" Initialize with Search Dates \"\"\" if api_key is None : _api_key = RIDBConfig . API_KEY if isinstance ( _api_key , bytes ): _api_key : str = b64decode ( RIDBConfig . API_KEY ) . decode ( \"utf-8\" ) else : _api_key : str = api_key self . _ridb_api_headers : dict = dict ( accept = \"application/json\" , apikey = _api_key ) def __repr__ ( self ): \"\"\" String Representation Returns ------- str \"\"\" return \"<RecreationDotGov>\" def find_recreation_areas ( self , search_string : str = None , ** kwargs ) -> List [ dict ]: \"\"\" Find Matching Campsites Based on Search String Parameters ---------- search_string: str Search Keyword(s) Returns ------- filtered_responses: List[dict] Array of Matching Campsites \"\"\" try : assert any ( [ kwargs . get ( \"state\" , None ) is not None , search_string is not None and search_string != \"\" , ] ) except AssertionError : raise RuntimeError ( \"You must provide a search query or state(s) \" \"to find Recreation Areas\" ) logger . info ( f 'Searching for Recreation Areas: \" { search_string } \"' ) state_arg = kwargs . get ( \"state\" , None ) if state_arg is not None : kwargs . update ({ \"state\" : state_arg . upper ()}) params = dict ( query = search_string , sort = \"Name\" , full = \"true\" , ** kwargs ) if search_string is None : params . pop ( \"query\" ) api_response = self . _ridb_get_paginate ( path = RIDBConfig . REC_AREA_API_PATH , params = params ) logger . info ( f \" { len ( api_response ) } recreation areas found.\" ) logging_messages = list () for recreation_area_object in api_response : _ , recreation_area = self . _process_rec_area_response ( recreation_area = recreation_area_object ) if recreation_area is not None : logging_messages . append ( recreation_area ) log_sorted_response ( response_array = logging_messages ) return api_response def find_campgrounds ( self , search_string : str = None , rec_area_id : Optional [ List [ int ]] = None , campground_id : Optional [ List [ int ]] = None , campsite_id : Optional [ List [ int ]] = None , ** kwargs , ) -> List [ CampgroundFacility ]: \"\"\" Find Bookable Campgrounds Given a Set of Search Criteria Parameters ---------- search_string: str Search Keyword(s) rec_area_id: Optional[List[int]] Recreation Area ID to filter with campground_id: Optional[List[int]] ID of the Campground campsite_id: Optional[List[int]] ID of the Campsite Returns ------- facilities: List[CampgroundFacility] Array of Matching Campsites \"\"\" if campsite_id not in ( None , [], ()): facilities = self . _process_specific_campsites_provided ( campsite_id = campsite_id ) elif campground_id not in ( None , [], ()): facilities = self . _find_facilities_from_campgrounds ( campground_id = campground_id ) elif rec_area_id not in ( None , [], ()): facilities = list () for recreation_area in rec_area_id : facilities += self . find_facilities_per_recreation_area ( rec_area_id = recreation_area ) else : state_arg = kwargs . get ( \"state\" , None ) if state_arg is not None : kwargs . update ({ \"state\" : state_arg . upper ()}) if search_string in [ \"\" , None ] and state_arg is None : raise RuntimeError ( \"You must provide a search query or state to find campsites\" ) facilities = self . _find_facilities_from_search ( search = search_string , ** kwargs ) return facilities def find_facilities_per_recreation_area ( self , rec_area_id : int = None , ** kwargs ) -> List [ CampgroundFacility ]: \"\"\" Find Matching Campsites Based from Recreation Area Parameters ---------- rec_area_id: int Recreation Area ID Returns ------- campgrounds: List[CampgroundFacility] Array of Matching Campsites \"\"\" logger . info ( f \"Retrieving Facility Information for Recreation Area ID: ` { rec_area_id } `.\" ) api_path = f \" { RIDBConfig . REC_AREA_API_PATH } / { rec_area_id } / { RIDBConfig . FACILITIES_API_PATH } \" api_response = self . _ridb_get_paginate ( path = api_path , params = dict ( full = \"true\" , ** kwargs ) ) filtered_facilities = self . _filter_facilities_responses ( responses = api_response ) campgrounds = list () logger . info ( f \" { len ( filtered_facilities ) } Matching Campgrounds Found\" ) for facility in filtered_facilities : _ , campground_facility = self . process_facilities_responses ( facility = facility ) if campground_facility is not None : campgrounds . append ( campground_facility ) log_sorted_response ( response_array = campgrounds ) return campgrounds def _find_facilities_from_campgrounds ( self , campground_id : Union [ int , List [ int ]] ) -> List [ CampgroundFacility ]: \"\"\" Find Matching Campsites from Campground ID Parameters ---------- campground_id: Union[int, List[int]] ID of the Campsite Returns ------- filtered_responses: List[CampgroundFacility] Array of Matching Campsites \"\"\" campgrounds = list () for campground_identifier in campground_id : facility_data = self . get_ridb_data ( path = f \" { RIDBConfig . FACILITIES_API_PATH } / { campground_identifier } \" , params = dict ( full = True ), ) filtered_facility = self . _filter_facilities_responses ( responses = [ facility_data ] ) _ , campground_facility = self . process_facilities_responses ( facility = filtered_facility [ 0 ] ) if campground_facility is not None : campgrounds . append ( campground_facility ) logger . info ( f \" { len ( campgrounds ) } Matching Campgrounds Found\" ) log_sorted_response ( response_array = campgrounds ) return campgrounds def _find_facilities_from_search ( self , search : str , ** kwargs ) -> List [ dict ]: \"\"\" Find Matching Campgrounds Based on Search String Parameters ---------- search: str Search String Returns ------- campgrounds: List[dict] Array of Matching Campsites \"\"\" facilities_response = self . _ridb_get_paginate ( path = RIDBConfig . FACILITIES_API_PATH , params = dict ( query = search , activity = \"CAMPING\" , full = \"true\" , ** kwargs ), ) filtered_responses = self . _filter_facilities_responses ( responses = facilities_response ) logger . info ( f \" { len ( filtered_responses ) } Matching Campgrounds Found\" ) campgrounds = list () for facility in filtered_responses : _ , campground_facility = self . process_facilities_responses ( facility = facility ) if campground_facility is not None : campgrounds . append ( campground_facility ) log_sorted_response ( response_array = campgrounds ) return campgrounds @classmethod def _ridb_get_endpoint ( cls , path : str ) -> str : \"\"\" Return an API Endpoint for the RIDP Parameters ---------- path: str URL Endpoint, see https://ridb.recreation.gov/docs Returns ------- endpoint_url: str URL for the API Endpoint \"\"\" assert RIDBConfig . RIDB_BASE_PATH . endswith ( \"/\" ) base_url = api_utils . generate_url ( scheme = RIDBConfig . RIDB_SCHEME , netloc = RIDBConfig . RIDB_NET_LOC , path = RIDBConfig . RIDB_BASE_PATH , ) endpoint_url = parse . urljoin ( base_url , path ) return endpoint_url @tenacity . retry ( wait = tenacity . wait_random_exponential ( multiplier = 2 , max = 10 ), stop = tenacity . stop . stop_after_delay ( 15 ), ) def get_ridb_data ( self , path : str , params : Optional [ dict ] = None ) -> Union [ dict , list ]: \"\"\" Find Matching Campsites Based on Search String Parameters ---------- path: str URL Endpoint, see https://ridb.recreation.gov/docs params: Optional[dict] API Call Parameters Returns ------- Union[dict, list] \"\"\" api_endpoint = self . _ridb_get_endpoint ( path = path ) headers = self . _ridb_api_headers . copy () headers . update ( choice ( USER_AGENTS )) response = requests . get ( url = api_endpoint , headers = headers , params = params , timeout = 30 ) try : assert response . status_code == 200 except AssertionError : error_message = ( f \"Receiving bad data from Recreation.gov API: { response . text } \" ) logger . error ( error_message ) raise ConnectionError ( error_message ) return loads ( response . content ) def _ridb_get_paginate ( self , path : str , params : Optional [ dict ] = None , ) -> List [ dict ]: \"\"\" Return the Paginated Response from the RIDP Parameters ---------- path: str URL Endpoint, see https://ridb.recreation.gov/docs params: Optional[dict] API Call Parameters Returns ------- paginated_response: list Concatted Response \"\"\" if params is None : params = {} paginated_response = list () data_incomplete = True offset : int = 0 historical_results = 0 while data_incomplete is True : params . update ( offset = offset ) data_response = self . get_ridb_data ( path = path , params = params ) response_object = GenericResponse ( ** data_response ) paginated_response += response_object . RECDATA result_count = response_object . METADATA . RESULTS . CURRENT_COUNT historical_results += result_count total_count = response_object . METADATA . RESULTS . TOTAL_COUNT if offset >= 500 : logger . info ( f \"Too Many Results returned ( { total_count } ), \" \"try performing a more specific search\" ) data_incomplete = False elif historical_results < total_count : offset = historical_results else : data_incomplete = False return paginated_response @classmethod def _filter_facilities_responses ( cls , responses = List [ dict ]) -> List [ dict ]: \"\"\" Filter Facilities to Actual Reservable Campsites Parameters ---------- responses Returns ------- List[dict] \"\"\" filtered_responses = list () for possible_match in responses : try : facility = FacilityResponse ( ** possible_match ) except ValidationError as e : logger . error ( \"That doesn't look like a valid Campground Facility\" ) logger . error ( json . dumps ( possible_match )) logger . exception ( e ) raise ProviderSearchError ( \"Invalid Campground Facility Returned\" ) if all ( [ facility . FacilityTypeDescription == RIDBConfig . CAMPGROUND_FACILITY_FIELD_QUALIFIER , facility . Enabled is True , facility . Reservable is True , ] ): filtered_responses . append ( possible_match ) return filtered_responses @classmethod def process_facilities_responses ( cls , facility : dict ) -> Tuple [ dict , Optional [ CampgroundFacility ]]: \"\"\" Process Facilities Responses to be More Usable Parameters ---------- facility: dict Returns ------- Tuple[dict, CampgroundFacility] \"\"\" facility_object = FacilityResponse ( ** facility ) try : facility_state = facility_object . FACILITYADDRESS [ 0 ] . AddressStateCode . upper () except ( KeyError , IndexError ): facility_state = \"USA\" try : if len ( facility_object . RECAREA ) == 0 : recreation_area_id = facility_object . ParentRecAreaID formatted_recreation_area = ( f \" { facility_object . ORGANIZATION [ 0 ] . OrgName } , { facility_state } \" ) else : recreation_area = facility_object . RECAREA [ 0 ] . RecAreaName recreation_area_id = facility_object . RECAREA [ 0 ] . RecAreaID formatted_recreation_area = f \" { recreation_area } , { facility_state } \" campground_facility = CampgroundFacility ( facility_name = facility_object . FacilityName . title (), recreation_area = formatted_recreation_area , facility_id = facility_object . FacilityID , recreation_area_id = recreation_area_id , ) return facility , campground_facility except ( KeyError , IndexError ): return facility , None @classmethod def _process_rec_area_response ( cls , recreation_area = dict ) -> Tuple [ dict , Optional [ RecreationArea ]]: \"\"\" Process Rec Area Responses to be More Usable Parameters ---------- recreation_area: dict Returns ------- Tuple[dict, RecreationArea] \"\"\" rec_area_response = RecreationAreaResponse ( ** recreation_area ) try : recreation_area_location = rec_area_response . RECAREAADDRESS [ 0 ] . AddressStateCode recreation_area_tuple = RecreationArea ( recreation_area = rec_area_response . RecAreaName , recreation_area_id = rec_area_response . RecAreaID , recreation_area_location = recreation_area_location , ) return recreation_area , recreation_area_tuple except IndexError : return recreation_area , None @classmethod def _rec_availability_get_endpoint ( cls , path : str ) -> str : \"\"\" Return an API Endpoint for the Recreation.gov Campground Availability API Parameters ---------- path: str URL Endpoint Path Returns ------- endpoint_url: str URL for the API Endpoint \"\"\" base_url = api_utils . generate_url ( scheme = RecreationBookingConfig . API_SCHEME , netloc = RecreationBookingConfig . API_NET_LOC , path = RecreationBookingConfig . API_BASE_PATH , ) endpoint_url = parse . urljoin ( base_url , path ) return endpoint_url @classmethod def make_recdotgov_request ( cls , url : str , method : str = \"GET\" , params : Optional [ Dict [ str , Any ]] = None , ** kwargs , ) -> requests . Response : \"\"\" Make a Raw Request to RecreationDotGov Parameters ---------- url: str method: str params: Optional[Dict[str, Any]] Returns ------- requests.Response \"\"\" # BUILD THE HEADERS EXPECTED FROM THE API headers = STANDARD_HEADERS . copy () headers . update ( choice ( USER_AGENTS )) headers . update ( RecreationBookingConfig . API_REFERRERS ) response = requests . request ( method = method , url = url , headers = headers , params = params , timeout = 30 , ** kwargs ) return response @classmethod @tenacity . retry ( wait = tenacity . wait_random_exponential ( multiplier = 2 , max = 10 ), stop = tenacity . stop . stop_after_delay ( 15 ), ) def make_recdotgov_request_retry ( cls , url : str , method : str = \"GET\" , params : Optional [ Dict [ str , Any ]] = None , ** kwargs , ) -> requests . Response : \"\"\" Make a Raw Request to RecreationDotGov - But Handle 404 Parameters ---------- url: str method: str params: Optional[Dict[str, Any]] Returns ------- requests.Response \"\"\" response = cls . make_recdotgov_request ( url = url , method = method , params = params , ** kwargs ) response . raise_for_status () return response def paginate_recdotgov_campsites ( self , facility_id : int , equipment : Optional [ List [ str ]] = None ) -> List [ RecDotGovCampsite ]: \"\"\" Paginate through the RecDotGov Campsite Metadata \"\"\" results = 0 continue_paginate = True endpoint_url = api_utils . generate_url ( scheme = RecreationBookingConfig . API_SCHEME , netloc = RecreationBookingConfig . API_NET_LOC , path = \"api/search/campsites\" , ) fq_list = [ f \"asset_id: { facility_id } \" ] if isinstance ( equipment , list ) and len ( equipment ) > 0 : for item in equipment : fq_list . append ( f \"campsite_equipment_name: { item } \" ) params = dict ( start = 0 , size = 1000 , fq = fq_list , include_non_site_specific_campsites = True , ) campsites = [] while continue_paginate is True : response = self . make_recdotgov_request_retry ( method = \"GET\" , url = endpoint_url , params = params , ) returned_data = json . loads ( response . content ) campsite_response = RecDotGovCampsiteResponse ( ** returned_data ) campsites += campsite_response . campsites results += campsite_response . size params . update ( start = results ) if results == campsite_response . total : continue_paginate = False return campsites @tenacity . retry ( wait = tenacity . wait_random_exponential ( multiplier = 3 , max = 1800 ), stop = tenacity . stop . stop_after_delay ( 6000 ), ) def _make_recdotgov_availability_request ( self , campground_id : int , month : datetime , ) -> requests . Response : \"\"\" Make a request to the RecreationDotGov API - Handle Exponential Backoff Parameters ---------- campground_id month Returns ------- requests.Response \"\"\" try : api_endpoint = self . _rec_availability_get_endpoint ( path = f \" { campground_id } / { RecreationBookingConfig . API_MONTH_PATH } \" ) formatted_month = month . strftime ( \"%Y-%m-01T00:00:00.000Z\" ) query_params = dict ( start_date = formatted_month ) response = self . make_recdotgov_request ( method = \"GET\" , url = api_endpoint , params = query_params , ) assert response . status_code == 200 except AssertionError : response_error = response . text error_message = \"Bad Data Returned from the RecreationDotGov API\" logger . debug ( f \" { error_message } , will continue to retry\" ) logger . debug ( f \"Error Details: { response_error } \" ) raise ConnectionError ( f \" { error_message } : { response_error } \" ) return response def get_recdotgov_data ( self , campground_id : int , month : datetime ) -> Union [ dict , list ]: \"\"\" Find Campsite Availability Data Parameters ---------- campground_id: int Campground ID from the RIDB API. Can also be pulled of URLs on Recreation.gov month: datetime datetime object, results will be filtered to month Returns ------- Union[dict, list] \"\"\" try : response = self . _make_recdotgov_availability_request ( campground_id = campground_id , month = month ) except tenacity . RetryError : raise RuntimeError ( \"Something went wrong in fetching data from the \" \"RecreationDotGov API.\" ) return loads ( response . content ) @classmethod def _items_to_unique_dicts ( cls , item : Union [ List [ Dict [ str , Any ]], pd . Series ] ) -> List [ Dict [ str , Any ]]: \"\"\" Ensure the proper items are parsed for equipment and attributes \"\"\" if isinstance ( item , pd . Series ): list_of_dicts = list ( chain . from_iterable ( item . tolist ())) unique_list_of_dicts = [ dict ( s ) for s in set ( frozenset ( d . items ()) for d in list_of_dicts ) ] return unique_list_of_dicts else : return item @classmethod def _get_equipment_and_attributes ( cls , campsite_id : int , campsite_metadata : pd . DataFrame , ) -> Tuple [ List [ Dict [ str , Any ]], List [ Dict [ str , Any ]]]: \"\"\" Index a DataFrame in a Complicated Way \"\"\" try : equipment = campsite_metadata . at [ campsite_id , \"permitted_equipment\" ] except LookupError : equipment = None try : attributes = campsite_metadata . at [ campsite_id , \"attributes\" ] except LookupError : attributes = None equipment = cls . _items_to_unique_dicts ( item = equipment ) attributes = cls . _items_to_unique_dicts ( item = attributes ) return equipment , attributes @classmethod def process_campsite_availability ( cls , availability : dict , recreation_area : str , recreation_area_id : int , facility_name : str , facility_id : int , month : datetime , campsite_metadata : pd . DataFrame , ) -> List [ Optional [ AvailableCampsite ]]: \"\"\" Parse the JSON Response and return availabilities Parameters ---------- availability: dict API Response recreation_area: str Name of Recreation Area recreation_area_id: int ID of Recreation Area facility_name: str Campground Facility Name facility_id: int Campground Facility ID month: datetime Month to Process campsite_metadata: pd.DataFrame Metadata Fetched from the Recreation.gov API about the Campsites Returns ------- total_campsite_availability: List[Optional[AvailableCampsite]] Any monthly availabilities \"\"\" total_campsite_availability : List [ Optional [ AvailableCampsite ]] = list () campsite_data = CampsiteAvailabilityResponse ( ** availability ) for campsite_id , site_related_data in campsite_data . campsites . items (): for ( matching_date , availability_status , ) in site_related_data . availabilities . items (): if ( availability_status not in RecreationBookingConfig . CAMPSITE_UNAVAILABLE_STRINGS ): booking_url = ( f \" { RecreationBookingConfig . CAMPSITE_BOOKING_URL } / { campsite_id } \" ) equipment , attributes = cls . _get_equipment_and_attributes ( campsite_id = campsite_id , campsite_metadata = campsite_metadata ) available_campsite = AvailableCampsite ( campsite_id = campsite_id , booking_date = matching_date , booking_end_date = matching_date + timedelta ( days = 1 ), booking_nights = 1 , campsite_site_name = site_related_data . site , campsite_loop_name = site_related_data . loop , campsite_type = site_related_data . campsite_type , campsite_occupancy = ( site_related_data . min_num_people , site_related_data . max_num_people , ), campsite_use_type = site_related_data . type_of_use , availability_status = availability_status , recreation_area = recreation_area , recreation_area_id = recreation_area_id , facility_name = facility_name , facility_id = facility_id , booking_url = booking_url , permitted_equipment = equipment , campsite_attributes = attributes , ) total_campsite_availability . append ( available_campsite ) logger . info ( f \" \\t { logging_utils . get_emoji ( total_campsite_availability ) } \\t \" f \" { len ( total_campsite_availability ) } total sites found in month of \" f \" { month . strftime ( '%B' ) } \" ) return total_campsite_availability def get_campsite_by_id ( self , campsite_id : int ) -> CampsiteResponse : \"\"\" Get a Campsite's Details Parameters ---------- campsite_id: int Returns ------- CampsiteResponse \"\"\" data = self . get_ridb_data ( path = f \" { RIDBConfig . CAMPSITE_API_PATH } / { campsite_id } \" ) try : response = CampsiteResponse ( ** data [ 0 ]) except IndexError : raise ProviderSearchError ( f \"Campsite with ID # { campsite_id } not found.\" ) return response def get_campground_ids_by_campsites ( self , campsite_ids : List [ int ] ) -> Tuple [ List [ int ], List [ CampsiteResponse ]]: \"\"\" Retrieve a list of FacilityIDs, and Facilities from a Campsite ID List Parameters ---------- campsite_ids: List[int] List of Campsite IDs Returns ------- Tuple[List[int], List[CampsiteResponse]] \"\"\" campground_ids = list () campgrounds = list () for campsite_id in campsite_ids : campsite = self . get_campsite_by_id ( campsite_id = campsite_id ) campgrounds . append ( campsite ) campground_ids . append ( campsite . FacilityID ) return list ( set ( campground_ids )), list ( campgrounds ) def _process_specific_campsites_provided ( self , campsite_id : List [ int ] = None ) -> List [ CampgroundFacility ]: \"\"\" Process Requests for Campgrounds into Facilities Parameters ---------- campsite_id: Optional[List[int]] Returns ------- List[CampgroundFacility] \"\"\" facility_ids , campsites = self . get_campground_ids_by_campsites ( campsite_ids = campsite_id ) facilities = list () for campsite in campsites : facility = self . _find_facilities_from_campgrounds ( campground_id = [ campsite . FacilityID ] )[ 0 ] facilities . append ( facility ) logger . info ( \"Searching Specific Campsite: \u26fa\ufe0f \" f \" { campsite . CampsiteName } (# { campsite . CampsiteID } ) - \" f \" { facility . facility_name } , { facility . recreation_area } \" ) return facilities def get_internal_campsite_metadata ( self , facility_ids : List [ int ]) -> pd . DataFrame : \"\"\" Retrieve Metadata About all of the underlying Campsites to Search \"\"\" all_campsites : List [ RecDotGovCampsite ] = [] for facility_id in facility_ids : all_campsites += self . paginate_recdotgov_campsites ( facility_id = facility_id ) all_campsite_df = pd . DataFrame ( [ item . dict () for item in all_campsites ], columns = RecDotGovCampsite . __fields__ , ) all_campsite_df . set_index ( \"campsite_id\" , inplace = True ) return all_campsite_df __init__ ( api_key = None ) # Initialize with Search Dates Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 48 49 50 51 52 53 54 55 56 57 58 def __init__ ( self , api_key : str = None ): \"\"\" Initialize with Search Dates \"\"\" if api_key is None : _api_key = RIDBConfig . API_KEY if isinstance ( _api_key , bytes ): _api_key : str = b64decode ( RIDBConfig . API_KEY ) . decode ( \"utf-8\" ) else : _api_key : str = api_key self . _ridb_api_headers : dict = dict ( accept = \"application/json\" , apikey = _api_key ) __repr__ () # String Representation Returns # str Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 60 61 62 63 64 65 66 67 68 def __repr__ ( self ): \"\"\" String Representation Returns ------- str \"\"\" return \"<RecreationDotGov>\" find_campgrounds ( search_string = None , rec_area_id = None , campground_id = None , campsite_id = None , ** kwargs ) # Find Bookable Campgrounds Given a Set of Search Criteria Parameters # str Search Keyword(s) Optional[List[int]] Recreation Area ID to filter with Optional[List[int]] ID of the Campground Optional[List[int]] ID of the Campsite Returns # List[CampgroundFacility] Array of Matching Campsites Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def find_campgrounds ( self , search_string : str = None , rec_area_id : Optional [ List [ int ]] = None , campground_id : Optional [ List [ int ]] = None , campsite_id : Optional [ List [ int ]] = None , ** kwargs , ) -> List [ CampgroundFacility ]: \"\"\" Find Bookable Campgrounds Given a Set of Search Criteria Parameters ---------- search_string: str Search Keyword(s) rec_area_id: Optional[List[int]] Recreation Area ID to filter with campground_id: Optional[List[int]] ID of the Campground campsite_id: Optional[List[int]] ID of the Campsite Returns ------- facilities: List[CampgroundFacility] Array of Matching Campsites \"\"\" if campsite_id not in ( None , [], ()): facilities = self . _process_specific_campsites_provided ( campsite_id = campsite_id ) elif campground_id not in ( None , [], ()): facilities = self . _find_facilities_from_campgrounds ( campground_id = campground_id ) elif rec_area_id not in ( None , [], ()): facilities = list () for recreation_area in rec_area_id : facilities += self . find_facilities_per_recreation_area ( rec_area_id = recreation_area ) else : state_arg = kwargs . get ( \"state\" , None ) if state_arg is not None : kwargs . update ({ \"state\" : state_arg . upper ()}) if search_string in [ \"\" , None ] and state_arg is None : raise RuntimeError ( \"You must provide a search query or state to find campsites\" ) facilities = self . _find_facilities_from_search ( search = search_string , ** kwargs ) return facilities find_facilities_per_recreation_area ( rec_area_id = None , ** kwargs ) # Find Matching Campsites Based from Recreation Area Parameters # int Recreation Area ID Returns # List[CampgroundFacility] Array of Matching Campsites Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 def find_facilities_per_recreation_area ( self , rec_area_id : int = None , ** kwargs ) -> List [ CampgroundFacility ]: \"\"\" Find Matching Campsites Based from Recreation Area Parameters ---------- rec_area_id: int Recreation Area ID Returns ------- campgrounds: List[CampgroundFacility] Array of Matching Campsites \"\"\" logger . info ( f \"Retrieving Facility Information for Recreation Area ID: ` { rec_area_id } `.\" ) api_path = f \" { RIDBConfig . REC_AREA_API_PATH } / { rec_area_id } / { RIDBConfig . FACILITIES_API_PATH } \" api_response = self . _ridb_get_paginate ( path = api_path , params = dict ( full = \"true\" , ** kwargs ) ) filtered_facilities = self . _filter_facilities_responses ( responses = api_response ) campgrounds = list () logger . info ( f \" { len ( filtered_facilities ) } Matching Campgrounds Found\" ) for facility in filtered_facilities : _ , campground_facility = self . process_facilities_responses ( facility = facility ) if campground_facility is not None : campgrounds . append ( campground_facility ) log_sorted_response ( response_array = campgrounds ) return campgrounds find_recreation_areas ( search_string = None , ** kwargs ) # Find Matching Campsites Based on Search String Parameters # str Search Keyword(s) Returns # List[dict] Array of Matching Campsites Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def find_recreation_areas ( self , search_string : str = None , ** kwargs ) -> List [ dict ]: \"\"\" Find Matching Campsites Based on Search String Parameters ---------- search_string: str Search Keyword(s) Returns ------- filtered_responses: List[dict] Array of Matching Campsites \"\"\" try : assert any ( [ kwargs . get ( \"state\" , None ) is not None , search_string is not None and search_string != \"\" , ] ) except AssertionError : raise RuntimeError ( \"You must provide a search query or state(s) \" \"to find Recreation Areas\" ) logger . info ( f 'Searching for Recreation Areas: \" { search_string } \"' ) state_arg = kwargs . get ( \"state\" , None ) if state_arg is not None : kwargs . update ({ \"state\" : state_arg . upper ()}) params = dict ( query = search_string , sort = \"Name\" , full = \"true\" , ** kwargs ) if search_string is None : params . pop ( \"query\" ) api_response = self . _ridb_get_paginate ( path = RIDBConfig . REC_AREA_API_PATH , params = params ) logger . info ( f \" { len ( api_response ) } recreation areas found.\" ) logging_messages = list () for recreation_area_object in api_response : _ , recreation_area = self . _process_rec_area_response ( recreation_area = recreation_area_object ) if recreation_area is not None : logging_messages . append ( recreation_area ) log_sorted_response ( response_array = logging_messages ) return api_response get_campground_ids_by_campsites ( campsite_ids ) # Retrieve a list of FacilityIDs, and Facilities from a Campsite ID List Parameters # List[int] List of Campsite IDs Returns # Tuple[List[int], List[CampsiteResponse]] Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 def get_campground_ids_by_campsites ( self , campsite_ids : List [ int ] ) -> Tuple [ List [ int ], List [ CampsiteResponse ]]: \"\"\" Retrieve a list of FacilityIDs, and Facilities from a Campsite ID List Parameters ---------- campsite_ids: List[int] List of Campsite IDs Returns ------- Tuple[List[int], List[CampsiteResponse]] \"\"\" campground_ids = list () campgrounds = list () for campsite_id in campsite_ids : campsite = self . get_campsite_by_id ( campsite_id = campsite_id ) campgrounds . append ( campsite ) campground_ids . append ( campsite . FacilityID ) return list ( set ( campground_ids )), list ( campgrounds ) get_campsite_by_id ( campsite_id ) # Get a Campsite's Details Parameters # campsite_id: int Returns # CampsiteResponse Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 def get_campsite_by_id ( self , campsite_id : int ) -> CampsiteResponse : \"\"\" Get a Campsite's Details Parameters ---------- campsite_id: int Returns ------- CampsiteResponse \"\"\" data = self . get_ridb_data ( path = f \" { RIDBConfig . CAMPSITE_API_PATH } / { campsite_id } \" ) try : response = CampsiteResponse ( ** data [ 0 ]) except IndexError : raise ProviderSearchError ( f \"Campsite with ID # { campsite_id } not found.\" ) return response get_internal_campsite_metadata ( facility_ids ) # Retrieve Metadata About all of the underlying Campsites to Search Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 866 867 868 869 870 871 872 873 874 875 876 877 878 def get_internal_campsite_metadata ( self , facility_ids : List [ int ]) -> pd . DataFrame : \"\"\" Retrieve Metadata About all of the underlying Campsites to Search \"\"\" all_campsites : List [ RecDotGovCampsite ] = [] for facility_id in facility_ids : all_campsites += self . paginate_recdotgov_campsites ( facility_id = facility_id ) all_campsite_df = pd . DataFrame ( [ item . dict () for item in all_campsites ], columns = RecDotGovCampsite . __fields__ , ) all_campsite_df . set_index ( \"campsite_id\" , inplace = True ) return all_campsite_df get_recdotgov_data ( campground_id , month ) # Find Campsite Availability Data Parameters # int Campground ID from the RIDB API. Can also be pulled of URLs on Recreation.gov datetime datetime object, results will be filtered to month Returns # Union[dict, list] Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 def get_recdotgov_data ( self , campground_id : int , month : datetime ) -> Union [ dict , list ]: \"\"\" Find Campsite Availability Data Parameters ---------- campground_id: int Campground ID from the RIDB API. Can also be pulled of URLs on Recreation.gov month: datetime datetime object, results will be filtered to month Returns ------- Union[dict, list] \"\"\" try : response = self . _make_recdotgov_availability_request ( campground_id = campground_id , month = month ) except tenacity . RetryError : raise RuntimeError ( \"Something went wrong in fetching data from the \" \"RecreationDotGov API.\" ) return loads ( response . content ) get_ridb_data ( path , params = None ) # Find Matching Campsites Based on Search String Parameters # str URL Endpoint, see https://ridb.recreation.gov/docs Returns # Union[dict, list] Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 @tenacity . retry ( wait = tenacity . wait_random_exponential ( multiplier = 2 , max = 10 ), stop = tenacity . stop . stop_after_delay ( 15 ), ) def get_ridb_data ( self , path : str , params : Optional [ dict ] = None ) -> Union [ dict , list ]: \"\"\" Find Matching Campsites Based on Search String Parameters ---------- path: str URL Endpoint, see https://ridb.recreation.gov/docs params: Optional[dict] API Call Parameters Returns ------- Union[dict, list] \"\"\" api_endpoint = self . _ridb_get_endpoint ( path = path ) headers = self . _ridb_api_headers . copy () headers . update ( choice ( USER_AGENTS )) response = requests . get ( url = api_endpoint , headers = headers , params = params , timeout = 30 ) try : assert response . status_code == 200 except AssertionError : error_message = ( f \"Receiving bad data from Recreation.gov API: { response . text } \" ) logger . error ( error_message ) raise ConnectionError ( error_message ) return loads ( response . content ) make_recdotgov_request ( url , method = 'GET' , params = None , ** kwargs ) classmethod # Make a Raw Request to RecreationDotGov Parameters # url: str method: str Returns # requests.Response Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 @classmethod def make_recdotgov_request ( cls , url : str , method : str = \"GET\" , params : Optional [ Dict [ str , Any ]] = None , ** kwargs , ) -> requests . Response : \"\"\" Make a Raw Request to RecreationDotGov Parameters ---------- url: str method: str params: Optional[Dict[str, Any]] Returns ------- requests.Response \"\"\" # BUILD THE HEADERS EXPECTED FROM THE API headers = STANDARD_HEADERS . copy () headers . update ( choice ( USER_AGENTS )) headers . update ( RecreationBookingConfig . API_REFERRERS ) response = requests . request ( method = method , url = url , headers = headers , params = params , timeout = 30 , ** kwargs ) return response make_recdotgov_request_retry ( url , method = 'GET' , params = None , ** kwargs ) classmethod # Make a Raw Request to RecreationDotGov - But Handle 404 Parameters # url: str method: str Returns # requests.Response Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 @classmethod @tenacity . retry ( wait = tenacity . wait_random_exponential ( multiplier = 2 , max = 10 ), stop = tenacity . stop . stop_after_delay ( 15 ), ) def make_recdotgov_request_retry ( cls , url : str , method : str = \"GET\" , params : Optional [ Dict [ str , Any ]] = None , ** kwargs , ) -> requests . Response : \"\"\" Make a Raw Request to RecreationDotGov - But Handle 404 Parameters ---------- url: str method: str params: Optional[Dict[str, Any]] Returns ------- requests.Response \"\"\" response = cls . make_recdotgov_request ( url = url , method = method , params = params , ** kwargs ) response . raise_for_status () return response paginate_recdotgov_campsites ( facility_id , equipment = None ) # Paginate through the RecDotGov Campsite Metadata Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 def paginate_recdotgov_campsites ( self , facility_id : int , equipment : Optional [ List [ str ]] = None ) -> List [ RecDotGovCampsite ]: \"\"\" Paginate through the RecDotGov Campsite Metadata \"\"\" results = 0 continue_paginate = True endpoint_url = api_utils . generate_url ( scheme = RecreationBookingConfig . API_SCHEME , netloc = RecreationBookingConfig . API_NET_LOC , path = \"api/search/campsites\" , ) fq_list = [ f \"asset_id: { facility_id } \" ] if isinstance ( equipment , list ) and len ( equipment ) > 0 : for item in equipment : fq_list . append ( f \"campsite_equipment_name: { item } \" ) params = dict ( start = 0 , size = 1000 , fq = fq_list , include_non_site_specific_campsites = True , ) campsites = [] while continue_paginate is True : response = self . make_recdotgov_request_retry ( method = \"GET\" , url = endpoint_url , params = params , ) returned_data = json . loads ( response . content ) campsite_response = RecDotGovCampsiteResponse ( ** returned_data ) campsites += campsite_response . campsites results += campsite_response . size params . update ( start = results ) if results == campsite_response . total : continue_paginate = False return campsites process_campsite_availability ( availability , recreation_area , recreation_area_id , facility_name , facility_id , month , campsite_metadata ) classmethod # Parse the JSON Response and return availabilities Parameters # dict API Response str Name of Recreation Area int ID of Recreation Area str Campground Facility Name int Campground Facility ID datetime Month to Process pd.DataFrame Metadata Fetched from the Recreation.gov API about the Campsites Returns # List[Optional[AvailableCampsite]] Any monthly availabilities Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 @classmethod def process_campsite_availability ( cls , availability : dict , recreation_area : str , recreation_area_id : int , facility_name : str , facility_id : int , month : datetime , campsite_metadata : pd . DataFrame , ) -> List [ Optional [ AvailableCampsite ]]: \"\"\" Parse the JSON Response and return availabilities Parameters ---------- availability: dict API Response recreation_area: str Name of Recreation Area recreation_area_id: int ID of Recreation Area facility_name: str Campground Facility Name facility_id: int Campground Facility ID month: datetime Month to Process campsite_metadata: pd.DataFrame Metadata Fetched from the Recreation.gov API about the Campsites Returns ------- total_campsite_availability: List[Optional[AvailableCampsite]] Any monthly availabilities \"\"\" total_campsite_availability : List [ Optional [ AvailableCampsite ]] = list () campsite_data = CampsiteAvailabilityResponse ( ** availability ) for campsite_id , site_related_data in campsite_data . campsites . items (): for ( matching_date , availability_status , ) in site_related_data . availabilities . items (): if ( availability_status not in RecreationBookingConfig . CAMPSITE_UNAVAILABLE_STRINGS ): booking_url = ( f \" { RecreationBookingConfig . CAMPSITE_BOOKING_URL } / { campsite_id } \" ) equipment , attributes = cls . _get_equipment_and_attributes ( campsite_id = campsite_id , campsite_metadata = campsite_metadata ) available_campsite = AvailableCampsite ( campsite_id = campsite_id , booking_date = matching_date , booking_end_date = matching_date + timedelta ( days = 1 ), booking_nights = 1 , campsite_site_name = site_related_data . site , campsite_loop_name = site_related_data . loop , campsite_type = site_related_data . campsite_type , campsite_occupancy = ( site_related_data . min_num_people , site_related_data . max_num_people , ), campsite_use_type = site_related_data . type_of_use , availability_status = availability_status , recreation_area = recreation_area , recreation_area_id = recreation_area_id , facility_name = facility_name , facility_id = facility_id , booking_url = booking_url , permitted_equipment = equipment , campsite_attributes = attributes , ) total_campsite_availability . append ( available_campsite ) logger . info ( f \" \\t { logging_utils . get_emoji ( total_campsite_availability ) } \\t \" f \" { len ( total_campsite_availability ) } total sites found in month of \" f \" { month . strftime ( '%B' ) } \" ) return total_campsite_availability process_facilities_responses ( facility ) classmethod # Process Facilities Responses to be More Usable Parameters # facility: dict Returns # Tuple[dict, CampgroundFacility] Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 @classmethod def process_facilities_responses ( cls , facility : dict ) -> Tuple [ dict , Optional [ CampgroundFacility ]]: \"\"\" Process Facilities Responses to be More Usable Parameters ---------- facility: dict Returns ------- Tuple[dict, CampgroundFacility] \"\"\" facility_object = FacilityResponse ( ** facility ) try : facility_state = facility_object . FACILITYADDRESS [ 0 ] . AddressStateCode . upper () except ( KeyError , IndexError ): facility_state = \"USA\" try : if len ( facility_object . RECAREA ) == 0 : recreation_area_id = facility_object . ParentRecAreaID formatted_recreation_area = ( f \" { facility_object . ORGANIZATION [ 0 ] . OrgName } , { facility_state } \" ) else : recreation_area = facility_object . RECAREA [ 0 ] . RecAreaName recreation_area_id = facility_object . RECAREA [ 0 ] . RecAreaID formatted_recreation_area = f \" { recreation_area } , { facility_state } \" campground_facility = CampgroundFacility ( facility_name = facility_object . FacilityName . title (), recreation_area = formatted_recreation_area , facility_id = facility_object . FacilityID , recreation_area_id = recreation_area_id , ) return facility , campground_facility except ( KeyError , IndexError ): return facility , None","title":"recdotgov_provider"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov","text":"Bases: BaseProvider Python Class for Working with Recreation.gov API / NPS APIs Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 class RecreationDotGov ( BaseProvider ): \"\"\" Python Class for Working with Recreation.gov API / NPS APIs \"\"\" def __init__ ( self , api_key : str = None ): \"\"\" Initialize with Search Dates \"\"\" if api_key is None : _api_key = RIDBConfig . API_KEY if isinstance ( _api_key , bytes ): _api_key : str = b64decode ( RIDBConfig . API_KEY ) . decode ( \"utf-8\" ) else : _api_key : str = api_key self . _ridb_api_headers : dict = dict ( accept = \"application/json\" , apikey = _api_key ) def __repr__ ( self ): \"\"\" String Representation Returns ------- str \"\"\" return \"<RecreationDotGov>\" def find_recreation_areas ( self , search_string : str = None , ** kwargs ) -> List [ dict ]: \"\"\" Find Matching Campsites Based on Search String Parameters ---------- search_string: str Search Keyword(s) Returns ------- filtered_responses: List[dict] Array of Matching Campsites \"\"\" try : assert any ( [ kwargs . get ( \"state\" , None ) is not None , search_string is not None and search_string != \"\" , ] ) except AssertionError : raise RuntimeError ( \"You must provide a search query or state(s) \" \"to find Recreation Areas\" ) logger . info ( f 'Searching for Recreation Areas: \" { search_string } \"' ) state_arg = kwargs . get ( \"state\" , None ) if state_arg is not None : kwargs . update ({ \"state\" : state_arg . upper ()}) params = dict ( query = search_string , sort = \"Name\" , full = \"true\" , ** kwargs ) if search_string is None : params . pop ( \"query\" ) api_response = self . _ridb_get_paginate ( path = RIDBConfig . REC_AREA_API_PATH , params = params ) logger . info ( f \" { len ( api_response ) } recreation areas found.\" ) logging_messages = list () for recreation_area_object in api_response : _ , recreation_area = self . _process_rec_area_response ( recreation_area = recreation_area_object ) if recreation_area is not None : logging_messages . append ( recreation_area ) log_sorted_response ( response_array = logging_messages ) return api_response def find_campgrounds ( self , search_string : str = None , rec_area_id : Optional [ List [ int ]] = None , campground_id : Optional [ List [ int ]] = None , campsite_id : Optional [ List [ int ]] = None , ** kwargs , ) -> List [ CampgroundFacility ]: \"\"\" Find Bookable Campgrounds Given a Set of Search Criteria Parameters ---------- search_string: str Search Keyword(s) rec_area_id: Optional[List[int]] Recreation Area ID to filter with campground_id: Optional[List[int]] ID of the Campground campsite_id: Optional[List[int]] ID of the Campsite Returns ------- facilities: List[CampgroundFacility] Array of Matching Campsites \"\"\" if campsite_id not in ( None , [], ()): facilities = self . _process_specific_campsites_provided ( campsite_id = campsite_id ) elif campground_id not in ( None , [], ()): facilities = self . _find_facilities_from_campgrounds ( campground_id = campground_id ) elif rec_area_id not in ( None , [], ()): facilities = list () for recreation_area in rec_area_id : facilities += self . find_facilities_per_recreation_area ( rec_area_id = recreation_area ) else : state_arg = kwargs . get ( \"state\" , None ) if state_arg is not None : kwargs . update ({ \"state\" : state_arg . upper ()}) if search_string in [ \"\" , None ] and state_arg is None : raise RuntimeError ( \"You must provide a search query or state to find campsites\" ) facilities = self . _find_facilities_from_search ( search = search_string , ** kwargs ) return facilities def find_facilities_per_recreation_area ( self , rec_area_id : int = None , ** kwargs ) -> List [ CampgroundFacility ]: \"\"\" Find Matching Campsites Based from Recreation Area Parameters ---------- rec_area_id: int Recreation Area ID Returns ------- campgrounds: List[CampgroundFacility] Array of Matching Campsites \"\"\" logger . info ( f \"Retrieving Facility Information for Recreation Area ID: ` { rec_area_id } `.\" ) api_path = f \" { RIDBConfig . REC_AREA_API_PATH } / { rec_area_id } / { RIDBConfig . FACILITIES_API_PATH } \" api_response = self . _ridb_get_paginate ( path = api_path , params = dict ( full = \"true\" , ** kwargs ) ) filtered_facilities = self . _filter_facilities_responses ( responses = api_response ) campgrounds = list () logger . info ( f \" { len ( filtered_facilities ) } Matching Campgrounds Found\" ) for facility in filtered_facilities : _ , campground_facility = self . process_facilities_responses ( facility = facility ) if campground_facility is not None : campgrounds . append ( campground_facility ) log_sorted_response ( response_array = campgrounds ) return campgrounds def _find_facilities_from_campgrounds ( self , campground_id : Union [ int , List [ int ]] ) -> List [ CampgroundFacility ]: \"\"\" Find Matching Campsites from Campground ID Parameters ---------- campground_id: Union[int, List[int]] ID of the Campsite Returns ------- filtered_responses: List[CampgroundFacility] Array of Matching Campsites \"\"\" campgrounds = list () for campground_identifier in campground_id : facility_data = self . get_ridb_data ( path = f \" { RIDBConfig . FACILITIES_API_PATH } / { campground_identifier } \" , params = dict ( full = True ), ) filtered_facility = self . _filter_facilities_responses ( responses = [ facility_data ] ) _ , campground_facility = self . process_facilities_responses ( facility = filtered_facility [ 0 ] ) if campground_facility is not None : campgrounds . append ( campground_facility ) logger . info ( f \" { len ( campgrounds ) } Matching Campgrounds Found\" ) log_sorted_response ( response_array = campgrounds ) return campgrounds def _find_facilities_from_search ( self , search : str , ** kwargs ) -> List [ dict ]: \"\"\" Find Matching Campgrounds Based on Search String Parameters ---------- search: str Search String Returns ------- campgrounds: List[dict] Array of Matching Campsites \"\"\" facilities_response = self . _ridb_get_paginate ( path = RIDBConfig . FACILITIES_API_PATH , params = dict ( query = search , activity = \"CAMPING\" , full = \"true\" , ** kwargs ), ) filtered_responses = self . _filter_facilities_responses ( responses = facilities_response ) logger . info ( f \" { len ( filtered_responses ) } Matching Campgrounds Found\" ) campgrounds = list () for facility in filtered_responses : _ , campground_facility = self . process_facilities_responses ( facility = facility ) if campground_facility is not None : campgrounds . append ( campground_facility ) log_sorted_response ( response_array = campgrounds ) return campgrounds @classmethod def _ridb_get_endpoint ( cls , path : str ) -> str : \"\"\" Return an API Endpoint for the RIDP Parameters ---------- path: str URL Endpoint, see https://ridb.recreation.gov/docs Returns ------- endpoint_url: str URL for the API Endpoint \"\"\" assert RIDBConfig . RIDB_BASE_PATH . endswith ( \"/\" ) base_url = api_utils . generate_url ( scheme = RIDBConfig . RIDB_SCHEME , netloc = RIDBConfig . RIDB_NET_LOC , path = RIDBConfig . RIDB_BASE_PATH , ) endpoint_url = parse . urljoin ( base_url , path ) return endpoint_url @tenacity . retry ( wait = tenacity . wait_random_exponential ( multiplier = 2 , max = 10 ), stop = tenacity . stop . stop_after_delay ( 15 ), ) def get_ridb_data ( self , path : str , params : Optional [ dict ] = None ) -> Union [ dict , list ]: \"\"\" Find Matching Campsites Based on Search String Parameters ---------- path: str URL Endpoint, see https://ridb.recreation.gov/docs params: Optional[dict] API Call Parameters Returns ------- Union[dict, list] \"\"\" api_endpoint = self . _ridb_get_endpoint ( path = path ) headers = self . _ridb_api_headers . copy () headers . update ( choice ( USER_AGENTS )) response = requests . get ( url = api_endpoint , headers = headers , params = params , timeout = 30 ) try : assert response . status_code == 200 except AssertionError : error_message = ( f \"Receiving bad data from Recreation.gov API: { response . text } \" ) logger . error ( error_message ) raise ConnectionError ( error_message ) return loads ( response . content ) def _ridb_get_paginate ( self , path : str , params : Optional [ dict ] = None , ) -> List [ dict ]: \"\"\" Return the Paginated Response from the RIDP Parameters ---------- path: str URL Endpoint, see https://ridb.recreation.gov/docs params: Optional[dict] API Call Parameters Returns ------- paginated_response: list Concatted Response \"\"\" if params is None : params = {} paginated_response = list () data_incomplete = True offset : int = 0 historical_results = 0 while data_incomplete is True : params . update ( offset = offset ) data_response = self . get_ridb_data ( path = path , params = params ) response_object = GenericResponse ( ** data_response ) paginated_response += response_object . RECDATA result_count = response_object . METADATA . RESULTS . CURRENT_COUNT historical_results += result_count total_count = response_object . METADATA . RESULTS . TOTAL_COUNT if offset >= 500 : logger . info ( f \"Too Many Results returned ( { total_count } ), \" \"try performing a more specific search\" ) data_incomplete = False elif historical_results < total_count : offset = historical_results else : data_incomplete = False return paginated_response @classmethod def _filter_facilities_responses ( cls , responses = List [ dict ]) -> List [ dict ]: \"\"\" Filter Facilities to Actual Reservable Campsites Parameters ---------- responses Returns ------- List[dict] \"\"\" filtered_responses = list () for possible_match in responses : try : facility = FacilityResponse ( ** possible_match ) except ValidationError as e : logger . error ( \"That doesn't look like a valid Campground Facility\" ) logger . error ( json . dumps ( possible_match )) logger . exception ( e ) raise ProviderSearchError ( \"Invalid Campground Facility Returned\" ) if all ( [ facility . FacilityTypeDescription == RIDBConfig . CAMPGROUND_FACILITY_FIELD_QUALIFIER , facility . Enabled is True , facility . Reservable is True , ] ): filtered_responses . append ( possible_match ) return filtered_responses @classmethod def process_facilities_responses ( cls , facility : dict ) -> Tuple [ dict , Optional [ CampgroundFacility ]]: \"\"\" Process Facilities Responses to be More Usable Parameters ---------- facility: dict Returns ------- Tuple[dict, CampgroundFacility] \"\"\" facility_object = FacilityResponse ( ** facility ) try : facility_state = facility_object . FACILITYADDRESS [ 0 ] . AddressStateCode . upper () except ( KeyError , IndexError ): facility_state = \"USA\" try : if len ( facility_object . RECAREA ) == 0 : recreation_area_id = facility_object . ParentRecAreaID formatted_recreation_area = ( f \" { facility_object . ORGANIZATION [ 0 ] . OrgName } , { facility_state } \" ) else : recreation_area = facility_object . RECAREA [ 0 ] . RecAreaName recreation_area_id = facility_object . RECAREA [ 0 ] . RecAreaID formatted_recreation_area = f \" { recreation_area } , { facility_state } \" campground_facility = CampgroundFacility ( facility_name = facility_object . FacilityName . title (), recreation_area = formatted_recreation_area , facility_id = facility_object . FacilityID , recreation_area_id = recreation_area_id , ) return facility , campground_facility except ( KeyError , IndexError ): return facility , None @classmethod def _process_rec_area_response ( cls , recreation_area = dict ) -> Tuple [ dict , Optional [ RecreationArea ]]: \"\"\" Process Rec Area Responses to be More Usable Parameters ---------- recreation_area: dict Returns ------- Tuple[dict, RecreationArea] \"\"\" rec_area_response = RecreationAreaResponse ( ** recreation_area ) try : recreation_area_location = rec_area_response . RECAREAADDRESS [ 0 ] . AddressStateCode recreation_area_tuple = RecreationArea ( recreation_area = rec_area_response . RecAreaName , recreation_area_id = rec_area_response . RecAreaID , recreation_area_location = recreation_area_location , ) return recreation_area , recreation_area_tuple except IndexError : return recreation_area , None @classmethod def _rec_availability_get_endpoint ( cls , path : str ) -> str : \"\"\" Return an API Endpoint for the Recreation.gov Campground Availability API Parameters ---------- path: str URL Endpoint Path Returns ------- endpoint_url: str URL for the API Endpoint \"\"\" base_url = api_utils . generate_url ( scheme = RecreationBookingConfig . API_SCHEME , netloc = RecreationBookingConfig . API_NET_LOC , path = RecreationBookingConfig . API_BASE_PATH , ) endpoint_url = parse . urljoin ( base_url , path ) return endpoint_url @classmethod def make_recdotgov_request ( cls , url : str , method : str = \"GET\" , params : Optional [ Dict [ str , Any ]] = None , ** kwargs , ) -> requests . Response : \"\"\" Make a Raw Request to RecreationDotGov Parameters ---------- url: str method: str params: Optional[Dict[str, Any]] Returns ------- requests.Response \"\"\" # BUILD THE HEADERS EXPECTED FROM THE API headers = STANDARD_HEADERS . copy () headers . update ( choice ( USER_AGENTS )) headers . update ( RecreationBookingConfig . API_REFERRERS ) response = requests . request ( method = method , url = url , headers = headers , params = params , timeout = 30 , ** kwargs ) return response @classmethod @tenacity . retry ( wait = tenacity . wait_random_exponential ( multiplier = 2 , max = 10 ), stop = tenacity . stop . stop_after_delay ( 15 ), ) def make_recdotgov_request_retry ( cls , url : str , method : str = \"GET\" , params : Optional [ Dict [ str , Any ]] = None , ** kwargs , ) -> requests . Response : \"\"\" Make a Raw Request to RecreationDotGov - But Handle 404 Parameters ---------- url: str method: str params: Optional[Dict[str, Any]] Returns ------- requests.Response \"\"\" response = cls . make_recdotgov_request ( url = url , method = method , params = params , ** kwargs ) response . raise_for_status () return response def paginate_recdotgov_campsites ( self , facility_id : int , equipment : Optional [ List [ str ]] = None ) -> List [ RecDotGovCampsite ]: \"\"\" Paginate through the RecDotGov Campsite Metadata \"\"\" results = 0 continue_paginate = True endpoint_url = api_utils . generate_url ( scheme = RecreationBookingConfig . API_SCHEME , netloc = RecreationBookingConfig . API_NET_LOC , path = \"api/search/campsites\" , ) fq_list = [ f \"asset_id: { facility_id } \" ] if isinstance ( equipment , list ) and len ( equipment ) > 0 : for item in equipment : fq_list . append ( f \"campsite_equipment_name: { item } \" ) params = dict ( start = 0 , size = 1000 , fq = fq_list , include_non_site_specific_campsites = True , ) campsites = [] while continue_paginate is True : response = self . make_recdotgov_request_retry ( method = \"GET\" , url = endpoint_url , params = params , ) returned_data = json . loads ( response . content ) campsite_response = RecDotGovCampsiteResponse ( ** returned_data ) campsites += campsite_response . campsites results += campsite_response . size params . update ( start = results ) if results == campsite_response . total : continue_paginate = False return campsites @tenacity . retry ( wait = tenacity . wait_random_exponential ( multiplier = 3 , max = 1800 ), stop = tenacity . stop . stop_after_delay ( 6000 ), ) def _make_recdotgov_availability_request ( self , campground_id : int , month : datetime , ) -> requests . Response : \"\"\" Make a request to the RecreationDotGov API - Handle Exponential Backoff Parameters ---------- campground_id month Returns ------- requests.Response \"\"\" try : api_endpoint = self . _rec_availability_get_endpoint ( path = f \" { campground_id } / { RecreationBookingConfig . API_MONTH_PATH } \" ) formatted_month = month . strftime ( \"%Y-%m-01T00:00:00.000Z\" ) query_params = dict ( start_date = formatted_month ) response = self . make_recdotgov_request ( method = \"GET\" , url = api_endpoint , params = query_params , ) assert response . status_code == 200 except AssertionError : response_error = response . text error_message = \"Bad Data Returned from the RecreationDotGov API\" logger . debug ( f \" { error_message } , will continue to retry\" ) logger . debug ( f \"Error Details: { response_error } \" ) raise ConnectionError ( f \" { error_message } : { response_error } \" ) return response def get_recdotgov_data ( self , campground_id : int , month : datetime ) -> Union [ dict , list ]: \"\"\" Find Campsite Availability Data Parameters ---------- campground_id: int Campground ID from the RIDB API. Can also be pulled of URLs on Recreation.gov month: datetime datetime object, results will be filtered to month Returns ------- Union[dict, list] \"\"\" try : response = self . _make_recdotgov_availability_request ( campground_id = campground_id , month = month ) except tenacity . RetryError : raise RuntimeError ( \"Something went wrong in fetching data from the \" \"RecreationDotGov API.\" ) return loads ( response . content ) @classmethod def _items_to_unique_dicts ( cls , item : Union [ List [ Dict [ str , Any ]], pd . Series ] ) -> List [ Dict [ str , Any ]]: \"\"\" Ensure the proper items are parsed for equipment and attributes \"\"\" if isinstance ( item , pd . Series ): list_of_dicts = list ( chain . from_iterable ( item . tolist ())) unique_list_of_dicts = [ dict ( s ) for s in set ( frozenset ( d . items ()) for d in list_of_dicts ) ] return unique_list_of_dicts else : return item @classmethod def _get_equipment_and_attributes ( cls , campsite_id : int , campsite_metadata : pd . DataFrame , ) -> Tuple [ List [ Dict [ str , Any ]], List [ Dict [ str , Any ]]]: \"\"\" Index a DataFrame in a Complicated Way \"\"\" try : equipment = campsite_metadata . at [ campsite_id , \"permitted_equipment\" ] except LookupError : equipment = None try : attributes = campsite_metadata . at [ campsite_id , \"attributes\" ] except LookupError : attributes = None equipment = cls . _items_to_unique_dicts ( item = equipment ) attributes = cls . _items_to_unique_dicts ( item = attributes ) return equipment , attributes @classmethod def process_campsite_availability ( cls , availability : dict , recreation_area : str , recreation_area_id : int , facility_name : str , facility_id : int , month : datetime , campsite_metadata : pd . DataFrame , ) -> List [ Optional [ AvailableCampsite ]]: \"\"\" Parse the JSON Response and return availabilities Parameters ---------- availability: dict API Response recreation_area: str Name of Recreation Area recreation_area_id: int ID of Recreation Area facility_name: str Campground Facility Name facility_id: int Campground Facility ID month: datetime Month to Process campsite_metadata: pd.DataFrame Metadata Fetched from the Recreation.gov API about the Campsites Returns ------- total_campsite_availability: List[Optional[AvailableCampsite]] Any monthly availabilities \"\"\" total_campsite_availability : List [ Optional [ AvailableCampsite ]] = list () campsite_data = CampsiteAvailabilityResponse ( ** availability ) for campsite_id , site_related_data in campsite_data . campsites . items (): for ( matching_date , availability_status , ) in site_related_data . availabilities . items (): if ( availability_status not in RecreationBookingConfig . CAMPSITE_UNAVAILABLE_STRINGS ): booking_url = ( f \" { RecreationBookingConfig . CAMPSITE_BOOKING_URL } / { campsite_id } \" ) equipment , attributes = cls . _get_equipment_and_attributes ( campsite_id = campsite_id , campsite_metadata = campsite_metadata ) available_campsite = AvailableCampsite ( campsite_id = campsite_id , booking_date = matching_date , booking_end_date = matching_date + timedelta ( days = 1 ), booking_nights = 1 , campsite_site_name = site_related_data . site , campsite_loop_name = site_related_data . loop , campsite_type = site_related_data . campsite_type , campsite_occupancy = ( site_related_data . min_num_people , site_related_data . max_num_people , ), campsite_use_type = site_related_data . type_of_use , availability_status = availability_status , recreation_area = recreation_area , recreation_area_id = recreation_area_id , facility_name = facility_name , facility_id = facility_id , booking_url = booking_url , permitted_equipment = equipment , campsite_attributes = attributes , ) total_campsite_availability . append ( available_campsite ) logger . info ( f \" \\t { logging_utils . get_emoji ( total_campsite_availability ) } \\t \" f \" { len ( total_campsite_availability ) } total sites found in month of \" f \" { month . strftime ( '%B' ) } \" ) return total_campsite_availability def get_campsite_by_id ( self , campsite_id : int ) -> CampsiteResponse : \"\"\" Get a Campsite's Details Parameters ---------- campsite_id: int Returns ------- CampsiteResponse \"\"\" data = self . get_ridb_data ( path = f \" { RIDBConfig . CAMPSITE_API_PATH } / { campsite_id } \" ) try : response = CampsiteResponse ( ** data [ 0 ]) except IndexError : raise ProviderSearchError ( f \"Campsite with ID # { campsite_id } not found.\" ) return response def get_campground_ids_by_campsites ( self , campsite_ids : List [ int ] ) -> Tuple [ List [ int ], List [ CampsiteResponse ]]: \"\"\" Retrieve a list of FacilityIDs, and Facilities from a Campsite ID List Parameters ---------- campsite_ids: List[int] List of Campsite IDs Returns ------- Tuple[List[int], List[CampsiteResponse]] \"\"\" campground_ids = list () campgrounds = list () for campsite_id in campsite_ids : campsite = self . get_campsite_by_id ( campsite_id = campsite_id ) campgrounds . append ( campsite ) campground_ids . append ( campsite . FacilityID ) return list ( set ( campground_ids )), list ( campgrounds ) def _process_specific_campsites_provided ( self , campsite_id : List [ int ] = None ) -> List [ CampgroundFacility ]: \"\"\" Process Requests for Campgrounds into Facilities Parameters ---------- campsite_id: Optional[List[int]] Returns ------- List[CampgroundFacility] \"\"\" facility_ids , campsites = self . get_campground_ids_by_campsites ( campsite_ids = campsite_id ) facilities = list () for campsite in campsites : facility = self . _find_facilities_from_campgrounds ( campground_id = [ campsite . FacilityID ] )[ 0 ] facilities . append ( facility ) logger . info ( \"Searching Specific Campsite: \u26fa\ufe0f \" f \" { campsite . CampsiteName } (# { campsite . CampsiteID } ) - \" f \" { facility . facility_name } , { facility . recreation_area } \" ) return facilities def get_internal_campsite_metadata ( self , facility_ids : List [ int ]) -> pd . DataFrame : \"\"\" Retrieve Metadata About all of the underlying Campsites to Search \"\"\" all_campsites : List [ RecDotGovCampsite ] = [] for facility_id in facility_ids : all_campsites += self . paginate_recdotgov_campsites ( facility_id = facility_id ) all_campsite_df = pd . DataFrame ( [ item . dict () for item in all_campsites ], columns = RecDotGovCampsite . __fields__ , ) all_campsite_df . set_index ( \"campsite_id\" , inplace = True ) return all_campsite_df","title":"RecreationDotGov"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.__init__","text":"Initialize with Search Dates Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 48 49 50 51 52 53 54 55 56 57 58 def __init__ ( self , api_key : str = None ): \"\"\" Initialize with Search Dates \"\"\" if api_key is None : _api_key = RIDBConfig . API_KEY if isinstance ( _api_key , bytes ): _api_key : str = b64decode ( RIDBConfig . API_KEY ) . decode ( \"utf-8\" ) else : _api_key : str = api_key self . _ridb_api_headers : dict = dict ( accept = \"application/json\" , apikey = _api_key )","title":"__init__()"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.__repr__","text":"String Representation","title":"__repr__()"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.__repr__--returns","text":"str Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 60 61 62 63 64 65 66 67 68 def __repr__ ( self ): \"\"\" String Representation Returns ------- str \"\"\" return \"<RecreationDotGov>\"","title":"Returns"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.find_campgrounds","text":"Find Bookable Campgrounds Given a Set of Search Criteria","title":"find_campgrounds()"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.find_campgrounds--parameters","text":"str Search Keyword(s) Optional[List[int]] Recreation Area ID to filter with Optional[List[int]] ID of the Campground Optional[List[int]] ID of the Campsite","title":"Parameters"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.find_campgrounds--returns","text":"List[CampgroundFacility] Array of Matching Campsites Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def find_campgrounds ( self , search_string : str = None , rec_area_id : Optional [ List [ int ]] = None , campground_id : Optional [ List [ int ]] = None , campsite_id : Optional [ List [ int ]] = None , ** kwargs , ) -> List [ CampgroundFacility ]: \"\"\" Find Bookable Campgrounds Given a Set of Search Criteria Parameters ---------- search_string: str Search Keyword(s) rec_area_id: Optional[List[int]] Recreation Area ID to filter with campground_id: Optional[List[int]] ID of the Campground campsite_id: Optional[List[int]] ID of the Campsite Returns ------- facilities: List[CampgroundFacility] Array of Matching Campsites \"\"\" if campsite_id not in ( None , [], ()): facilities = self . _process_specific_campsites_provided ( campsite_id = campsite_id ) elif campground_id not in ( None , [], ()): facilities = self . _find_facilities_from_campgrounds ( campground_id = campground_id ) elif rec_area_id not in ( None , [], ()): facilities = list () for recreation_area in rec_area_id : facilities += self . find_facilities_per_recreation_area ( rec_area_id = recreation_area ) else : state_arg = kwargs . get ( \"state\" , None ) if state_arg is not None : kwargs . update ({ \"state\" : state_arg . upper ()}) if search_string in [ \"\" , None ] and state_arg is None : raise RuntimeError ( \"You must provide a search query or state to find campsites\" ) facilities = self . _find_facilities_from_search ( search = search_string , ** kwargs ) return facilities","title":"Returns"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.find_facilities_per_recreation_area","text":"Find Matching Campsites Based from Recreation Area","title":"find_facilities_per_recreation_area()"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.find_facilities_per_recreation_area--parameters","text":"int Recreation Area ID","title":"Parameters"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.find_facilities_per_recreation_area--returns","text":"List[CampgroundFacility] Array of Matching Campsites Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 def find_facilities_per_recreation_area ( self , rec_area_id : int = None , ** kwargs ) -> List [ CampgroundFacility ]: \"\"\" Find Matching Campsites Based from Recreation Area Parameters ---------- rec_area_id: int Recreation Area ID Returns ------- campgrounds: List[CampgroundFacility] Array of Matching Campsites \"\"\" logger . info ( f \"Retrieving Facility Information for Recreation Area ID: ` { rec_area_id } `.\" ) api_path = f \" { RIDBConfig . REC_AREA_API_PATH } / { rec_area_id } / { RIDBConfig . FACILITIES_API_PATH } \" api_response = self . _ridb_get_paginate ( path = api_path , params = dict ( full = \"true\" , ** kwargs ) ) filtered_facilities = self . _filter_facilities_responses ( responses = api_response ) campgrounds = list () logger . info ( f \" { len ( filtered_facilities ) } Matching Campgrounds Found\" ) for facility in filtered_facilities : _ , campground_facility = self . process_facilities_responses ( facility = facility ) if campground_facility is not None : campgrounds . append ( campground_facility ) log_sorted_response ( response_array = campgrounds ) return campgrounds","title":"Returns"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.find_recreation_areas","text":"Find Matching Campsites Based on Search String","title":"find_recreation_areas()"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.find_recreation_areas--parameters","text":"str Search Keyword(s)","title":"Parameters"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.find_recreation_areas--returns","text":"List[dict] Array of Matching Campsites Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def find_recreation_areas ( self , search_string : str = None , ** kwargs ) -> List [ dict ]: \"\"\" Find Matching Campsites Based on Search String Parameters ---------- search_string: str Search Keyword(s) Returns ------- filtered_responses: List[dict] Array of Matching Campsites \"\"\" try : assert any ( [ kwargs . get ( \"state\" , None ) is not None , search_string is not None and search_string != \"\" , ] ) except AssertionError : raise RuntimeError ( \"You must provide a search query or state(s) \" \"to find Recreation Areas\" ) logger . info ( f 'Searching for Recreation Areas: \" { search_string } \"' ) state_arg = kwargs . get ( \"state\" , None ) if state_arg is not None : kwargs . update ({ \"state\" : state_arg . upper ()}) params = dict ( query = search_string , sort = \"Name\" , full = \"true\" , ** kwargs ) if search_string is None : params . pop ( \"query\" ) api_response = self . _ridb_get_paginate ( path = RIDBConfig . REC_AREA_API_PATH , params = params ) logger . info ( f \" { len ( api_response ) } recreation areas found.\" ) logging_messages = list () for recreation_area_object in api_response : _ , recreation_area = self . _process_rec_area_response ( recreation_area = recreation_area_object ) if recreation_area is not None : logging_messages . append ( recreation_area ) log_sorted_response ( response_array = logging_messages ) return api_response","title":"Returns"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.get_campground_ids_by_campsites","text":"Retrieve a list of FacilityIDs, and Facilities from a Campsite ID List","title":"get_campground_ids_by_campsites()"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.get_campground_ids_by_campsites--parameters","text":"List[int] List of Campsite IDs","title":"Parameters"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.get_campground_ids_by_campsites--returns","text":"Tuple[List[int], List[CampsiteResponse]] Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 def get_campground_ids_by_campsites ( self , campsite_ids : List [ int ] ) -> Tuple [ List [ int ], List [ CampsiteResponse ]]: \"\"\" Retrieve a list of FacilityIDs, and Facilities from a Campsite ID List Parameters ---------- campsite_ids: List[int] List of Campsite IDs Returns ------- Tuple[List[int], List[CampsiteResponse]] \"\"\" campground_ids = list () campgrounds = list () for campsite_id in campsite_ids : campsite = self . get_campsite_by_id ( campsite_id = campsite_id ) campgrounds . append ( campsite ) campground_ids . append ( campsite . FacilityID ) return list ( set ( campground_ids )), list ( campgrounds )","title":"Returns"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.get_campsite_by_id","text":"Get a Campsite's Details","title":"get_campsite_by_id()"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.get_campsite_by_id--parameters","text":"campsite_id: int","title":"Parameters"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.get_campsite_by_id--returns","text":"CampsiteResponse Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 def get_campsite_by_id ( self , campsite_id : int ) -> CampsiteResponse : \"\"\" Get a Campsite's Details Parameters ---------- campsite_id: int Returns ------- CampsiteResponse \"\"\" data = self . get_ridb_data ( path = f \" { RIDBConfig . CAMPSITE_API_PATH } / { campsite_id } \" ) try : response = CampsiteResponse ( ** data [ 0 ]) except IndexError : raise ProviderSearchError ( f \"Campsite with ID # { campsite_id } not found.\" ) return response","title":"Returns"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.get_internal_campsite_metadata","text":"Retrieve Metadata About all of the underlying Campsites to Search Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 866 867 868 869 870 871 872 873 874 875 876 877 878 def get_internal_campsite_metadata ( self , facility_ids : List [ int ]) -> pd . DataFrame : \"\"\" Retrieve Metadata About all of the underlying Campsites to Search \"\"\" all_campsites : List [ RecDotGovCampsite ] = [] for facility_id in facility_ids : all_campsites += self . paginate_recdotgov_campsites ( facility_id = facility_id ) all_campsite_df = pd . DataFrame ( [ item . dict () for item in all_campsites ], columns = RecDotGovCampsite . __fields__ , ) all_campsite_df . set_index ( \"campsite_id\" , inplace = True ) return all_campsite_df","title":"get_internal_campsite_metadata()"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.get_recdotgov_data","text":"Find Campsite Availability Data","title":"get_recdotgov_data()"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.get_recdotgov_data--parameters","text":"int Campground ID from the RIDB API. Can also be pulled of URLs on Recreation.gov datetime datetime object, results will be filtered to month","title":"Parameters"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.get_recdotgov_data--returns","text":"Union[dict, list] Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 def get_recdotgov_data ( self , campground_id : int , month : datetime ) -> Union [ dict , list ]: \"\"\" Find Campsite Availability Data Parameters ---------- campground_id: int Campground ID from the RIDB API. Can also be pulled of URLs on Recreation.gov month: datetime datetime object, results will be filtered to month Returns ------- Union[dict, list] \"\"\" try : response = self . _make_recdotgov_availability_request ( campground_id = campground_id , month = month ) except tenacity . RetryError : raise RuntimeError ( \"Something went wrong in fetching data from the \" \"RecreationDotGov API.\" ) return loads ( response . content )","title":"Returns"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.get_ridb_data","text":"Find Matching Campsites Based on Search String","title":"get_ridb_data()"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.get_ridb_data--parameters","text":"str URL Endpoint, see https://ridb.recreation.gov/docs","title":"Parameters"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.get_ridb_data--returns","text":"Union[dict, list] Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 @tenacity . retry ( wait = tenacity . wait_random_exponential ( multiplier = 2 , max = 10 ), stop = tenacity . stop . stop_after_delay ( 15 ), ) def get_ridb_data ( self , path : str , params : Optional [ dict ] = None ) -> Union [ dict , list ]: \"\"\" Find Matching Campsites Based on Search String Parameters ---------- path: str URL Endpoint, see https://ridb.recreation.gov/docs params: Optional[dict] API Call Parameters Returns ------- Union[dict, list] \"\"\" api_endpoint = self . _ridb_get_endpoint ( path = path ) headers = self . _ridb_api_headers . copy () headers . update ( choice ( USER_AGENTS )) response = requests . get ( url = api_endpoint , headers = headers , params = params , timeout = 30 ) try : assert response . status_code == 200 except AssertionError : error_message = ( f \"Receiving bad data from Recreation.gov API: { response . text } \" ) logger . error ( error_message ) raise ConnectionError ( error_message ) return loads ( response . content )","title":"Returns"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.make_recdotgov_request","text":"Make a Raw Request to RecreationDotGov","title":"make_recdotgov_request()"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.make_recdotgov_request--parameters","text":"url: str method: str","title":"Parameters"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.make_recdotgov_request--returns","text":"requests.Response Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 @classmethod def make_recdotgov_request ( cls , url : str , method : str = \"GET\" , params : Optional [ Dict [ str , Any ]] = None , ** kwargs , ) -> requests . Response : \"\"\" Make a Raw Request to RecreationDotGov Parameters ---------- url: str method: str params: Optional[Dict[str, Any]] Returns ------- requests.Response \"\"\" # BUILD THE HEADERS EXPECTED FROM THE API headers = STANDARD_HEADERS . copy () headers . update ( choice ( USER_AGENTS )) headers . update ( RecreationBookingConfig . API_REFERRERS ) response = requests . request ( method = method , url = url , headers = headers , params = params , timeout = 30 , ** kwargs ) return response","title":"Returns"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.make_recdotgov_request_retry","text":"Make a Raw Request to RecreationDotGov - But Handle 404","title":"make_recdotgov_request_retry()"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.make_recdotgov_request_retry--parameters","text":"url: str method: str","title":"Parameters"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.make_recdotgov_request_retry--returns","text":"requests.Response Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 @classmethod @tenacity . retry ( wait = tenacity . wait_random_exponential ( multiplier = 2 , max = 10 ), stop = tenacity . stop . stop_after_delay ( 15 ), ) def make_recdotgov_request_retry ( cls , url : str , method : str = \"GET\" , params : Optional [ Dict [ str , Any ]] = None , ** kwargs , ) -> requests . Response : \"\"\" Make a Raw Request to RecreationDotGov - But Handle 404 Parameters ---------- url: str method: str params: Optional[Dict[str, Any]] Returns ------- requests.Response \"\"\" response = cls . make_recdotgov_request ( url = url , method = method , params = params , ** kwargs ) response . raise_for_status () return response","title":"Returns"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.paginate_recdotgov_campsites","text":"Paginate through the RecDotGov Campsite Metadata Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 def paginate_recdotgov_campsites ( self , facility_id : int , equipment : Optional [ List [ str ]] = None ) -> List [ RecDotGovCampsite ]: \"\"\" Paginate through the RecDotGov Campsite Metadata \"\"\" results = 0 continue_paginate = True endpoint_url = api_utils . generate_url ( scheme = RecreationBookingConfig . API_SCHEME , netloc = RecreationBookingConfig . API_NET_LOC , path = \"api/search/campsites\" , ) fq_list = [ f \"asset_id: { facility_id } \" ] if isinstance ( equipment , list ) and len ( equipment ) > 0 : for item in equipment : fq_list . append ( f \"campsite_equipment_name: { item } \" ) params = dict ( start = 0 , size = 1000 , fq = fq_list , include_non_site_specific_campsites = True , ) campsites = [] while continue_paginate is True : response = self . make_recdotgov_request_retry ( method = \"GET\" , url = endpoint_url , params = params , ) returned_data = json . loads ( response . content ) campsite_response = RecDotGovCampsiteResponse ( ** returned_data ) campsites += campsite_response . campsites results += campsite_response . size params . update ( start = results ) if results == campsite_response . total : continue_paginate = False return campsites","title":"paginate_recdotgov_campsites()"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.process_campsite_availability","text":"Parse the JSON Response and return availabilities","title":"process_campsite_availability()"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.process_campsite_availability--parameters","text":"dict API Response str Name of Recreation Area int ID of Recreation Area str Campground Facility Name int Campground Facility ID datetime Month to Process pd.DataFrame Metadata Fetched from the Recreation.gov API about the Campsites","title":"Parameters"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.process_campsite_availability--returns","text":"List[Optional[AvailableCampsite]] Any monthly availabilities Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 @classmethod def process_campsite_availability ( cls , availability : dict , recreation_area : str , recreation_area_id : int , facility_name : str , facility_id : int , month : datetime , campsite_metadata : pd . DataFrame , ) -> List [ Optional [ AvailableCampsite ]]: \"\"\" Parse the JSON Response and return availabilities Parameters ---------- availability: dict API Response recreation_area: str Name of Recreation Area recreation_area_id: int ID of Recreation Area facility_name: str Campground Facility Name facility_id: int Campground Facility ID month: datetime Month to Process campsite_metadata: pd.DataFrame Metadata Fetched from the Recreation.gov API about the Campsites Returns ------- total_campsite_availability: List[Optional[AvailableCampsite]] Any monthly availabilities \"\"\" total_campsite_availability : List [ Optional [ AvailableCampsite ]] = list () campsite_data = CampsiteAvailabilityResponse ( ** availability ) for campsite_id , site_related_data in campsite_data . campsites . items (): for ( matching_date , availability_status , ) in site_related_data . availabilities . items (): if ( availability_status not in RecreationBookingConfig . CAMPSITE_UNAVAILABLE_STRINGS ): booking_url = ( f \" { RecreationBookingConfig . CAMPSITE_BOOKING_URL } / { campsite_id } \" ) equipment , attributes = cls . _get_equipment_and_attributes ( campsite_id = campsite_id , campsite_metadata = campsite_metadata ) available_campsite = AvailableCampsite ( campsite_id = campsite_id , booking_date = matching_date , booking_end_date = matching_date + timedelta ( days = 1 ), booking_nights = 1 , campsite_site_name = site_related_data . site , campsite_loop_name = site_related_data . loop , campsite_type = site_related_data . campsite_type , campsite_occupancy = ( site_related_data . min_num_people , site_related_data . max_num_people , ), campsite_use_type = site_related_data . type_of_use , availability_status = availability_status , recreation_area = recreation_area , recreation_area_id = recreation_area_id , facility_name = facility_name , facility_id = facility_id , booking_url = booking_url , permitted_equipment = equipment , campsite_attributes = attributes , ) total_campsite_availability . append ( available_campsite ) logger . info ( f \" \\t { logging_utils . get_emoji ( total_campsite_availability ) } \\t \" f \" { len ( total_campsite_availability ) } total sites found in month of \" f \" { month . strftime ( '%B' ) } \" ) return total_campsite_availability","title":"Returns"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.process_facilities_responses","text":"Process Facilities Responses to be More Usable","title":"process_facilities_responses()"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.process_facilities_responses--parameters","text":"facility: dict","title":"Parameters"},{"location":"reference/providers/recreation_dot_gov/recdotgov_provider/#camply.providers.recreation_dot_gov.recdotgov_provider.RecreationDotGov.process_facilities_responses--returns","text":"Tuple[dict, CampgroundFacility] Source code in camply/providers/recreation_dot_gov/recdotgov_provider.py 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 @classmethod def process_facilities_responses ( cls , facility : dict ) -> Tuple [ dict , Optional [ CampgroundFacility ]]: \"\"\" Process Facilities Responses to be More Usable Parameters ---------- facility: dict Returns ------- Tuple[dict, CampgroundFacility] \"\"\" facility_object = FacilityResponse ( ** facility ) try : facility_state = facility_object . FACILITYADDRESS [ 0 ] . AddressStateCode . upper () except ( KeyError , IndexError ): facility_state = \"USA\" try : if len ( facility_object . RECAREA ) == 0 : recreation_area_id = facility_object . ParentRecAreaID formatted_recreation_area = ( f \" { facility_object . ORGANIZATION [ 0 ] . OrgName } , { facility_state } \" ) else : recreation_area = facility_object . RECAREA [ 0 ] . RecAreaName recreation_area_id = facility_object . RECAREA [ 0 ] . RecAreaID formatted_recreation_area = f \" { recreation_area } , { facility_state } \" campground_facility = CampgroundFacility ( facility_name = facility_object . FacilityName . title (), recreation_area = formatted_recreation_area , facility_id = facility_object . FacilityID , recreation_area_id = recreation_area_id , ) return facility , campground_facility except ( KeyError , IndexError ): return facility , None","title":"Returns"},{"location":"reference/providers/xanterra/","text":"Xanterra init","title":"xanterra"},{"location":"reference/providers/xanterra/yellowstone_lodging/","text":"Python Class Check Yellowstone Campground Booking API for Availability YellowstoneLodging # Bases: BaseProvider Scanner for Lodging in Yellowstone Source code in camply/providers/xanterra/yellowstone_lodging.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 class YellowstoneLodging ( BaseProvider ): \"\"\" Scanner for Lodging in Yellowstone \"\"\" def __repr__ ( self ): \"\"\" String Representation Returns ------- str \"\"\" return \"<YellowstoneLodging>\" def _get_monthly_availability ( self , month : datetime , nights : int = None ) -> dict : \"\"\" Check All Lodging in Yellowstone for Campground Data Returns ------- data_availability: dict Data Availability Dictionary \"\"\" query_dict = dict ( date = self . _ensure_current_month ( month = month ), limit = 31 , rate_code = YellowstoneConfig . RATE_CODE , ) if nights is not None : query_dict . update ( dict ( nights = nights )) api_endpoint = self . _get_api_endpoint ( url_path = YellowstoneConfig . YELLOWSTONE_LODGING_PATH , query = None ) logger . info ( f \"Searching for Yellowstone Lodging Availability: { month . strftime ( '%B, %Y' ) } \" ) all_resort_availability_data = self . make_yellowstone_request ( endpoint = api_endpoint , params = query_dict ) return all_resort_availability_data @staticmethod @tenacity . retry ( wait = tenacity . wait_random_exponential ( multiplier = 3 , max = 1800 ), stop = tenacity . stop . stop_after_delay ( 6000 ), ) def _try_retry_get_data ( endpoint : str , params : Optional [ dict ] = None ) -> dict : \"\"\" Try and Retry Fetching Data from the Yellowstone API. Unfortunately this is a required method to request the data since the Yellowstone API doesn't always return data. Parameters ---------- endpoint: str API Endpoint params Returns ------- dict \"\"\" yellowstone_headers = choice ( USER_AGENTS ) yellowstone_headers . update ( STANDARD_HEADERS ) yellowstone_headers . update ( YellowstoneConfig . API_REFERRERS ) response = requests . get ( url = endpoint , headers = yellowstone_headers , params = params , timeout = 30 ) if response . status_code == 200 and response . text . strip () != \"\" : return loads ( response . content ) else : error_message = ( \"Something went wrong with checking the \" \"Yellowstone Booking API. Will continue retrying.\" ) logger . warning ( error_message ) raise RuntimeError ( error_message ) @staticmethod def make_yellowstone_request ( endpoint : str , params : Optional [ dict ] = None ) -> dict : \"\"\" Try and Retry Fetching Data from the Yellowstone API. Unfortunately this is a required method to request the data since the Yellowstone API doesn't always return data. Parameters ---------- endpoint: str API Endpoint params Returns ------- dict \"\"\" try : content = YellowstoneLodging . _try_retry_get_data ( endpoint = endpoint , params = params ) except RuntimeError as re : raise RuntimeError ( f \"error_message: { re } \" ) return content @classmethod def _get_api_endpoint ( cls , url_path : str , query : Optional [ dict ] = None ) -> str : \"\"\" Build the API Endpoint for All Yellowstone Lodging \"\"\" if query is not None : query_string = parse . urlencode ( query = query ) else : query_string = \"\" url_components = dict ( scheme = YellowstoneConfig . API_SCHEME , netloc = YellowstoneConfig . API_BASE_ENDPOINT , url = url_path , params = \"\" , query = query_string , fragment = \"\" , ) api_endpoint = parse . urlunparse ( tuple ( url_components . values ())) return api_endpoint @classmethod def _return_lodging_url ( cls , lodging_code : str , month : datetime , params : Optional [ dict ] = \"\" ) -> str : \"\"\" Return a Browser Loadable URL to book from Parameters ---------- lodging_code: str Lodging Code from API month: datetime Month to return bookings filtered to params: Optional[dict] Optional URL Parameters Returns ------- str URL String \"\"\" query = dict ( dateFrom = month . strftime ( \"%m- %d -%Y\" ), adults = 1 , destination = lodging_code , children = 0 , ) if params is not None : query . update ( params ) query_string = parse . urlencode ( query = query ) url_components = dict ( scheme = YellowstoneConfig . API_SCHEME , netloc = YellowstoneConfig . WEBUI_BASE_ENDPOINT , url = YellowstoneConfig . WEBUI_BOOKING_PATH , params = \"\" , query = query_string , fragment = \"\" , ) webui_endpoint = parse . urlunparse ( tuple ( url_components . values ())) return webui_endpoint @classmethod def _compile_campground_availabilities ( cls , availability : XantResortData ) -> List [ dict ]: \"\"\" Gather Data about campground availabilities within a JSON Availability Objet Parameters ---------- availability: ResortData JSON Availability Object Returns ------- available_campsites: List[dict] List of Availabilities as JSON \"\"\" available_campsites = list () for booking_date , daily_data in availability . availability . items (): camping_keys = [ key for key in daily_data . keys () if YellowstoneConfig . LODGING_CAMPGROUND_QUALIFIER in key ] for hotel_code in camping_keys : hotel_data = daily_data [ hotel_code ] try : hotel_title = hotel_data . rates [ YellowstoneConfig . RATE_CODE ] . title hotel_rate_mins = hotel_data . rates [ YellowstoneConfig . RATE_CODE ] . mins if hotel_rate_mins != { 1 : 0 }: min_capacity = min ( hotel_rate_mins . keys ()) max_capacity = max ( hotel_rate_mins . keys ()) capacity = ( min_capacity , max_capacity ) campsite = dict ( campsite_id = None , booking_date = booking_date , campsite_occupancy = capacity , recreation_area = YellowstoneConfig . YELLOWSTONE_RECREATION_AREA_NAME , recreation_area_id = YellowstoneConfig . YELLOWSTONE_RECREATION_AREA_ID , facility_name = hotel_title . replace ( * YellowstoneConfig . YELLOWSTONE_CAMPGROUND_NAME_REPLACE ), facility_id = hotel_code , ) available_campsites . append ( campsite ) except KeyError : pass logger . info ( f \" \\t { logging_utils . get_emoji ( available_campsites ) } \\t \" f \" { len ( available_campsites ) } sites found.\" ) return available_campsites def _gather_campsite_specific_availability ( self , available_campsites : List [ dict ], month : datetime , nights : Optional [ int ] = None , ) -> List [ dict ]: \"\"\" Get campsite extra information Given a DataFrame of campsite availability, return updated Data with details about the actual campsites that are available (i.e Tent Size, RV Length, Etc) Parameters ---------- available_campsites: List[dict] List of Available Campsites as JSON objects month: datetime Month object Returns ------- List[dict] \"\"\" available_room_array = list () availability_df = DataFrame ( data = available_campsites ) if availability_df . empty is True : return available_room_array for facility_id , _facility_df in availability_df . groupby ( YellowstoneConfig . FACILITY_ID ): api_endpoint = self . _get_api_endpoint ( url_path = YellowstoneConfig . YELLOWSTONE_CAMPSITE_AVAILABILITY , query = None ) params = dict ( date = self . _ensure_current_month ( month = month ), limit = 31 ) if nights is not None : params . update ( dict ( nights = nights )) campsite_data = self . make_yellowstone_request ( endpoint = f \" { api_endpoint } / { facility_id } \" , params = params ) campsite_availability = campsite_data [ YellowstoneConfig . BOOKING_AVAILABILITY ] booking_dates = campsite_availability . keys () availabilities = self . _process_daily_availability ( booking_dates = booking_dates , campsite_availability = campsite_availability , facility_id = facility_id , ) available_room_array += availabilities return available_room_array @classmethod def _process_daily_availability ( cls , booking_dates : List [ str ], campsite_availability : dict , facility_id : str ) -> List [ dict ]: \"\"\" Process Monthly Availability Parameters ---------- booking_dates: List[str] List of booking dates to process campsite_availability: dict Campsite availability dict facility_id: str Identification of the Facility Returns ------- List[dict] \"\"\" daily_availabilities = list () for booking_date_str in booking_dates : daily_availability = campsite_availability [ booking_date_str ] if ( daily_availability [ YellowstoneConfig . FACILITY_STATUS ] == YellowstoneConfig . FACILITY_STATUS_QUALIFIER ): available_rooms = daily_availability [ YellowstoneConfig . FACILITY_ROOMS ] for room in available_rooms : if room [ YellowstoneConfig . FACILITY_AVAILABLE_QUALIFIER ] > 0 : daily_availabilities . append ( dict ( booking_date = booking_date_str , facility_id = facility_id , campsite_code = room [ YellowstoneConfig . FACILITY_ROOM_CODE ], available = room [ YellowstoneConfig . FACILITY_AVAILABLE_QUALIFIER ], price = room [ YellowstoneConfig . FACILITY_PRICE ], ) ) return daily_availabilities def _get_property_information ( self , available_rooms : List [ dict ]) -> List [ dict ]: \"\"\" Gather Information About All Campgrounds / Hotels within Yellowstone Parameters ---------- available_rooms: List[dict] Returns ------- List[dict] \"\"\" property_info_array = list () availability_df = DataFrame ( data = available_rooms ) if availability_df . empty is True : return property_info_array facility_identifiers = availability_df [ YellowstoneConfig . FACILITY_ID ] . unique () for facility_id in facility_identifiers : api_endpoint = self . _get_api_endpoint ( url_path = YellowstoneConfig . YELLOWSTONE_PROPERTY_INFO , query = None ) campsite_info = self . make_yellowstone_request ( endpoint = f \" { api_endpoint } / { facility_id } \" ) campsite_codes = campsite_info . keys () for campsite_code in campsite_codes : campsite_data = campsite_info [ campsite_code ] property_info_array . append ( dict ( facility_id = facility_id , campsite_code = campsite_code , campsite_title = campsite_data [ YellowstoneConfig . LODGING_TITLE ], campsite_type = campsite_data [ YellowstoneConfig . FACILITY_TYPE ] . upper (), capacity = ( campsite_data [ YellowstoneConfig . LODGING_OCCUPANCY_BASE ], campsite_data [ YellowstoneConfig . LODGING_OCCUPANCY_MAX ], ), ) ) return property_info_array def get_monthly_campsites ( self , month : datetime , nights : Optional [ int ] = None ) -> List [ AvailableCampsite ]: \"\"\" Return All Campsites Available in a Given Month Parameters ---------- month: datetime Month to Search nights: Optional[int] Search for consecutive nights Returns ------- List[AvailableCampsite] \"\"\" now = datetime . now () . date () search_date = month . replace ( day = 1 ) if month <= now : logger . info ( \"Cannot input search dates before today, adjusting search parameters.\" ) search_date = search_date . replace ( year = now . year , month = now . month , day = now . day ) availability_found = self . _get_monthly_availability ( month = search_date , nights = nights ) availability = XantResortData ( ** availability_found ) monthly_campsites = self . _compile_campground_availabilities ( availability = availability ) campsite_data = DataFrame ( monthly_campsites , columns = YellowstoneConfig . CAMPSITE_DATA_COLUMNS ) . drop_duplicates () if campsite_data . empty is True : return list () available_room_array = self . _gather_campsite_specific_availability ( available_campsites = monthly_campsites , month = month , nights = nights ) available_rooms = DataFrame ( available_room_array ) property_info = self . _get_property_information ( available_rooms = available_room_array ) properties = DataFrame ( property_info ) merged_campsites = available_rooms . merge ( properties , on = [ YellowstoneConfig . FACILITY_ID_COLUMN , YellowstoneConfig . CAMPSITE_ID_COLUMN , ], ) merged_campsites [ YellowstoneConfig . BOOKING_DATE_COLUMN ] = to_datetime ( merged_campsites [ YellowstoneConfig . BOOKING_DATE_COLUMN ] ) if nights is not None : nights_param = dict ( nights = nights ) else : nights_param = dict ( nights = 1 ) booking_nights = nights_param . get ( \"nights\" ) merged_campsites [ YellowstoneConfig . BOOKING_END_DATE_COLUMN ] = merged_campsites [ YellowstoneConfig . BOOKING_DATE_COLUMN ] + timedelta ( days = booking_nights ) merged_campsites [ YellowstoneConfig . BOOKING_NIGHTS_COLUMN ] = booking_nights final_campsites = merged_campsites . merge ( campsite_data , on = YellowstoneConfig . FACILITY_ID_COLUMN ) . sort_values ( by = YellowstoneConfig . BOOKING_DATE_COLUMN ) final_campsites [ YellowstoneConfig . BOOKING_URL_COLUMN ] = final_campsites . apply ( lambda x : self . _return_lodging_url ( lodging_code = x . facility_id , month = x . booking_date , params = nights_param ), axis = 1 , ) all_monthly_campsite_array = self . _df_to_campsites ( campsite_df = final_campsites ) return all_monthly_campsite_array @classmethod def _df_to_campsites ( cls , campsite_df : DataFrame ) -> List [ AvailableCampsite ]: \"\"\" Transform a DataFrame into an array of AvailableCampsites Parameters ---------- campsite_df: DataFrame Returns ------- List[AvailableCampsite] \"\"\" all_monthly_campsite_array = list () for _ , row in campsite_df . iterrows (): campsite = AvailableCampsite ( campsite_id = row [ YellowstoneConfig . CAMPSITE_ID_COLUMN ], booking_date = row [ YellowstoneConfig . BOOKING_DATE_COLUMN ], booking_end_date = row [ YellowstoneConfig . BOOKING_END_DATE_COLUMN ], booking_nights = row [ YellowstoneConfig . BOOKING_NIGHTS_COLUMN ], campsite_site_name = row [ YellowstoneConfig . CAMPSITE_SITE_NAME_COLUMN ], campsite_loop_name = YellowstoneConfig . YELLOWSTONE_LOOP_NAME , campsite_type = row [ YellowstoneConfig . CAMPSITE_TYPE_COLUMN ], campsite_occupancy = row [ YellowstoneConfig . CAMPSITE_OCCUPANCY_COLUMN ], campsite_use_type = row [ YellowstoneConfig . CAMPSITE_USE_TYPE_COLUMN ], availability_status = YellowstoneConfig . CAMPSITE_AVAILABILITY_STATUS , recreation_area = YellowstoneConfig . YELLOWSTONE_RECREATION_AREA_NAME , recreation_area_id = YellowstoneConfig . YELLOWSTONE_RECREATION_AREA_ID , facility_name = row [ YellowstoneConfig . FACILITY_NAME_COLUMN ], facility_id = row [ YellowstoneConfig . FACILITY_ID_COLUMN ], booking_url = row [ YellowstoneConfig . BOOKING_URL_COLUMN ], ) all_monthly_campsite_array . append ( campsite ) return all_monthly_campsite_array @classmethod def _ensure_current_month ( cls , month : datetime ) -> datetime : \"\"\" Ensure That We Never Give the Yellowstone API Dates in the past. Parameters ---------- month: datetime Returns ------- datetime \"\"\" yellowstone_timezone = timezone ( YellowstoneConfig . YELLOWSTONE_TIMEZONE ) yellowstone_current_time = datetime . now ( yellowstone_timezone ) . date () today = datetime ( year = yellowstone_current_time . year , month = yellowstone_current_time . month , day = yellowstone_current_time . day , ) . date () if today > month : month = today return month __repr__ () # String Representation Returns # str Source code in camply/providers/xanterra/yellowstone_lodging.py 31 32 33 34 35 36 37 38 39 def __repr__ ( self ): \"\"\" String Representation Returns ------- str \"\"\" return \"<YellowstoneLodging>\" get_monthly_campsites ( month , nights = None ) # Return All Campsites Available in a Given Month Parameters # datetime Month to Search Optional[int] Search for consecutive nights Returns # List[AvailableCampsite] Source code in camply/providers/xanterra/yellowstone_lodging.py 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 def get_monthly_campsites ( self , month : datetime , nights : Optional [ int ] = None ) -> List [ AvailableCampsite ]: \"\"\" Return All Campsites Available in a Given Month Parameters ---------- month: datetime Month to Search nights: Optional[int] Search for consecutive nights Returns ------- List[AvailableCampsite] \"\"\" now = datetime . now () . date () search_date = month . replace ( day = 1 ) if month <= now : logger . info ( \"Cannot input search dates before today, adjusting search parameters.\" ) search_date = search_date . replace ( year = now . year , month = now . month , day = now . day ) availability_found = self . _get_monthly_availability ( month = search_date , nights = nights ) availability = XantResortData ( ** availability_found ) monthly_campsites = self . _compile_campground_availabilities ( availability = availability ) campsite_data = DataFrame ( monthly_campsites , columns = YellowstoneConfig . CAMPSITE_DATA_COLUMNS ) . drop_duplicates () if campsite_data . empty is True : return list () available_room_array = self . _gather_campsite_specific_availability ( available_campsites = monthly_campsites , month = month , nights = nights ) available_rooms = DataFrame ( available_room_array ) property_info = self . _get_property_information ( available_rooms = available_room_array ) properties = DataFrame ( property_info ) merged_campsites = available_rooms . merge ( properties , on = [ YellowstoneConfig . FACILITY_ID_COLUMN , YellowstoneConfig . CAMPSITE_ID_COLUMN , ], ) merged_campsites [ YellowstoneConfig . BOOKING_DATE_COLUMN ] = to_datetime ( merged_campsites [ YellowstoneConfig . BOOKING_DATE_COLUMN ] ) if nights is not None : nights_param = dict ( nights = nights ) else : nights_param = dict ( nights = 1 ) booking_nights = nights_param . get ( \"nights\" ) merged_campsites [ YellowstoneConfig . BOOKING_END_DATE_COLUMN ] = merged_campsites [ YellowstoneConfig . BOOKING_DATE_COLUMN ] + timedelta ( days = booking_nights ) merged_campsites [ YellowstoneConfig . BOOKING_NIGHTS_COLUMN ] = booking_nights final_campsites = merged_campsites . merge ( campsite_data , on = YellowstoneConfig . FACILITY_ID_COLUMN ) . sort_values ( by = YellowstoneConfig . BOOKING_DATE_COLUMN ) final_campsites [ YellowstoneConfig . BOOKING_URL_COLUMN ] = final_campsites . apply ( lambda x : self . _return_lodging_url ( lodging_code = x . facility_id , month = x . booking_date , params = nights_param ), axis = 1 , ) all_monthly_campsite_array = self . _df_to_campsites ( campsite_df = final_campsites ) return all_monthly_campsite_array make_yellowstone_request ( endpoint , params = None ) staticmethod # Try and Retry Fetching Data from the Yellowstone API. Unfortunately this is a required method to request the data since the Yellowstone API doesn't always return data. Parameters # str API Endpoint params Returns # dict Source code in camply/providers/xanterra/yellowstone_lodging.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 @staticmethod def make_yellowstone_request ( endpoint : str , params : Optional [ dict ] = None ) -> dict : \"\"\" Try and Retry Fetching Data from the Yellowstone API. Unfortunately this is a required method to request the data since the Yellowstone API doesn't always return data. Parameters ---------- endpoint: str API Endpoint params Returns ------- dict \"\"\" try : content = YellowstoneLodging . _try_retry_get_data ( endpoint = endpoint , params = params ) except RuntimeError as re : raise RuntimeError ( f \"error_message: { re } \" ) return content","title":"yellowstone_lodging"},{"location":"reference/providers/xanterra/yellowstone_lodging/#camply.providers.xanterra.yellowstone_lodging.YellowstoneLodging","text":"Bases: BaseProvider Scanner for Lodging in Yellowstone Source code in camply/providers/xanterra/yellowstone_lodging.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 class YellowstoneLodging ( BaseProvider ): \"\"\" Scanner for Lodging in Yellowstone \"\"\" def __repr__ ( self ): \"\"\" String Representation Returns ------- str \"\"\" return \"<YellowstoneLodging>\" def _get_monthly_availability ( self , month : datetime , nights : int = None ) -> dict : \"\"\" Check All Lodging in Yellowstone for Campground Data Returns ------- data_availability: dict Data Availability Dictionary \"\"\" query_dict = dict ( date = self . _ensure_current_month ( month = month ), limit = 31 , rate_code = YellowstoneConfig . RATE_CODE , ) if nights is not None : query_dict . update ( dict ( nights = nights )) api_endpoint = self . _get_api_endpoint ( url_path = YellowstoneConfig . YELLOWSTONE_LODGING_PATH , query = None ) logger . info ( f \"Searching for Yellowstone Lodging Availability: { month . strftime ( '%B, %Y' ) } \" ) all_resort_availability_data = self . make_yellowstone_request ( endpoint = api_endpoint , params = query_dict ) return all_resort_availability_data @staticmethod @tenacity . retry ( wait = tenacity . wait_random_exponential ( multiplier = 3 , max = 1800 ), stop = tenacity . stop . stop_after_delay ( 6000 ), ) def _try_retry_get_data ( endpoint : str , params : Optional [ dict ] = None ) -> dict : \"\"\" Try and Retry Fetching Data from the Yellowstone API. Unfortunately this is a required method to request the data since the Yellowstone API doesn't always return data. Parameters ---------- endpoint: str API Endpoint params Returns ------- dict \"\"\" yellowstone_headers = choice ( USER_AGENTS ) yellowstone_headers . update ( STANDARD_HEADERS ) yellowstone_headers . update ( YellowstoneConfig . API_REFERRERS ) response = requests . get ( url = endpoint , headers = yellowstone_headers , params = params , timeout = 30 ) if response . status_code == 200 and response . text . strip () != \"\" : return loads ( response . content ) else : error_message = ( \"Something went wrong with checking the \" \"Yellowstone Booking API. Will continue retrying.\" ) logger . warning ( error_message ) raise RuntimeError ( error_message ) @staticmethod def make_yellowstone_request ( endpoint : str , params : Optional [ dict ] = None ) -> dict : \"\"\" Try and Retry Fetching Data from the Yellowstone API. Unfortunately this is a required method to request the data since the Yellowstone API doesn't always return data. Parameters ---------- endpoint: str API Endpoint params Returns ------- dict \"\"\" try : content = YellowstoneLodging . _try_retry_get_data ( endpoint = endpoint , params = params ) except RuntimeError as re : raise RuntimeError ( f \"error_message: { re } \" ) return content @classmethod def _get_api_endpoint ( cls , url_path : str , query : Optional [ dict ] = None ) -> str : \"\"\" Build the API Endpoint for All Yellowstone Lodging \"\"\" if query is not None : query_string = parse . urlencode ( query = query ) else : query_string = \"\" url_components = dict ( scheme = YellowstoneConfig . API_SCHEME , netloc = YellowstoneConfig . API_BASE_ENDPOINT , url = url_path , params = \"\" , query = query_string , fragment = \"\" , ) api_endpoint = parse . urlunparse ( tuple ( url_components . values ())) return api_endpoint @classmethod def _return_lodging_url ( cls , lodging_code : str , month : datetime , params : Optional [ dict ] = \"\" ) -> str : \"\"\" Return a Browser Loadable URL to book from Parameters ---------- lodging_code: str Lodging Code from API month: datetime Month to return bookings filtered to params: Optional[dict] Optional URL Parameters Returns ------- str URL String \"\"\" query = dict ( dateFrom = month . strftime ( \"%m- %d -%Y\" ), adults = 1 , destination = lodging_code , children = 0 , ) if params is not None : query . update ( params ) query_string = parse . urlencode ( query = query ) url_components = dict ( scheme = YellowstoneConfig . API_SCHEME , netloc = YellowstoneConfig . WEBUI_BASE_ENDPOINT , url = YellowstoneConfig . WEBUI_BOOKING_PATH , params = \"\" , query = query_string , fragment = \"\" , ) webui_endpoint = parse . urlunparse ( tuple ( url_components . values ())) return webui_endpoint @classmethod def _compile_campground_availabilities ( cls , availability : XantResortData ) -> List [ dict ]: \"\"\" Gather Data about campground availabilities within a JSON Availability Objet Parameters ---------- availability: ResortData JSON Availability Object Returns ------- available_campsites: List[dict] List of Availabilities as JSON \"\"\" available_campsites = list () for booking_date , daily_data in availability . availability . items (): camping_keys = [ key for key in daily_data . keys () if YellowstoneConfig . LODGING_CAMPGROUND_QUALIFIER in key ] for hotel_code in camping_keys : hotel_data = daily_data [ hotel_code ] try : hotel_title = hotel_data . rates [ YellowstoneConfig . RATE_CODE ] . title hotel_rate_mins = hotel_data . rates [ YellowstoneConfig . RATE_CODE ] . mins if hotel_rate_mins != { 1 : 0 }: min_capacity = min ( hotel_rate_mins . keys ()) max_capacity = max ( hotel_rate_mins . keys ()) capacity = ( min_capacity , max_capacity ) campsite = dict ( campsite_id = None , booking_date = booking_date , campsite_occupancy = capacity , recreation_area = YellowstoneConfig . YELLOWSTONE_RECREATION_AREA_NAME , recreation_area_id = YellowstoneConfig . YELLOWSTONE_RECREATION_AREA_ID , facility_name = hotel_title . replace ( * YellowstoneConfig . YELLOWSTONE_CAMPGROUND_NAME_REPLACE ), facility_id = hotel_code , ) available_campsites . append ( campsite ) except KeyError : pass logger . info ( f \" \\t { logging_utils . get_emoji ( available_campsites ) } \\t \" f \" { len ( available_campsites ) } sites found.\" ) return available_campsites def _gather_campsite_specific_availability ( self , available_campsites : List [ dict ], month : datetime , nights : Optional [ int ] = None , ) -> List [ dict ]: \"\"\" Get campsite extra information Given a DataFrame of campsite availability, return updated Data with details about the actual campsites that are available (i.e Tent Size, RV Length, Etc) Parameters ---------- available_campsites: List[dict] List of Available Campsites as JSON objects month: datetime Month object Returns ------- List[dict] \"\"\" available_room_array = list () availability_df = DataFrame ( data = available_campsites ) if availability_df . empty is True : return available_room_array for facility_id , _facility_df in availability_df . groupby ( YellowstoneConfig . FACILITY_ID ): api_endpoint = self . _get_api_endpoint ( url_path = YellowstoneConfig . YELLOWSTONE_CAMPSITE_AVAILABILITY , query = None ) params = dict ( date = self . _ensure_current_month ( month = month ), limit = 31 ) if nights is not None : params . update ( dict ( nights = nights )) campsite_data = self . make_yellowstone_request ( endpoint = f \" { api_endpoint } / { facility_id } \" , params = params ) campsite_availability = campsite_data [ YellowstoneConfig . BOOKING_AVAILABILITY ] booking_dates = campsite_availability . keys () availabilities = self . _process_daily_availability ( booking_dates = booking_dates , campsite_availability = campsite_availability , facility_id = facility_id , ) available_room_array += availabilities return available_room_array @classmethod def _process_daily_availability ( cls , booking_dates : List [ str ], campsite_availability : dict , facility_id : str ) -> List [ dict ]: \"\"\" Process Monthly Availability Parameters ---------- booking_dates: List[str] List of booking dates to process campsite_availability: dict Campsite availability dict facility_id: str Identification of the Facility Returns ------- List[dict] \"\"\" daily_availabilities = list () for booking_date_str in booking_dates : daily_availability = campsite_availability [ booking_date_str ] if ( daily_availability [ YellowstoneConfig . FACILITY_STATUS ] == YellowstoneConfig . FACILITY_STATUS_QUALIFIER ): available_rooms = daily_availability [ YellowstoneConfig . FACILITY_ROOMS ] for room in available_rooms : if room [ YellowstoneConfig . FACILITY_AVAILABLE_QUALIFIER ] > 0 : daily_availabilities . append ( dict ( booking_date = booking_date_str , facility_id = facility_id , campsite_code = room [ YellowstoneConfig . FACILITY_ROOM_CODE ], available = room [ YellowstoneConfig . FACILITY_AVAILABLE_QUALIFIER ], price = room [ YellowstoneConfig . FACILITY_PRICE ], ) ) return daily_availabilities def _get_property_information ( self , available_rooms : List [ dict ]) -> List [ dict ]: \"\"\" Gather Information About All Campgrounds / Hotels within Yellowstone Parameters ---------- available_rooms: List[dict] Returns ------- List[dict] \"\"\" property_info_array = list () availability_df = DataFrame ( data = available_rooms ) if availability_df . empty is True : return property_info_array facility_identifiers = availability_df [ YellowstoneConfig . FACILITY_ID ] . unique () for facility_id in facility_identifiers : api_endpoint = self . _get_api_endpoint ( url_path = YellowstoneConfig . YELLOWSTONE_PROPERTY_INFO , query = None ) campsite_info = self . make_yellowstone_request ( endpoint = f \" { api_endpoint } / { facility_id } \" ) campsite_codes = campsite_info . keys () for campsite_code in campsite_codes : campsite_data = campsite_info [ campsite_code ] property_info_array . append ( dict ( facility_id = facility_id , campsite_code = campsite_code , campsite_title = campsite_data [ YellowstoneConfig . LODGING_TITLE ], campsite_type = campsite_data [ YellowstoneConfig . FACILITY_TYPE ] . upper (), capacity = ( campsite_data [ YellowstoneConfig . LODGING_OCCUPANCY_BASE ], campsite_data [ YellowstoneConfig . LODGING_OCCUPANCY_MAX ], ), ) ) return property_info_array def get_monthly_campsites ( self , month : datetime , nights : Optional [ int ] = None ) -> List [ AvailableCampsite ]: \"\"\" Return All Campsites Available in a Given Month Parameters ---------- month: datetime Month to Search nights: Optional[int] Search for consecutive nights Returns ------- List[AvailableCampsite] \"\"\" now = datetime . now () . date () search_date = month . replace ( day = 1 ) if month <= now : logger . info ( \"Cannot input search dates before today, adjusting search parameters.\" ) search_date = search_date . replace ( year = now . year , month = now . month , day = now . day ) availability_found = self . _get_monthly_availability ( month = search_date , nights = nights ) availability = XantResortData ( ** availability_found ) monthly_campsites = self . _compile_campground_availabilities ( availability = availability ) campsite_data = DataFrame ( monthly_campsites , columns = YellowstoneConfig . CAMPSITE_DATA_COLUMNS ) . drop_duplicates () if campsite_data . empty is True : return list () available_room_array = self . _gather_campsite_specific_availability ( available_campsites = monthly_campsites , month = month , nights = nights ) available_rooms = DataFrame ( available_room_array ) property_info = self . _get_property_information ( available_rooms = available_room_array ) properties = DataFrame ( property_info ) merged_campsites = available_rooms . merge ( properties , on = [ YellowstoneConfig . FACILITY_ID_COLUMN , YellowstoneConfig . CAMPSITE_ID_COLUMN , ], ) merged_campsites [ YellowstoneConfig . BOOKING_DATE_COLUMN ] = to_datetime ( merged_campsites [ YellowstoneConfig . BOOKING_DATE_COLUMN ] ) if nights is not None : nights_param = dict ( nights = nights ) else : nights_param = dict ( nights = 1 ) booking_nights = nights_param . get ( \"nights\" ) merged_campsites [ YellowstoneConfig . BOOKING_END_DATE_COLUMN ] = merged_campsites [ YellowstoneConfig . BOOKING_DATE_COLUMN ] + timedelta ( days = booking_nights ) merged_campsites [ YellowstoneConfig . BOOKING_NIGHTS_COLUMN ] = booking_nights final_campsites = merged_campsites . merge ( campsite_data , on = YellowstoneConfig . FACILITY_ID_COLUMN ) . sort_values ( by = YellowstoneConfig . BOOKING_DATE_COLUMN ) final_campsites [ YellowstoneConfig . BOOKING_URL_COLUMN ] = final_campsites . apply ( lambda x : self . _return_lodging_url ( lodging_code = x . facility_id , month = x . booking_date , params = nights_param ), axis = 1 , ) all_monthly_campsite_array = self . _df_to_campsites ( campsite_df = final_campsites ) return all_monthly_campsite_array @classmethod def _df_to_campsites ( cls , campsite_df : DataFrame ) -> List [ AvailableCampsite ]: \"\"\" Transform a DataFrame into an array of AvailableCampsites Parameters ---------- campsite_df: DataFrame Returns ------- List[AvailableCampsite] \"\"\" all_monthly_campsite_array = list () for _ , row in campsite_df . iterrows (): campsite = AvailableCampsite ( campsite_id = row [ YellowstoneConfig . CAMPSITE_ID_COLUMN ], booking_date = row [ YellowstoneConfig . BOOKING_DATE_COLUMN ], booking_end_date = row [ YellowstoneConfig . BOOKING_END_DATE_COLUMN ], booking_nights = row [ YellowstoneConfig . BOOKING_NIGHTS_COLUMN ], campsite_site_name = row [ YellowstoneConfig . CAMPSITE_SITE_NAME_COLUMN ], campsite_loop_name = YellowstoneConfig . YELLOWSTONE_LOOP_NAME , campsite_type = row [ YellowstoneConfig . CAMPSITE_TYPE_COLUMN ], campsite_occupancy = row [ YellowstoneConfig . CAMPSITE_OCCUPANCY_COLUMN ], campsite_use_type = row [ YellowstoneConfig . CAMPSITE_USE_TYPE_COLUMN ], availability_status = YellowstoneConfig . CAMPSITE_AVAILABILITY_STATUS , recreation_area = YellowstoneConfig . YELLOWSTONE_RECREATION_AREA_NAME , recreation_area_id = YellowstoneConfig . YELLOWSTONE_RECREATION_AREA_ID , facility_name = row [ YellowstoneConfig . FACILITY_NAME_COLUMN ], facility_id = row [ YellowstoneConfig . FACILITY_ID_COLUMN ], booking_url = row [ YellowstoneConfig . BOOKING_URL_COLUMN ], ) all_monthly_campsite_array . append ( campsite ) return all_monthly_campsite_array @classmethod def _ensure_current_month ( cls , month : datetime ) -> datetime : \"\"\" Ensure That We Never Give the Yellowstone API Dates in the past. Parameters ---------- month: datetime Returns ------- datetime \"\"\" yellowstone_timezone = timezone ( YellowstoneConfig . YELLOWSTONE_TIMEZONE ) yellowstone_current_time = datetime . now ( yellowstone_timezone ) . date () today = datetime ( year = yellowstone_current_time . year , month = yellowstone_current_time . month , day = yellowstone_current_time . day , ) . date () if today > month : month = today return month","title":"YellowstoneLodging"},{"location":"reference/providers/xanterra/yellowstone_lodging/#camply.providers.xanterra.yellowstone_lodging.YellowstoneLodging.__repr__","text":"String Representation","title":"__repr__()"},{"location":"reference/providers/xanterra/yellowstone_lodging/#camply.providers.xanterra.yellowstone_lodging.YellowstoneLodging.__repr__--returns","text":"str Source code in camply/providers/xanterra/yellowstone_lodging.py 31 32 33 34 35 36 37 38 39 def __repr__ ( self ): \"\"\" String Representation Returns ------- str \"\"\" return \"<YellowstoneLodging>\"","title":"Returns"},{"location":"reference/providers/xanterra/yellowstone_lodging/#camply.providers.xanterra.yellowstone_lodging.YellowstoneLodging.get_monthly_campsites","text":"Return All Campsites Available in a Given Month","title":"get_monthly_campsites()"},{"location":"reference/providers/xanterra/yellowstone_lodging/#camply.providers.xanterra.yellowstone_lodging.YellowstoneLodging.get_monthly_campsites--parameters","text":"datetime Month to Search Optional[int] Search for consecutive nights","title":"Parameters"},{"location":"reference/providers/xanterra/yellowstone_lodging/#camply.providers.xanterra.yellowstone_lodging.YellowstoneLodging.get_monthly_campsites--returns","text":"List[AvailableCampsite] Source code in camply/providers/xanterra/yellowstone_lodging.py 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 def get_monthly_campsites ( self , month : datetime , nights : Optional [ int ] = None ) -> List [ AvailableCampsite ]: \"\"\" Return All Campsites Available in a Given Month Parameters ---------- month: datetime Month to Search nights: Optional[int] Search for consecutive nights Returns ------- List[AvailableCampsite] \"\"\" now = datetime . now () . date () search_date = month . replace ( day = 1 ) if month <= now : logger . info ( \"Cannot input search dates before today, adjusting search parameters.\" ) search_date = search_date . replace ( year = now . year , month = now . month , day = now . day ) availability_found = self . _get_monthly_availability ( month = search_date , nights = nights ) availability = XantResortData ( ** availability_found ) monthly_campsites = self . _compile_campground_availabilities ( availability = availability ) campsite_data = DataFrame ( monthly_campsites , columns = YellowstoneConfig . CAMPSITE_DATA_COLUMNS ) . drop_duplicates () if campsite_data . empty is True : return list () available_room_array = self . _gather_campsite_specific_availability ( available_campsites = monthly_campsites , month = month , nights = nights ) available_rooms = DataFrame ( available_room_array ) property_info = self . _get_property_information ( available_rooms = available_room_array ) properties = DataFrame ( property_info ) merged_campsites = available_rooms . merge ( properties , on = [ YellowstoneConfig . FACILITY_ID_COLUMN , YellowstoneConfig . CAMPSITE_ID_COLUMN , ], ) merged_campsites [ YellowstoneConfig . BOOKING_DATE_COLUMN ] = to_datetime ( merged_campsites [ YellowstoneConfig . BOOKING_DATE_COLUMN ] ) if nights is not None : nights_param = dict ( nights = nights ) else : nights_param = dict ( nights = 1 ) booking_nights = nights_param . get ( \"nights\" ) merged_campsites [ YellowstoneConfig . BOOKING_END_DATE_COLUMN ] = merged_campsites [ YellowstoneConfig . BOOKING_DATE_COLUMN ] + timedelta ( days = booking_nights ) merged_campsites [ YellowstoneConfig . BOOKING_NIGHTS_COLUMN ] = booking_nights final_campsites = merged_campsites . merge ( campsite_data , on = YellowstoneConfig . FACILITY_ID_COLUMN ) . sort_values ( by = YellowstoneConfig . BOOKING_DATE_COLUMN ) final_campsites [ YellowstoneConfig . BOOKING_URL_COLUMN ] = final_campsites . apply ( lambda x : self . _return_lodging_url ( lodging_code = x . facility_id , month = x . booking_date , params = nights_param ), axis = 1 , ) all_monthly_campsite_array = self . _df_to_campsites ( campsite_df = final_campsites ) return all_monthly_campsite_array","title":"Returns"},{"location":"reference/providers/xanterra/yellowstone_lodging/#camply.providers.xanterra.yellowstone_lodging.YellowstoneLodging.make_yellowstone_request","text":"Try and Retry Fetching Data from the Yellowstone API. Unfortunately this is a required method to request the data since the Yellowstone API doesn't always return data.","title":"make_yellowstone_request()"},{"location":"reference/providers/xanterra/yellowstone_lodging/#camply.providers.xanterra.yellowstone_lodging.YellowstoneLodging.make_yellowstone_request--parameters","text":"str API Endpoint params","title":"Parameters"},{"location":"reference/providers/xanterra/yellowstone_lodging/#camply.providers.xanterra.yellowstone_lodging.YellowstoneLodging.make_yellowstone_request--returns","text":"dict Source code in camply/providers/xanterra/yellowstone_lodging.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 @staticmethod def make_yellowstone_request ( endpoint : str , params : Optional [ dict ] = None ) -> dict : \"\"\" Try and Retry Fetching Data from the Yellowstone API. Unfortunately this is a required method to request the data since the Yellowstone API doesn't always return data. Parameters ---------- endpoint: str API Endpoint params Returns ------- dict \"\"\" try : content = YellowstoneLodging . _try_retry_get_data ( endpoint = endpoint , params = params ) except RuntimeError as re : raise RuntimeError ( f \"error_message: { re } \" ) return content","title":"Returns"},{"location":"reference/search/","text":"camply search init file BaseCampingSearch # Bases: ABC Camping Search Object Source code in camply/search/base_search.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 class BaseCampingSearch ( ABC ): \"\"\" Camping Search Object \"\"\" def __init__ ( self , provider : Union [ RecreationDotGov , YellowstoneLodging ], search_window : Union [ SearchWindow , List [ SearchWindow ]], weekends_only : bool = False , nights : int = 1 , offline_search : bool = False , offline_search_path : Optional [ str ] = None , ** kwargs , ) -> None : \"\"\" Initialize with Search Parameters Parameters ---------- provider: Union[RecreationDotGov, YellowstoneLodging] API Provider search_window: Union[SearchWindow, List[SearchWindow]] Search Window tuple containing start date and End Date weekends_only: bool Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights) nights: int minimum number of consecutive nights to search per campsite,defaults to 1 offline_search: bool When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. offline_search_path: Optional[str] When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to `camply_campsites.json` \"\"\" self . campsite_finder : Union [ RecreationDotGov , YellowstoneLodging ] = provider self . search_window : List [ SearchWindow ] = make_list ( search_window ) self . weekends_only : bool = weekends_only self . search_days : List [ datetime ] = self . _get_search_days () self . search_months : List [ datetime ] = self . _get_search_months () self . nights = self . _validate_consecutive_nights ( nights = nights ) self . offline_search = offline_search self . offline_search_path = self . _set_offline_search_path ( file_path = offline_search_path ) self . campsites_found : Set [ AvailableCampsite ] = set () self . loaded_campsites : Set [ AvailableCampsite ] = set () if self . offline_search_path . suffixes [ - 1 ] == \".json\" : self . offline_mode : str = \"json\" elif self . offline_search_path . suffixes [ - 1 ] in [ \".pkl\" , \".pickle\" ]: self . offline_mode : str = \"pickle\" else : raise CamplyError ( \"You must provide a `.json` or a `.pickle` / `.pkl` file name for offline searches\" ) if self . offline_search is True : logger . info ( \"Campsite search is configured to save offline: %s \" , self . offline_search_path , ) self . campsites_found : Set [ AvailableCampsite ] = self . load_campsites_from_file () self . loaded_campsites : Set [ AvailableCampsite ] = self . campsites_found . copy () @abstractmethod def get_all_campsites ( self ) -> List [ AvailableCampsite ]: \"\"\" Perform the Search and Return Matching Availabilities. This method must be implemented on all sub-classes. Returns ------- List[AvailableCampsite] \"\"\" def _get_intersection_date_overlap ( self , date : Timestamp , periods : int ) -> bool : \"\"\" Find Date Overlap Parameters ---------- date: Timestamp periods: int Returns ------- bool \"\"\" timestamp_range : List [ Timestamp ] = date_range ( start = date . to_pydatetime (), periods = periods ) campsite_date_range = { item . date () for item in timestamp_range } intersection = campsite_date_range . intersection ( self . search_days ) if intersection : return True else : return False def _compare_date_overlap ( self , campsite : AvailableCampsite ) -> bool : \"\"\" See whether a campsite should be returned as found Parameters ---------- campsite: AvailableCampsite Returns ------- bool \"\"\" intersection = self . _get_intersection_date_overlap ( date = campsite . booking_date , periods = campsite . booking_nights ) return intersection def _filter_date_overlap ( self , campsites : DataFrame ) -> pd . DataFrame : \"\"\" See whether a campsite should be returned as found Parameters ---------- campsites: pd.DataFrame Returns ------- pd.DataFrame \"\"\" matches = campsites . apply ( lambda x : self . _get_intersection_date_overlap ( date = x . booking_date , periods = x . booking_nights ), axis = 1 , ) filtered_campsites = campsites [ matches ] . copy () . reset_index ( drop = True ) return filtered_campsites def _search_matching_campsites_available ( self , log : bool = False , verbose : bool = False , raise_error : bool = False ) -> List [ AvailableCampsite ]: \"\"\" Perform the Search and Return Matching Availabilities Parameters ---------- log: bool Whether to log found campsites verbose: bool Used with `log` to enhance the amount of info logged to the console raise_error: bool Whether to raise an error if nothing is found. Defaults to False. Returns ------- List[AvailableCampsite] \"\"\" matching_campgrounds = list () for camp in self . get_all_campsites (): if all ( [ self . _compare_date_overlap ( campsite = camp ) is True , camp . booking_nights >= self . nights , ] ): matching_campgrounds . append ( camp ) logger . info ( f \" { ( get_emoji ( matching_campgrounds ) + ' ' ) * 4 }{ len ( matching_campgrounds ) } \" \"Reservable Campsites Matching Search Preferences\" ) self . assemble_availabilities ( matching_data = matching_campgrounds , log = log , verbose = verbose ) if ( self . offline_search is True and self . loaded_campsites . issuperset ( matching_campgrounds ) and raise_error is True ): campsite_availability_message = ( \"No New Campsites were found, we'll continue checking\" ) logger . info ( campsite_availability_message ) raise CampsiteNotFoundError ( campsite_availability_message ) elif len ( matching_campgrounds ) == 0 and raise_error is True : campsite_availability_message = ( \"No Campsites were found, we'll continue checking\" ) logger . info ( campsite_availability_message ) raise CampsiteNotFoundError ( campsite_availability_message ) return matching_campgrounds @classmethod def _get_polling_minutes ( cls , polling_interval : Optional [ int ]) -> int : \"\"\" Return the Number of Minutes to Search Parameters ---------- polling_interval: Optional[int] Used with `continuous=True`, the amount of time to wait between searches. Defaults to 10 if not provided, cannot be less than 5 Returns ------- int \"\"\" if polling_interval is None : polling_interval = getenv ( \"POLLING_INTERVAL\" , SearchConfig . RECOMMENDED_POLLING_INTERVAL ) if int ( polling_interval ) < SearchConfig . POLLING_INTERVAL_MINIMUM : polling_interval = SearchConfig . POLLING_INTERVAL_MINIMUM polling_interval_minutes = int ( round ( float ( polling_interval ), 2 )) return polling_interval_minutes def _continuous_search_retry ( self , log : bool , verbose : bool , polling_interval : int , continuous_search_attempts : int , notification_provider : Union [ str , List [ str ], BaseNotifications , None ], notify_first_try : bool , ) -> List [ AvailableCampsite ]: \"\"\" Search for Campsites until at least one is found Parameters ---------- log: bool Whether to log found campsites verbose: bool Used with `log` to enhance the amount of info logged to the console polling_interval: Optional[int] Used with `continuous=True`, the amount of time to wait between searches. Defaults to 10 if not provided, cannot be less than 5 continuous_search_attempts: int Number of preexisting search attempts notification_provider: provider: Union[str, List[str]] Used with `continuous=True`, Name of notification provider to use. Accepts \"email\", \"pushover\", and defaults to \"silent\". Also accepts a list or commma separated string of these options or even a notification provider object itself notify_first_try: bool Used with `continuous=True`, whether to send all non-silent notifications if more than 5 matching campsites are found on the first try. Defaults to false which only sends the first 5. Returns ------- List[AvailableCampsite] \"\"\" polling_interval_minutes = self . _get_polling_minutes ( polling_interval = polling_interval ) notifier = MultiNotifierProvider ( provider = notification_provider ) logger . info ( f \"Searching for campsites every { polling_interval_minutes } minutes. \" ) notifier . log_providers () retryer = tenacity . Retrying ( retry = tenacity . retry_if_exception_type ( CampsiteNotFoundError ), wait = tenacity . wait . wait_fixed ( int ( polling_interval_minutes ) * 60 ), ) matching_campsites = retryer . __call__ ( self . _search_matching_campsites_available , False , False , True ) found_campsites = set ( matching_campsites ) new_campsites = found_campsites . difference ( self . campsites_found ) self . assemble_availabilities ( matching_data = list ( new_campsites ), log = log , verbose = verbose ) logger . info ( f \" { len ( new_campsites ) } New Campsites Found.\" ) self . campsites_found . update ( new_campsites ) logged_campsites = list ( new_campsites ) self . _handle_notifications ( retryer = retryer , notifier = notifier , logged_campsites = logged_campsites , continuous_search_attempts = continuous_search_attempts , notify_first_try = notify_first_try , ) return list ( self . campsites_found ) @classmethod def _handle_notifications ( cls , retryer : tenacity . Retrying , notifier : MultiNotifierProvider , logged_campsites : List [ AvailableCampsite ], continuous_search_attempts : int , notify_first_try : bool , ) -> None : \"\"\" Handle sending notifications Parameters ---------- retryer: tenacity.Retrying notifier: MultiNotifierProvider logged_campsites: List[AvailableCampsite] continuous_search_attempts: int notify_first_try: bool Returns ------- None \"\"\" attempt_number = retryer . statistics . get ( \"attempt_number\" , 1 ) minimum_first_notify = SearchConfig . MINIMUM_CAMPSITES_FIRST_NOTIFY if max ([ attempt_number , continuous_search_attempts ]) > 1 : logged_campsites = cls . _handle_too_many_campsites_found ( notifier = notifier , logged_campsites = logged_campsites ) notifier . send_campsites ( campsites = logged_campsites ) elif attempt_number == 1 and notify_first_try is True : logged_campsites = cls . _handle_too_many_campsites_found ( notifier = notifier , logged_campsites = logged_campsites ) notifier . send_campsites ( campsites = logged_campsites ) else : if ( len ( notifier . providers ) > 1 and len ( logged_campsites ) > minimum_first_notify ): error_message = ( f \"Found more than { minimum_first_notify } \" f \"matching campsites ( { len ( logged_campsites ) } ) on the \" \"first try. Try searching online instead. \" f \"camply is only sending the first \" f \" { minimum_first_notify } notifications. \" \"Go Get your campsite! \ud83c\udfd5\" ) logger . warning ( error_message ) notifier . send_message ( message = error_message ) logged_campsites = logged_campsites [: minimum_first_notify ] notifier . send_campsites ( campsites = logged_campsites ) @classmethod def _handle_too_many_campsites_found ( cls , notifier : MultiNotifierProvider , logged_campsites : List [ AvailableCampsite ] ) -> List [ AvailableCampsite ]: \"\"\" Handle Scenarios Where Too Many Campsites are Found Parameters ---------- notifier: MultiNotifierProvider logged_campsites: List[AvailableCampsite] Returns ------- List[AvailableCampsite] \"\"\" limit = SearchConfig . MAXIMUM_NOTIFICATION_BATCH_SIZE number_campsites = len ( logged_campsites ) if number_campsites > limit : warning_message = ( f \"Too many campsites were found during the search ( { number_campsites } \" f \"total). camply will only send you the first { limit } notifications.\" ) logger . warning ( warning_message ) restricted_campsites = logged_campsites [: limit ] notifier . send_message ( warning_message ) else : restricted_campsites = logged_campsites return restricted_campsites def _search_campsites_continuous ( self , log : bool = True , verbose : bool = False , polling_interval : Optional [ int ] = None , notification_provider : str = \"silent\" , notify_first_try : bool = False , search_forever : bool = False , ): \"\"\" Continuously Search For Campsites Parameters ---------- log: bool Whether to log found campsites verbose: bool Used with `log` to enhance the amount of info logged to the console polling_interval: Optional[int] Used with `continuous=True`, the amount of time to wait between searches. Defaults to 10 if not provided, cannot be less than 5 notification_provider: str Used with `continuous=True`, Name of notification provider to use. Accepts \"email\", \"pushover\", and defaults to \"silent\". Also accepts a list or commma separated string of these options or even a notification provider object itself notify_first_try: bool Used with `continuous=True`, whether to send all non-silent notifications if more than 5 matching campsites are found on the first try. Defaults to false which only sends the first 5. search_forever: bool Used with `continuous=True`, This option searches for new campsites forever, with the caveat being that it will never notify about the same campsite. Returns ------- List[AvailableCampsite] \"\"\" polling_interval_minutes = self . _get_polling_minutes ( polling_interval = polling_interval ) continuous_search = True continuous_search_attempts = 1 while continuous_search is True : starting_count = len ( self . campsites_found ) self . _continuous_search_retry ( log = log , verbose = verbose , polling_interval = polling_interval , notification_provider = notification_provider , notify_first_try = notify_first_try , continuous_search_attempts = continuous_search_attempts , ) ending_count = len ( self . campsites_found ) continuous_search_attempts += 1 if self . offline_search is True and ending_count > starting_count : self . unload_campsites_to_file () if search_forever is True : sleep ( int ( polling_interval_minutes ) * 60 ) else : continuous_search = False return list ( self . campsites_found ) def get_matching_campsites ( self , log : bool = True , verbose : bool = False , continuous : bool = False , polling_interval : Optional [ int ] = None , notification_provider : str = \"silent\" , notify_first_try : bool = False , search_forever : bool = False , ) -> List [ AvailableCampsite ]: \"\"\" Perform the Search and Return Matching Availabilities Parameters ---------- log: bool Whether to log found campsites verbose: bool Used with `log` to enhance the amount of info logged to the console continuous: bool Whether to continue searching beyond just the first time polling_interval: Optional[int] Used with `continuous=True`, the amount of time to wait between searches. Defaults to 10 if not provided, cannot be less than 5 notification_provider: str Used with `continuous=True`, Name of notification provider to use. Accepts \"email\", \"pushover\", and defaults to \"silent\". Also accepts a list or commma separated string of these options or even a notification provider object itself notify_first_try: bool Used with `continuous=True`, whether to send all non-silent notifications if more than 5 matching campsites are found on the first try. Defaults to false which only sends the first 5. search_forever: bool Used with `continuous=True`, This option searches for new campsites forever, with the caveat being that it will never notify about the same campsite. Returns ------- List[AvailableCampsite] \"\"\" if continuous is True : self . _search_campsites_continuous ( log = log , verbose = verbose , polling_interval = polling_interval , notification_provider = notification_provider , notify_first_try = notify_first_try , search_forever = search_forever , ) else : starting_count = len ( self . campsites_found ) matching_campsites = self . _search_matching_campsites_available ( log = log , verbose = True ) self . campsites_found . update ( set ( matching_campsites )) ending_count = len ( self . campsites_found ) if self . offline_search is True and ending_count > starting_count : self . unload_campsites_to_file () return list ( self . campsites_found ) def _get_search_days ( self ) -> List [ datetime ]: \"\"\" Retrieve Specific Days to Search For Returns ------- search_days: List[datetime] Datetime days to search for reservations \"\"\" current_date = datetime . now () . date () search_nights = set () for window in self . search_window : generated_dates = { date for date in window . get_date_range () if date >= current_date } search_nights . update ( generated_dates ) if self . weekends_only is True : logger . info ( \"Limiting Search of Campgrounds to Weekend Availabilities\" ) search_nights = { x for x in search_nights if x . weekday () in [ 4 , 5 ]} if len ( search_nights ) > 0 : logger . info ( f \" { len ( search_nights ) } booking nights selected for search, \" f \"ranging from { min ( search_nights ) } to { max ( search_nights ) } \" ) else : logger . info ( SearchConfig . ERROR_MESSAGE ) raise RuntimeError ( SearchConfig . ERROR_MESSAGE ) return list ( sorted ( search_nights )) def _get_search_months ( self ) -> List [ datetime ]: \"\"\" Get the Unique Months that need to be Searched Returns ------- search_months: List[datetime] Datetime Months to search for reservations \"\"\" truncated_months = set ([ day . replace ( day = 1 ) for day in self . search_days ]) if len ( truncated_months ) > 1 : logger . info ( f \" { len ( truncated_months ) } different months selected for search, \" f \"ranging from { min ( self . search_days ) } to { max ( self . search_days ) } \" ) return sorted ( list ( truncated_months )) elif len ( truncated_months ) == 0 : logger . info ( SearchConfig . ERROR_MESSAGE ) raise RuntimeError ( SearchConfig . ERROR_MESSAGE ) else : return sorted ( list ( truncated_months )) @classmethod def _consolidate_campsites ( cls , campsite_df : DataFrame , nights : int ) -> List [ AvailableCampsite ]: \"\"\" Consolidate Single Night Campsites into Multiple Night Campsites Parameters ---------- campsite_df: DataFrame DataFrame of AvailableCampsites Returns ------- List[AvailableCampsite] \"\"\" composed_groupings = list () for _ , campsite_slice in campsite_df . groupby ( [ CampsiteContainerFields . CAMPSITE_ID , CampsiteContainerFields . CAMPGROUND_ID ] ): # SORT THE VALUES AND CREATE A COPIED SLICE campsite_grouping = campsite_slice . sort_values ( by = CampsiteContainerFields . BOOKING_DATE , ascending = True ) . copy () # ASSEMBLE THE CAMPSITES AVAILABILITIES INTO GROUPS THAT ARE CONSECUTIVE booking_date = campsite_grouping [ CampsiteContainerFields . BOOKING_DATE ] date = Timedelta ( \"1d\" ) consecutive_nights = booking_date . diff () != date group_identifier = consecutive_nights . cumsum () campsite_grouping [ CampsiteContainerFields . CAMPSITE_GROUP ] = group_identifier # USE THE ASSEMBLED GROUPS TO CREATE UPDATED CAMPSITES AND REMOVE DUPLICATES for _campsite_group , campsite_group_slice in campsite_grouping . groupby ( [ CampsiteContainerFields . CAMPSITE_GROUP ] ): composed_grouping = campsite_group_slice . sort_values ( by = CampsiteContainerFields . BOOKING_DATE , ascending = True ) . copy () composed_grouping . drop ( columns = [ CampsiteContainerFields . CAMPSITE_GROUP ], inplace = True ) nightly_breakouts = cls . _find_consecutive_nights ( dataframe = composed_grouping , nights = nights ) composed_groupings . append ( nightly_breakouts ) if len ( composed_groupings ) == 0 : composed_groupings = [ DataFrame ()] return concat ( composed_groupings , ignore_index = True ) @classmethod def _consecutive_subseq ( cls , iterable : Iterable , length : int ) -> Generator : \"\"\" Find All Sub Sequences by length Given a List See https://tinyurl.com/5av5unjd Parameters ---------- iterable: Iterable length: int Returns ------- Generator \"\"\" for _ , consec_run in groupby ( enumerate ( iterable ), lambda x : x [ 0 ] - x [ 1 ]): k_wise = tee ( map ( itemgetter ( 1 ), consec_run ), length ) for n , it in enumerate ( k_wise ): next ( islice ( it , n , n ), None ) yield from zip ( * k_wise ) @classmethod def _find_consecutive_nights ( cls , dataframe : DataFrame , nights : int ) -> DataFrame : \"\"\" Explode a DataFrame of Consecutive Nightly Campsite Availabilities, Expand to all unique possibilities given the length of the stay. Parameters ---------- dataframe: DataFrame nights: int Returns ------- DataFrame \"\"\" duplicate_subset = set ( dataframe . columns ) - AvailableCampsite . __unhashable__ dataframe_slice = dataframe . copy () . reset_index ( drop = True ) nights_indexes = dataframe_slice . booking_date . index consecutive_generator = cls . _consecutive_subseq ( iterable = nights_indexes , length = nights ) sequences = list ( consecutive_generator ) concatted_data = list () for sequence in sequences : index_list = list ( sequence ) data_copy = dataframe_slice . iloc [ index_list ] . copy () data_copy . booking_date = data_copy . booking_date . min () data_copy . booking_end_date = data_copy . booking_end_date . max () data_copy . booking_url = data_copy . booking_url . loc [ index_list [ 0 ]] data_copy . booking_nights = ( data_copy . booking_end_date - data_copy . booking_date ) . dt . days data_copy . drop_duplicates ( inplace = True , subset = duplicate_subset ) concatted_data . append ( data_copy ) if len ( concatted_data ) == 0 : concatted_data = [ DataFrame ()] return concat ( concatted_data , ignore_index = True ) def _validate_consecutive_nights ( self , nights : int ) -> int : \"\"\" Validate the number of consecutive nights to search Parameters ---------- nights : int Number of nights to check Returns ------- int The proper number of nights to search \"\"\" search_days = Series ( self . search_days ) consecutive_nights = search_days . diff () != Timedelta ( \"1d\" ) largest_grouping = consecutive_nights . cumsum () . value_counts () . max () if nights > 1 : logger . info ( f \"Searching for availabilities with { nights } consecutive night stays.\" ) if nights > largest_grouping : logger . warning ( \"Too many consecutive nights selected. \" \"The consecutive night parameter will be set to \" f \"the max possible, { largest_grouping } .\" ) return largest_grouping else : return nights @staticmethod def campsites_to_df ( campsites : List [ AvailableCampsite ]) -> DataFrame : \"\"\" Convert Campsite Array to Parameters ---------- campsites: List[AvailableCampsite] Returns ------- DataFrame \"\"\" campsite_df = DataFrame ( data = [ campsite . dict () for campsite in campsites ], columns = AvailableCampsite . __fields__ , ) return campsite_df @staticmethod def df_to_campsites ( campsite_df : DataFrame ) -> List [ AvailableCampsite ]: \"\"\" Convert Campsite DataFrame to array of AvailableCampsite objects Parameters ---------- campsite_df: DataFrame Returns ------- List[AvailableCampsite] \"\"\" composed_campsite_array = list () composed_campsite_data_array = campsite_df . to_dict ( orient = \"records\" ) for campsite_record in composed_campsite_data_array : composed_campsite_array . append ( AvailableCampsite ( ** campsite_record )) return composed_campsite_array @classmethod def assemble_availabilities ( cls , matching_data : List [ AvailableCampsite ], log : bool = True , verbose : bool = False , ) -> DataFrame : \"\"\" Prepare a Pandas DataFrame from Array of AvailableCampsite objects Parameters ---------- matching_data: List[AvailableCampsite] List of campsites to assemble log: bool Whether to log found campsites verbose: bool Used with `log` to enhance the amount of info logged to the console Returns ------- availability_df: DataFrame \"\"\" availability_df = cls . campsites_to_df ( campsites = matching_data ) if log is True : cls . _log_availabilities ( availability_df = availability_df , verbose = verbose ) return availability_df @classmethod def _log_availabilities ( cls , availability_df : DataFrame , verbose : bool ) -> DataFrame : \"\"\" Log the Availabilities Parameters ---------- availability_df: DataFrame verbose: bool Returns ------- DataFrame \"\"\" booking_date : datetime for booking_date , available_sites in availability_df . groupby ( \"booking_date\" ): logger . info ( f \"\ud83d\udcc5 { booking_date . strftime ( ' %a , %B %d ' ) } \" f \"\ud83c\udfd5 { len ( available_sites ) } sites\" ) location_tuple : tuple for location_tuple , campground_availability in available_sites . groupby ( [ DataColumns . RECREATION_AREA_COLUMN , DataColumns . FACILITY_NAME_COLUMN ] ): logger . info ( f \" \\t \u26f0\ufe0f { ' \ud83c\udfd5 ' . join ( location_tuple ) } : \u26fa \" f \" { len ( campground_availability ) } sites\" ) if verbose is True : for ( booking_nights , nightly_availability , ) in campground_availability . groupby ( [ DataColumns . BOOKING_NIGHTS_COLUMN ] ): unique_urls = nightly_availability [ DataColumns . BOOKING_URL_COLUMN ] . unique () for booking_url in sorted ( unique_urls ): logger . info ( f \" \\t\\t \ud83d\udd17 { booking_url } \" f \"( { booking_nights } night\" f \" { 's' if booking_nights > 1 else '' } )\" ) return availability_df def unload_campsites_to_file ( self ) -> pathlib . Path : \"\"\" Unload a BaseSearch Object's campsites to a serialized Pickle file. Returns ------- pathlib.Path \"\"\" if self . offline_mode == \"pickle\" : pickle . dump ( obj = self . campsites_found , file = self . offline_search_path . open ( mode = \"wb\" ), protocol = 4 , fix_imports = True , ) elif self . offline_mode == \"json\" : json . dump ( obj = self . campsites_found , fp = self . offline_search_path . open ( mode = \"w\" ), sort_keys = True , default = pydantic_encoder , indent = 4 , ) logger . debug ( \" %s campsites saved to file: %s \" , len ( self . campsites_found ), self . offline_search_path , ) return self . offline_search_path def load_campsites_from_file ( self ) -> Set [ AvailableCampsite ]: \"\"\" Load a BaseSearch Object's campsites from a serialized Pickle file. Returns ------- Set[AvailableCampsite] \"\"\" if self . offline_search_path . exists (): if self . offline_mode == \"pickle\" : campsites : Set [ AvailableCampsite ] = pickle . load ( file = self . offline_search_path . open ( mode = \"rb\" ), fix_imports = True ) elif self . offline_mode == \"json\" : campsites_dicts : List [ Dict [ str , Any ]] = json . load ( self . offline_search_path . open ( mode = \"r\" ), ) campsites : Set [ AvailableCampsite ] = set ( [ AvailableCampsite ( ** json_dict ) for json_dict in campsites_dicts ] ) if len ( campsites ) > 0 : logger . info ( \" %s campsites loaded from file: %s \" , len ( campsites ), self . offline_search_path , ) else : campsites = set () return campsites @staticmethod def _set_offline_search_path ( file_path : Optional [ str ]) -> pathlib . Path : default_file_path = \"camply_campsites.json\" if file_path is None : file_path = default_file_path returned_path = pathlib . Path ( file_path ) . resolve () parent_dir = pathlib . Path . cwd () if all ( [ returned_path . exists (), returned_path . is_file (), set ( returned_path . suffixes ) . issubset ({ \".pkl\" , \".pickle\" , \".json\" }), ] ): path_obj = returned_path elif all ( [ returned_path . exists (), returned_path . is_dir (), ] ): path_obj = returned_path . joinpath ( default_file_path ) else : path_obj = parent_dir . joinpath ( file_path ) return path_obj __init__ ( provider , search_window , weekends_only = False , nights = 1 , offline_search = False , offline_search_path = None , ** kwargs ) # Initialize with Search Parameters Parameters # Union[RecreationDotGov, YellowstoneLodging] API Provider Union[SearchWindow, List[SearchWindow]] Search Window tuple containing start date and End Date bool Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights) int minimum number of consecutive nights to search per campsite,defaults to 1 bool When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. Optional[str] When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to camply_campsites.json Source code in camply/search/base_search.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def __init__ ( self , provider : Union [ RecreationDotGov , YellowstoneLodging ], search_window : Union [ SearchWindow , List [ SearchWindow ]], weekends_only : bool = False , nights : int = 1 , offline_search : bool = False , offline_search_path : Optional [ str ] = None , ** kwargs , ) -> None : \"\"\" Initialize with Search Parameters Parameters ---------- provider: Union[RecreationDotGov, YellowstoneLodging] API Provider search_window: Union[SearchWindow, List[SearchWindow]] Search Window tuple containing start date and End Date weekends_only: bool Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights) nights: int minimum number of consecutive nights to search per campsite,defaults to 1 offline_search: bool When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. offline_search_path: Optional[str] When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to `camply_campsites.json` \"\"\" self . campsite_finder : Union [ RecreationDotGov , YellowstoneLodging ] = provider self . search_window : List [ SearchWindow ] = make_list ( search_window ) self . weekends_only : bool = weekends_only self . search_days : List [ datetime ] = self . _get_search_days () self . search_months : List [ datetime ] = self . _get_search_months () self . nights = self . _validate_consecutive_nights ( nights = nights ) self . offline_search = offline_search self . offline_search_path = self . _set_offline_search_path ( file_path = offline_search_path ) self . campsites_found : Set [ AvailableCampsite ] = set () self . loaded_campsites : Set [ AvailableCampsite ] = set () if self . offline_search_path . suffixes [ - 1 ] == \".json\" : self . offline_mode : str = \"json\" elif self . offline_search_path . suffixes [ - 1 ] in [ \".pkl\" , \".pickle\" ]: self . offline_mode : str = \"pickle\" else : raise CamplyError ( \"You must provide a `.json` or a `.pickle` / `.pkl` file name for offline searches\" ) if self . offline_search is True : logger . info ( \"Campsite search is configured to save offline: %s \" , self . offline_search_path , ) self . campsites_found : Set [ AvailableCampsite ] = self . load_campsites_from_file () self . loaded_campsites : Set [ AvailableCampsite ] = self . campsites_found . copy () assemble_availabilities ( matching_data , log = True , verbose = False ) classmethod # Prepare a Pandas DataFrame from Array of AvailableCampsite objects Parameters # List[AvailableCampsite] List of campsites to assemble bool Whether to log found campsites bool Used with log to enhance the amount of info logged to the console Returns # availability_df: DataFrame Source code in camply/search/base_search.py 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 @classmethod def assemble_availabilities ( cls , matching_data : List [ AvailableCampsite ], log : bool = True , verbose : bool = False , ) -> DataFrame : \"\"\" Prepare a Pandas DataFrame from Array of AvailableCampsite objects Parameters ---------- matching_data: List[AvailableCampsite] List of campsites to assemble log: bool Whether to log found campsites verbose: bool Used with `log` to enhance the amount of info logged to the console Returns ------- availability_df: DataFrame \"\"\" availability_df = cls . campsites_to_df ( campsites = matching_data ) if log is True : cls . _log_availabilities ( availability_df = availability_df , verbose = verbose ) return availability_df campsites_to_df ( campsites ) staticmethod # Convert Campsite Array to Parameters # campsites: List[AvailableCampsite] Returns # DataFrame Source code in camply/search/base_search.py 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 @staticmethod def campsites_to_df ( campsites : List [ AvailableCampsite ]) -> DataFrame : \"\"\" Convert Campsite Array to Parameters ---------- campsites: List[AvailableCampsite] Returns ------- DataFrame \"\"\" campsite_df = DataFrame ( data = [ campsite . dict () for campsite in campsites ], columns = AvailableCampsite . __fields__ , ) return campsite_df df_to_campsites ( campsite_df ) staticmethod # Convert Campsite DataFrame to array of AvailableCampsite objects Parameters # campsite_df: DataFrame Returns # List[AvailableCampsite] Source code in camply/search/base_search.py 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 @staticmethod def df_to_campsites ( campsite_df : DataFrame ) -> List [ AvailableCampsite ]: \"\"\" Convert Campsite DataFrame to array of AvailableCampsite objects Parameters ---------- campsite_df: DataFrame Returns ------- List[AvailableCampsite] \"\"\" composed_campsite_array = list () composed_campsite_data_array = campsite_df . to_dict ( orient = \"records\" ) for campsite_record in composed_campsite_data_array : composed_campsite_array . append ( AvailableCampsite ( ** campsite_record )) return composed_campsite_array get_all_campsites () abstractmethod # Perform the Search and Return Matching Availabilities. This method must be implemented on all sub-classes. Returns # List[AvailableCampsite] Source code in camply/search/base_search.py 117 118 119 120 121 122 123 124 125 126 127 128 @abstractmethod def get_all_campsites ( self ) -> List [ AvailableCampsite ]: \"\"\" Perform the Search and Return Matching Availabilities. This method must be implemented on all sub-classes. Returns ------- List[AvailableCampsite] \"\"\" get_matching_campsites ( log = True , verbose = False , continuous = False , polling_interval = None , notification_provider = 'silent' , notify_first_try = False , search_forever = False ) # Perform the Search and Return Matching Availabilities Parameters # bool Whether to log found campsites bool Used with log to enhance the amount of info logged to the console bool Whether to continue searching beyond just the first time Optional[int] Used with continuous=True , the amount of time to wait between searches. Defaults to 10 if not provided, cannot be less than 5 str Used with continuous=True , Name of notification provider to use. Accepts \"email\", \"pushover\", and defaults to \"silent\". Also accepts a list or commma separated string of these options or even a notification provider object itself bool Used with continuous=True , whether to send all non-silent notifications if more than 5 matching campsites are found on the first try. Defaults to false which only sends the first 5. bool Used with continuous=True , This option searches for new campsites forever, with the caveat being that it will never notify about the same campsite. Returns # List[AvailableCampsite] Source code in camply/search/base_search.py 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 def get_matching_campsites ( self , log : bool = True , verbose : bool = False , continuous : bool = False , polling_interval : Optional [ int ] = None , notification_provider : str = \"silent\" , notify_first_try : bool = False , search_forever : bool = False , ) -> List [ AvailableCampsite ]: \"\"\" Perform the Search and Return Matching Availabilities Parameters ---------- log: bool Whether to log found campsites verbose: bool Used with `log` to enhance the amount of info logged to the console continuous: bool Whether to continue searching beyond just the first time polling_interval: Optional[int] Used with `continuous=True`, the amount of time to wait between searches. Defaults to 10 if not provided, cannot be less than 5 notification_provider: str Used with `continuous=True`, Name of notification provider to use. Accepts \"email\", \"pushover\", and defaults to \"silent\". Also accepts a list or commma separated string of these options or even a notification provider object itself notify_first_try: bool Used with `continuous=True`, whether to send all non-silent notifications if more than 5 matching campsites are found on the first try. Defaults to false which only sends the first 5. search_forever: bool Used with `continuous=True`, This option searches for new campsites forever, with the caveat being that it will never notify about the same campsite. Returns ------- List[AvailableCampsite] \"\"\" if continuous is True : self . _search_campsites_continuous ( log = log , verbose = verbose , polling_interval = polling_interval , notification_provider = notification_provider , notify_first_try = notify_first_try , search_forever = search_forever , ) else : starting_count = len ( self . campsites_found ) matching_campsites = self . _search_matching_campsites_available ( log = log , verbose = True ) self . campsites_found . update ( set ( matching_campsites )) ending_count = len ( self . campsites_found ) if self . offline_search is True and ending_count > starting_count : self . unload_campsites_to_file () return list ( self . campsites_found ) load_campsites_from_file () # Load a BaseSearch Object's campsites from a serialized Pickle file. Returns # Set[AvailableCampsite] Source code in camply/search/base_search.py 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 def load_campsites_from_file ( self ) -> Set [ AvailableCampsite ]: \"\"\" Load a BaseSearch Object's campsites from a serialized Pickle file. Returns ------- Set[AvailableCampsite] \"\"\" if self . offline_search_path . exists (): if self . offline_mode == \"pickle\" : campsites : Set [ AvailableCampsite ] = pickle . load ( file = self . offline_search_path . open ( mode = \"rb\" ), fix_imports = True ) elif self . offline_mode == \"json\" : campsites_dicts : List [ Dict [ str , Any ]] = json . load ( self . offline_search_path . open ( mode = \"r\" ), ) campsites : Set [ AvailableCampsite ] = set ( [ AvailableCampsite ( ** json_dict ) for json_dict in campsites_dicts ] ) if len ( campsites ) > 0 : logger . info ( \" %s campsites loaded from file: %s \" , len ( campsites ), self . offline_search_path , ) else : campsites = set () return campsites unload_campsites_to_file () # Unload a BaseSearch Object's campsites to a serialized Pickle file. Returns # pathlib.Path Source code in camply/search/base_search.py 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 def unload_campsites_to_file ( self ) -> pathlib . Path : \"\"\" Unload a BaseSearch Object's campsites to a serialized Pickle file. Returns ------- pathlib.Path \"\"\" if self . offline_mode == \"pickle\" : pickle . dump ( obj = self . campsites_found , file = self . offline_search_path . open ( mode = \"wb\" ), protocol = 4 , fix_imports = True , ) elif self . offline_mode == \"json\" : json . dump ( obj = self . campsites_found , fp = self . offline_search_path . open ( mode = \"w\" ), sort_keys = True , default = pydantic_encoder , indent = 4 , ) logger . debug ( \" %s campsites saved to file: %s \" , len ( self . campsites_found ), self . offline_search_path , ) return self . offline_search_path SearchRecreationDotGov # Bases: BaseCampingSearch Camping Search Object Source code in camply/search/search_recreationdotgov.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 class SearchRecreationDotGov ( BaseCampingSearch ): \"\"\" Camping Search Object \"\"\" def __init__ ( self , search_window : Union [ SearchWindow , List [ SearchWindow ]], recreation_area : Optional [ Union [ List [ int ], int ]] = None , campgrounds : Optional [ Union [ List [ int ], int ]] = None , campsites : Optional [ Union [ List [ int ], int ]] = None , weekends_only : bool = False , nights : int = 1 , equipment : Optional [ List [ Tuple [ str , Optional [ int ]]]] = None , offline_search : bool = False , offline_search_path : Optional [ str ] = None , ** kwargs , ) -> None : \"\"\" Initialize with Search Parameters Parameters ---------- search_window: Union[SearchWindow, List[SearchWindow]] Search Window tuple containing start date and End Date recreation_area: Optional[Union[List[int], int]] ID of Recreation Area (i.e. 2907 - Rocky Mountain National Park) campgrounds: Optional[Union[List[int], int]] Campground ID or List of Campground IDs campsites: Optional[Union[List[int], int]] Campsite ID or List of Campsite IDs weekends_only: bool Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights) nights: int minimum number of consecutive nights to search per campsite,defaults to 1 equipment: Optional[List[Tuple[str, Optional[int]]]] List of Tuples of Equipment to Search for. An equipment tuple array looks like this: `[(\"Tent\", None), (\"RV\", 20)]` - meaning the selected search looks for sites to accommodate any tent size and RVs less than or equal to 20 feet. Tuples contain the Equipment name and an optional equipment length, otherwise provide None. Equipment names include `Tent`, `RV`, `Trailer`, `Vehicle` and are not case-sensitive. offline_search: bool When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. offline_search_path: Optional[str] When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to `camply_campsites.json` \"\"\" self . campsite_finder : RecreationDotGov super ( SearchRecreationDotGov , self ) . __init__ ( provider = RecreationDotGov (), search_window = search_window , weekends_only = weekends_only , nights = nights , offline_search = offline_search , offline_search_path = offline_search_path , ) self . _recreation_area_id = make_list ( recreation_area ) self . _campground_object = campgrounds self . weekends_only = weekends_only assert ( any ( [ campsites not in [[], None ], campgrounds not in [[], None ], recreation_area is not None , ] ) is True ) self . campsites = make_list ( campsites ) self . campgrounds = self . _get_searchable_campgrounds () self . campsite_metadata : Optional [ pd . DataFrame ] = None self . equipment : List [ Tuple [ str , Optional [ int ]]] = [] self . equipment = self . _get_searchable_equipment ( equipment = equipment ) def _get_searchable_campgrounds ( self ) -> List [ CampgroundFacility ]: \"\"\" Return a List of Campgrounds to search This handles scenarios where a recreation area is provided instead of a campground list Returns ------- searchable_campgrounds: List[int] List of searchable campground IDs \"\"\" if self . campsites not in [(), [], None ]: self . campsites = [ int ( campsite_id ) for campsite_id in self . campsites ] searchable_campgrounds = self . _get_campgrounds_by_campsite_id () elif self . _campground_object not in [(), [], None ]: searchable_campgrounds = self . _get_campgrounds_by_campground_id () elif self . _recreation_area_id not in [(), [], None ]: searchable_campgrounds = self . _get_campgrounds_by_recreation_area_id () else : raise RuntimeError ( \"You must provide a Campground or Recreation Area ID\" ) return list ( set ( searchable_campgrounds )) @classmethod def _get_searchable_equipment ( cls , equipment : Optional [ List [ Tuple [ str , Optional [ int ]]]] ) -> Optional [ List [ Tuple [ str , Optional [ int ]]]]: \"\"\" Sort through and validate Equipment Parameters ---------- equipment: Optional[List[Tuple[str, Optional[int]]]] Returns ------- Optional[List[Tuple[str, Optional[int]]]] \"\"\" equipment_names = [] final_equipment = None if isinstance ( equipment , ( list , tuple )): final_equipment = [] for equipment_name , equipment_length in equipment : if ( equipment_name . lower () not in EquipmentOptions . __all_accepted_equipment__ ): logger . warning ( f \"Equipment name not recognized: { equipment_name } . This won't \" \"be used for filtering.\" \"Acceptable options are: \" f \" { ', ' . join ( EquipmentOptions . __all_accepted_equipment__ ) } \" ) else : final_equipment . append (( equipment_name , equipment_length )) equipment_names . append ( equipment_name ) if len ( final_equipment ) > 0 : logger . info ( f \"Filtering Campsites based on Equipment: { ' | ' . join ( equipment_names ) } \" ) return final_equipment def _get_campgrounds_by_campground_id ( self ) -> List [ CampgroundFacility ]: \"\"\" Return a List of Campgrounds to search when provided with campground IDs Returns ------- returned_sites: List[int] List of searchable campground IDs \"\"\" campground_list = make_list ( self . _campground_object ) facilities = self . campsite_finder . find_campgrounds ( campground_id = campground_list ) return facilities def _get_campgrounds_by_campsite_id ( self ) -> List [ CampgroundFacility ]: \"\"\" Return a List of Campgrounds to search when provided with Campsite IDs Returns ------- returned_sites: List[int] List of searchable campground IDs \"\"\" campsite_list = make_list ( self . campsites ) facilities = self . campsite_finder . find_campgrounds ( campsite_id = campsite_list ) return facilities def _get_campgrounds_by_recreation_area_id ( self ) -> List [ CampgroundFacility ]: \"\"\" Return a List of Campgrounds to search when provided with Recreation Area IDs Returns ------- campgrounds: List[CampgroundFacility] \"\"\" campgrounds = list () for rec_area in self . _recreation_area_id : campground_array = self . campsite_finder . find_facilities_per_recreation_area ( rec_area_id = rec_area ) campgrounds += campground_array return campgrounds def get_all_campsites ( self ) -> List [ AvailableCampsite ]: \"\"\" Perform the Search and Return All Monthly Availabilities Returns ------- List[AvailableCampsite] \"\"\" found_campsites = list () if len ( self . campgrounds ) == 0 : error_message = \"No campgrounds found to search\" logger . error ( error_message ) raise SearchError ( error_message ) logger . info ( f \"Searching across { len ( self . campgrounds ) } campgrounds\" ) if self . campsite_metadata is None : self . campsite_metadata = ( self . campsite_finder . get_internal_campsite_metadata ( facility_ids = [ facil . facility_id for facil in self . campgrounds ] ) ) logger . info ( \"Metadata fetched for %s campsites\" , len ( self . campsite_metadata ) ) for index , campground in enumerate ( self . campgrounds ): for month in self . search_months : logger . info ( f \"Searching { campground . facility_name } , { campground . recreation_area } \" f \"( { campground . facility_id } ) for availability: \" f \" { month . strftime ( '%B, %Y' ) } \" ) availabilities = self . campsite_finder . get_recdotgov_data ( campground_id = campground . facility_id , month = month ) campsites = self . campsite_finder . process_campsite_availability ( availability = availabilities , recreation_area = campground . recreation_area , recreation_area_id = campground . recreation_area_id , facility_name = campground . facility_name , facility_id = campground . facility_id , month = month , campsite_metadata = self . campsite_metadata , ) if self . campsites not in [ None , []]: campsites = [ campsite_obj for campsite_obj in campsites if int ( campsite_obj . campsite_id ) in self . campsites ] found_campsites += campsites if index + 1 < len ( self . campgrounds ): sleep ( round ( uniform ( * RecreationBookingConfig . RATE_LIMITING ), 2 )) campsite_df = self . campsites_to_df ( campsites = found_campsites ) campsite_df_validated = self . _filter_date_overlap ( campsites = campsite_df ) compiled_campsite_df = self . _consolidate_campsites ( campsite_df = campsite_df_validated , nights = self . nights ) equipment_filtered_campsites = self . filter_campsites_to_equipment ( campsites = compiled_campsite_df ) compiled_campsites = self . df_to_campsites ( campsite_df = equipment_filtered_campsites ) return compiled_campsites def filter_campsites_to_equipment ( self , campsites : pd . DataFrame ) -> pd . DataFrame : \"\"\" Filter a Campsite DataFrame down to specified equipment Parameters ---------- campsites: pd.DataFrame Returns ------- pd.DataFrame \"\"\" if self . equipment is None or len ( self . equipment ) == 0 or len ( campsites ) == 0 : return campsites column_names = [ \"campsite_id\" , \"permitted_equipment\" ] exploded_data = campsites [ column_names ] . explode ( \"permitted_equipment\" ) expanded_data = exploded_data [ \"permitted_equipment\" ] . apply ( pd . Series ) joined_data = pd . DataFrame ( pd . concat ([ exploded_data , expanded_data ], axis = 1 ), columns = column_names + [ \"equipment_name\" , \"max_length\" ], ) joined_data [ \"equipment_name_normalized\" ] = ( joined_data [ \"equipment_name\" ] . fillna ( \"\" ) . apply ( lambda x : EquipmentConfig . EQUIPMENT_REVERSE_MAPPING [ x ]) ) equipment_types = [ item [ 0 ] . lower () for item in self . equipment ] matching_equipment = joined_data [ joined_data [ \"equipment_name_normalized\" ] . isin ( equipment_types ) ] matching_ids = [] for equipment_name , equipment_length in self . equipment : matching_data = matching_equipment [ matching_equipment [ \"equipment_name_normalized\" ] == equipment_name . lower () ] . copy () if equipment_length is not None : matching_data = matching_data [ matching_data [ \"max_length\" ] >= float ( equipment_length ) ] matching_ids += list ( matching_data [ \"campsite_id\" ] . unique ()) original_campsites = campsites [ campsites [ \"campsite_id\" ] . isin ( matching_ids ) ] . copy () return original_campsites __init__ ( search_window , recreation_area = None , campgrounds = None , campsites = None , weekends_only = False , nights = 1 , equipment = None , offline_search = False , offline_search_path = None , ** kwargs ) # Initialize with Search Parameters Parameters # Union[SearchWindow, List[SearchWindow]] Search Window tuple containing start date and End Date Optional[Union[List[int], int]] ID of Recreation Area (i.e. 2907 - Rocky Mountain National Park) Optional[Union[List[int], int]] Campground ID or List of Campground IDs Optional[Union[List[int], int]] Campsite ID or List of Campsite IDs bool Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights) int minimum number of consecutive nights to search per campsite,defaults to 1 Optional[List[Tuple[str, Optional[int]]]] List of Tuples of Equipment to Search for. An equipment tuple array looks like this: [(\"Tent\", None), (\"RV\", 20)] - meaning the selected search looks for sites to accommodate any tent size and RVs less than or equal to 20 feet. Tuples contain the Equipment name and an optional equipment length, otherwise provide None. Equipment names include Tent , RV , Trailer , Vehicle and are not case-sensitive. bool When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. Optional[str] When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to camply_campsites.json Source code in camply/search/search_recreationdotgov.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def __init__ ( self , search_window : Union [ SearchWindow , List [ SearchWindow ]], recreation_area : Optional [ Union [ List [ int ], int ]] = None , campgrounds : Optional [ Union [ List [ int ], int ]] = None , campsites : Optional [ Union [ List [ int ], int ]] = None , weekends_only : bool = False , nights : int = 1 , equipment : Optional [ List [ Tuple [ str , Optional [ int ]]]] = None , offline_search : bool = False , offline_search_path : Optional [ str ] = None , ** kwargs , ) -> None : \"\"\" Initialize with Search Parameters Parameters ---------- search_window: Union[SearchWindow, List[SearchWindow]] Search Window tuple containing start date and End Date recreation_area: Optional[Union[List[int], int]] ID of Recreation Area (i.e. 2907 - Rocky Mountain National Park) campgrounds: Optional[Union[List[int], int]] Campground ID or List of Campground IDs campsites: Optional[Union[List[int], int]] Campsite ID or List of Campsite IDs weekends_only: bool Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights) nights: int minimum number of consecutive nights to search per campsite,defaults to 1 equipment: Optional[List[Tuple[str, Optional[int]]]] List of Tuples of Equipment to Search for. An equipment tuple array looks like this: `[(\"Tent\", None), (\"RV\", 20)]` - meaning the selected search looks for sites to accommodate any tent size and RVs less than or equal to 20 feet. Tuples contain the Equipment name and an optional equipment length, otherwise provide None. Equipment names include `Tent`, `RV`, `Trailer`, `Vehicle` and are not case-sensitive. offline_search: bool When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. offline_search_path: Optional[str] When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to `camply_campsites.json` \"\"\" self . campsite_finder : RecreationDotGov super ( SearchRecreationDotGov , self ) . __init__ ( provider = RecreationDotGov (), search_window = search_window , weekends_only = weekends_only , nights = nights , offline_search = offline_search , offline_search_path = offline_search_path , ) self . _recreation_area_id = make_list ( recreation_area ) self . _campground_object = campgrounds self . weekends_only = weekends_only assert ( any ( [ campsites not in [[], None ], campgrounds not in [[], None ], recreation_area is not None , ] ) is True ) self . campsites = make_list ( campsites ) self . campgrounds = self . _get_searchable_campgrounds () self . campsite_metadata : Optional [ pd . DataFrame ] = None self . equipment : List [ Tuple [ str , Optional [ int ]]] = [] self . equipment = self . _get_searchable_equipment ( equipment = equipment ) filter_campsites_to_equipment ( campsites ) # Filter a Campsite DataFrame down to specified equipment Parameters # campsites: pd.DataFrame Returns # pd.DataFrame Source code in camply/search/search_recreationdotgov.py 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 def filter_campsites_to_equipment ( self , campsites : pd . DataFrame ) -> pd . DataFrame : \"\"\" Filter a Campsite DataFrame down to specified equipment Parameters ---------- campsites: pd.DataFrame Returns ------- pd.DataFrame \"\"\" if self . equipment is None or len ( self . equipment ) == 0 or len ( campsites ) == 0 : return campsites column_names = [ \"campsite_id\" , \"permitted_equipment\" ] exploded_data = campsites [ column_names ] . explode ( \"permitted_equipment\" ) expanded_data = exploded_data [ \"permitted_equipment\" ] . apply ( pd . Series ) joined_data = pd . DataFrame ( pd . concat ([ exploded_data , expanded_data ], axis = 1 ), columns = column_names + [ \"equipment_name\" , \"max_length\" ], ) joined_data [ \"equipment_name_normalized\" ] = ( joined_data [ \"equipment_name\" ] . fillna ( \"\" ) . apply ( lambda x : EquipmentConfig . EQUIPMENT_REVERSE_MAPPING [ x ]) ) equipment_types = [ item [ 0 ] . lower () for item in self . equipment ] matching_equipment = joined_data [ joined_data [ \"equipment_name_normalized\" ] . isin ( equipment_types ) ] matching_ids = [] for equipment_name , equipment_length in self . equipment : matching_data = matching_equipment [ matching_equipment [ \"equipment_name_normalized\" ] == equipment_name . lower () ] . copy () if equipment_length is not None : matching_data = matching_data [ matching_data [ \"max_length\" ] >= float ( equipment_length ) ] matching_ids += list ( matching_data [ \"campsite_id\" ] . unique ()) original_campsites = campsites [ campsites [ \"campsite_id\" ] . isin ( matching_ids ) ] . copy () return original_campsites get_all_campsites () # Perform the Search and Return All Monthly Availabilities Returns # List[AvailableCampsite] Source code in camply/search/search_recreationdotgov.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 def get_all_campsites ( self ) -> List [ AvailableCampsite ]: \"\"\" Perform the Search and Return All Monthly Availabilities Returns ------- List[AvailableCampsite] \"\"\" found_campsites = list () if len ( self . campgrounds ) == 0 : error_message = \"No campgrounds found to search\" logger . error ( error_message ) raise SearchError ( error_message ) logger . info ( f \"Searching across { len ( self . campgrounds ) } campgrounds\" ) if self . campsite_metadata is None : self . campsite_metadata = ( self . campsite_finder . get_internal_campsite_metadata ( facility_ids = [ facil . facility_id for facil in self . campgrounds ] ) ) logger . info ( \"Metadata fetched for %s campsites\" , len ( self . campsite_metadata ) ) for index , campground in enumerate ( self . campgrounds ): for month in self . search_months : logger . info ( f \"Searching { campground . facility_name } , { campground . recreation_area } \" f \"( { campground . facility_id } ) for availability: \" f \" { month . strftime ( '%B, %Y' ) } \" ) availabilities = self . campsite_finder . get_recdotgov_data ( campground_id = campground . facility_id , month = month ) campsites = self . campsite_finder . process_campsite_availability ( availability = availabilities , recreation_area = campground . recreation_area , recreation_area_id = campground . recreation_area_id , facility_name = campground . facility_name , facility_id = campground . facility_id , month = month , campsite_metadata = self . campsite_metadata , ) if self . campsites not in [ None , []]: campsites = [ campsite_obj for campsite_obj in campsites if int ( campsite_obj . campsite_id ) in self . campsites ] found_campsites += campsites if index + 1 < len ( self . campgrounds ): sleep ( round ( uniform ( * RecreationBookingConfig . RATE_LIMITING ), 2 )) campsite_df = self . campsites_to_df ( campsites = found_campsites ) campsite_df_validated = self . _filter_date_overlap ( campsites = campsite_df ) compiled_campsite_df = self . _consolidate_campsites ( campsite_df = campsite_df_validated , nights = self . nights ) equipment_filtered_campsites = self . filter_campsites_to_equipment ( campsites = compiled_campsite_df ) compiled_campsites = self . df_to_campsites ( campsite_df = equipment_filtered_campsites ) return compiled_campsites SearchYellowstone # Bases: BaseCampingSearch Camping Search Object Source code in camply/search/search_yellowstone.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 class SearchYellowstone ( BaseCampingSearch ): \"\"\" Camping Search Object \"\"\" # noinspection PyUnusedLocal def __init__ ( self , search_window : Union [ SearchWindow , List [ SearchWindow ]], weekends_only : bool = False , campgrounds : Optional [ Union [ List [ str ], str ]] = None , nights : int = 1 , offline_search : bool = False , offline_search_path : Optional [ str ] = None , ** kwargs , ) -> None : \"\"\" Initialize with Search Parameters Parameters ---------- search_window: Union[SearchWindow, List[SearchWindow]] Search Window tuple containing start date and End Date weekends_only: bool Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights) campgrounds: Optional[Union[List[str], str]] Campground ID or List of Campground IDs nights: int minimum number of consecutive nights to search per campsite,defaults to 1 offline_search: bool When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. offline_search_path: Optional[str] When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to `camply_campsites.json` \"\"\" super () . __init__ ( provider = YellowstoneLodging (), search_window = search_window , weekends_only = weekends_only , nights = nights , offline_search = offline_search , offline_search_path = offline_search_path , ) self . campgrounds = make_list ( campgrounds ) def get_all_campsites ( self ) -> List [ AvailableCampsite ]: \"\"\" Search for all matching campsites in Yellowstone. Returns ------- List[AvailableCampsite] \"\"\" all_campsites = list () searchable_campgrounds = self . _get_searchable_campgrounds () this_month = datetime . now () . date () . replace ( day = 1 ) for month in self . search_months : if month >= this_month : all_campsites += self . campsite_finder . get_monthly_campsites ( month = month , nights = None if self . nights == 1 else self . nights ) matching_campsites = self . _filter_campsites_to_campgrounds ( campsites = all_campsites , searchable_campgrounds = searchable_campgrounds ) campsite_df = self . campsites_to_df ( campsites = matching_campsites ) campsite_df_validated = self . _filter_date_overlap ( campsites = campsite_df ) time_window_end = max ( self . search_days ) + timedelta ( days = 1 ) compiled_campsite_df = campsite_df_validated [ campsite_df_validated . booking_end_date <= pd . Timestamp ( time_window_end ) ] compiled_campsites = self . df_to_campsites ( campsite_df = compiled_campsite_df ) return compiled_campsites def _get_searchable_campgrounds ( self ) -> Optional [ Set [ str ]]: \"\"\" Return the Campgrounds for the Camping Search Returns ------- Optional[Set[str]] \"\"\" if self . campgrounds in [ None , []]: return None supported_campsites = set ( YellowstoneConfig . YELLOWSTONE_CAMPGROUNDS . keys ()) selected_campsites = set ( self . campgrounds ) searchable_campgrounds = supported_campsites . intersection ( selected_campsites ) if len ( searchable_campgrounds ) == 0 : campground_ids = [ f \"` { key } ` ( { value } )\" for key , value in YellowstoneConfig . YELLOWSTONE_CAMPGROUNDS . items () ] error_message = ( \"You must supply a YellowstoneNationalParkLodges supported \" \"campground ID. Current supported Campground IDs: \" f \" { ', ' . join ( campground_ids ) } \" ) logger . error ( error_message ) raise SearchError ( error_message ) logger . info ( f \" { len ( searchable_campgrounds ) } Matching Campgrounds Found\" ) for campground in searchable_campgrounds : logger . info ( f \"\u26f0 { YellowstoneConfig . YELLOWSTONE_RECREATION_AREA_FORMAL_NAME } \" f \"(# { YellowstoneConfig . YELLOWSTONE_RECREATION_AREA_ID } ) - \ud83c\udfd5 \" f \" { YellowstoneConfig . YELLOWSTONE_CAMPGROUNDS [ campground ] } ( { campground } )\" ) return searchable_campgrounds def _filter_campsites_to_campgrounds ( self , campsites : List [ AvailableCampsite ], searchable_campgrounds : Set [ str ] ) -> List [ AvailableCampsite ]: \"\"\" Filter Campsites Down to Matching Campgrounds Parameters ---------- campsites: List[AvailableCampsite] searchable_campgrounds: Set[str] Returns ------- List[AvailableCampsite] \"\"\" if self . campgrounds in [ None , []]: return campsites matching_campsites = [ campsite for campsite in campsites if campsite . facility_id in searchable_campgrounds ] return matching_campsites @staticmethod def print_campgrounds () -> None : \"\"\" Print the Campgrounds inside of Yellowstone \"\"\" log_sorted_response ( YellowstoneConfig . YELLOWSTONE_CAMPGROUND_OBJECTS ) __init__ ( search_window , weekends_only = False , campgrounds = None , nights = 1 , offline_search = False , offline_search_path = None , ** kwargs ) # Initialize with Search Parameters Parameters # Union[SearchWindow, List[SearchWindow]] Search Window tuple containing start date and End Date bool Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights) Optional[Union[List[str], str]] Campground ID or List of Campground IDs int minimum number of consecutive nights to search per campsite,defaults to 1 bool When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. Optional[str] When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to camply_campsites.json Source code in camply/search/search_yellowstone.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def __init__ ( self , search_window : Union [ SearchWindow , List [ SearchWindow ]], weekends_only : bool = False , campgrounds : Optional [ Union [ List [ str ], str ]] = None , nights : int = 1 , offline_search : bool = False , offline_search_path : Optional [ str ] = None , ** kwargs , ) -> None : \"\"\" Initialize with Search Parameters Parameters ---------- search_window: Union[SearchWindow, List[SearchWindow]] Search Window tuple containing start date and End Date weekends_only: bool Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights) campgrounds: Optional[Union[List[str], str]] Campground ID or List of Campground IDs nights: int minimum number of consecutive nights to search per campsite,defaults to 1 offline_search: bool When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. offline_search_path: Optional[str] When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to `camply_campsites.json` \"\"\" super () . __init__ ( provider = YellowstoneLodging (), search_window = search_window , weekends_only = weekends_only , nights = nights , offline_search = offline_search , offline_search_path = offline_search_path , ) self . campgrounds = make_list ( campgrounds ) get_all_campsites () # Search for all matching campsites in Yellowstone. Returns # List[AvailableCampsite] Source code in camply/search/search_yellowstone.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def get_all_campsites ( self ) -> List [ AvailableCampsite ]: \"\"\" Search for all matching campsites in Yellowstone. Returns ------- List[AvailableCampsite] \"\"\" all_campsites = list () searchable_campgrounds = self . _get_searchable_campgrounds () this_month = datetime . now () . date () . replace ( day = 1 ) for month in self . search_months : if month >= this_month : all_campsites += self . campsite_finder . get_monthly_campsites ( month = month , nights = None if self . nights == 1 else self . nights ) matching_campsites = self . _filter_campsites_to_campgrounds ( campsites = all_campsites , searchable_campgrounds = searchable_campgrounds ) campsite_df = self . campsites_to_df ( campsites = matching_campsites ) campsite_df_validated = self . _filter_date_overlap ( campsites = campsite_df ) time_window_end = max ( self . search_days ) + timedelta ( days = 1 ) compiled_campsite_df = campsite_df_validated [ campsite_df_validated . booking_end_date <= pd . Timestamp ( time_window_end ) ] compiled_campsites = self . df_to_campsites ( campsite_df = compiled_campsite_df ) return compiled_campsites print_campgrounds () staticmethod # Print the Campgrounds inside of Yellowstone Source code in camply/search/search_yellowstone.py 155 156 157 158 159 160 @staticmethod def print_campgrounds () -> None : \"\"\" Print the Campgrounds inside of Yellowstone \"\"\" log_sorted_response ( YellowstoneConfig . YELLOWSTONE_CAMPGROUND_OBJECTS )","title":"search"},{"location":"reference/search/#camply.search.BaseCampingSearch","text":"Bases: ABC Camping Search Object Source code in camply/search/base_search.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 class BaseCampingSearch ( ABC ): \"\"\" Camping Search Object \"\"\" def __init__ ( self , provider : Union [ RecreationDotGov , YellowstoneLodging ], search_window : Union [ SearchWindow , List [ SearchWindow ]], weekends_only : bool = False , nights : int = 1 , offline_search : bool = False , offline_search_path : Optional [ str ] = None , ** kwargs , ) -> None : \"\"\" Initialize with Search Parameters Parameters ---------- provider: Union[RecreationDotGov, YellowstoneLodging] API Provider search_window: Union[SearchWindow, List[SearchWindow]] Search Window tuple containing start date and End Date weekends_only: bool Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights) nights: int minimum number of consecutive nights to search per campsite,defaults to 1 offline_search: bool When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. offline_search_path: Optional[str] When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to `camply_campsites.json` \"\"\" self . campsite_finder : Union [ RecreationDotGov , YellowstoneLodging ] = provider self . search_window : List [ SearchWindow ] = make_list ( search_window ) self . weekends_only : bool = weekends_only self . search_days : List [ datetime ] = self . _get_search_days () self . search_months : List [ datetime ] = self . _get_search_months () self . nights = self . _validate_consecutive_nights ( nights = nights ) self . offline_search = offline_search self . offline_search_path = self . _set_offline_search_path ( file_path = offline_search_path ) self . campsites_found : Set [ AvailableCampsite ] = set () self . loaded_campsites : Set [ AvailableCampsite ] = set () if self . offline_search_path . suffixes [ - 1 ] == \".json\" : self . offline_mode : str = \"json\" elif self . offline_search_path . suffixes [ - 1 ] in [ \".pkl\" , \".pickle\" ]: self . offline_mode : str = \"pickle\" else : raise CamplyError ( \"You must provide a `.json` or a `.pickle` / `.pkl` file name for offline searches\" ) if self . offline_search is True : logger . info ( \"Campsite search is configured to save offline: %s \" , self . offline_search_path , ) self . campsites_found : Set [ AvailableCampsite ] = self . load_campsites_from_file () self . loaded_campsites : Set [ AvailableCampsite ] = self . campsites_found . copy () @abstractmethod def get_all_campsites ( self ) -> List [ AvailableCampsite ]: \"\"\" Perform the Search and Return Matching Availabilities. This method must be implemented on all sub-classes. Returns ------- List[AvailableCampsite] \"\"\" def _get_intersection_date_overlap ( self , date : Timestamp , periods : int ) -> bool : \"\"\" Find Date Overlap Parameters ---------- date: Timestamp periods: int Returns ------- bool \"\"\" timestamp_range : List [ Timestamp ] = date_range ( start = date . to_pydatetime (), periods = periods ) campsite_date_range = { item . date () for item in timestamp_range } intersection = campsite_date_range . intersection ( self . search_days ) if intersection : return True else : return False def _compare_date_overlap ( self , campsite : AvailableCampsite ) -> bool : \"\"\" See whether a campsite should be returned as found Parameters ---------- campsite: AvailableCampsite Returns ------- bool \"\"\" intersection = self . _get_intersection_date_overlap ( date = campsite . booking_date , periods = campsite . booking_nights ) return intersection def _filter_date_overlap ( self , campsites : DataFrame ) -> pd . DataFrame : \"\"\" See whether a campsite should be returned as found Parameters ---------- campsites: pd.DataFrame Returns ------- pd.DataFrame \"\"\" matches = campsites . apply ( lambda x : self . _get_intersection_date_overlap ( date = x . booking_date , periods = x . booking_nights ), axis = 1 , ) filtered_campsites = campsites [ matches ] . copy () . reset_index ( drop = True ) return filtered_campsites def _search_matching_campsites_available ( self , log : bool = False , verbose : bool = False , raise_error : bool = False ) -> List [ AvailableCampsite ]: \"\"\" Perform the Search and Return Matching Availabilities Parameters ---------- log: bool Whether to log found campsites verbose: bool Used with `log` to enhance the amount of info logged to the console raise_error: bool Whether to raise an error if nothing is found. Defaults to False. Returns ------- List[AvailableCampsite] \"\"\" matching_campgrounds = list () for camp in self . get_all_campsites (): if all ( [ self . _compare_date_overlap ( campsite = camp ) is True , camp . booking_nights >= self . nights , ] ): matching_campgrounds . append ( camp ) logger . info ( f \" { ( get_emoji ( matching_campgrounds ) + ' ' ) * 4 }{ len ( matching_campgrounds ) } \" \"Reservable Campsites Matching Search Preferences\" ) self . assemble_availabilities ( matching_data = matching_campgrounds , log = log , verbose = verbose ) if ( self . offline_search is True and self . loaded_campsites . issuperset ( matching_campgrounds ) and raise_error is True ): campsite_availability_message = ( \"No New Campsites were found, we'll continue checking\" ) logger . info ( campsite_availability_message ) raise CampsiteNotFoundError ( campsite_availability_message ) elif len ( matching_campgrounds ) == 0 and raise_error is True : campsite_availability_message = ( \"No Campsites were found, we'll continue checking\" ) logger . info ( campsite_availability_message ) raise CampsiteNotFoundError ( campsite_availability_message ) return matching_campgrounds @classmethod def _get_polling_minutes ( cls , polling_interval : Optional [ int ]) -> int : \"\"\" Return the Number of Minutes to Search Parameters ---------- polling_interval: Optional[int] Used with `continuous=True`, the amount of time to wait between searches. Defaults to 10 if not provided, cannot be less than 5 Returns ------- int \"\"\" if polling_interval is None : polling_interval = getenv ( \"POLLING_INTERVAL\" , SearchConfig . RECOMMENDED_POLLING_INTERVAL ) if int ( polling_interval ) < SearchConfig . POLLING_INTERVAL_MINIMUM : polling_interval = SearchConfig . POLLING_INTERVAL_MINIMUM polling_interval_minutes = int ( round ( float ( polling_interval ), 2 )) return polling_interval_minutes def _continuous_search_retry ( self , log : bool , verbose : bool , polling_interval : int , continuous_search_attempts : int , notification_provider : Union [ str , List [ str ], BaseNotifications , None ], notify_first_try : bool , ) -> List [ AvailableCampsite ]: \"\"\" Search for Campsites until at least one is found Parameters ---------- log: bool Whether to log found campsites verbose: bool Used with `log` to enhance the amount of info logged to the console polling_interval: Optional[int] Used with `continuous=True`, the amount of time to wait between searches. Defaults to 10 if not provided, cannot be less than 5 continuous_search_attempts: int Number of preexisting search attempts notification_provider: provider: Union[str, List[str]] Used with `continuous=True`, Name of notification provider to use. Accepts \"email\", \"pushover\", and defaults to \"silent\". Also accepts a list or commma separated string of these options or even a notification provider object itself notify_first_try: bool Used with `continuous=True`, whether to send all non-silent notifications if more than 5 matching campsites are found on the first try. Defaults to false which only sends the first 5. Returns ------- List[AvailableCampsite] \"\"\" polling_interval_minutes = self . _get_polling_minutes ( polling_interval = polling_interval ) notifier = MultiNotifierProvider ( provider = notification_provider ) logger . info ( f \"Searching for campsites every { polling_interval_minutes } minutes. \" ) notifier . log_providers () retryer = tenacity . Retrying ( retry = tenacity . retry_if_exception_type ( CampsiteNotFoundError ), wait = tenacity . wait . wait_fixed ( int ( polling_interval_minutes ) * 60 ), ) matching_campsites = retryer . __call__ ( self . _search_matching_campsites_available , False , False , True ) found_campsites = set ( matching_campsites ) new_campsites = found_campsites . difference ( self . campsites_found ) self . assemble_availabilities ( matching_data = list ( new_campsites ), log = log , verbose = verbose ) logger . info ( f \" { len ( new_campsites ) } New Campsites Found.\" ) self . campsites_found . update ( new_campsites ) logged_campsites = list ( new_campsites ) self . _handle_notifications ( retryer = retryer , notifier = notifier , logged_campsites = logged_campsites , continuous_search_attempts = continuous_search_attempts , notify_first_try = notify_first_try , ) return list ( self . campsites_found ) @classmethod def _handle_notifications ( cls , retryer : tenacity . Retrying , notifier : MultiNotifierProvider , logged_campsites : List [ AvailableCampsite ], continuous_search_attempts : int , notify_first_try : bool , ) -> None : \"\"\" Handle sending notifications Parameters ---------- retryer: tenacity.Retrying notifier: MultiNotifierProvider logged_campsites: List[AvailableCampsite] continuous_search_attempts: int notify_first_try: bool Returns ------- None \"\"\" attempt_number = retryer . statistics . get ( \"attempt_number\" , 1 ) minimum_first_notify = SearchConfig . MINIMUM_CAMPSITES_FIRST_NOTIFY if max ([ attempt_number , continuous_search_attempts ]) > 1 : logged_campsites = cls . _handle_too_many_campsites_found ( notifier = notifier , logged_campsites = logged_campsites ) notifier . send_campsites ( campsites = logged_campsites ) elif attempt_number == 1 and notify_first_try is True : logged_campsites = cls . _handle_too_many_campsites_found ( notifier = notifier , logged_campsites = logged_campsites ) notifier . send_campsites ( campsites = logged_campsites ) else : if ( len ( notifier . providers ) > 1 and len ( logged_campsites ) > minimum_first_notify ): error_message = ( f \"Found more than { minimum_first_notify } \" f \"matching campsites ( { len ( logged_campsites ) } ) on the \" \"first try. Try searching online instead. \" f \"camply is only sending the first \" f \" { minimum_first_notify } notifications. \" \"Go Get your campsite! \ud83c\udfd5\" ) logger . warning ( error_message ) notifier . send_message ( message = error_message ) logged_campsites = logged_campsites [: minimum_first_notify ] notifier . send_campsites ( campsites = logged_campsites ) @classmethod def _handle_too_many_campsites_found ( cls , notifier : MultiNotifierProvider , logged_campsites : List [ AvailableCampsite ] ) -> List [ AvailableCampsite ]: \"\"\" Handle Scenarios Where Too Many Campsites are Found Parameters ---------- notifier: MultiNotifierProvider logged_campsites: List[AvailableCampsite] Returns ------- List[AvailableCampsite] \"\"\" limit = SearchConfig . MAXIMUM_NOTIFICATION_BATCH_SIZE number_campsites = len ( logged_campsites ) if number_campsites > limit : warning_message = ( f \"Too many campsites were found during the search ( { number_campsites } \" f \"total). camply will only send you the first { limit } notifications.\" ) logger . warning ( warning_message ) restricted_campsites = logged_campsites [: limit ] notifier . send_message ( warning_message ) else : restricted_campsites = logged_campsites return restricted_campsites def _search_campsites_continuous ( self , log : bool = True , verbose : bool = False , polling_interval : Optional [ int ] = None , notification_provider : str = \"silent\" , notify_first_try : bool = False , search_forever : bool = False , ): \"\"\" Continuously Search For Campsites Parameters ---------- log: bool Whether to log found campsites verbose: bool Used with `log` to enhance the amount of info logged to the console polling_interval: Optional[int] Used with `continuous=True`, the amount of time to wait between searches. Defaults to 10 if not provided, cannot be less than 5 notification_provider: str Used with `continuous=True`, Name of notification provider to use. Accepts \"email\", \"pushover\", and defaults to \"silent\". Also accepts a list or commma separated string of these options or even a notification provider object itself notify_first_try: bool Used with `continuous=True`, whether to send all non-silent notifications if more than 5 matching campsites are found on the first try. Defaults to false which only sends the first 5. search_forever: bool Used with `continuous=True`, This option searches for new campsites forever, with the caveat being that it will never notify about the same campsite. Returns ------- List[AvailableCampsite] \"\"\" polling_interval_minutes = self . _get_polling_minutes ( polling_interval = polling_interval ) continuous_search = True continuous_search_attempts = 1 while continuous_search is True : starting_count = len ( self . campsites_found ) self . _continuous_search_retry ( log = log , verbose = verbose , polling_interval = polling_interval , notification_provider = notification_provider , notify_first_try = notify_first_try , continuous_search_attempts = continuous_search_attempts , ) ending_count = len ( self . campsites_found ) continuous_search_attempts += 1 if self . offline_search is True and ending_count > starting_count : self . unload_campsites_to_file () if search_forever is True : sleep ( int ( polling_interval_minutes ) * 60 ) else : continuous_search = False return list ( self . campsites_found ) def get_matching_campsites ( self , log : bool = True , verbose : bool = False , continuous : bool = False , polling_interval : Optional [ int ] = None , notification_provider : str = \"silent\" , notify_first_try : bool = False , search_forever : bool = False , ) -> List [ AvailableCampsite ]: \"\"\" Perform the Search and Return Matching Availabilities Parameters ---------- log: bool Whether to log found campsites verbose: bool Used with `log` to enhance the amount of info logged to the console continuous: bool Whether to continue searching beyond just the first time polling_interval: Optional[int] Used with `continuous=True`, the amount of time to wait between searches. Defaults to 10 if not provided, cannot be less than 5 notification_provider: str Used with `continuous=True`, Name of notification provider to use. Accepts \"email\", \"pushover\", and defaults to \"silent\". Also accepts a list or commma separated string of these options or even a notification provider object itself notify_first_try: bool Used with `continuous=True`, whether to send all non-silent notifications if more than 5 matching campsites are found on the first try. Defaults to false which only sends the first 5. search_forever: bool Used with `continuous=True`, This option searches for new campsites forever, with the caveat being that it will never notify about the same campsite. Returns ------- List[AvailableCampsite] \"\"\" if continuous is True : self . _search_campsites_continuous ( log = log , verbose = verbose , polling_interval = polling_interval , notification_provider = notification_provider , notify_first_try = notify_first_try , search_forever = search_forever , ) else : starting_count = len ( self . campsites_found ) matching_campsites = self . _search_matching_campsites_available ( log = log , verbose = True ) self . campsites_found . update ( set ( matching_campsites )) ending_count = len ( self . campsites_found ) if self . offline_search is True and ending_count > starting_count : self . unload_campsites_to_file () return list ( self . campsites_found ) def _get_search_days ( self ) -> List [ datetime ]: \"\"\" Retrieve Specific Days to Search For Returns ------- search_days: List[datetime] Datetime days to search for reservations \"\"\" current_date = datetime . now () . date () search_nights = set () for window in self . search_window : generated_dates = { date for date in window . get_date_range () if date >= current_date } search_nights . update ( generated_dates ) if self . weekends_only is True : logger . info ( \"Limiting Search of Campgrounds to Weekend Availabilities\" ) search_nights = { x for x in search_nights if x . weekday () in [ 4 , 5 ]} if len ( search_nights ) > 0 : logger . info ( f \" { len ( search_nights ) } booking nights selected for search, \" f \"ranging from { min ( search_nights ) } to { max ( search_nights ) } \" ) else : logger . info ( SearchConfig . ERROR_MESSAGE ) raise RuntimeError ( SearchConfig . ERROR_MESSAGE ) return list ( sorted ( search_nights )) def _get_search_months ( self ) -> List [ datetime ]: \"\"\" Get the Unique Months that need to be Searched Returns ------- search_months: List[datetime] Datetime Months to search for reservations \"\"\" truncated_months = set ([ day . replace ( day = 1 ) for day in self . search_days ]) if len ( truncated_months ) > 1 : logger . info ( f \" { len ( truncated_months ) } different months selected for search, \" f \"ranging from { min ( self . search_days ) } to { max ( self . search_days ) } \" ) return sorted ( list ( truncated_months )) elif len ( truncated_months ) == 0 : logger . info ( SearchConfig . ERROR_MESSAGE ) raise RuntimeError ( SearchConfig . ERROR_MESSAGE ) else : return sorted ( list ( truncated_months )) @classmethod def _consolidate_campsites ( cls , campsite_df : DataFrame , nights : int ) -> List [ AvailableCampsite ]: \"\"\" Consolidate Single Night Campsites into Multiple Night Campsites Parameters ---------- campsite_df: DataFrame DataFrame of AvailableCampsites Returns ------- List[AvailableCampsite] \"\"\" composed_groupings = list () for _ , campsite_slice in campsite_df . groupby ( [ CampsiteContainerFields . CAMPSITE_ID , CampsiteContainerFields . CAMPGROUND_ID ] ): # SORT THE VALUES AND CREATE A COPIED SLICE campsite_grouping = campsite_slice . sort_values ( by = CampsiteContainerFields . BOOKING_DATE , ascending = True ) . copy () # ASSEMBLE THE CAMPSITES AVAILABILITIES INTO GROUPS THAT ARE CONSECUTIVE booking_date = campsite_grouping [ CampsiteContainerFields . BOOKING_DATE ] date = Timedelta ( \"1d\" ) consecutive_nights = booking_date . diff () != date group_identifier = consecutive_nights . cumsum () campsite_grouping [ CampsiteContainerFields . CAMPSITE_GROUP ] = group_identifier # USE THE ASSEMBLED GROUPS TO CREATE UPDATED CAMPSITES AND REMOVE DUPLICATES for _campsite_group , campsite_group_slice in campsite_grouping . groupby ( [ CampsiteContainerFields . CAMPSITE_GROUP ] ): composed_grouping = campsite_group_slice . sort_values ( by = CampsiteContainerFields . BOOKING_DATE , ascending = True ) . copy () composed_grouping . drop ( columns = [ CampsiteContainerFields . CAMPSITE_GROUP ], inplace = True ) nightly_breakouts = cls . _find_consecutive_nights ( dataframe = composed_grouping , nights = nights ) composed_groupings . append ( nightly_breakouts ) if len ( composed_groupings ) == 0 : composed_groupings = [ DataFrame ()] return concat ( composed_groupings , ignore_index = True ) @classmethod def _consecutive_subseq ( cls , iterable : Iterable , length : int ) -> Generator : \"\"\" Find All Sub Sequences by length Given a List See https://tinyurl.com/5av5unjd Parameters ---------- iterable: Iterable length: int Returns ------- Generator \"\"\" for _ , consec_run in groupby ( enumerate ( iterable ), lambda x : x [ 0 ] - x [ 1 ]): k_wise = tee ( map ( itemgetter ( 1 ), consec_run ), length ) for n , it in enumerate ( k_wise ): next ( islice ( it , n , n ), None ) yield from zip ( * k_wise ) @classmethod def _find_consecutive_nights ( cls , dataframe : DataFrame , nights : int ) -> DataFrame : \"\"\" Explode a DataFrame of Consecutive Nightly Campsite Availabilities, Expand to all unique possibilities given the length of the stay. Parameters ---------- dataframe: DataFrame nights: int Returns ------- DataFrame \"\"\" duplicate_subset = set ( dataframe . columns ) - AvailableCampsite . __unhashable__ dataframe_slice = dataframe . copy () . reset_index ( drop = True ) nights_indexes = dataframe_slice . booking_date . index consecutive_generator = cls . _consecutive_subseq ( iterable = nights_indexes , length = nights ) sequences = list ( consecutive_generator ) concatted_data = list () for sequence in sequences : index_list = list ( sequence ) data_copy = dataframe_slice . iloc [ index_list ] . copy () data_copy . booking_date = data_copy . booking_date . min () data_copy . booking_end_date = data_copy . booking_end_date . max () data_copy . booking_url = data_copy . booking_url . loc [ index_list [ 0 ]] data_copy . booking_nights = ( data_copy . booking_end_date - data_copy . booking_date ) . dt . days data_copy . drop_duplicates ( inplace = True , subset = duplicate_subset ) concatted_data . append ( data_copy ) if len ( concatted_data ) == 0 : concatted_data = [ DataFrame ()] return concat ( concatted_data , ignore_index = True ) def _validate_consecutive_nights ( self , nights : int ) -> int : \"\"\" Validate the number of consecutive nights to search Parameters ---------- nights : int Number of nights to check Returns ------- int The proper number of nights to search \"\"\" search_days = Series ( self . search_days ) consecutive_nights = search_days . diff () != Timedelta ( \"1d\" ) largest_grouping = consecutive_nights . cumsum () . value_counts () . max () if nights > 1 : logger . info ( f \"Searching for availabilities with { nights } consecutive night stays.\" ) if nights > largest_grouping : logger . warning ( \"Too many consecutive nights selected. \" \"The consecutive night parameter will be set to \" f \"the max possible, { largest_grouping } .\" ) return largest_grouping else : return nights @staticmethod def campsites_to_df ( campsites : List [ AvailableCampsite ]) -> DataFrame : \"\"\" Convert Campsite Array to Parameters ---------- campsites: List[AvailableCampsite] Returns ------- DataFrame \"\"\" campsite_df = DataFrame ( data = [ campsite . dict () for campsite in campsites ], columns = AvailableCampsite . __fields__ , ) return campsite_df @staticmethod def df_to_campsites ( campsite_df : DataFrame ) -> List [ AvailableCampsite ]: \"\"\" Convert Campsite DataFrame to array of AvailableCampsite objects Parameters ---------- campsite_df: DataFrame Returns ------- List[AvailableCampsite] \"\"\" composed_campsite_array = list () composed_campsite_data_array = campsite_df . to_dict ( orient = \"records\" ) for campsite_record in composed_campsite_data_array : composed_campsite_array . append ( AvailableCampsite ( ** campsite_record )) return composed_campsite_array @classmethod def assemble_availabilities ( cls , matching_data : List [ AvailableCampsite ], log : bool = True , verbose : bool = False , ) -> DataFrame : \"\"\" Prepare a Pandas DataFrame from Array of AvailableCampsite objects Parameters ---------- matching_data: List[AvailableCampsite] List of campsites to assemble log: bool Whether to log found campsites verbose: bool Used with `log` to enhance the amount of info logged to the console Returns ------- availability_df: DataFrame \"\"\" availability_df = cls . campsites_to_df ( campsites = matching_data ) if log is True : cls . _log_availabilities ( availability_df = availability_df , verbose = verbose ) return availability_df @classmethod def _log_availabilities ( cls , availability_df : DataFrame , verbose : bool ) -> DataFrame : \"\"\" Log the Availabilities Parameters ---------- availability_df: DataFrame verbose: bool Returns ------- DataFrame \"\"\" booking_date : datetime for booking_date , available_sites in availability_df . groupby ( \"booking_date\" ): logger . info ( f \"\ud83d\udcc5 { booking_date . strftime ( ' %a , %B %d ' ) } \" f \"\ud83c\udfd5 { len ( available_sites ) } sites\" ) location_tuple : tuple for location_tuple , campground_availability in available_sites . groupby ( [ DataColumns . RECREATION_AREA_COLUMN , DataColumns . FACILITY_NAME_COLUMN ] ): logger . info ( f \" \\t \u26f0\ufe0f { ' \ud83c\udfd5 ' . join ( location_tuple ) } : \u26fa \" f \" { len ( campground_availability ) } sites\" ) if verbose is True : for ( booking_nights , nightly_availability , ) in campground_availability . groupby ( [ DataColumns . BOOKING_NIGHTS_COLUMN ] ): unique_urls = nightly_availability [ DataColumns . BOOKING_URL_COLUMN ] . unique () for booking_url in sorted ( unique_urls ): logger . info ( f \" \\t\\t \ud83d\udd17 { booking_url } \" f \"( { booking_nights } night\" f \" { 's' if booking_nights > 1 else '' } )\" ) return availability_df def unload_campsites_to_file ( self ) -> pathlib . Path : \"\"\" Unload a BaseSearch Object's campsites to a serialized Pickle file. Returns ------- pathlib.Path \"\"\" if self . offline_mode == \"pickle\" : pickle . dump ( obj = self . campsites_found , file = self . offline_search_path . open ( mode = \"wb\" ), protocol = 4 , fix_imports = True , ) elif self . offline_mode == \"json\" : json . dump ( obj = self . campsites_found , fp = self . offline_search_path . open ( mode = \"w\" ), sort_keys = True , default = pydantic_encoder , indent = 4 , ) logger . debug ( \" %s campsites saved to file: %s \" , len ( self . campsites_found ), self . offline_search_path , ) return self . offline_search_path def load_campsites_from_file ( self ) -> Set [ AvailableCampsite ]: \"\"\" Load a BaseSearch Object's campsites from a serialized Pickle file. Returns ------- Set[AvailableCampsite] \"\"\" if self . offline_search_path . exists (): if self . offline_mode == \"pickle\" : campsites : Set [ AvailableCampsite ] = pickle . load ( file = self . offline_search_path . open ( mode = \"rb\" ), fix_imports = True ) elif self . offline_mode == \"json\" : campsites_dicts : List [ Dict [ str , Any ]] = json . load ( self . offline_search_path . open ( mode = \"r\" ), ) campsites : Set [ AvailableCampsite ] = set ( [ AvailableCampsite ( ** json_dict ) for json_dict in campsites_dicts ] ) if len ( campsites ) > 0 : logger . info ( \" %s campsites loaded from file: %s \" , len ( campsites ), self . offline_search_path , ) else : campsites = set () return campsites @staticmethod def _set_offline_search_path ( file_path : Optional [ str ]) -> pathlib . Path : default_file_path = \"camply_campsites.json\" if file_path is None : file_path = default_file_path returned_path = pathlib . Path ( file_path ) . resolve () parent_dir = pathlib . Path . cwd () if all ( [ returned_path . exists (), returned_path . is_file (), set ( returned_path . suffixes ) . issubset ({ \".pkl\" , \".pickle\" , \".json\" }), ] ): path_obj = returned_path elif all ( [ returned_path . exists (), returned_path . is_dir (), ] ): path_obj = returned_path . joinpath ( default_file_path ) else : path_obj = parent_dir . joinpath ( file_path ) return path_obj","title":"BaseCampingSearch"},{"location":"reference/search/#camply.search.base_search.BaseCampingSearch.__init__","text":"Initialize with Search Parameters","title":"__init__()"},{"location":"reference/search/#camply.search.base_search.BaseCampingSearch.__init__--parameters","text":"Union[RecreationDotGov, YellowstoneLodging] API Provider Union[SearchWindow, List[SearchWindow]] Search Window tuple containing start date and End Date bool Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights) int minimum number of consecutive nights to search per campsite,defaults to 1 bool When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. Optional[str] When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to camply_campsites.json Source code in camply/search/base_search.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def __init__ ( self , provider : Union [ RecreationDotGov , YellowstoneLodging ], search_window : Union [ SearchWindow , List [ SearchWindow ]], weekends_only : bool = False , nights : int = 1 , offline_search : bool = False , offline_search_path : Optional [ str ] = None , ** kwargs , ) -> None : \"\"\" Initialize with Search Parameters Parameters ---------- provider: Union[RecreationDotGov, YellowstoneLodging] API Provider search_window: Union[SearchWindow, List[SearchWindow]] Search Window tuple containing start date and End Date weekends_only: bool Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights) nights: int minimum number of consecutive nights to search per campsite,defaults to 1 offline_search: bool When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. offline_search_path: Optional[str] When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to `camply_campsites.json` \"\"\" self . campsite_finder : Union [ RecreationDotGov , YellowstoneLodging ] = provider self . search_window : List [ SearchWindow ] = make_list ( search_window ) self . weekends_only : bool = weekends_only self . search_days : List [ datetime ] = self . _get_search_days () self . search_months : List [ datetime ] = self . _get_search_months () self . nights = self . _validate_consecutive_nights ( nights = nights ) self . offline_search = offline_search self . offline_search_path = self . _set_offline_search_path ( file_path = offline_search_path ) self . campsites_found : Set [ AvailableCampsite ] = set () self . loaded_campsites : Set [ AvailableCampsite ] = set () if self . offline_search_path . suffixes [ - 1 ] == \".json\" : self . offline_mode : str = \"json\" elif self . offline_search_path . suffixes [ - 1 ] in [ \".pkl\" , \".pickle\" ]: self . offline_mode : str = \"pickle\" else : raise CamplyError ( \"You must provide a `.json` or a `.pickle` / `.pkl` file name for offline searches\" ) if self . offline_search is True : logger . info ( \"Campsite search is configured to save offline: %s \" , self . offline_search_path , ) self . campsites_found : Set [ AvailableCampsite ] = self . load_campsites_from_file () self . loaded_campsites : Set [ AvailableCampsite ] = self . campsites_found . copy ()","title":"Parameters"},{"location":"reference/search/#camply.search.base_search.BaseCampingSearch.assemble_availabilities","text":"Prepare a Pandas DataFrame from Array of AvailableCampsite objects","title":"assemble_availabilities()"},{"location":"reference/search/#camply.search.base_search.BaseCampingSearch.assemble_availabilities--parameters","text":"List[AvailableCampsite] List of campsites to assemble bool Whether to log found campsites bool Used with log to enhance the amount of info logged to the console","title":"Parameters"},{"location":"reference/search/#camply.search.base_search.BaseCampingSearch.assemble_availabilities--returns","text":"availability_df: DataFrame Source code in camply/search/base_search.py 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 @classmethod def assemble_availabilities ( cls , matching_data : List [ AvailableCampsite ], log : bool = True , verbose : bool = False , ) -> DataFrame : \"\"\" Prepare a Pandas DataFrame from Array of AvailableCampsite objects Parameters ---------- matching_data: List[AvailableCampsite] List of campsites to assemble log: bool Whether to log found campsites verbose: bool Used with `log` to enhance the amount of info logged to the console Returns ------- availability_df: DataFrame \"\"\" availability_df = cls . campsites_to_df ( campsites = matching_data ) if log is True : cls . _log_availabilities ( availability_df = availability_df , verbose = verbose ) return availability_df","title":"Returns"},{"location":"reference/search/#camply.search.base_search.BaseCampingSearch.campsites_to_df","text":"Convert Campsite Array to","title":"campsites_to_df()"},{"location":"reference/search/#camply.search.base_search.BaseCampingSearch.campsites_to_df--parameters","text":"campsites: List[AvailableCampsite]","title":"Parameters"},{"location":"reference/search/#camply.search.base_search.BaseCampingSearch.campsites_to_df--returns","text":"DataFrame Source code in camply/search/base_search.py 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 @staticmethod def campsites_to_df ( campsites : List [ AvailableCampsite ]) -> DataFrame : \"\"\" Convert Campsite Array to Parameters ---------- campsites: List[AvailableCampsite] Returns ------- DataFrame \"\"\" campsite_df = DataFrame ( data = [ campsite . dict () for campsite in campsites ], columns = AvailableCampsite . __fields__ , ) return campsite_df","title":"Returns"},{"location":"reference/search/#camply.search.base_search.BaseCampingSearch.df_to_campsites","text":"Convert Campsite DataFrame to array of AvailableCampsite objects","title":"df_to_campsites()"},{"location":"reference/search/#camply.search.base_search.BaseCampingSearch.df_to_campsites--parameters","text":"campsite_df: DataFrame","title":"Parameters"},{"location":"reference/search/#camply.search.base_search.BaseCampingSearch.df_to_campsites--returns","text":"List[AvailableCampsite] Source code in camply/search/base_search.py 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 @staticmethod def df_to_campsites ( campsite_df : DataFrame ) -> List [ AvailableCampsite ]: \"\"\" Convert Campsite DataFrame to array of AvailableCampsite objects Parameters ---------- campsite_df: DataFrame Returns ------- List[AvailableCampsite] \"\"\" composed_campsite_array = list () composed_campsite_data_array = campsite_df . to_dict ( orient = \"records\" ) for campsite_record in composed_campsite_data_array : composed_campsite_array . append ( AvailableCampsite ( ** campsite_record )) return composed_campsite_array","title":"Returns"},{"location":"reference/search/#camply.search.base_search.BaseCampingSearch.get_all_campsites","text":"Perform the Search and Return Matching Availabilities. This method must be implemented on all sub-classes.","title":"get_all_campsites()"},{"location":"reference/search/#camply.search.base_search.BaseCampingSearch.get_all_campsites--returns","text":"List[AvailableCampsite] Source code in camply/search/base_search.py 117 118 119 120 121 122 123 124 125 126 127 128 @abstractmethod def get_all_campsites ( self ) -> List [ AvailableCampsite ]: \"\"\" Perform the Search and Return Matching Availabilities. This method must be implemented on all sub-classes. Returns ------- List[AvailableCampsite] \"\"\"","title":"Returns"},{"location":"reference/search/#camply.search.base_search.BaseCampingSearch.get_matching_campsites","text":"Perform the Search and Return Matching Availabilities","title":"get_matching_campsites()"},{"location":"reference/search/#camply.search.base_search.BaseCampingSearch.get_matching_campsites--parameters","text":"bool Whether to log found campsites bool Used with log to enhance the amount of info logged to the console bool Whether to continue searching beyond just the first time Optional[int] Used with continuous=True , the amount of time to wait between searches. Defaults to 10 if not provided, cannot be less than 5 str Used with continuous=True , Name of notification provider to use. Accepts \"email\", \"pushover\", and defaults to \"silent\". Also accepts a list or commma separated string of these options or even a notification provider object itself bool Used with continuous=True , whether to send all non-silent notifications if more than 5 matching campsites are found on the first try. Defaults to false which only sends the first 5. bool Used with continuous=True , This option searches for new campsites forever, with the caveat being that it will never notify about the same campsite.","title":"Parameters"},{"location":"reference/search/#camply.search.base_search.BaseCampingSearch.get_matching_campsites--returns","text":"List[AvailableCampsite] Source code in camply/search/base_search.py 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 def get_matching_campsites ( self , log : bool = True , verbose : bool = False , continuous : bool = False , polling_interval : Optional [ int ] = None , notification_provider : str = \"silent\" , notify_first_try : bool = False , search_forever : bool = False , ) -> List [ AvailableCampsite ]: \"\"\" Perform the Search and Return Matching Availabilities Parameters ---------- log: bool Whether to log found campsites verbose: bool Used with `log` to enhance the amount of info logged to the console continuous: bool Whether to continue searching beyond just the first time polling_interval: Optional[int] Used with `continuous=True`, the amount of time to wait between searches. Defaults to 10 if not provided, cannot be less than 5 notification_provider: str Used with `continuous=True`, Name of notification provider to use. Accepts \"email\", \"pushover\", and defaults to \"silent\". Also accepts a list or commma separated string of these options or even a notification provider object itself notify_first_try: bool Used with `continuous=True`, whether to send all non-silent notifications if more than 5 matching campsites are found on the first try. Defaults to false which only sends the first 5. search_forever: bool Used with `continuous=True`, This option searches for new campsites forever, with the caveat being that it will never notify about the same campsite. Returns ------- List[AvailableCampsite] \"\"\" if continuous is True : self . _search_campsites_continuous ( log = log , verbose = verbose , polling_interval = polling_interval , notification_provider = notification_provider , notify_first_try = notify_first_try , search_forever = search_forever , ) else : starting_count = len ( self . campsites_found ) matching_campsites = self . _search_matching_campsites_available ( log = log , verbose = True ) self . campsites_found . update ( set ( matching_campsites )) ending_count = len ( self . campsites_found ) if self . offline_search is True and ending_count > starting_count : self . unload_campsites_to_file () return list ( self . campsites_found )","title":"Returns"},{"location":"reference/search/#camply.search.base_search.BaseCampingSearch.load_campsites_from_file","text":"Load a BaseSearch Object's campsites from a serialized Pickle file.","title":"load_campsites_from_file()"},{"location":"reference/search/#camply.search.base_search.BaseCampingSearch.load_campsites_from_file--returns","text":"Set[AvailableCampsite] Source code in camply/search/base_search.py 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 def load_campsites_from_file ( self ) -> Set [ AvailableCampsite ]: \"\"\" Load a BaseSearch Object's campsites from a serialized Pickle file. Returns ------- Set[AvailableCampsite] \"\"\" if self . offline_search_path . exists (): if self . offline_mode == \"pickle\" : campsites : Set [ AvailableCampsite ] = pickle . load ( file = self . offline_search_path . open ( mode = \"rb\" ), fix_imports = True ) elif self . offline_mode == \"json\" : campsites_dicts : List [ Dict [ str , Any ]] = json . load ( self . offline_search_path . open ( mode = \"r\" ), ) campsites : Set [ AvailableCampsite ] = set ( [ AvailableCampsite ( ** json_dict ) for json_dict in campsites_dicts ] ) if len ( campsites ) > 0 : logger . info ( \" %s campsites loaded from file: %s \" , len ( campsites ), self . offline_search_path , ) else : campsites = set () return campsites","title":"Returns"},{"location":"reference/search/#camply.search.base_search.BaseCampingSearch.unload_campsites_to_file","text":"Unload a BaseSearch Object's campsites to a serialized Pickle file.","title":"unload_campsites_to_file()"},{"location":"reference/search/#camply.search.base_search.BaseCampingSearch.unload_campsites_to_file--returns","text":"pathlib.Path Source code in camply/search/base_search.py 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 def unload_campsites_to_file ( self ) -> pathlib . Path : \"\"\" Unload a BaseSearch Object's campsites to a serialized Pickle file. Returns ------- pathlib.Path \"\"\" if self . offline_mode == \"pickle\" : pickle . dump ( obj = self . campsites_found , file = self . offline_search_path . open ( mode = \"wb\" ), protocol = 4 , fix_imports = True , ) elif self . offline_mode == \"json\" : json . dump ( obj = self . campsites_found , fp = self . offline_search_path . open ( mode = \"w\" ), sort_keys = True , default = pydantic_encoder , indent = 4 , ) logger . debug ( \" %s campsites saved to file: %s \" , len ( self . campsites_found ), self . offline_search_path , ) return self . offline_search_path","title":"Returns"},{"location":"reference/search/#camply.search.SearchRecreationDotGov","text":"Bases: BaseCampingSearch Camping Search Object Source code in camply/search/search_recreationdotgov.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 class SearchRecreationDotGov ( BaseCampingSearch ): \"\"\" Camping Search Object \"\"\" def __init__ ( self , search_window : Union [ SearchWindow , List [ SearchWindow ]], recreation_area : Optional [ Union [ List [ int ], int ]] = None , campgrounds : Optional [ Union [ List [ int ], int ]] = None , campsites : Optional [ Union [ List [ int ], int ]] = None , weekends_only : bool = False , nights : int = 1 , equipment : Optional [ List [ Tuple [ str , Optional [ int ]]]] = None , offline_search : bool = False , offline_search_path : Optional [ str ] = None , ** kwargs , ) -> None : \"\"\" Initialize with Search Parameters Parameters ---------- search_window: Union[SearchWindow, List[SearchWindow]] Search Window tuple containing start date and End Date recreation_area: Optional[Union[List[int], int]] ID of Recreation Area (i.e. 2907 - Rocky Mountain National Park) campgrounds: Optional[Union[List[int], int]] Campground ID or List of Campground IDs campsites: Optional[Union[List[int], int]] Campsite ID or List of Campsite IDs weekends_only: bool Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights) nights: int minimum number of consecutive nights to search per campsite,defaults to 1 equipment: Optional[List[Tuple[str, Optional[int]]]] List of Tuples of Equipment to Search for. An equipment tuple array looks like this: `[(\"Tent\", None), (\"RV\", 20)]` - meaning the selected search looks for sites to accommodate any tent size and RVs less than or equal to 20 feet. Tuples contain the Equipment name and an optional equipment length, otherwise provide None. Equipment names include `Tent`, `RV`, `Trailer`, `Vehicle` and are not case-sensitive. offline_search: bool When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. offline_search_path: Optional[str] When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to `camply_campsites.json` \"\"\" self . campsite_finder : RecreationDotGov super ( SearchRecreationDotGov , self ) . __init__ ( provider = RecreationDotGov (), search_window = search_window , weekends_only = weekends_only , nights = nights , offline_search = offline_search , offline_search_path = offline_search_path , ) self . _recreation_area_id = make_list ( recreation_area ) self . _campground_object = campgrounds self . weekends_only = weekends_only assert ( any ( [ campsites not in [[], None ], campgrounds not in [[], None ], recreation_area is not None , ] ) is True ) self . campsites = make_list ( campsites ) self . campgrounds = self . _get_searchable_campgrounds () self . campsite_metadata : Optional [ pd . DataFrame ] = None self . equipment : List [ Tuple [ str , Optional [ int ]]] = [] self . equipment = self . _get_searchable_equipment ( equipment = equipment ) def _get_searchable_campgrounds ( self ) -> List [ CampgroundFacility ]: \"\"\" Return a List of Campgrounds to search This handles scenarios where a recreation area is provided instead of a campground list Returns ------- searchable_campgrounds: List[int] List of searchable campground IDs \"\"\" if self . campsites not in [(), [], None ]: self . campsites = [ int ( campsite_id ) for campsite_id in self . campsites ] searchable_campgrounds = self . _get_campgrounds_by_campsite_id () elif self . _campground_object not in [(), [], None ]: searchable_campgrounds = self . _get_campgrounds_by_campground_id () elif self . _recreation_area_id not in [(), [], None ]: searchable_campgrounds = self . _get_campgrounds_by_recreation_area_id () else : raise RuntimeError ( \"You must provide a Campground or Recreation Area ID\" ) return list ( set ( searchable_campgrounds )) @classmethod def _get_searchable_equipment ( cls , equipment : Optional [ List [ Tuple [ str , Optional [ int ]]]] ) -> Optional [ List [ Tuple [ str , Optional [ int ]]]]: \"\"\" Sort through and validate Equipment Parameters ---------- equipment: Optional[List[Tuple[str, Optional[int]]]] Returns ------- Optional[List[Tuple[str, Optional[int]]]] \"\"\" equipment_names = [] final_equipment = None if isinstance ( equipment , ( list , tuple )): final_equipment = [] for equipment_name , equipment_length in equipment : if ( equipment_name . lower () not in EquipmentOptions . __all_accepted_equipment__ ): logger . warning ( f \"Equipment name not recognized: { equipment_name } . This won't \" \"be used for filtering.\" \"Acceptable options are: \" f \" { ', ' . join ( EquipmentOptions . __all_accepted_equipment__ ) } \" ) else : final_equipment . append (( equipment_name , equipment_length )) equipment_names . append ( equipment_name ) if len ( final_equipment ) > 0 : logger . info ( f \"Filtering Campsites based on Equipment: { ' | ' . join ( equipment_names ) } \" ) return final_equipment def _get_campgrounds_by_campground_id ( self ) -> List [ CampgroundFacility ]: \"\"\" Return a List of Campgrounds to search when provided with campground IDs Returns ------- returned_sites: List[int] List of searchable campground IDs \"\"\" campground_list = make_list ( self . _campground_object ) facilities = self . campsite_finder . find_campgrounds ( campground_id = campground_list ) return facilities def _get_campgrounds_by_campsite_id ( self ) -> List [ CampgroundFacility ]: \"\"\" Return a List of Campgrounds to search when provided with Campsite IDs Returns ------- returned_sites: List[int] List of searchable campground IDs \"\"\" campsite_list = make_list ( self . campsites ) facilities = self . campsite_finder . find_campgrounds ( campsite_id = campsite_list ) return facilities def _get_campgrounds_by_recreation_area_id ( self ) -> List [ CampgroundFacility ]: \"\"\" Return a List of Campgrounds to search when provided with Recreation Area IDs Returns ------- campgrounds: List[CampgroundFacility] \"\"\" campgrounds = list () for rec_area in self . _recreation_area_id : campground_array = self . campsite_finder . find_facilities_per_recreation_area ( rec_area_id = rec_area ) campgrounds += campground_array return campgrounds def get_all_campsites ( self ) -> List [ AvailableCampsite ]: \"\"\" Perform the Search and Return All Monthly Availabilities Returns ------- List[AvailableCampsite] \"\"\" found_campsites = list () if len ( self . campgrounds ) == 0 : error_message = \"No campgrounds found to search\" logger . error ( error_message ) raise SearchError ( error_message ) logger . info ( f \"Searching across { len ( self . campgrounds ) } campgrounds\" ) if self . campsite_metadata is None : self . campsite_metadata = ( self . campsite_finder . get_internal_campsite_metadata ( facility_ids = [ facil . facility_id for facil in self . campgrounds ] ) ) logger . info ( \"Metadata fetched for %s campsites\" , len ( self . campsite_metadata ) ) for index , campground in enumerate ( self . campgrounds ): for month in self . search_months : logger . info ( f \"Searching { campground . facility_name } , { campground . recreation_area } \" f \"( { campground . facility_id } ) for availability: \" f \" { month . strftime ( '%B, %Y' ) } \" ) availabilities = self . campsite_finder . get_recdotgov_data ( campground_id = campground . facility_id , month = month ) campsites = self . campsite_finder . process_campsite_availability ( availability = availabilities , recreation_area = campground . recreation_area , recreation_area_id = campground . recreation_area_id , facility_name = campground . facility_name , facility_id = campground . facility_id , month = month , campsite_metadata = self . campsite_metadata , ) if self . campsites not in [ None , []]: campsites = [ campsite_obj for campsite_obj in campsites if int ( campsite_obj . campsite_id ) in self . campsites ] found_campsites += campsites if index + 1 < len ( self . campgrounds ): sleep ( round ( uniform ( * RecreationBookingConfig . RATE_LIMITING ), 2 )) campsite_df = self . campsites_to_df ( campsites = found_campsites ) campsite_df_validated = self . _filter_date_overlap ( campsites = campsite_df ) compiled_campsite_df = self . _consolidate_campsites ( campsite_df = campsite_df_validated , nights = self . nights ) equipment_filtered_campsites = self . filter_campsites_to_equipment ( campsites = compiled_campsite_df ) compiled_campsites = self . df_to_campsites ( campsite_df = equipment_filtered_campsites ) return compiled_campsites def filter_campsites_to_equipment ( self , campsites : pd . DataFrame ) -> pd . DataFrame : \"\"\" Filter a Campsite DataFrame down to specified equipment Parameters ---------- campsites: pd.DataFrame Returns ------- pd.DataFrame \"\"\" if self . equipment is None or len ( self . equipment ) == 0 or len ( campsites ) == 0 : return campsites column_names = [ \"campsite_id\" , \"permitted_equipment\" ] exploded_data = campsites [ column_names ] . explode ( \"permitted_equipment\" ) expanded_data = exploded_data [ \"permitted_equipment\" ] . apply ( pd . Series ) joined_data = pd . DataFrame ( pd . concat ([ exploded_data , expanded_data ], axis = 1 ), columns = column_names + [ \"equipment_name\" , \"max_length\" ], ) joined_data [ \"equipment_name_normalized\" ] = ( joined_data [ \"equipment_name\" ] . fillna ( \"\" ) . apply ( lambda x : EquipmentConfig . EQUIPMENT_REVERSE_MAPPING [ x ]) ) equipment_types = [ item [ 0 ] . lower () for item in self . equipment ] matching_equipment = joined_data [ joined_data [ \"equipment_name_normalized\" ] . isin ( equipment_types ) ] matching_ids = [] for equipment_name , equipment_length in self . equipment : matching_data = matching_equipment [ matching_equipment [ \"equipment_name_normalized\" ] == equipment_name . lower () ] . copy () if equipment_length is not None : matching_data = matching_data [ matching_data [ \"max_length\" ] >= float ( equipment_length ) ] matching_ids += list ( matching_data [ \"campsite_id\" ] . unique ()) original_campsites = campsites [ campsites [ \"campsite_id\" ] . isin ( matching_ids ) ] . copy () return original_campsites","title":"SearchRecreationDotGov"},{"location":"reference/search/#camply.search.search_recreationdotgov.SearchRecreationDotGov.__init__","text":"Initialize with Search Parameters","title":"__init__()"},{"location":"reference/search/#camply.search.search_recreationdotgov.SearchRecreationDotGov.__init__--parameters","text":"Union[SearchWindow, List[SearchWindow]] Search Window tuple containing start date and End Date Optional[Union[List[int], int]] ID of Recreation Area (i.e. 2907 - Rocky Mountain National Park) Optional[Union[List[int], int]] Campground ID or List of Campground IDs Optional[Union[List[int], int]] Campsite ID or List of Campsite IDs bool Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights) int minimum number of consecutive nights to search per campsite,defaults to 1 Optional[List[Tuple[str, Optional[int]]]] List of Tuples of Equipment to Search for. An equipment tuple array looks like this: [(\"Tent\", None), (\"RV\", 20)] - meaning the selected search looks for sites to accommodate any tent size and RVs less than or equal to 20 feet. Tuples contain the Equipment name and an optional equipment length, otherwise provide None. Equipment names include Tent , RV , Trailer , Vehicle and are not case-sensitive. bool When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. Optional[str] When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to camply_campsites.json Source code in camply/search/search_recreationdotgov.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def __init__ ( self , search_window : Union [ SearchWindow , List [ SearchWindow ]], recreation_area : Optional [ Union [ List [ int ], int ]] = None , campgrounds : Optional [ Union [ List [ int ], int ]] = None , campsites : Optional [ Union [ List [ int ], int ]] = None , weekends_only : bool = False , nights : int = 1 , equipment : Optional [ List [ Tuple [ str , Optional [ int ]]]] = None , offline_search : bool = False , offline_search_path : Optional [ str ] = None , ** kwargs , ) -> None : \"\"\" Initialize with Search Parameters Parameters ---------- search_window: Union[SearchWindow, List[SearchWindow]] Search Window tuple containing start date and End Date recreation_area: Optional[Union[List[int], int]] ID of Recreation Area (i.e. 2907 - Rocky Mountain National Park) campgrounds: Optional[Union[List[int], int]] Campground ID or List of Campground IDs campsites: Optional[Union[List[int], int]] Campsite ID or List of Campsite IDs weekends_only: bool Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights) nights: int minimum number of consecutive nights to search per campsite,defaults to 1 equipment: Optional[List[Tuple[str, Optional[int]]]] List of Tuples of Equipment to Search for. An equipment tuple array looks like this: `[(\"Tent\", None), (\"RV\", 20)]` - meaning the selected search looks for sites to accommodate any tent size and RVs less than or equal to 20 feet. Tuples contain the Equipment name and an optional equipment length, otherwise provide None. Equipment names include `Tent`, `RV`, `Trailer`, `Vehicle` and are not case-sensitive. offline_search: bool When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. offline_search_path: Optional[str] When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to `camply_campsites.json` \"\"\" self . campsite_finder : RecreationDotGov super ( SearchRecreationDotGov , self ) . __init__ ( provider = RecreationDotGov (), search_window = search_window , weekends_only = weekends_only , nights = nights , offline_search = offline_search , offline_search_path = offline_search_path , ) self . _recreation_area_id = make_list ( recreation_area ) self . _campground_object = campgrounds self . weekends_only = weekends_only assert ( any ( [ campsites not in [[], None ], campgrounds not in [[], None ], recreation_area is not None , ] ) is True ) self . campsites = make_list ( campsites ) self . campgrounds = self . _get_searchable_campgrounds () self . campsite_metadata : Optional [ pd . DataFrame ] = None self . equipment : List [ Tuple [ str , Optional [ int ]]] = [] self . equipment = self . _get_searchable_equipment ( equipment = equipment )","title":"Parameters"},{"location":"reference/search/#camply.search.search_recreationdotgov.SearchRecreationDotGov.filter_campsites_to_equipment","text":"Filter a Campsite DataFrame down to specified equipment","title":"filter_campsites_to_equipment()"},{"location":"reference/search/#camply.search.search_recreationdotgov.SearchRecreationDotGov.filter_campsites_to_equipment--parameters","text":"campsites: pd.DataFrame","title":"Parameters"},{"location":"reference/search/#camply.search.search_recreationdotgov.SearchRecreationDotGov.filter_campsites_to_equipment--returns","text":"pd.DataFrame Source code in camply/search/search_recreationdotgov.py 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 def filter_campsites_to_equipment ( self , campsites : pd . DataFrame ) -> pd . DataFrame : \"\"\" Filter a Campsite DataFrame down to specified equipment Parameters ---------- campsites: pd.DataFrame Returns ------- pd.DataFrame \"\"\" if self . equipment is None or len ( self . equipment ) == 0 or len ( campsites ) == 0 : return campsites column_names = [ \"campsite_id\" , \"permitted_equipment\" ] exploded_data = campsites [ column_names ] . explode ( \"permitted_equipment\" ) expanded_data = exploded_data [ \"permitted_equipment\" ] . apply ( pd . Series ) joined_data = pd . DataFrame ( pd . concat ([ exploded_data , expanded_data ], axis = 1 ), columns = column_names + [ \"equipment_name\" , \"max_length\" ], ) joined_data [ \"equipment_name_normalized\" ] = ( joined_data [ \"equipment_name\" ] . fillna ( \"\" ) . apply ( lambda x : EquipmentConfig . EQUIPMENT_REVERSE_MAPPING [ x ]) ) equipment_types = [ item [ 0 ] . lower () for item in self . equipment ] matching_equipment = joined_data [ joined_data [ \"equipment_name_normalized\" ] . isin ( equipment_types ) ] matching_ids = [] for equipment_name , equipment_length in self . equipment : matching_data = matching_equipment [ matching_equipment [ \"equipment_name_normalized\" ] == equipment_name . lower () ] . copy () if equipment_length is not None : matching_data = matching_data [ matching_data [ \"max_length\" ] >= float ( equipment_length ) ] matching_ids += list ( matching_data [ \"campsite_id\" ] . unique ()) original_campsites = campsites [ campsites [ \"campsite_id\" ] . isin ( matching_ids ) ] . copy () return original_campsites","title":"Returns"},{"location":"reference/search/#camply.search.search_recreationdotgov.SearchRecreationDotGov.get_all_campsites","text":"Perform the Search and Return All Monthly Availabilities","title":"get_all_campsites()"},{"location":"reference/search/#camply.search.search_recreationdotgov.SearchRecreationDotGov.get_all_campsites--returns","text":"List[AvailableCampsite] Source code in camply/search/search_recreationdotgov.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 def get_all_campsites ( self ) -> List [ AvailableCampsite ]: \"\"\" Perform the Search and Return All Monthly Availabilities Returns ------- List[AvailableCampsite] \"\"\" found_campsites = list () if len ( self . campgrounds ) == 0 : error_message = \"No campgrounds found to search\" logger . error ( error_message ) raise SearchError ( error_message ) logger . info ( f \"Searching across { len ( self . campgrounds ) } campgrounds\" ) if self . campsite_metadata is None : self . campsite_metadata = ( self . campsite_finder . get_internal_campsite_metadata ( facility_ids = [ facil . facility_id for facil in self . campgrounds ] ) ) logger . info ( \"Metadata fetched for %s campsites\" , len ( self . campsite_metadata ) ) for index , campground in enumerate ( self . campgrounds ): for month in self . search_months : logger . info ( f \"Searching { campground . facility_name } , { campground . recreation_area } \" f \"( { campground . facility_id } ) for availability: \" f \" { month . strftime ( '%B, %Y' ) } \" ) availabilities = self . campsite_finder . get_recdotgov_data ( campground_id = campground . facility_id , month = month ) campsites = self . campsite_finder . process_campsite_availability ( availability = availabilities , recreation_area = campground . recreation_area , recreation_area_id = campground . recreation_area_id , facility_name = campground . facility_name , facility_id = campground . facility_id , month = month , campsite_metadata = self . campsite_metadata , ) if self . campsites not in [ None , []]: campsites = [ campsite_obj for campsite_obj in campsites if int ( campsite_obj . campsite_id ) in self . campsites ] found_campsites += campsites if index + 1 < len ( self . campgrounds ): sleep ( round ( uniform ( * RecreationBookingConfig . RATE_LIMITING ), 2 )) campsite_df = self . campsites_to_df ( campsites = found_campsites ) campsite_df_validated = self . _filter_date_overlap ( campsites = campsite_df ) compiled_campsite_df = self . _consolidate_campsites ( campsite_df = campsite_df_validated , nights = self . nights ) equipment_filtered_campsites = self . filter_campsites_to_equipment ( campsites = compiled_campsite_df ) compiled_campsites = self . df_to_campsites ( campsite_df = equipment_filtered_campsites ) return compiled_campsites","title":"Returns"},{"location":"reference/search/#camply.search.SearchYellowstone","text":"Bases: BaseCampingSearch Camping Search Object Source code in camply/search/search_yellowstone.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 class SearchYellowstone ( BaseCampingSearch ): \"\"\" Camping Search Object \"\"\" # noinspection PyUnusedLocal def __init__ ( self , search_window : Union [ SearchWindow , List [ SearchWindow ]], weekends_only : bool = False , campgrounds : Optional [ Union [ List [ str ], str ]] = None , nights : int = 1 , offline_search : bool = False , offline_search_path : Optional [ str ] = None , ** kwargs , ) -> None : \"\"\" Initialize with Search Parameters Parameters ---------- search_window: Union[SearchWindow, List[SearchWindow]] Search Window tuple containing start date and End Date weekends_only: bool Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights) campgrounds: Optional[Union[List[str], str]] Campground ID or List of Campground IDs nights: int minimum number of consecutive nights to search per campsite,defaults to 1 offline_search: bool When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. offline_search_path: Optional[str] When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to `camply_campsites.json` \"\"\" super () . __init__ ( provider = YellowstoneLodging (), search_window = search_window , weekends_only = weekends_only , nights = nights , offline_search = offline_search , offline_search_path = offline_search_path , ) self . campgrounds = make_list ( campgrounds ) def get_all_campsites ( self ) -> List [ AvailableCampsite ]: \"\"\" Search for all matching campsites in Yellowstone. Returns ------- List[AvailableCampsite] \"\"\" all_campsites = list () searchable_campgrounds = self . _get_searchable_campgrounds () this_month = datetime . now () . date () . replace ( day = 1 ) for month in self . search_months : if month >= this_month : all_campsites += self . campsite_finder . get_monthly_campsites ( month = month , nights = None if self . nights == 1 else self . nights ) matching_campsites = self . _filter_campsites_to_campgrounds ( campsites = all_campsites , searchable_campgrounds = searchable_campgrounds ) campsite_df = self . campsites_to_df ( campsites = matching_campsites ) campsite_df_validated = self . _filter_date_overlap ( campsites = campsite_df ) time_window_end = max ( self . search_days ) + timedelta ( days = 1 ) compiled_campsite_df = campsite_df_validated [ campsite_df_validated . booking_end_date <= pd . Timestamp ( time_window_end ) ] compiled_campsites = self . df_to_campsites ( campsite_df = compiled_campsite_df ) return compiled_campsites def _get_searchable_campgrounds ( self ) -> Optional [ Set [ str ]]: \"\"\" Return the Campgrounds for the Camping Search Returns ------- Optional[Set[str]] \"\"\" if self . campgrounds in [ None , []]: return None supported_campsites = set ( YellowstoneConfig . YELLOWSTONE_CAMPGROUNDS . keys ()) selected_campsites = set ( self . campgrounds ) searchable_campgrounds = supported_campsites . intersection ( selected_campsites ) if len ( searchable_campgrounds ) == 0 : campground_ids = [ f \"` { key } ` ( { value } )\" for key , value in YellowstoneConfig . YELLOWSTONE_CAMPGROUNDS . items () ] error_message = ( \"You must supply a YellowstoneNationalParkLodges supported \" \"campground ID. Current supported Campground IDs: \" f \" { ', ' . join ( campground_ids ) } \" ) logger . error ( error_message ) raise SearchError ( error_message ) logger . info ( f \" { len ( searchable_campgrounds ) } Matching Campgrounds Found\" ) for campground in searchable_campgrounds : logger . info ( f \"\u26f0 { YellowstoneConfig . YELLOWSTONE_RECREATION_AREA_FORMAL_NAME } \" f \"(# { YellowstoneConfig . YELLOWSTONE_RECREATION_AREA_ID } ) - \ud83c\udfd5 \" f \" { YellowstoneConfig . YELLOWSTONE_CAMPGROUNDS [ campground ] } ( { campground } )\" ) return searchable_campgrounds def _filter_campsites_to_campgrounds ( self , campsites : List [ AvailableCampsite ], searchable_campgrounds : Set [ str ] ) -> List [ AvailableCampsite ]: \"\"\" Filter Campsites Down to Matching Campgrounds Parameters ---------- campsites: List[AvailableCampsite] searchable_campgrounds: Set[str] Returns ------- List[AvailableCampsite] \"\"\" if self . campgrounds in [ None , []]: return campsites matching_campsites = [ campsite for campsite in campsites if campsite . facility_id in searchable_campgrounds ] return matching_campsites @staticmethod def print_campgrounds () -> None : \"\"\" Print the Campgrounds inside of Yellowstone \"\"\" log_sorted_response ( YellowstoneConfig . YELLOWSTONE_CAMPGROUND_OBJECTS )","title":"SearchYellowstone"},{"location":"reference/search/#camply.search.search_yellowstone.SearchYellowstone.__init__","text":"Initialize with Search Parameters","title":"__init__()"},{"location":"reference/search/#camply.search.search_yellowstone.SearchYellowstone.__init__--parameters","text":"Union[SearchWindow, List[SearchWindow]] Search Window tuple containing start date and End Date bool Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights) Optional[Union[List[str], str]] Campground ID or List of Campground IDs int minimum number of consecutive nights to search per campsite,defaults to 1 bool When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. Optional[str] When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to camply_campsites.json Source code in camply/search/search_yellowstone.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def __init__ ( self , search_window : Union [ SearchWindow , List [ SearchWindow ]], weekends_only : bool = False , campgrounds : Optional [ Union [ List [ str ], str ]] = None , nights : int = 1 , offline_search : bool = False , offline_search_path : Optional [ str ] = None , ** kwargs , ) -> None : \"\"\" Initialize with Search Parameters Parameters ---------- search_window: Union[SearchWindow, List[SearchWindow]] Search Window tuple containing start date and End Date weekends_only: bool Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights) campgrounds: Optional[Union[List[str], str]] Campground ID or List of Campground IDs nights: int minimum number of consecutive nights to search per campsite,defaults to 1 offline_search: bool When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. offline_search_path: Optional[str] When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to `camply_campsites.json` \"\"\" super () . __init__ ( provider = YellowstoneLodging (), search_window = search_window , weekends_only = weekends_only , nights = nights , offline_search = offline_search , offline_search_path = offline_search_path , ) self . campgrounds = make_list ( campgrounds )","title":"Parameters"},{"location":"reference/search/#camply.search.search_yellowstone.SearchYellowstone.get_all_campsites","text":"Search for all matching campsites in Yellowstone.","title":"get_all_campsites()"},{"location":"reference/search/#camply.search.search_yellowstone.SearchYellowstone.get_all_campsites--returns","text":"List[AvailableCampsite] Source code in camply/search/search_yellowstone.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def get_all_campsites ( self ) -> List [ AvailableCampsite ]: \"\"\" Search for all matching campsites in Yellowstone. Returns ------- List[AvailableCampsite] \"\"\" all_campsites = list () searchable_campgrounds = self . _get_searchable_campgrounds () this_month = datetime . now () . date () . replace ( day = 1 ) for month in self . search_months : if month >= this_month : all_campsites += self . campsite_finder . get_monthly_campsites ( month = month , nights = None if self . nights == 1 else self . nights ) matching_campsites = self . _filter_campsites_to_campgrounds ( campsites = all_campsites , searchable_campgrounds = searchable_campgrounds ) campsite_df = self . campsites_to_df ( campsites = matching_campsites ) campsite_df_validated = self . _filter_date_overlap ( campsites = campsite_df ) time_window_end = max ( self . search_days ) + timedelta ( days = 1 ) compiled_campsite_df = campsite_df_validated [ campsite_df_validated . booking_end_date <= pd . Timestamp ( time_window_end ) ] compiled_campsites = self . df_to_campsites ( campsite_df = compiled_campsite_df ) return compiled_campsites","title":"Returns"},{"location":"reference/search/#camply.search.search_yellowstone.SearchYellowstone.print_campgrounds","text":"Print the Campgrounds inside of Yellowstone Source code in camply/search/search_yellowstone.py 155 156 157 158 159 160 @staticmethod def print_campgrounds () -> None : \"\"\" Print the Campgrounds inside of Yellowstone \"\"\" log_sorted_response ( YellowstoneConfig . YELLOWSTONE_CAMPGROUND_OBJECTS )","title":"print_campgrounds()"},{"location":"reference/search/base_search/","text":"Recreation.gov Web Searching Utilities BaseCampingSearch # Bases: ABC Camping Search Object Source code in camply/search/base_search.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 class BaseCampingSearch ( ABC ): \"\"\" Camping Search Object \"\"\" def __init__ ( self , provider : Union [ RecreationDotGov , YellowstoneLodging ], search_window : Union [ SearchWindow , List [ SearchWindow ]], weekends_only : bool = False , nights : int = 1 , offline_search : bool = False , offline_search_path : Optional [ str ] = None , ** kwargs , ) -> None : \"\"\" Initialize with Search Parameters Parameters ---------- provider: Union[RecreationDotGov, YellowstoneLodging] API Provider search_window: Union[SearchWindow, List[SearchWindow]] Search Window tuple containing start date and End Date weekends_only: bool Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights) nights: int minimum number of consecutive nights to search per campsite,defaults to 1 offline_search: bool When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. offline_search_path: Optional[str] When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to `camply_campsites.json` \"\"\" self . campsite_finder : Union [ RecreationDotGov , YellowstoneLodging ] = provider self . search_window : List [ SearchWindow ] = make_list ( search_window ) self . weekends_only : bool = weekends_only self . search_days : List [ datetime ] = self . _get_search_days () self . search_months : List [ datetime ] = self . _get_search_months () self . nights = self . _validate_consecutive_nights ( nights = nights ) self . offline_search = offline_search self . offline_search_path = self . _set_offline_search_path ( file_path = offline_search_path ) self . campsites_found : Set [ AvailableCampsite ] = set () self . loaded_campsites : Set [ AvailableCampsite ] = set () if self . offline_search_path . suffixes [ - 1 ] == \".json\" : self . offline_mode : str = \"json\" elif self . offline_search_path . suffixes [ - 1 ] in [ \".pkl\" , \".pickle\" ]: self . offline_mode : str = \"pickle\" else : raise CamplyError ( \"You must provide a `.json` or a `.pickle` / `.pkl` file name for offline searches\" ) if self . offline_search is True : logger . info ( \"Campsite search is configured to save offline: %s \" , self . offline_search_path , ) self . campsites_found : Set [ AvailableCampsite ] = self . load_campsites_from_file () self . loaded_campsites : Set [ AvailableCampsite ] = self . campsites_found . copy () @abstractmethod def get_all_campsites ( self ) -> List [ AvailableCampsite ]: \"\"\" Perform the Search and Return Matching Availabilities. This method must be implemented on all sub-classes. Returns ------- List[AvailableCampsite] \"\"\" def _get_intersection_date_overlap ( self , date : Timestamp , periods : int ) -> bool : \"\"\" Find Date Overlap Parameters ---------- date: Timestamp periods: int Returns ------- bool \"\"\" timestamp_range : List [ Timestamp ] = date_range ( start = date . to_pydatetime (), periods = periods ) campsite_date_range = { item . date () for item in timestamp_range } intersection = campsite_date_range . intersection ( self . search_days ) if intersection : return True else : return False def _compare_date_overlap ( self , campsite : AvailableCampsite ) -> bool : \"\"\" See whether a campsite should be returned as found Parameters ---------- campsite: AvailableCampsite Returns ------- bool \"\"\" intersection = self . _get_intersection_date_overlap ( date = campsite . booking_date , periods = campsite . booking_nights ) return intersection def _filter_date_overlap ( self , campsites : DataFrame ) -> pd . DataFrame : \"\"\" See whether a campsite should be returned as found Parameters ---------- campsites: pd.DataFrame Returns ------- pd.DataFrame \"\"\" matches = campsites . apply ( lambda x : self . _get_intersection_date_overlap ( date = x . booking_date , periods = x . booking_nights ), axis = 1 , ) filtered_campsites = campsites [ matches ] . copy () . reset_index ( drop = True ) return filtered_campsites def _search_matching_campsites_available ( self , log : bool = False , verbose : bool = False , raise_error : bool = False ) -> List [ AvailableCampsite ]: \"\"\" Perform the Search and Return Matching Availabilities Parameters ---------- log: bool Whether to log found campsites verbose: bool Used with `log` to enhance the amount of info logged to the console raise_error: bool Whether to raise an error if nothing is found. Defaults to False. Returns ------- List[AvailableCampsite] \"\"\" matching_campgrounds = list () for camp in self . get_all_campsites (): if all ( [ self . _compare_date_overlap ( campsite = camp ) is True , camp . booking_nights >= self . nights , ] ): matching_campgrounds . append ( camp ) logger . info ( f \" { ( get_emoji ( matching_campgrounds ) + ' ' ) * 4 }{ len ( matching_campgrounds ) } \" \"Reservable Campsites Matching Search Preferences\" ) self . assemble_availabilities ( matching_data = matching_campgrounds , log = log , verbose = verbose ) if ( self . offline_search is True and self . loaded_campsites . issuperset ( matching_campgrounds ) and raise_error is True ): campsite_availability_message = ( \"No New Campsites were found, we'll continue checking\" ) logger . info ( campsite_availability_message ) raise CampsiteNotFoundError ( campsite_availability_message ) elif len ( matching_campgrounds ) == 0 and raise_error is True : campsite_availability_message = ( \"No Campsites were found, we'll continue checking\" ) logger . info ( campsite_availability_message ) raise CampsiteNotFoundError ( campsite_availability_message ) return matching_campgrounds @classmethod def _get_polling_minutes ( cls , polling_interval : Optional [ int ]) -> int : \"\"\" Return the Number of Minutes to Search Parameters ---------- polling_interval: Optional[int] Used with `continuous=True`, the amount of time to wait between searches. Defaults to 10 if not provided, cannot be less than 5 Returns ------- int \"\"\" if polling_interval is None : polling_interval = getenv ( \"POLLING_INTERVAL\" , SearchConfig . RECOMMENDED_POLLING_INTERVAL ) if int ( polling_interval ) < SearchConfig . POLLING_INTERVAL_MINIMUM : polling_interval = SearchConfig . POLLING_INTERVAL_MINIMUM polling_interval_minutes = int ( round ( float ( polling_interval ), 2 )) return polling_interval_minutes def _continuous_search_retry ( self , log : bool , verbose : bool , polling_interval : int , continuous_search_attempts : int , notification_provider : Union [ str , List [ str ], BaseNotifications , None ], notify_first_try : bool , ) -> List [ AvailableCampsite ]: \"\"\" Search for Campsites until at least one is found Parameters ---------- log: bool Whether to log found campsites verbose: bool Used with `log` to enhance the amount of info logged to the console polling_interval: Optional[int] Used with `continuous=True`, the amount of time to wait between searches. Defaults to 10 if not provided, cannot be less than 5 continuous_search_attempts: int Number of preexisting search attempts notification_provider: provider: Union[str, List[str]] Used with `continuous=True`, Name of notification provider to use. Accepts \"email\", \"pushover\", and defaults to \"silent\". Also accepts a list or commma separated string of these options or even a notification provider object itself notify_first_try: bool Used with `continuous=True`, whether to send all non-silent notifications if more than 5 matching campsites are found on the first try. Defaults to false which only sends the first 5. Returns ------- List[AvailableCampsite] \"\"\" polling_interval_minutes = self . _get_polling_minutes ( polling_interval = polling_interval ) notifier = MultiNotifierProvider ( provider = notification_provider ) logger . info ( f \"Searching for campsites every { polling_interval_minutes } minutes. \" ) notifier . log_providers () retryer = tenacity . Retrying ( retry = tenacity . retry_if_exception_type ( CampsiteNotFoundError ), wait = tenacity . wait . wait_fixed ( int ( polling_interval_minutes ) * 60 ), ) matching_campsites = retryer . __call__ ( self . _search_matching_campsites_available , False , False , True ) found_campsites = set ( matching_campsites ) new_campsites = found_campsites . difference ( self . campsites_found ) self . assemble_availabilities ( matching_data = list ( new_campsites ), log = log , verbose = verbose ) logger . info ( f \" { len ( new_campsites ) } New Campsites Found.\" ) self . campsites_found . update ( new_campsites ) logged_campsites = list ( new_campsites ) self . _handle_notifications ( retryer = retryer , notifier = notifier , logged_campsites = logged_campsites , continuous_search_attempts = continuous_search_attempts , notify_first_try = notify_first_try , ) return list ( self . campsites_found ) @classmethod def _handle_notifications ( cls , retryer : tenacity . Retrying , notifier : MultiNotifierProvider , logged_campsites : List [ AvailableCampsite ], continuous_search_attempts : int , notify_first_try : bool , ) -> None : \"\"\" Handle sending notifications Parameters ---------- retryer: tenacity.Retrying notifier: MultiNotifierProvider logged_campsites: List[AvailableCampsite] continuous_search_attempts: int notify_first_try: bool Returns ------- None \"\"\" attempt_number = retryer . statistics . get ( \"attempt_number\" , 1 ) minimum_first_notify = SearchConfig . MINIMUM_CAMPSITES_FIRST_NOTIFY if max ([ attempt_number , continuous_search_attempts ]) > 1 : logged_campsites = cls . _handle_too_many_campsites_found ( notifier = notifier , logged_campsites = logged_campsites ) notifier . send_campsites ( campsites = logged_campsites ) elif attempt_number == 1 and notify_first_try is True : logged_campsites = cls . _handle_too_many_campsites_found ( notifier = notifier , logged_campsites = logged_campsites ) notifier . send_campsites ( campsites = logged_campsites ) else : if ( len ( notifier . providers ) > 1 and len ( logged_campsites ) > minimum_first_notify ): error_message = ( f \"Found more than { minimum_first_notify } \" f \"matching campsites ( { len ( logged_campsites ) } ) on the \" \"first try. Try searching online instead. \" f \"camply is only sending the first \" f \" { minimum_first_notify } notifications. \" \"Go Get your campsite! \ud83c\udfd5\" ) logger . warning ( error_message ) notifier . send_message ( message = error_message ) logged_campsites = logged_campsites [: minimum_first_notify ] notifier . send_campsites ( campsites = logged_campsites ) @classmethod def _handle_too_many_campsites_found ( cls , notifier : MultiNotifierProvider , logged_campsites : List [ AvailableCampsite ] ) -> List [ AvailableCampsite ]: \"\"\" Handle Scenarios Where Too Many Campsites are Found Parameters ---------- notifier: MultiNotifierProvider logged_campsites: List[AvailableCampsite] Returns ------- List[AvailableCampsite] \"\"\" limit = SearchConfig . MAXIMUM_NOTIFICATION_BATCH_SIZE number_campsites = len ( logged_campsites ) if number_campsites > limit : warning_message = ( f \"Too many campsites were found during the search ( { number_campsites } \" f \"total). camply will only send you the first { limit } notifications.\" ) logger . warning ( warning_message ) restricted_campsites = logged_campsites [: limit ] notifier . send_message ( warning_message ) else : restricted_campsites = logged_campsites return restricted_campsites def _search_campsites_continuous ( self , log : bool = True , verbose : bool = False , polling_interval : Optional [ int ] = None , notification_provider : str = \"silent\" , notify_first_try : bool = False , search_forever : bool = False , ): \"\"\" Continuously Search For Campsites Parameters ---------- log: bool Whether to log found campsites verbose: bool Used with `log` to enhance the amount of info logged to the console polling_interval: Optional[int] Used with `continuous=True`, the amount of time to wait between searches. Defaults to 10 if not provided, cannot be less than 5 notification_provider: str Used with `continuous=True`, Name of notification provider to use. Accepts \"email\", \"pushover\", and defaults to \"silent\". Also accepts a list or commma separated string of these options or even a notification provider object itself notify_first_try: bool Used with `continuous=True`, whether to send all non-silent notifications if more than 5 matching campsites are found on the first try. Defaults to false which only sends the first 5. search_forever: bool Used with `continuous=True`, This option searches for new campsites forever, with the caveat being that it will never notify about the same campsite. Returns ------- List[AvailableCampsite] \"\"\" polling_interval_minutes = self . _get_polling_minutes ( polling_interval = polling_interval ) continuous_search = True continuous_search_attempts = 1 while continuous_search is True : starting_count = len ( self . campsites_found ) self . _continuous_search_retry ( log = log , verbose = verbose , polling_interval = polling_interval , notification_provider = notification_provider , notify_first_try = notify_first_try , continuous_search_attempts = continuous_search_attempts , ) ending_count = len ( self . campsites_found ) continuous_search_attempts += 1 if self . offline_search is True and ending_count > starting_count : self . unload_campsites_to_file () if search_forever is True : sleep ( int ( polling_interval_minutes ) * 60 ) else : continuous_search = False return list ( self . campsites_found ) def get_matching_campsites ( self , log : bool = True , verbose : bool = False , continuous : bool = False , polling_interval : Optional [ int ] = None , notification_provider : str = \"silent\" , notify_first_try : bool = False , search_forever : bool = False , ) -> List [ AvailableCampsite ]: \"\"\" Perform the Search and Return Matching Availabilities Parameters ---------- log: bool Whether to log found campsites verbose: bool Used with `log` to enhance the amount of info logged to the console continuous: bool Whether to continue searching beyond just the first time polling_interval: Optional[int] Used with `continuous=True`, the amount of time to wait between searches. Defaults to 10 if not provided, cannot be less than 5 notification_provider: str Used with `continuous=True`, Name of notification provider to use. Accepts \"email\", \"pushover\", and defaults to \"silent\". Also accepts a list or commma separated string of these options or even a notification provider object itself notify_first_try: bool Used with `continuous=True`, whether to send all non-silent notifications if more than 5 matching campsites are found on the first try. Defaults to false which only sends the first 5. search_forever: bool Used with `continuous=True`, This option searches for new campsites forever, with the caveat being that it will never notify about the same campsite. Returns ------- List[AvailableCampsite] \"\"\" if continuous is True : self . _search_campsites_continuous ( log = log , verbose = verbose , polling_interval = polling_interval , notification_provider = notification_provider , notify_first_try = notify_first_try , search_forever = search_forever , ) else : starting_count = len ( self . campsites_found ) matching_campsites = self . _search_matching_campsites_available ( log = log , verbose = True ) self . campsites_found . update ( set ( matching_campsites )) ending_count = len ( self . campsites_found ) if self . offline_search is True and ending_count > starting_count : self . unload_campsites_to_file () return list ( self . campsites_found ) def _get_search_days ( self ) -> List [ datetime ]: \"\"\" Retrieve Specific Days to Search For Returns ------- search_days: List[datetime] Datetime days to search for reservations \"\"\" current_date = datetime . now () . date () search_nights = set () for window in self . search_window : generated_dates = { date for date in window . get_date_range () if date >= current_date } search_nights . update ( generated_dates ) if self . weekends_only is True : logger . info ( \"Limiting Search of Campgrounds to Weekend Availabilities\" ) search_nights = { x for x in search_nights if x . weekday () in [ 4 , 5 ]} if len ( search_nights ) > 0 : logger . info ( f \" { len ( search_nights ) } booking nights selected for search, \" f \"ranging from { min ( search_nights ) } to { max ( search_nights ) } \" ) else : logger . info ( SearchConfig . ERROR_MESSAGE ) raise RuntimeError ( SearchConfig . ERROR_MESSAGE ) return list ( sorted ( search_nights )) def _get_search_months ( self ) -> List [ datetime ]: \"\"\" Get the Unique Months that need to be Searched Returns ------- search_months: List[datetime] Datetime Months to search for reservations \"\"\" truncated_months = set ([ day . replace ( day = 1 ) for day in self . search_days ]) if len ( truncated_months ) > 1 : logger . info ( f \" { len ( truncated_months ) } different months selected for search, \" f \"ranging from { min ( self . search_days ) } to { max ( self . search_days ) } \" ) return sorted ( list ( truncated_months )) elif len ( truncated_months ) == 0 : logger . info ( SearchConfig . ERROR_MESSAGE ) raise RuntimeError ( SearchConfig . ERROR_MESSAGE ) else : return sorted ( list ( truncated_months )) @classmethod def _consolidate_campsites ( cls , campsite_df : DataFrame , nights : int ) -> List [ AvailableCampsite ]: \"\"\" Consolidate Single Night Campsites into Multiple Night Campsites Parameters ---------- campsite_df: DataFrame DataFrame of AvailableCampsites Returns ------- List[AvailableCampsite] \"\"\" composed_groupings = list () for _ , campsite_slice in campsite_df . groupby ( [ CampsiteContainerFields . CAMPSITE_ID , CampsiteContainerFields . CAMPGROUND_ID ] ): # SORT THE VALUES AND CREATE A COPIED SLICE campsite_grouping = campsite_slice . sort_values ( by = CampsiteContainerFields . BOOKING_DATE , ascending = True ) . copy () # ASSEMBLE THE CAMPSITES AVAILABILITIES INTO GROUPS THAT ARE CONSECUTIVE booking_date = campsite_grouping [ CampsiteContainerFields . BOOKING_DATE ] date = Timedelta ( \"1d\" ) consecutive_nights = booking_date . diff () != date group_identifier = consecutive_nights . cumsum () campsite_grouping [ CampsiteContainerFields . CAMPSITE_GROUP ] = group_identifier # USE THE ASSEMBLED GROUPS TO CREATE UPDATED CAMPSITES AND REMOVE DUPLICATES for _campsite_group , campsite_group_slice in campsite_grouping . groupby ( [ CampsiteContainerFields . CAMPSITE_GROUP ] ): composed_grouping = campsite_group_slice . sort_values ( by = CampsiteContainerFields . BOOKING_DATE , ascending = True ) . copy () composed_grouping . drop ( columns = [ CampsiteContainerFields . CAMPSITE_GROUP ], inplace = True ) nightly_breakouts = cls . _find_consecutive_nights ( dataframe = composed_grouping , nights = nights ) composed_groupings . append ( nightly_breakouts ) if len ( composed_groupings ) == 0 : composed_groupings = [ DataFrame ()] return concat ( composed_groupings , ignore_index = True ) @classmethod def _consecutive_subseq ( cls , iterable : Iterable , length : int ) -> Generator : \"\"\" Find All Sub Sequences by length Given a List See https://tinyurl.com/5av5unjd Parameters ---------- iterable: Iterable length: int Returns ------- Generator \"\"\" for _ , consec_run in groupby ( enumerate ( iterable ), lambda x : x [ 0 ] - x [ 1 ]): k_wise = tee ( map ( itemgetter ( 1 ), consec_run ), length ) for n , it in enumerate ( k_wise ): next ( islice ( it , n , n ), None ) yield from zip ( * k_wise ) @classmethod def _find_consecutive_nights ( cls , dataframe : DataFrame , nights : int ) -> DataFrame : \"\"\" Explode a DataFrame of Consecutive Nightly Campsite Availabilities, Expand to all unique possibilities given the length of the stay. Parameters ---------- dataframe: DataFrame nights: int Returns ------- DataFrame \"\"\" duplicate_subset = set ( dataframe . columns ) - AvailableCampsite . __unhashable__ dataframe_slice = dataframe . copy () . reset_index ( drop = True ) nights_indexes = dataframe_slice . booking_date . index consecutive_generator = cls . _consecutive_subseq ( iterable = nights_indexes , length = nights ) sequences = list ( consecutive_generator ) concatted_data = list () for sequence in sequences : index_list = list ( sequence ) data_copy = dataframe_slice . iloc [ index_list ] . copy () data_copy . booking_date = data_copy . booking_date . min () data_copy . booking_end_date = data_copy . booking_end_date . max () data_copy . booking_url = data_copy . booking_url . loc [ index_list [ 0 ]] data_copy . booking_nights = ( data_copy . booking_end_date - data_copy . booking_date ) . dt . days data_copy . drop_duplicates ( inplace = True , subset = duplicate_subset ) concatted_data . append ( data_copy ) if len ( concatted_data ) == 0 : concatted_data = [ DataFrame ()] return concat ( concatted_data , ignore_index = True ) def _validate_consecutive_nights ( self , nights : int ) -> int : \"\"\" Validate the number of consecutive nights to search Parameters ---------- nights : int Number of nights to check Returns ------- int The proper number of nights to search \"\"\" search_days = Series ( self . search_days ) consecutive_nights = search_days . diff () != Timedelta ( \"1d\" ) largest_grouping = consecutive_nights . cumsum () . value_counts () . max () if nights > 1 : logger . info ( f \"Searching for availabilities with { nights } consecutive night stays.\" ) if nights > largest_grouping : logger . warning ( \"Too many consecutive nights selected. \" \"The consecutive night parameter will be set to \" f \"the max possible, { largest_grouping } .\" ) return largest_grouping else : return nights @staticmethod def campsites_to_df ( campsites : List [ AvailableCampsite ]) -> DataFrame : \"\"\" Convert Campsite Array to Parameters ---------- campsites: List[AvailableCampsite] Returns ------- DataFrame \"\"\" campsite_df = DataFrame ( data = [ campsite . dict () for campsite in campsites ], columns = AvailableCampsite . __fields__ , ) return campsite_df @staticmethod def df_to_campsites ( campsite_df : DataFrame ) -> List [ AvailableCampsite ]: \"\"\" Convert Campsite DataFrame to array of AvailableCampsite objects Parameters ---------- campsite_df: DataFrame Returns ------- List[AvailableCampsite] \"\"\" composed_campsite_array = list () composed_campsite_data_array = campsite_df . to_dict ( orient = \"records\" ) for campsite_record in composed_campsite_data_array : composed_campsite_array . append ( AvailableCampsite ( ** campsite_record )) return composed_campsite_array @classmethod def assemble_availabilities ( cls , matching_data : List [ AvailableCampsite ], log : bool = True , verbose : bool = False , ) -> DataFrame : \"\"\" Prepare a Pandas DataFrame from Array of AvailableCampsite objects Parameters ---------- matching_data: List[AvailableCampsite] List of campsites to assemble log: bool Whether to log found campsites verbose: bool Used with `log` to enhance the amount of info logged to the console Returns ------- availability_df: DataFrame \"\"\" availability_df = cls . campsites_to_df ( campsites = matching_data ) if log is True : cls . _log_availabilities ( availability_df = availability_df , verbose = verbose ) return availability_df @classmethod def _log_availabilities ( cls , availability_df : DataFrame , verbose : bool ) -> DataFrame : \"\"\" Log the Availabilities Parameters ---------- availability_df: DataFrame verbose: bool Returns ------- DataFrame \"\"\" booking_date : datetime for booking_date , available_sites in availability_df . groupby ( \"booking_date\" ): logger . info ( f \"\ud83d\udcc5 { booking_date . strftime ( ' %a , %B %d ' ) } \" f \"\ud83c\udfd5 { len ( available_sites ) } sites\" ) location_tuple : tuple for location_tuple , campground_availability in available_sites . groupby ( [ DataColumns . RECREATION_AREA_COLUMN , DataColumns . FACILITY_NAME_COLUMN ] ): logger . info ( f \" \\t \u26f0\ufe0f { ' \ud83c\udfd5 ' . join ( location_tuple ) } : \u26fa \" f \" { len ( campground_availability ) } sites\" ) if verbose is True : for ( booking_nights , nightly_availability , ) in campground_availability . groupby ( [ DataColumns . BOOKING_NIGHTS_COLUMN ] ): unique_urls = nightly_availability [ DataColumns . BOOKING_URL_COLUMN ] . unique () for booking_url in sorted ( unique_urls ): logger . info ( f \" \\t\\t \ud83d\udd17 { booking_url } \" f \"( { booking_nights } night\" f \" { 's' if booking_nights > 1 else '' } )\" ) return availability_df def unload_campsites_to_file ( self ) -> pathlib . Path : \"\"\" Unload a BaseSearch Object's campsites to a serialized Pickle file. Returns ------- pathlib.Path \"\"\" if self . offline_mode == \"pickle\" : pickle . dump ( obj = self . campsites_found , file = self . offline_search_path . open ( mode = \"wb\" ), protocol = 4 , fix_imports = True , ) elif self . offline_mode == \"json\" : json . dump ( obj = self . campsites_found , fp = self . offline_search_path . open ( mode = \"w\" ), sort_keys = True , default = pydantic_encoder , indent = 4 , ) logger . debug ( \" %s campsites saved to file: %s \" , len ( self . campsites_found ), self . offline_search_path , ) return self . offline_search_path def load_campsites_from_file ( self ) -> Set [ AvailableCampsite ]: \"\"\" Load a BaseSearch Object's campsites from a serialized Pickle file. Returns ------- Set[AvailableCampsite] \"\"\" if self . offline_search_path . exists (): if self . offline_mode == \"pickle\" : campsites : Set [ AvailableCampsite ] = pickle . load ( file = self . offline_search_path . open ( mode = \"rb\" ), fix_imports = True ) elif self . offline_mode == \"json\" : campsites_dicts : List [ Dict [ str , Any ]] = json . load ( self . offline_search_path . open ( mode = \"r\" ), ) campsites : Set [ AvailableCampsite ] = set ( [ AvailableCampsite ( ** json_dict ) for json_dict in campsites_dicts ] ) if len ( campsites ) > 0 : logger . info ( \" %s campsites loaded from file: %s \" , len ( campsites ), self . offline_search_path , ) else : campsites = set () return campsites @staticmethod def _set_offline_search_path ( file_path : Optional [ str ]) -> pathlib . Path : default_file_path = \"camply_campsites.json\" if file_path is None : file_path = default_file_path returned_path = pathlib . Path ( file_path ) . resolve () parent_dir = pathlib . Path . cwd () if all ( [ returned_path . exists (), returned_path . is_file (), set ( returned_path . suffixes ) . issubset ({ \".pkl\" , \".pickle\" , \".json\" }), ] ): path_obj = returned_path elif all ( [ returned_path . exists (), returned_path . is_dir (), ] ): path_obj = returned_path . joinpath ( default_file_path ) else : path_obj = parent_dir . joinpath ( file_path ) return path_obj __init__ ( provider , search_window , weekends_only = False , nights = 1 , offline_search = False , offline_search_path = None , ** kwargs ) # Initialize with Search Parameters Parameters # Union[RecreationDotGov, YellowstoneLodging] API Provider Union[SearchWindow, List[SearchWindow]] Search Window tuple containing start date and End Date bool Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights) int minimum number of consecutive nights to search per campsite,defaults to 1 bool When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. Optional[str] When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to camply_campsites.json Source code in camply/search/base_search.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def __init__ ( self , provider : Union [ RecreationDotGov , YellowstoneLodging ], search_window : Union [ SearchWindow , List [ SearchWindow ]], weekends_only : bool = False , nights : int = 1 , offline_search : bool = False , offline_search_path : Optional [ str ] = None , ** kwargs , ) -> None : \"\"\" Initialize with Search Parameters Parameters ---------- provider: Union[RecreationDotGov, YellowstoneLodging] API Provider search_window: Union[SearchWindow, List[SearchWindow]] Search Window tuple containing start date and End Date weekends_only: bool Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights) nights: int minimum number of consecutive nights to search per campsite,defaults to 1 offline_search: bool When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. offline_search_path: Optional[str] When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to `camply_campsites.json` \"\"\" self . campsite_finder : Union [ RecreationDotGov , YellowstoneLodging ] = provider self . search_window : List [ SearchWindow ] = make_list ( search_window ) self . weekends_only : bool = weekends_only self . search_days : List [ datetime ] = self . _get_search_days () self . search_months : List [ datetime ] = self . _get_search_months () self . nights = self . _validate_consecutive_nights ( nights = nights ) self . offline_search = offline_search self . offline_search_path = self . _set_offline_search_path ( file_path = offline_search_path ) self . campsites_found : Set [ AvailableCampsite ] = set () self . loaded_campsites : Set [ AvailableCampsite ] = set () if self . offline_search_path . suffixes [ - 1 ] == \".json\" : self . offline_mode : str = \"json\" elif self . offline_search_path . suffixes [ - 1 ] in [ \".pkl\" , \".pickle\" ]: self . offline_mode : str = \"pickle\" else : raise CamplyError ( \"You must provide a `.json` or a `.pickle` / `.pkl` file name for offline searches\" ) if self . offline_search is True : logger . info ( \"Campsite search is configured to save offline: %s \" , self . offline_search_path , ) self . campsites_found : Set [ AvailableCampsite ] = self . load_campsites_from_file () self . loaded_campsites : Set [ AvailableCampsite ] = self . campsites_found . copy () assemble_availabilities ( matching_data , log = True , verbose = False ) classmethod # Prepare a Pandas DataFrame from Array of AvailableCampsite objects Parameters # List[AvailableCampsite] List of campsites to assemble bool Whether to log found campsites bool Used with log to enhance the amount of info logged to the console Returns # availability_df: DataFrame Source code in camply/search/base_search.py 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 @classmethod def assemble_availabilities ( cls , matching_data : List [ AvailableCampsite ], log : bool = True , verbose : bool = False , ) -> DataFrame : \"\"\" Prepare a Pandas DataFrame from Array of AvailableCampsite objects Parameters ---------- matching_data: List[AvailableCampsite] List of campsites to assemble log: bool Whether to log found campsites verbose: bool Used with `log` to enhance the amount of info logged to the console Returns ------- availability_df: DataFrame \"\"\" availability_df = cls . campsites_to_df ( campsites = matching_data ) if log is True : cls . _log_availabilities ( availability_df = availability_df , verbose = verbose ) return availability_df campsites_to_df ( campsites ) staticmethod # Convert Campsite Array to Parameters # campsites: List[AvailableCampsite] Returns # DataFrame Source code in camply/search/base_search.py 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 @staticmethod def campsites_to_df ( campsites : List [ AvailableCampsite ]) -> DataFrame : \"\"\" Convert Campsite Array to Parameters ---------- campsites: List[AvailableCampsite] Returns ------- DataFrame \"\"\" campsite_df = DataFrame ( data = [ campsite . dict () for campsite in campsites ], columns = AvailableCampsite . __fields__ , ) return campsite_df df_to_campsites ( campsite_df ) staticmethod # Convert Campsite DataFrame to array of AvailableCampsite objects Parameters # campsite_df: DataFrame Returns # List[AvailableCampsite] Source code in camply/search/base_search.py 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 @staticmethod def df_to_campsites ( campsite_df : DataFrame ) -> List [ AvailableCampsite ]: \"\"\" Convert Campsite DataFrame to array of AvailableCampsite objects Parameters ---------- campsite_df: DataFrame Returns ------- List[AvailableCampsite] \"\"\" composed_campsite_array = list () composed_campsite_data_array = campsite_df . to_dict ( orient = \"records\" ) for campsite_record in composed_campsite_data_array : composed_campsite_array . append ( AvailableCampsite ( ** campsite_record )) return composed_campsite_array get_all_campsites () abstractmethod # Perform the Search and Return Matching Availabilities. This method must be implemented on all sub-classes. Returns # List[AvailableCampsite] Source code in camply/search/base_search.py 117 118 119 120 121 122 123 124 125 126 127 128 @abstractmethod def get_all_campsites ( self ) -> List [ AvailableCampsite ]: \"\"\" Perform the Search and Return Matching Availabilities. This method must be implemented on all sub-classes. Returns ------- List[AvailableCampsite] \"\"\" get_matching_campsites ( log = True , verbose = False , continuous = False , polling_interval = None , notification_provider = 'silent' , notify_first_try = False , search_forever = False ) # Perform the Search and Return Matching Availabilities Parameters # bool Whether to log found campsites bool Used with log to enhance the amount of info logged to the console bool Whether to continue searching beyond just the first time Optional[int] Used with continuous=True , the amount of time to wait between searches. Defaults to 10 if not provided, cannot be less than 5 str Used with continuous=True , Name of notification provider to use. Accepts \"email\", \"pushover\", and defaults to \"silent\". Also accepts a list or commma separated string of these options or even a notification provider object itself bool Used with continuous=True , whether to send all non-silent notifications if more than 5 matching campsites are found on the first try. Defaults to false which only sends the first 5. bool Used with continuous=True , This option searches for new campsites forever, with the caveat being that it will never notify about the same campsite. Returns # List[AvailableCampsite] Source code in camply/search/base_search.py 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 def get_matching_campsites ( self , log : bool = True , verbose : bool = False , continuous : bool = False , polling_interval : Optional [ int ] = None , notification_provider : str = \"silent\" , notify_first_try : bool = False , search_forever : bool = False , ) -> List [ AvailableCampsite ]: \"\"\" Perform the Search and Return Matching Availabilities Parameters ---------- log: bool Whether to log found campsites verbose: bool Used with `log` to enhance the amount of info logged to the console continuous: bool Whether to continue searching beyond just the first time polling_interval: Optional[int] Used with `continuous=True`, the amount of time to wait between searches. Defaults to 10 if not provided, cannot be less than 5 notification_provider: str Used with `continuous=True`, Name of notification provider to use. Accepts \"email\", \"pushover\", and defaults to \"silent\". Also accepts a list or commma separated string of these options or even a notification provider object itself notify_first_try: bool Used with `continuous=True`, whether to send all non-silent notifications if more than 5 matching campsites are found on the first try. Defaults to false which only sends the first 5. search_forever: bool Used with `continuous=True`, This option searches for new campsites forever, with the caveat being that it will never notify about the same campsite. Returns ------- List[AvailableCampsite] \"\"\" if continuous is True : self . _search_campsites_continuous ( log = log , verbose = verbose , polling_interval = polling_interval , notification_provider = notification_provider , notify_first_try = notify_first_try , search_forever = search_forever , ) else : starting_count = len ( self . campsites_found ) matching_campsites = self . _search_matching_campsites_available ( log = log , verbose = True ) self . campsites_found . update ( set ( matching_campsites )) ending_count = len ( self . campsites_found ) if self . offline_search is True and ending_count > starting_count : self . unload_campsites_to_file () return list ( self . campsites_found ) load_campsites_from_file () # Load a BaseSearch Object's campsites from a serialized Pickle file. Returns # Set[AvailableCampsite] Source code in camply/search/base_search.py 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 def load_campsites_from_file ( self ) -> Set [ AvailableCampsite ]: \"\"\" Load a BaseSearch Object's campsites from a serialized Pickle file. Returns ------- Set[AvailableCampsite] \"\"\" if self . offline_search_path . exists (): if self . offline_mode == \"pickle\" : campsites : Set [ AvailableCampsite ] = pickle . load ( file = self . offline_search_path . open ( mode = \"rb\" ), fix_imports = True ) elif self . offline_mode == \"json\" : campsites_dicts : List [ Dict [ str , Any ]] = json . load ( self . offline_search_path . open ( mode = \"r\" ), ) campsites : Set [ AvailableCampsite ] = set ( [ AvailableCampsite ( ** json_dict ) for json_dict in campsites_dicts ] ) if len ( campsites ) > 0 : logger . info ( \" %s campsites loaded from file: %s \" , len ( campsites ), self . offline_search_path , ) else : campsites = set () return campsites unload_campsites_to_file () # Unload a BaseSearch Object's campsites to a serialized Pickle file. Returns # pathlib.Path Source code in camply/search/base_search.py 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 def unload_campsites_to_file ( self ) -> pathlib . Path : \"\"\" Unload a BaseSearch Object's campsites to a serialized Pickle file. Returns ------- pathlib.Path \"\"\" if self . offline_mode == \"pickle\" : pickle . dump ( obj = self . campsites_found , file = self . offline_search_path . open ( mode = \"wb\" ), protocol = 4 , fix_imports = True , ) elif self . offline_mode == \"json\" : json . dump ( obj = self . campsites_found , fp = self . offline_search_path . open ( mode = \"w\" ), sort_keys = True , default = pydantic_encoder , indent = 4 , ) logger . debug ( \" %s campsites saved to file: %s \" , len ( self . campsites_found ), self . offline_search_path , ) return self . offline_search_path CamplyError # Bases: Exception Base Camply Error Source code in camply/search/base_search.py 32 33 34 35 class CamplyError ( Exception ): \"\"\" Base Camply Error \"\"\" CampsiteNotFoundError # Bases: SearchError Campsite not found Error Source code in camply/search/base_search.py 44 45 46 47 class CampsiteNotFoundError ( SearchError ): \"\"\" Campsite not found Error \"\"\" SearchError # Bases: CamplyError Generic Search Error Source code in camply/search/base_search.py 38 39 40 41 class SearchError ( CamplyError ): \"\"\" Generic Search Error \"\"\"","title":"base_search"},{"location":"reference/search/base_search/#camply.search.base_search.BaseCampingSearch","text":"Bases: ABC Camping Search Object Source code in camply/search/base_search.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 class BaseCampingSearch ( ABC ): \"\"\" Camping Search Object \"\"\" def __init__ ( self , provider : Union [ RecreationDotGov , YellowstoneLodging ], search_window : Union [ SearchWindow , List [ SearchWindow ]], weekends_only : bool = False , nights : int = 1 , offline_search : bool = False , offline_search_path : Optional [ str ] = None , ** kwargs , ) -> None : \"\"\" Initialize with Search Parameters Parameters ---------- provider: Union[RecreationDotGov, YellowstoneLodging] API Provider search_window: Union[SearchWindow, List[SearchWindow]] Search Window tuple containing start date and End Date weekends_only: bool Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights) nights: int minimum number of consecutive nights to search per campsite,defaults to 1 offline_search: bool When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. offline_search_path: Optional[str] When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to `camply_campsites.json` \"\"\" self . campsite_finder : Union [ RecreationDotGov , YellowstoneLodging ] = provider self . search_window : List [ SearchWindow ] = make_list ( search_window ) self . weekends_only : bool = weekends_only self . search_days : List [ datetime ] = self . _get_search_days () self . search_months : List [ datetime ] = self . _get_search_months () self . nights = self . _validate_consecutive_nights ( nights = nights ) self . offline_search = offline_search self . offline_search_path = self . _set_offline_search_path ( file_path = offline_search_path ) self . campsites_found : Set [ AvailableCampsite ] = set () self . loaded_campsites : Set [ AvailableCampsite ] = set () if self . offline_search_path . suffixes [ - 1 ] == \".json\" : self . offline_mode : str = \"json\" elif self . offline_search_path . suffixes [ - 1 ] in [ \".pkl\" , \".pickle\" ]: self . offline_mode : str = \"pickle\" else : raise CamplyError ( \"You must provide a `.json` or a `.pickle` / `.pkl` file name for offline searches\" ) if self . offline_search is True : logger . info ( \"Campsite search is configured to save offline: %s \" , self . offline_search_path , ) self . campsites_found : Set [ AvailableCampsite ] = self . load_campsites_from_file () self . loaded_campsites : Set [ AvailableCampsite ] = self . campsites_found . copy () @abstractmethod def get_all_campsites ( self ) -> List [ AvailableCampsite ]: \"\"\" Perform the Search and Return Matching Availabilities. This method must be implemented on all sub-classes. Returns ------- List[AvailableCampsite] \"\"\" def _get_intersection_date_overlap ( self , date : Timestamp , periods : int ) -> bool : \"\"\" Find Date Overlap Parameters ---------- date: Timestamp periods: int Returns ------- bool \"\"\" timestamp_range : List [ Timestamp ] = date_range ( start = date . to_pydatetime (), periods = periods ) campsite_date_range = { item . date () for item in timestamp_range } intersection = campsite_date_range . intersection ( self . search_days ) if intersection : return True else : return False def _compare_date_overlap ( self , campsite : AvailableCampsite ) -> bool : \"\"\" See whether a campsite should be returned as found Parameters ---------- campsite: AvailableCampsite Returns ------- bool \"\"\" intersection = self . _get_intersection_date_overlap ( date = campsite . booking_date , periods = campsite . booking_nights ) return intersection def _filter_date_overlap ( self , campsites : DataFrame ) -> pd . DataFrame : \"\"\" See whether a campsite should be returned as found Parameters ---------- campsites: pd.DataFrame Returns ------- pd.DataFrame \"\"\" matches = campsites . apply ( lambda x : self . _get_intersection_date_overlap ( date = x . booking_date , periods = x . booking_nights ), axis = 1 , ) filtered_campsites = campsites [ matches ] . copy () . reset_index ( drop = True ) return filtered_campsites def _search_matching_campsites_available ( self , log : bool = False , verbose : bool = False , raise_error : bool = False ) -> List [ AvailableCampsite ]: \"\"\" Perform the Search and Return Matching Availabilities Parameters ---------- log: bool Whether to log found campsites verbose: bool Used with `log` to enhance the amount of info logged to the console raise_error: bool Whether to raise an error if nothing is found. Defaults to False. Returns ------- List[AvailableCampsite] \"\"\" matching_campgrounds = list () for camp in self . get_all_campsites (): if all ( [ self . _compare_date_overlap ( campsite = camp ) is True , camp . booking_nights >= self . nights , ] ): matching_campgrounds . append ( camp ) logger . info ( f \" { ( get_emoji ( matching_campgrounds ) + ' ' ) * 4 }{ len ( matching_campgrounds ) } \" \"Reservable Campsites Matching Search Preferences\" ) self . assemble_availabilities ( matching_data = matching_campgrounds , log = log , verbose = verbose ) if ( self . offline_search is True and self . loaded_campsites . issuperset ( matching_campgrounds ) and raise_error is True ): campsite_availability_message = ( \"No New Campsites were found, we'll continue checking\" ) logger . info ( campsite_availability_message ) raise CampsiteNotFoundError ( campsite_availability_message ) elif len ( matching_campgrounds ) == 0 and raise_error is True : campsite_availability_message = ( \"No Campsites were found, we'll continue checking\" ) logger . info ( campsite_availability_message ) raise CampsiteNotFoundError ( campsite_availability_message ) return matching_campgrounds @classmethod def _get_polling_minutes ( cls , polling_interval : Optional [ int ]) -> int : \"\"\" Return the Number of Minutes to Search Parameters ---------- polling_interval: Optional[int] Used with `continuous=True`, the amount of time to wait between searches. Defaults to 10 if not provided, cannot be less than 5 Returns ------- int \"\"\" if polling_interval is None : polling_interval = getenv ( \"POLLING_INTERVAL\" , SearchConfig . RECOMMENDED_POLLING_INTERVAL ) if int ( polling_interval ) < SearchConfig . POLLING_INTERVAL_MINIMUM : polling_interval = SearchConfig . POLLING_INTERVAL_MINIMUM polling_interval_minutes = int ( round ( float ( polling_interval ), 2 )) return polling_interval_minutes def _continuous_search_retry ( self , log : bool , verbose : bool , polling_interval : int , continuous_search_attempts : int , notification_provider : Union [ str , List [ str ], BaseNotifications , None ], notify_first_try : bool , ) -> List [ AvailableCampsite ]: \"\"\" Search for Campsites until at least one is found Parameters ---------- log: bool Whether to log found campsites verbose: bool Used with `log` to enhance the amount of info logged to the console polling_interval: Optional[int] Used with `continuous=True`, the amount of time to wait between searches. Defaults to 10 if not provided, cannot be less than 5 continuous_search_attempts: int Number of preexisting search attempts notification_provider: provider: Union[str, List[str]] Used with `continuous=True`, Name of notification provider to use. Accepts \"email\", \"pushover\", and defaults to \"silent\". Also accepts a list or commma separated string of these options or even a notification provider object itself notify_first_try: bool Used with `continuous=True`, whether to send all non-silent notifications if more than 5 matching campsites are found on the first try. Defaults to false which only sends the first 5. Returns ------- List[AvailableCampsite] \"\"\" polling_interval_minutes = self . _get_polling_minutes ( polling_interval = polling_interval ) notifier = MultiNotifierProvider ( provider = notification_provider ) logger . info ( f \"Searching for campsites every { polling_interval_minutes } minutes. \" ) notifier . log_providers () retryer = tenacity . Retrying ( retry = tenacity . retry_if_exception_type ( CampsiteNotFoundError ), wait = tenacity . wait . wait_fixed ( int ( polling_interval_minutes ) * 60 ), ) matching_campsites = retryer . __call__ ( self . _search_matching_campsites_available , False , False , True ) found_campsites = set ( matching_campsites ) new_campsites = found_campsites . difference ( self . campsites_found ) self . assemble_availabilities ( matching_data = list ( new_campsites ), log = log , verbose = verbose ) logger . info ( f \" { len ( new_campsites ) } New Campsites Found.\" ) self . campsites_found . update ( new_campsites ) logged_campsites = list ( new_campsites ) self . _handle_notifications ( retryer = retryer , notifier = notifier , logged_campsites = logged_campsites , continuous_search_attempts = continuous_search_attempts , notify_first_try = notify_first_try , ) return list ( self . campsites_found ) @classmethod def _handle_notifications ( cls , retryer : tenacity . Retrying , notifier : MultiNotifierProvider , logged_campsites : List [ AvailableCampsite ], continuous_search_attempts : int , notify_first_try : bool , ) -> None : \"\"\" Handle sending notifications Parameters ---------- retryer: tenacity.Retrying notifier: MultiNotifierProvider logged_campsites: List[AvailableCampsite] continuous_search_attempts: int notify_first_try: bool Returns ------- None \"\"\" attempt_number = retryer . statistics . get ( \"attempt_number\" , 1 ) minimum_first_notify = SearchConfig . MINIMUM_CAMPSITES_FIRST_NOTIFY if max ([ attempt_number , continuous_search_attempts ]) > 1 : logged_campsites = cls . _handle_too_many_campsites_found ( notifier = notifier , logged_campsites = logged_campsites ) notifier . send_campsites ( campsites = logged_campsites ) elif attempt_number == 1 and notify_first_try is True : logged_campsites = cls . _handle_too_many_campsites_found ( notifier = notifier , logged_campsites = logged_campsites ) notifier . send_campsites ( campsites = logged_campsites ) else : if ( len ( notifier . providers ) > 1 and len ( logged_campsites ) > minimum_first_notify ): error_message = ( f \"Found more than { minimum_first_notify } \" f \"matching campsites ( { len ( logged_campsites ) } ) on the \" \"first try. Try searching online instead. \" f \"camply is only sending the first \" f \" { minimum_first_notify } notifications. \" \"Go Get your campsite! \ud83c\udfd5\" ) logger . warning ( error_message ) notifier . send_message ( message = error_message ) logged_campsites = logged_campsites [: minimum_first_notify ] notifier . send_campsites ( campsites = logged_campsites ) @classmethod def _handle_too_many_campsites_found ( cls , notifier : MultiNotifierProvider , logged_campsites : List [ AvailableCampsite ] ) -> List [ AvailableCampsite ]: \"\"\" Handle Scenarios Where Too Many Campsites are Found Parameters ---------- notifier: MultiNotifierProvider logged_campsites: List[AvailableCampsite] Returns ------- List[AvailableCampsite] \"\"\" limit = SearchConfig . MAXIMUM_NOTIFICATION_BATCH_SIZE number_campsites = len ( logged_campsites ) if number_campsites > limit : warning_message = ( f \"Too many campsites were found during the search ( { number_campsites } \" f \"total). camply will only send you the first { limit } notifications.\" ) logger . warning ( warning_message ) restricted_campsites = logged_campsites [: limit ] notifier . send_message ( warning_message ) else : restricted_campsites = logged_campsites return restricted_campsites def _search_campsites_continuous ( self , log : bool = True , verbose : bool = False , polling_interval : Optional [ int ] = None , notification_provider : str = \"silent\" , notify_first_try : bool = False , search_forever : bool = False , ): \"\"\" Continuously Search For Campsites Parameters ---------- log: bool Whether to log found campsites verbose: bool Used with `log` to enhance the amount of info logged to the console polling_interval: Optional[int] Used with `continuous=True`, the amount of time to wait between searches. Defaults to 10 if not provided, cannot be less than 5 notification_provider: str Used with `continuous=True`, Name of notification provider to use. Accepts \"email\", \"pushover\", and defaults to \"silent\". Also accepts a list or commma separated string of these options or even a notification provider object itself notify_first_try: bool Used with `continuous=True`, whether to send all non-silent notifications if more than 5 matching campsites are found on the first try. Defaults to false which only sends the first 5. search_forever: bool Used with `continuous=True`, This option searches for new campsites forever, with the caveat being that it will never notify about the same campsite. Returns ------- List[AvailableCampsite] \"\"\" polling_interval_minutes = self . _get_polling_minutes ( polling_interval = polling_interval ) continuous_search = True continuous_search_attempts = 1 while continuous_search is True : starting_count = len ( self . campsites_found ) self . _continuous_search_retry ( log = log , verbose = verbose , polling_interval = polling_interval , notification_provider = notification_provider , notify_first_try = notify_first_try , continuous_search_attempts = continuous_search_attempts , ) ending_count = len ( self . campsites_found ) continuous_search_attempts += 1 if self . offline_search is True and ending_count > starting_count : self . unload_campsites_to_file () if search_forever is True : sleep ( int ( polling_interval_minutes ) * 60 ) else : continuous_search = False return list ( self . campsites_found ) def get_matching_campsites ( self , log : bool = True , verbose : bool = False , continuous : bool = False , polling_interval : Optional [ int ] = None , notification_provider : str = \"silent\" , notify_first_try : bool = False , search_forever : bool = False , ) -> List [ AvailableCampsite ]: \"\"\" Perform the Search and Return Matching Availabilities Parameters ---------- log: bool Whether to log found campsites verbose: bool Used with `log` to enhance the amount of info logged to the console continuous: bool Whether to continue searching beyond just the first time polling_interval: Optional[int] Used with `continuous=True`, the amount of time to wait between searches. Defaults to 10 if not provided, cannot be less than 5 notification_provider: str Used with `continuous=True`, Name of notification provider to use. Accepts \"email\", \"pushover\", and defaults to \"silent\". Also accepts a list or commma separated string of these options or even a notification provider object itself notify_first_try: bool Used with `continuous=True`, whether to send all non-silent notifications if more than 5 matching campsites are found on the first try. Defaults to false which only sends the first 5. search_forever: bool Used with `continuous=True`, This option searches for new campsites forever, with the caveat being that it will never notify about the same campsite. Returns ------- List[AvailableCampsite] \"\"\" if continuous is True : self . _search_campsites_continuous ( log = log , verbose = verbose , polling_interval = polling_interval , notification_provider = notification_provider , notify_first_try = notify_first_try , search_forever = search_forever , ) else : starting_count = len ( self . campsites_found ) matching_campsites = self . _search_matching_campsites_available ( log = log , verbose = True ) self . campsites_found . update ( set ( matching_campsites )) ending_count = len ( self . campsites_found ) if self . offline_search is True and ending_count > starting_count : self . unload_campsites_to_file () return list ( self . campsites_found ) def _get_search_days ( self ) -> List [ datetime ]: \"\"\" Retrieve Specific Days to Search For Returns ------- search_days: List[datetime] Datetime days to search for reservations \"\"\" current_date = datetime . now () . date () search_nights = set () for window in self . search_window : generated_dates = { date for date in window . get_date_range () if date >= current_date } search_nights . update ( generated_dates ) if self . weekends_only is True : logger . info ( \"Limiting Search of Campgrounds to Weekend Availabilities\" ) search_nights = { x for x in search_nights if x . weekday () in [ 4 , 5 ]} if len ( search_nights ) > 0 : logger . info ( f \" { len ( search_nights ) } booking nights selected for search, \" f \"ranging from { min ( search_nights ) } to { max ( search_nights ) } \" ) else : logger . info ( SearchConfig . ERROR_MESSAGE ) raise RuntimeError ( SearchConfig . ERROR_MESSAGE ) return list ( sorted ( search_nights )) def _get_search_months ( self ) -> List [ datetime ]: \"\"\" Get the Unique Months that need to be Searched Returns ------- search_months: List[datetime] Datetime Months to search for reservations \"\"\" truncated_months = set ([ day . replace ( day = 1 ) for day in self . search_days ]) if len ( truncated_months ) > 1 : logger . info ( f \" { len ( truncated_months ) } different months selected for search, \" f \"ranging from { min ( self . search_days ) } to { max ( self . search_days ) } \" ) return sorted ( list ( truncated_months )) elif len ( truncated_months ) == 0 : logger . info ( SearchConfig . ERROR_MESSAGE ) raise RuntimeError ( SearchConfig . ERROR_MESSAGE ) else : return sorted ( list ( truncated_months )) @classmethod def _consolidate_campsites ( cls , campsite_df : DataFrame , nights : int ) -> List [ AvailableCampsite ]: \"\"\" Consolidate Single Night Campsites into Multiple Night Campsites Parameters ---------- campsite_df: DataFrame DataFrame of AvailableCampsites Returns ------- List[AvailableCampsite] \"\"\" composed_groupings = list () for _ , campsite_slice in campsite_df . groupby ( [ CampsiteContainerFields . CAMPSITE_ID , CampsiteContainerFields . CAMPGROUND_ID ] ): # SORT THE VALUES AND CREATE A COPIED SLICE campsite_grouping = campsite_slice . sort_values ( by = CampsiteContainerFields . BOOKING_DATE , ascending = True ) . copy () # ASSEMBLE THE CAMPSITES AVAILABILITIES INTO GROUPS THAT ARE CONSECUTIVE booking_date = campsite_grouping [ CampsiteContainerFields . BOOKING_DATE ] date = Timedelta ( \"1d\" ) consecutive_nights = booking_date . diff () != date group_identifier = consecutive_nights . cumsum () campsite_grouping [ CampsiteContainerFields . CAMPSITE_GROUP ] = group_identifier # USE THE ASSEMBLED GROUPS TO CREATE UPDATED CAMPSITES AND REMOVE DUPLICATES for _campsite_group , campsite_group_slice in campsite_grouping . groupby ( [ CampsiteContainerFields . CAMPSITE_GROUP ] ): composed_grouping = campsite_group_slice . sort_values ( by = CampsiteContainerFields . BOOKING_DATE , ascending = True ) . copy () composed_grouping . drop ( columns = [ CampsiteContainerFields . CAMPSITE_GROUP ], inplace = True ) nightly_breakouts = cls . _find_consecutive_nights ( dataframe = composed_grouping , nights = nights ) composed_groupings . append ( nightly_breakouts ) if len ( composed_groupings ) == 0 : composed_groupings = [ DataFrame ()] return concat ( composed_groupings , ignore_index = True ) @classmethod def _consecutive_subseq ( cls , iterable : Iterable , length : int ) -> Generator : \"\"\" Find All Sub Sequences by length Given a List See https://tinyurl.com/5av5unjd Parameters ---------- iterable: Iterable length: int Returns ------- Generator \"\"\" for _ , consec_run in groupby ( enumerate ( iterable ), lambda x : x [ 0 ] - x [ 1 ]): k_wise = tee ( map ( itemgetter ( 1 ), consec_run ), length ) for n , it in enumerate ( k_wise ): next ( islice ( it , n , n ), None ) yield from zip ( * k_wise ) @classmethod def _find_consecutive_nights ( cls , dataframe : DataFrame , nights : int ) -> DataFrame : \"\"\" Explode a DataFrame of Consecutive Nightly Campsite Availabilities, Expand to all unique possibilities given the length of the stay. Parameters ---------- dataframe: DataFrame nights: int Returns ------- DataFrame \"\"\" duplicate_subset = set ( dataframe . columns ) - AvailableCampsite . __unhashable__ dataframe_slice = dataframe . copy () . reset_index ( drop = True ) nights_indexes = dataframe_slice . booking_date . index consecutive_generator = cls . _consecutive_subseq ( iterable = nights_indexes , length = nights ) sequences = list ( consecutive_generator ) concatted_data = list () for sequence in sequences : index_list = list ( sequence ) data_copy = dataframe_slice . iloc [ index_list ] . copy () data_copy . booking_date = data_copy . booking_date . min () data_copy . booking_end_date = data_copy . booking_end_date . max () data_copy . booking_url = data_copy . booking_url . loc [ index_list [ 0 ]] data_copy . booking_nights = ( data_copy . booking_end_date - data_copy . booking_date ) . dt . days data_copy . drop_duplicates ( inplace = True , subset = duplicate_subset ) concatted_data . append ( data_copy ) if len ( concatted_data ) == 0 : concatted_data = [ DataFrame ()] return concat ( concatted_data , ignore_index = True ) def _validate_consecutive_nights ( self , nights : int ) -> int : \"\"\" Validate the number of consecutive nights to search Parameters ---------- nights : int Number of nights to check Returns ------- int The proper number of nights to search \"\"\" search_days = Series ( self . search_days ) consecutive_nights = search_days . diff () != Timedelta ( \"1d\" ) largest_grouping = consecutive_nights . cumsum () . value_counts () . max () if nights > 1 : logger . info ( f \"Searching for availabilities with { nights } consecutive night stays.\" ) if nights > largest_grouping : logger . warning ( \"Too many consecutive nights selected. \" \"The consecutive night parameter will be set to \" f \"the max possible, { largest_grouping } .\" ) return largest_grouping else : return nights @staticmethod def campsites_to_df ( campsites : List [ AvailableCampsite ]) -> DataFrame : \"\"\" Convert Campsite Array to Parameters ---------- campsites: List[AvailableCampsite] Returns ------- DataFrame \"\"\" campsite_df = DataFrame ( data = [ campsite . dict () for campsite in campsites ], columns = AvailableCampsite . __fields__ , ) return campsite_df @staticmethod def df_to_campsites ( campsite_df : DataFrame ) -> List [ AvailableCampsite ]: \"\"\" Convert Campsite DataFrame to array of AvailableCampsite objects Parameters ---------- campsite_df: DataFrame Returns ------- List[AvailableCampsite] \"\"\" composed_campsite_array = list () composed_campsite_data_array = campsite_df . to_dict ( orient = \"records\" ) for campsite_record in composed_campsite_data_array : composed_campsite_array . append ( AvailableCampsite ( ** campsite_record )) return composed_campsite_array @classmethod def assemble_availabilities ( cls , matching_data : List [ AvailableCampsite ], log : bool = True , verbose : bool = False , ) -> DataFrame : \"\"\" Prepare a Pandas DataFrame from Array of AvailableCampsite objects Parameters ---------- matching_data: List[AvailableCampsite] List of campsites to assemble log: bool Whether to log found campsites verbose: bool Used with `log` to enhance the amount of info logged to the console Returns ------- availability_df: DataFrame \"\"\" availability_df = cls . campsites_to_df ( campsites = matching_data ) if log is True : cls . _log_availabilities ( availability_df = availability_df , verbose = verbose ) return availability_df @classmethod def _log_availabilities ( cls , availability_df : DataFrame , verbose : bool ) -> DataFrame : \"\"\" Log the Availabilities Parameters ---------- availability_df: DataFrame verbose: bool Returns ------- DataFrame \"\"\" booking_date : datetime for booking_date , available_sites in availability_df . groupby ( \"booking_date\" ): logger . info ( f \"\ud83d\udcc5 { booking_date . strftime ( ' %a , %B %d ' ) } \" f \"\ud83c\udfd5 { len ( available_sites ) } sites\" ) location_tuple : tuple for location_tuple , campground_availability in available_sites . groupby ( [ DataColumns . RECREATION_AREA_COLUMN , DataColumns . FACILITY_NAME_COLUMN ] ): logger . info ( f \" \\t \u26f0\ufe0f { ' \ud83c\udfd5 ' . join ( location_tuple ) } : \u26fa \" f \" { len ( campground_availability ) } sites\" ) if verbose is True : for ( booking_nights , nightly_availability , ) in campground_availability . groupby ( [ DataColumns . BOOKING_NIGHTS_COLUMN ] ): unique_urls = nightly_availability [ DataColumns . BOOKING_URL_COLUMN ] . unique () for booking_url in sorted ( unique_urls ): logger . info ( f \" \\t\\t \ud83d\udd17 { booking_url } \" f \"( { booking_nights } night\" f \" { 's' if booking_nights > 1 else '' } )\" ) return availability_df def unload_campsites_to_file ( self ) -> pathlib . Path : \"\"\" Unload a BaseSearch Object's campsites to a serialized Pickle file. Returns ------- pathlib.Path \"\"\" if self . offline_mode == \"pickle\" : pickle . dump ( obj = self . campsites_found , file = self . offline_search_path . open ( mode = \"wb\" ), protocol = 4 , fix_imports = True , ) elif self . offline_mode == \"json\" : json . dump ( obj = self . campsites_found , fp = self . offline_search_path . open ( mode = \"w\" ), sort_keys = True , default = pydantic_encoder , indent = 4 , ) logger . debug ( \" %s campsites saved to file: %s \" , len ( self . campsites_found ), self . offline_search_path , ) return self . offline_search_path def load_campsites_from_file ( self ) -> Set [ AvailableCampsite ]: \"\"\" Load a BaseSearch Object's campsites from a serialized Pickle file. Returns ------- Set[AvailableCampsite] \"\"\" if self . offline_search_path . exists (): if self . offline_mode == \"pickle\" : campsites : Set [ AvailableCampsite ] = pickle . load ( file = self . offline_search_path . open ( mode = \"rb\" ), fix_imports = True ) elif self . offline_mode == \"json\" : campsites_dicts : List [ Dict [ str , Any ]] = json . load ( self . offline_search_path . open ( mode = \"r\" ), ) campsites : Set [ AvailableCampsite ] = set ( [ AvailableCampsite ( ** json_dict ) for json_dict in campsites_dicts ] ) if len ( campsites ) > 0 : logger . info ( \" %s campsites loaded from file: %s \" , len ( campsites ), self . offline_search_path , ) else : campsites = set () return campsites @staticmethod def _set_offline_search_path ( file_path : Optional [ str ]) -> pathlib . Path : default_file_path = \"camply_campsites.json\" if file_path is None : file_path = default_file_path returned_path = pathlib . Path ( file_path ) . resolve () parent_dir = pathlib . Path . cwd () if all ( [ returned_path . exists (), returned_path . is_file (), set ( returned_path . suffixes ) . issubset ({ \".pkl\" , \".pickle\" , \".json\" }), ] ): path_obj = returned_path elif all ( [ returned_path . exists (), returned_path . is_dir (), ] ): path_obj = returned_path . joinpath ( default_file_path ) else : path_obj = parent_dir . joinpath ( file_path ) return path_obj","title":"BaseCampingSearch"},{"location":"reference/search/base_search/#camply.search.base_search.BaseCampingSearch.__init__","text":"Initialize with Search Parameters","title":"__init__()"},{"location":"reference/search/base_search/#camply.search.base_search.BaseCampingSearch.__init__--parameters","text":"Union[RecreationDotGov, YellowstoneLodging] API Provider Union[SearchWindow, List[SearchWindow]] Search Window tuple containing start date and End Date bool Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights) int minimum number of consecutive nights to search per campsite,defaults to 1 bool When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. Optional[str] When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to camply_campsites.json Source code in camply/search/base_search.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def __init__ ( self , provider : Union [ RecreationDotGov , YellowstoneLodging ], search_window : Union [ SearchWindow , List [ SearchWindow ]], weekends_only : bool = False , nights : int = 1 , offline_search : bool = False , offline_search_path : Optional [ str ] = None , ** kwargs , ) -> None : \"\"\" Initialize with Search Parameters Parameters ---------- provider: Union[RecreationDotGov, YellowstoneLodging] API Provider search_window: Union[SearchWindow, List[SearchWindow]] Search Window tuple containing start date and End Date weekends_only: bool Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights) nights: int minimum number of consecutive nights to search per campsite,defaults to 1 offline_search: bool When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. offline_search_path: Optional[str] When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to `camply_campsites.json` \"\"\" self . campsite_finder : Union [ RecreationDotGov , YellowstoneLodging ] = provider self . search_window : List [ SearchWindow ] = make_list ( search_window ) self . weekends_only : bool = weekends_only self . search_days : List [ datetime ] = self . _get_search_days () self . search_months : List [ datetime ] = self . _get_search_months () self . nights = self . _validate_consecutive_nights ( nights = nights ) self . offline_search = offline_search self . offline_search_path = self . _set_offline_search_path ( file_path = offline_search_path ) self . campsites_found : Set [ AvailableCampsite ] = set () self . loaded_campsites : Set [ AvailableCampsite ] = set () if self . offline_search_path . suffixes [ - 1 ] == \".json\" : self . offline_mode : str = \"json\" elif self . offline_search_path . suffixes [ - 1 ] in [ \".pkl\" , \".pickle\" ]: self . offline_mode : str = \"pickle\" else : raise CamplyError ( \"You must provide a `.json` or a `.pickle` / `.pkl` file name for offline searches\" ) if self . offline_search is True : logger . info ( \"Campsite search is configured to save offline: %s \" , self . offline_search_path , ) self . campsites_found : Set [ AvailableCampsite ] = self . load_campsites_from_file () self . loaded_campsites : Set [ AvailableCampsite ] = self . campsites_found . copy ()","title":"Parameters"},{"location":"reference/search/base_search/#camply.search.base_search.BaseCampingSearch.assemble_availabilities","text":"Prepare a Pandas DataFrame from Array of AvailableCampsite objects","title":"assemble_availabilities()"},{"location":"reference/search/base_search/#camply.search.base_search.BaseCampingSearch.assemble_availabilities--parameters","text":"List[AvailableCampsite] List of campsites to assemble bool Whether to log found campsites bool Used with log to enhance the amount of info logged to the console","title":"Parameters"},{"location":"reference/search/base_search/#camply.search.base_search.BaseCampingSearch.assemble_availabilities--returns","text":"availability_df: DataFrame Source code in camply/search/base_search.py 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 @classmethod def assemble_availabilities ( cls , matching_data : List [ AvailableCampsite ], log : bool = True , verbose : bool = False , ) -> DataFrame : \"\"\" Prepare a Pandas DataFrame from Array of AvailableCampsite objects Parameters ---------- matching_data: List[AvailableCampsite] List of campsites to assemble log: bool Whether to log found campsites verbose: bool Used with `log` to enhance the amount of info logged to the console Returns ------- availability_df: DataFrame \"\"\" availability_df = cls . campsites_to_df ( campsites = matching_data ) if log is True : cls . _log_availabilities ( availability_df = availability_df , verbose = verbose ) return availability_df","title":"Returns"},{"location":"reference/search/base_search/#camply.search.base_search.BaseCampingSearch.campsites_to_df","text":"Convert Campsite Array to","title":"campsites_to_df()"},{"location":"reference/search/base_search/#camply.search.base_search.BaseCampingSearch.campsites_to_df--parameters","text":"campsites: List[AvailableCampsite]","title":"Parameters"},{"location":"reference/search/base_search/#camply.search.base_search.BaseCampingSearch.campsites_to_df--returns","text":"DataFrame Source code in camply/search/base_search.py 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 @staticmethod def campsites_to_df ( campsites : List [ AvailableCampsite ]) -> DataFrame : \"\"\" Convert Campsite Array to Parameters ---------- campsites: List[AvailableCampsite] Returns ------- DataFrame \"\"\" campsite_df = DataFrame ( data = [ campsite . dict () for campsite in campsites ], columns = AvailableCampsite . __fields__ , ) return campsite_df","title":"Returns"},{"location":"reference/search/base_search/#camply.search.base_search.BaseCampingSearch.df_to_campsites","text":"Convert Campsite DataFrame to array of AvailableCampsite objects","title":"df_to_campsites()"},{"location":"reference/search/base_search/#camply.search.base_search.BaseCampingSearch.df_to_campsites--parameters","text":"campsite_df: DataFrame","title":"Parameters"},{"location":"reference/search/base_search/#camply.search.base_search.BaseCampingSearch.df_to_campsites--returns","text":"List[AvailableCampsite] Source code in camply/search/base_search.py 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 @staticmethod def df_to_campsites ( campsite_df : DataFrame ) -> List [ AvailableCampsite ]: \"\"\" Convert Campsite DataFrame to array of AvailableCampsite objects Parameters ---------- campsite_df: DataFrame Returns ------- List[AvailableCampsite] \"\"\" composed_campsite_array = list () composed_campsite_data_array = campsite_df . to_dict ( orient = \"records\" ) for campsite_record in composed_campsite_data_array : composed_campsite_array . append ( AvailableCampsite ( ** campsite_record )) return composed_campsite_array","title":"Returns"},{"location":"reference/search/base_search/#camply.search.base_search.BaseCampingSearch.get_all_campsites","text":"Perform the Search and Return Matching Availabilities. This method must be implemented on all sub-classes.","title":"get_all_campsites()"},{"location":"reference/search/base_search/#camply.search.base_search.BaseCampingSearch.get_all_campsites--returns","text":"List[AvailableCampsite] Source code in camply/search/base_search.py 117 118 119 120 121 122 123 124 125 126 127 128 @abstractmethod def get_all_campsites ( self ) -> List [ AvailableCampsite ]: \"\"\" Perform the Search and Return Matching Availabilities. This method must be implemented on all sub-classes. Returns ------- List[AvailableCampsite] \"\"\"","title":"Returns"},{"location":"reference/search/base_search/#camply.search.base_search.BaseCampingSearch.get_matching_campsites","text":"Perform the Search and Return Matching Availabilities","title":"get_matching_campsites()"},{"location":"reference/search/base_search/#camply.search.base_search.BaseCampingSearch.get_matching_campsites--parameters","text":"bool Whether to log found campsites bool Used with log to enhance the amount of info logged to the console bool Whether to continue searching beyond just the first time Optional[int] Used with continuous=True , the amount of time to wait between searches. Defaults to 10 if not provided, cannot be less than 5 str Used with continuous=True , Name of notification provider to use. Accepts \"email\", \"pushover\", and defaults to \"silent\". Also accepts a list or commma separated string of these options or even a notification provider object itself bool Used with continuous=True , whether to send all non-silent notifications if more than 5 matching campsites are found on the first try. Defaults to false which only sends the first 5. bool Used with continuous=True , This option searches for new campsites forever, with the caveat being that it will never notify about the same campsite.","title":"Parameters"},{"location":"reference/search/base_search/#camply.search.base_search.BaseCampingSearch.get_matching_campsites--returns","text":"List[AvailableCampsite] Source code in camply/search/base_search.py 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 def get_matching_campsites ( self , log : bool = True , verbose : bool = False , continuous : bool = False , polling_interval : Optional [ int ] = None , notification_provider : str = \"silent\" , notify_first_try : bool = False , search_forever : bool = False , ) -> List [ AvailableCampsite ]: \"\"\" Perform the Search and Return Matching Availabilities Parameters ---------- log: bool Whether to log found campsites verbose: bool Used with `log` to enhance the amount of info logged to the console continuous: bool Whether to continue searching beyond just the first time polling_interval: Optional[int] Used with `continuous=True`, the amount of time to wait between searches. Defaults to 10 if not provided, cannot be less than 5 notification_provider: str Used with `continuous=True`, Name of notification provider to use. Accepts \"email\", \"pushover\", and defaults to \"silent\". Also accepts a list or commma separated string of these options or even a notification provider object itself notify_first_try: bool Used with `continuous=True`, whether to send all non-silent notifications if more than 5 matching campsites are found on the first try. Defaults to false which only sends the first 5. search_forever: bool Used with `continuous=True`, This option searches for new campsites forever, with the caveat being that it will never notify about the same campsite. Returns ------- List[AvailableCampsite] \"\"\" if continuous is True : self . _search_campsites_continuous ( log = log , verbose = verbose , polling_interval = polling_interval , notification_provider = notification_provider , notify_first_try = notify_first_try , search_forever = search_forever , ) else : starting_count = len ( self . campsites_found ) matching_campsites = self . _search_matching_campsites_available ( log = log , verbose = True ) self . campsites_found . update ( set ( matching_campsites )) ending_count = len ( self . campsites_found ) if self . offline_search is True and ending_count > starting_count : self . unload_campsites_to_file () return list ( self . campsites_found )","title":"Returns"},{"location":"reference/search/base_search/#camply.search.base_search.BaseCampingSearch.load_campsites_from_file","text":"Load a BaseSearch Object's campsites from a serialized Pickle file.","title":"load_campsites_from_file()"},{"location":"reference/search/base_search/#camply.search.base_search.BaseCampingSearch.load_campsites_from_file--returns","text":"Set[AvailableCampsite] Source code in camply/search/base_search.py 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 def load_campsites_from_file ( self ) -> Set [ AvailableCampsite ]: \"\"\" Load a BaseSearch Object's campsites from a serialized Pickle file. Returns ------- Set[AvailableCampsite] \"\"\" if self . offline_search_path . exists (): if self . offline_mode == \"pickle\" : campsites : Set [ AvailableCampsite ] = pickle . load ( file = self . offline_search_path . open ( mode = \"rb\" ), fix_imports = True ) elif self . offline_mode == \"json\" : campsites_dicts : List [ Dict [ str , Any ]] = json . load ( self . offline_search_path . open ( mode = \"r\" ), ) campsites : Set [ AvailableCampsite ] = set ( [ AvailableCampsite ( ** json_dict ) for json_dict in campsites_dicts ] ) if len ( campsites ) > 0 : logger . info ( \" %s campsites loaded from file: %s \" , len ( campsites ), self . offline_search_path , ) else : campsites = set () return campsites","title":"Returns"},{"location":"reference/search/base_search/#camply.search.base_search.BaseCampingSearch.unload_campsites_to_file","text":"Unload a BaseSearch Object's campsites to a serialized Pickle file.","title":"unload_campsites_to_file()"},{"location":"reference/search/base_search/#camply.search.base_search.BaseCampingSearch.unload_campsites_to_file--returns","text":"pathlib.Path Source code in camply/search/base_search.py 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 def unload_campsites_to_file ( self ) -> pathlib . Path : \"\"\" Unload a BaseSearch Object's campsites to a serialized Pickle file. Returns ------- pathlib.Path \"\"\" if self . offline_mode == \"pickle\" : pickle . dump ( obj = self . campsites_found , file = self . offline_search_path . open ( mode = \"wb\" ), protocol = 4 , fix_imports = True , ) elif self . offline_mode == \"json\" : json . dump ( obj = self . campsites_found , fp = self . offline_search_path . open ( mode = \"w\" ), sort_keys = True , default = pydantic_encoder , indent = 4 , ) logger . debug ( \" %s campsites saved to file: %s \" , len ( self . campsites_found ), self . offline_search_path , ) return self . offline_search_path","title":"Returns"},{"location":"reference/search/base_search/#camply.search.base_search.CamplyError","text":"Bases: Exception Base Camply Error Source code in camply/search/base_search.py 32 33 34 35 class CamplyError ( Exception ): \"\"\" Base Camply Error \"\"\"","title":"CamplyError"},{"location":"reference/search/base_search/#camply.search.base_search.CampsiteNotFoundError","text":"Bases: SearchError Campsite not found Error Source code in camply/search/base_search.py 44 45 46 47 class CampsiteNotFoundError ( SearchError ): \"\"\" Campsite not found Error \"\"\"","title":"CampsiteNotFoundError"},{"location":"reference/search/base_search/#camply.search.base_search.SearchError","text":"Bases: CamplyError Generic Search Error Source code in camply/search/base_search.py 38 39 40 41 class SearchError ( CamplyError ): \"\"\" Generic Search Error \"\"\"","title":"SearchError"},{"location":"reference/search/search_recreationdotgov/","text":"Recreation.gov Web Searching Utilities SearchRecreationDotGov # Bases: BaseCampingSearch Camping Search Object Source code in camply/search/search_recreationdotgov.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 class SearchRecreationDotGov ( BaseCampingSearch ): \"\"\" Camping Search Object \"\"\" def __init__ ( self , search_window : Union [ SearchWindow , List [ SearchWindow ]], recreation_area : Optional [ Union [ List [ int ], int ]] = None , campgrounds : Optional [ Union [ List [ int ], int ]] = None , campsites : Optional [ Union [ List [ int ], int ]] = None , weekends_only : bool = False , nights : int = 1 , equipment : Optional [ List [ Tuple [ str , Optional [ int ]]]] = None , offline_search : bool = False , offline_search_path : Optional [ str ] = None , ** kwargs , ) -> None : \"\"\" Initialize with Search Parameters Parameters ---------- search_window: Union[SearchWindow, List[SearchWindow]] Search Window tuple containing start date and End Date recreation_area: Optional[Union[List[int], int]] ID of Recreation Area (i.e. 2907 - Rocky Mountain National Park) campgrounds: Optional[Union[List[int], int]] Campground ID or List of Campground IDs campsites: Optional[Union[List[int], int]] Campsite ID or List of Campsite IDs weekends_only: bool Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights) nights: int minimum number of consecutive nights to search per campsite,defaults to 1 equipment: Optional[List[Tuple[str, Optional[int]]]] List of Tuples of Equipment to Search for. An equipment tuple array looks like this: `[(\"Tent\", None), (\"RV\", 20)]` - meaning the selected search looks for sites to accommodate any tent size and RVs less than or equal to 20 feet. Tuples contain the Equipment name and an optional equipment length, otherwise provide None. Equipment names include `Tent`, `RV`, `Trailer`, `Vehicle` and are not case-sensitive. offline_search: bool When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. offline_search_path: Optional[str] When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to `camply_campsites.json` \"\"\" self . campsite_finder : RecreationDotGov super ( SearchRecreationDotGov , self ) . __init__ ( provider = RecreationDotGov (), search_window = search_window , weekends_only = weekends_only , nights = nights , offline_search = offline_search , offline_search_path = offline_search_path , ) self . _recreation_area_id = make_list ( recreation_area ) self . _campground_object = campgrounds self . weekends_only = weekends_only assert ( any ( [ campsites not in [[], None ], campgrounds not in [[], None ], recreation_area is not None , ] ) is True ) self . campsites = make_list ( campsites ) self . campgrounds = self . _get_searchable_campgrounds () self . campsite_metadata : Optional [ pd . DataFrame ] = None self . equipment : List [ Tuple [ str , Optional [ int ]]] = [] self . equipment = self . _get_searchable_equipment ( equipment = equipment ) def _get_searchable_campgrounds ( self ) -> List [ CampgroundFacility ]: \"\"\" Return a List of Campgrounds to search This handles scenarios where a recreation area is provided instead of a campground list Returns ------- searchable_campgrounds: List[int] List of searchable campground IDs \"\"\" if self . campsites not in [(), [], None ]: self . campsites = [ int ( campsite_id ) for campsite_id in self . campsites ] searchable_campgrounds = self . _get_campgrounds_by_campsite_id () elif self . _campground_object not in [(), [], None ]: searchable_campgrounds = self . _get_campgrounds_by_campground_id () elif self . _recreation_area_id not in [(), [], None ]: searchable_campgrounds = self . _get_campgrounds_by_recreation_area_id () else : raise RuntimeError ( \"You must provide a Campground or Recreation Area ID\" ) return list ( set ( searchable_campgrounds )) @classmethod def _get_searchable_equipment ( cls , equipment : Optional [ List [ Tuple [ str , Optional [ int ]]]] ) -> Optional [ List [ Tuple [ str , Optional [ int ]]]]: \"\"\" Sort through and validate Equipment Parameters ---------- equipment: Optional[List[Tuple[str, Optional[int]]]] Returns ------- Optional[List[Tuple[str, Optional[int]]]] \"\"\" equipment_names = [] final_equipment = None if isinstance ( equipment , ( list , tuple )): final_equipment = [] for equipment_name , equipment_length in equipment : if ( equipment_name . lower () not in EquipmentOptions . __all_accepted_equipment__ ): logger . warning ( f \"Equipment name not recognized: { equipment_name } . This won't \" \"be used for filtering.\" \"Acceptable options are: \" f \" { ', ' . join ( EquipmentOptions . __all_accepted_equipment__ ) } \" ) else : final_equipment . append (( equipment_name , equipment_length )) equipment_names . append ( equipment_name ) if len ( final_equipment ) > 0 : logger . info ( f \"Filtering Campsites based on Equipment: { ' | ' . join ( equipment_names ) } \" ) return final_equipment def _get_campgrounds_by_campground_id ( self ) -> List [ CampgroundFacility ]: \"\"\" Return a List of Campgrounds to search when provided with campground IDs Returns ------- returned_sites: List[int] List of searchable campground IDs \"\"\" campground_list = make_list ( self . _campground_object ) facilities = self . campsite_finder . find_campgrounds ( campground_id = campground_list ) return facilities def _get_campgrounds_by_campsite_id ( self ) -> List [ CampgroundFacility ]: \"\"\" Return a List of Campgrounds to search when provided with Campsite IDs Returns ------- returned_sites: List[int] List of searchable campground IDs \"\"\" campsite_list = make_list ( self . campsites ) facilities = self . campsite_finder . find_campgrounds ( campsite_id = campsite_list ) return facilities def _get_campgrounds_by_recreation_area_id ( self ) -> List [ CampgroundFacility ]: \"\"\" Return a List of Campgrounds to search when provided with Recreation Area IDs Returns ------- campgrounds: List[CampgroundFacility] \"\"\" campgrounds = list () for rec_area in self . _recreation_area_id : campground_array = self . campsite_finder . find_facilities_per_recreation_area ( rec_area_id = rec_area ) campgrounds += campground_array return campgrounds def get_all_campsites ( self ) -> List [ AvailableCampsite ]: \"\"\" Perform the Search and Return All Monthly Availabilities Returns ------- List[AvailableCampsite] \"\"\" found_campsites = list () if len ( self . campgrounds ) == 0 : error_message = \"No campgrounds found to search\" logger . error ( error_message ) raise SearchError ( error_message ) logger . info ( f \"Searching across { len ( self . campgrounds ) } campgrounds\" ) if self . campsite_metadata is None : self . campsite_metadata = ( self . campsite_finder . get_internal_campsite_metadata ( facility_ids = [ facil . facility_id for facil in self . campgrounds ] ) ) logger . info ( \"Metadata fetched for %s campsites\" , len ( self . campsite_metadata ) ) for index , campground in enumerate ( self . campgrounds ): for month in self . search_months : logger . info ( f \"Searching { campground . facility_name } , { campground . recreation_area } \" f \"( { campground . facility_id } ) for availability: \" f \" { month . strftime ( '%B, %Y' ) } \" ) availabilities = self . campsite_finder . get_recdotgov_data ( campground_id = campground . facility_id , month = month ) campsites = self . campsite_finder . process_campsite_availability ( availability = availabilities , recreation_area = campground . recreation_area , recreation_area_id = campground . recreation_area_id , facility_name = campground . facility_name , facility_id = campground . facility_id , month = month , campsite_metadata = self . campsite_metadata , ) if self . campsites not in [ None , []]: campsites = [ campsite_obj for campsite_obj in campsites if int ( campsite_obj . campsite_id ) in self . campsites ] found_campsites += campsites if index + 1 < len ( self . campgrounds ): sleep ( round ( uniform ( * RecreationBookingConfig . RATE_LIMITING ), 2 )) campsite_df = self . campsites_to_df ( campsites = found_campsites ) campsite_df_validated = self . _filter_date_overlap ( campsites = campsite_df ) compiled_campsite_df = self . _consolidate_campsites ( campsite_df = campsite_df_validated , nights = self . nights ) equipment_filtered_campsites = self . filter_campsites_to_equipment ( campsites = compiled_campsite_df ) compiled_campsites = self . df_to_campsites ( campsite_df = equipment_filtered_campsites ) return compiled_campsites def filter_campsites_to_equipment ( self , campsites : pd . DataFrame ) -> pd . DataFrame : \"\"\" Filter a Campsite DataFrame down to specified equipment Parameters ---------- campsites: pd.DataFrame Returns ------- pd.DataFrame \"\"\" if self . equipment is None or len ( self . equipment ) == 0 or len ( campsites ) == 0 : return campsites column_names = [ \"campsite_id\" , \"permitted_equipment\" ] exploded_data = campsites [ column_names ] . explode ( \"permitted_equipment\" ) expanded_data = exploded_data [ \"permitted_equipment\" ] . apply ( pd . Series ) joined_data = pd . DataFrame ( pd . concat ([ exploded_data , expanded_data ], axis = 1 ), columns = column_names + [ \"equipment_name\" , \"max_length\" ], ) joined_data [ \"equipment_name_normalized\" ] = ( joined_data [ \"equipment_name\" ] . fillna ( \"\" ) . apply ( lambda x : EquipmentConfig . EQUIPMENT_REVERSE_MAPPING [ x ]) ) equipment_types = [ item [ 0 ] . lower () for item in self . equipment ] matching_equipment = joined_data [ joined_data [ \"equipment_name_normalized\" ] . isin ( equipment_types ) ] matching_ids = [] for equipment_name , equipment_length in self . equipment : matching_data = matching_equipment [ matching_equipment [ \"equipment_name_normalized\" ] == equipment_name . lower () ] . copy () if equipment_length is not None : matching_data = matching_data [ matching_data [ \"max_length\" ] >= float ( equipment_length ) ] matching_ids += list ( matching_data [ \"campsite_id\" ] . unique ()) original_campsites = campsites [ campsites [ \"campsite_id\" ] . isin ( matching_ids ) ] . copy () return original_campsites __init__ ( search_window , recreation_area = None , campgrounds = None , campsites = None , weekends_only = False , nights = 1 , equipment = None , offline_search = False , offline_search_path = None , ** kwargs ) # Initialize with Search Parameters Parameters # Union[SearchWindow, List[SearchWindow]] Search Window tuple containing start date and End Date Optional[Union[List[int], int]] ID of Recreation Area (i.e. 2907 - Rocky Mountain National Park) Optional[Union[List[int], int]] Campground ID or List of Campground IDs Optional[Union[List[int], int]] Campsite ID or List of Campsite IDs bool Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights) int minimum number of consecutive nights to search per campsite,defaults to 1 Optional[List[Tuple[str, Optional[int]]]] List of Tuples of Equipment to Search for. An equipment tuple array looks like this: [(\"Tent\", None), (\"RV\", 20)] - meaning the selected search looks for sites to accommodate any tent size and RVs less than or equal to 20 feet. Tuples contain the Equipment name and an optional equipment length, otherwise provide None. Equipment names include Tent , RV , Trailer , Vehicle and are not case-sensitive. bool When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. Optional[str] When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to camply_campsites.json Source code in camply/search/search_recreationdotgov.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def __init__ ( self , search_window : Union [ SearchWindow , List [ SearchWindow ]], recreation_area : Optional [ Union [ List [ int ], int ]] = None , campgrounds : Optional [ Union [ List [ int ], int ]] = None , campsites : Optional [ Union [ List [ int ], int ]] = None , weekends_only : bool = False , nights : int = 1 , equipment : Optional [ List [ Tuple [ str , Optional [ int ]]]] = None , offline_search : bool = False , offline_search_path : Optional [ str ] = None , ** kwargs , ) -> None : \"\"\" Initialize with Search Parameters Parameters ---------- search_window: Union[SearchWindow, List[SearchWindow]] Search Window tuple containing start date and End Date recreation_area: Optional[Union[List[int], int]] ID of Recreation Area (i.e. 2907 - Rocky Mountain National Park) campgrounds: Optional[Union[List[int], int]] Campground ID or List of Campground IDs campsites: Optional[Union[List[int], int]] Campsite ID or List of Campsite IDs weekends_only: bool Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights) nights: int minimum number of consecutive nights to search per campsite,defaults to 1 equipment: Optional[List[Tuple[str, Optional[int]]]] List of Tuples of Equipment to Search for. An equipment tuple array looks like this: `[(\"Tent\", None), (\"RV\", 20)]` - meaning the selected search looks for sites to accommodate any tent size and RVs less than or equal to 20 feet. Tuples contain the Equipment name and an optional equipment length, otherwise provide None. Equipment names include `Tent`, `RV`, `Trailer`, `Vehicle` and are not case-sensitive. offline_search: bool When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. offline_search_path: Optional[str] When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to `camply_campsites.json` \"\"\" self . campsite_finder : RecreationDotGov super ( SearchRecreationDotGov , self ) . __init__ ( provider = RecreationDotGov (), search_window = search_window , weekends_only = weekends_only , nights = nights , offline_search = offline_search , offline_search_path = offline_search_path , ) self . _recreation_area_id = make_list ( recreation_area ) self . _campground_object = campgrounds self . weekends_only = weekends_only assert ( any ( [ campsites not in [[], None ], campgrounds not in [[], None ], recreation_area is not None , ] ) is True ) self . campsites = make_list ( campsites ) self . campgrounds = self . _get_searchable_campgrounds () self . campsite_metadata : Optional [ pd . DataFrame ] = None self . equipment : List [ Tuple [ str , Optional [ int ]]] = [] self . equipment = self . _get_searchable_equipment ( equipment = equipment ) filter_campsites_to_equipment ( campsites ) # Filter a Campsite DataFrame down to specified equipment Parameters # campsites: pd.DataFrame Returns # pd.DataFrame Source code in camply/search/search_recreationdotgov.py 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 def filter_campsites_to_equipment ( self , campsites : pd . DataFrame ) -> pd . DataFrame : \"\"\" Filter a Campsite DataFrame down to specified equipment Parameters ---------- campsites: pd.DataFrame Returns ------- pd.DataFrame \"\"\" if self . equipment is None or len ( self . equipment ) == 0 or len ( campsites ) == 0 : return campsites column_names = [ \"campsite_id\" , \"permitted_equipment\" ] exploded_data = campsites [ column_names ] . explode ( \"permitted_equipment\" ) expanded_data = exploded_data [ \"permitted_equipment\" ] . apply ( pd . Series ) joined_data = pd . DataFrame ( pd . concat ([ exploded_data , expanded_data ], axis = 1 ), columns = column_names + [ \"equipment_name\" , \"max_length\" ], ) joined_data [ \"equipment_name_normalized\" ] = ( joined_data [ \"equipment_name\" ] . fillna ( \"\" ) . apply ( lambda x : EquipmentConfig . EQUIPMENT_REVERSE_MAPPING [ x ]) ) equipment_types = [ item [ 0 ] . lower () for item in self . equipment ] matching_equipment = joined_data [ joined_data [ \"equipment_name_normalized\" ] . isin ( equipment_types ) ] matching_ids = [] for equipment_name , equipment_length in self . equipment : matching_data = matching_equipment [ matching_equipment [ \"equipment_name_normalized\" ] == equipment_name . lower () ] . copy () if equipment_length is not None : matching_data = matching_data [ matching_data [ \"max_length\" ] >= float ( equipment_length ) ] matching_ids += list ( matching_data [ \"campsite_id\" ] . unique ()) original_campsites = campsites [ campsites [ \"campsite_id\" ] . isin ( matching_ids ) ] . copy () return original_campsites get_all_campsites () # Perform the Search and Return All Monthly Availabilities Returns # List[AvailableCampsite] Source code in camply/search/search_recreationdotgov.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 def get_all_campsites ( self ) -> List [ AvailableCampsite ]: \"\"\" Perform the Search and Return All Monthly Availabilities Returns ------- List[AvailableCampsite] \"\"\" found_campsites = list () if len ( self . campgrounds ) == 0 : error_message = \"No campgrounds found to search\" logger . error ( error_message ) raise SearchError ( error_message ) logger . info ( f \"Searching across { len ( self . campgrounds ) } campgrounds\" ) if self . campsite_metadata is None : self . campsite_metadata = ( self . campsite_finder . get_internal_campsite_metadata ( facility_ids = [ facil . facility_id for facil in self . campgrounds ] ) ) logger . info ( \"Metadata fetched for %s campsites\" , len ( self . campsite_metadata ) ) for index , campground in enumerate ( self . campgrounds ): for month in self . search_months : logger . info ( f \"Searching { campground . facility_name } , { campground . recreation_area } \" f \"( { campground . facility_id } ) for availability: \" f \" { month . strftime ( '%B, %Y' ) } \" ) availabilities = self . campsite_finder . get_recdotgov_data ( campground_id = campground . facility_id , month = month ) campsites = self . campsite_finder . process_campsite_availability ( availability = availabilities , recreation_area = campground . recreation_area , recreation_area_id = campground . recreation_area_id , facility_name = campground . facility_name , facility_id = campground . facility_id , month = month , campsite_metadata = self . campsite_metadata , ) if self . campsites not in [ None , []]: campsites = [ campsite_obj for campsite_obj in campsites if int ( campsite_obj . campsite_id ) in self . campsites ] found_campsites += campsites if index + 1 < len ( self . campgrounds ): sleep ( round ( uniform ( * RecreationBookingConfig . RATE_LIMITING ), 2 )) campsite_df = self . campsites_to_df ( campsites = found_campsites ) campsite_df_validated = self . _filter_date_overlap ( campsites = campsite_df ) compiled_campsite_df = self . _consolidate_campsites ( campsite_df = campsite_df_validated , nights = self . nights ) equipment_filtered_campsites = self . filter_campsites_to_equipment ( campsites = compiled_campsite_df ) compiled_campsites = self . df_to_campsites ( campsite_df = equipment_filtered_campsites ) return compiled_campsites","title":"search_recreationdotgov"},{"location":"reference/search/search_recreationdotgov/#camply.search.search_recreationdotgov.SearchRecreationDotGov","text":"Bases: BaseCampingSearch Camping Search Object Source code in camply/search/search_recreationdotgov.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 class SearchRecreationDotGov ( BaseCampingSearch ): \"\"\" Camping Search Object \"\"\" def __init__ ( self , search_window : Union [ SearchWindow , List [ SearchWindow ]], recreation_area : Optional [ Union [ List [ int ], int ]] = None , campgrounds : Optional [ Union [ List [ int ], int ]] = None , campsites : Optional [ Union [ List [ int ], int ]] = None , weekends_only : bool = False , nights : int = 1 , equipment : Optional [ List [ Tuple [ str , Optional [ int ]]]] = None , offline_search : bool = False , offline_search_path : Optional [ str ] = None , ** kwargs , ) -> None : \"\"\" Initialize with Search Parameters Parameters ---------- search_window: Union[SearchWindow, List[SearchWindow]] Search Window tuple containing start date and End Date recreation_area: Optional[Union[List[int], int]] ID of Recreation Area (i.e. 2907 - Rocky Mountain National Park) campgrounds: Optional[Union[List[int], int]] Campground ID or List of Campground IDs campsites: Optional[Union[List[int], int]] Campsite ID or List of Campsite IDs weekends_only: bool Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights) nights: int minimum number of consecutive nights to search per campsite,defaults to 1 equipment: Optional[List[Tuple[str, Optional[int]]]] List of Tuples of Equipment to Search for. An equipment tuple array looks like this: `[(\"Tent\", None), (\"RV\", 20)]` - meaning the selected search looks for sites to accommodate any tent size and RVs less than or equal to 20 feet. Tuples contain the Equipment name and an optional equipment length, otherwise provide None. Equipment names include `Tent`, `RV`, `Trailer`, `Vehicle` and are not case-sensitive. offline_search: bool When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. offline_search_path: Optional[str] When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to `camply_campsites.json` \"\"\" self . campsite_finder : RecreationDotGov super ( SearchRecreationDotGov , self ) . __init__ ( provider = RecreationDotGov (), search_window = search_window , weekends_only = weekends_only , nights = nights , offline_search = offline_search , offline_search_path = offline_search_path , ) self . _recreation_area_id = make_list ( recreation_area ) self . _campground_object = campgrounds self . weekends_only = weekends_only assert ( any ( [ campsites not in [[], None ], campgrounds not in [[], None ], recreation_area is not None , ] ) is True ) self . campsites = make_list ( campsites ) self . campgrounds = self . _get_searchable_campgrounds () self . campsite_metadata : Optional [ pd . DataFrame ] = None self . equipment : List [ Tuple [ str , Optional [ int ]]] = [] self . equipment = self . _get_searchable_equipment ( equipment = equipment ) def _get_searchable_campgrounds ( self ) -> List [ CampgroundFacility ]: \"\"\" Return a List of Campgrounds to search This handles scenarios where a recreation area is provided instead of a campground list Returns ------- searchable_campgrounds: List[int] List of searchable campground IDs \"\"\" if self . campsites not in [(), [], None ]: self . campsites = [ int ( campsite_id ) for campsite_id in self . campsites ] searchable_campgrounds = self . _get_campgrounds_by_campsite_id () elif self . _campground_object not in [(), [], None ]: searchable_campgrounds = self . _get_campgrounds_by_campground_id () elif self . _recreation_area_id not in [(), [], None ]: searchable_campgrounds = self . _get_campgrounds_by_recreation_area_id () else : raise RuntimeError ( \"You must provide a Campground or Recreation Area ID\" ) return list ( set ( searchable_campgrounds )) @classmethod def _get_searchable_equipment ( cls , equipment : Optional [ List [ Tuple [ str , Optional [ int ]]]] ) -> Optional [ List [ Tuple [ str , Optional [ int ]]]]: \"\"\" Sort through and validate Equipment Parameters ---------- equipment: Optional[List[Tuple[str, Optional[int]]]] Returns ------- Optional[List[Tuple[str, Optional[int]]]] \"\"\" equipment_names = [] final_equipment = None if isinstance ( equipment , ( list , tuple )): final_equipment = [] for equipment_name , equipment_length in equipment : if ( equipment_name . lower () not in EquipmentOptions . __all_accepted_equipment__ ): logger . warning ( f \"Equipment name not recognized: { equipment_name } . This won't \" \"be used for filtering.\" \"Acceptable options are: \" f \" { ', ' . join ( EquipmentOptions . __all_accepted_equipment__ ) } \" ) else : final_equipment . append (( equipment_name , equipment_length )) equipment_names . append ( equipment_name ) if len ( final_equipment ) > 0 : logger . info ( f \"Filtering Campsites based on Equipment: { ' | ' . join ( equipment_names ) } \" ) return final_equipment def _get_campgrounds_by_campground_id ( self ) -> List [ CampgroundFacility ]: \"\"\" Return a List of Campgrounds to search when provided with campground IDs Returns ------- returned_sites: List[int] List of searchable campground IDs \"\"\" campground_list = make_list ( self . _campground_object ) facilities = self . campsite_finder . find_campgrounds ( campground_id = campground_list ) return facilities def _get_campgrounds_by_campsite_id ( self ) -> List [ CampgroundFacility ]: \"\"\" Return a List of Campgrounds to search when provided with Campsite IDs Returns ------- returned_sites: List[int] List of searchable campground IDs \"\"\" campsite_list = make_list ( self . campsites ) facilities = self . campsite_finder . find_campgrounds ( campsite_id = campsite_list ) return facilities def _get_campgrounds_by_recreation_area_id ( self ) -> List [ CampgroundFacility ]: \"\"\" Return a List of Campgrounds to search when provided with Recreation Area IDs Returns ------- campgrounds: List[CampgroundFacility] \"\"\" campgrounds = list () for rec_area in self . _recreation_area_id : campground_array = self . campsite_finder . find_facilities_per_recreation_area ( rec_area_id = rec_area ) campgrounds += campground_array return campgrounds def get_all_campsites ( self ) -> List [ AvailableCampsite ]: \"\"\" Perform the Search and Return All Monthly Availabilities Returns ------- List[AvailableCampsite] \"\"\" found_campsites = list () if len ( self . campgrounds ) == 0 : error_message = \"No campgrounds found to search\" logger . error ( error_message ) raise SearchError ( error_message ) logger . info ( f \"Searching across { len ( self . campgrounds ) } campgrounds\" ) if self . campsite_metadata is None : self . campsite_metadata = ( self . campsite_finder . get_internal_campsite_metadata ( facility_ids = [ facil . facility_id for facil in self . campgrounds ] ) ) logger . info ( \"Metadata fetched for %s campsites\" , len ( self . campsite_metadata ) ) for index , campground in enumerate ( self . campgrounds ): for month in self . search_months : logger . info ( f \"Searching { campground . facility_name } , { campground . recreation_area } \" f \"( { campground . facility_id } ) for availability: \" f \" { month . strftime ( '%B, %Y' ) } \" ) availabilities = self . campsite_finder . get_recdotgov_data ( campground_id = campground . facility_id , month = month ) campsites = self . campsite_finder . process_campsite_availability ( availability = availabilities , recreation_area = campground . recreation_area , recreation_area_id = campground . recreation_area_id , facility_name = campground . facility_name , facility_id = campground . facility_id , month = month , campsite_metadata = self . campsite_metadata , ) if self . campsites not in [ None , []]: campsites = [ campsite_obj for campsite_obj in campsites if int ( campsite_obj . campsite_id ) in self . campsites ] found_campsites += campsites if index + 1 < len ( self . campgrounds ): sleep ( round ( uniform ( * RecreationBookingConfig . RATE_LIMITING ), 2 )) campsite_df = self . campsites_to_df ( campsites = found_campsites ) campsite_df_validated = self . _filter_date_overlap ( campsites = campsite_df ) compiled_campsite_df = self . _consolidate_campsites ( campsite_df = campsite_df_validated , nights = self . nights ) equipment_filtered_campsites = self . filter_campsites_to_equipment ( campsites = compiled_campsite_df ) compiled_campsites = self . df_to_campsites ( campsite_df = equipment_filtered_campsites ) return compiled_campsites def filter_campsites_to_equipment ( self , campsites : pd . DataFrame ) -> pd . DataFrame : \"\"\" Filter a Campsite DataFrame down to specified equipment Parameters ---------- campsites: pd.DataFrame Returns ------- pd.DataFrame \"\"\" if self . equipment is None or len ( self . equipment ) == 0 or len ( campsites ) == 0 : return campsites column_names = [ \"campsite_id\" , \"permitted_equipment\" ] exploded_data = campsites [ column_names ] . explode ( \"permitted_equipment\" ) expanded_data = exploded_data [ \"permitted_equipment\" ] . apply ( pd . Series ) joined_data = pd . DataFrame ( pd . concat ([ exploded_data , expanded_data ], axis = 1 ), columns = column_names + [ \"equipment_name\" , \"max_length\" ], ) joined_data [ \"equipment_name_normalized\" ] = ( joined_data [ \"equipment_name\" ] . fillna ( \"\" ) . apply ( lambda x : EquipmentConfig . EQUIPMENT_REVERSE_MAPPING [ x ]) ) equipment_types = [ item [ 0 ] . lower () for item in self . equipment ] matching_equipment = joined_data [ joined_data [ \"equipment_name_normalized\" ] . isin ( equipment_types ) ] matching_ids = [] for equipment_name , equipment_length in self . equipment : matching_data = matching_equipment [ matching_equipment [ \"equipment_name_normalized\" ] == equipment_name . lower () ] . copy () if equipment_length is not None : matching_data = matching_data [ matching_data [ \"max_length\" ] >= float ( equipment_length ) ] matching_ids += list ( matching_data [ \"campsite_id\" ] . unique ()) original_campsites = campsites [ campsites [ \"campsite_id\" ] . isin ( matching_ids ) ] . copy () return original_campsites","title":"SearchRecreationDotGov"},{"location":"reference/search/search_recreationdotgov/#camply.search.search_recreationdotgov.SearchRecreationDotGov.__init__","text":"Initialize with Search Parameters","title":"__init__()"},{"location":"reference/search/search_recreationdotgov/#camply.search.search_recreationdotgov.SearchRecreationDotGov.__init__--parameters","text":"Union[SearchWindow, List[SearchWindow]] Search Window tuple containing start date and End Date Optional[Union[List[int], int]] ID of Recreation Area (i.e. 2907 - Rocky Mountain National Park) Optional[Union[List[int], int]] Campground ID or List of Campground IDs Optional[Union[List[int], int]] Campsite ID or List of Campsite IDs bool Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights) int minimum number of consecutive nights to search per campsite,defaults to 1 Optional[List[Tuple[str, Optional[int]]]] List of Tuples of Equipment to Search for. An equipment tuple array looks like this: [(\"Tent\", None), (\"RV\", 20)] - meaning the selected search looks for sites to accommodate any tent size and RVs less than or equal to 20 feet. Tuples contain the Equipment name and an optional equipment length, otherwise provide None. Equipment names include Tent , RV , Trailer , Vehicle and are not case-sensitive. bool When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. Optional[str] When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to camply_campsites.json Source code in camply/search/search_recreationdotgov.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def __init__ ( self , search_window : Union [ SearchWindow , List [ SearchWindow ]], recreation_area : Optional [ Union [ List [ int ], int ]] = None , campgrounds : Optional [ Union [ List [ int ], int ]] = None , campsites : Optional [ Union [ List [ int ], int ]] = None , weekends_only : bool = False , nights : int = 1 , equipment : Optional [ List [ Tuple [ str , Optional [ int ]]]] = None , offline_search : bool = False , offline_search_path : Optional [ str ] = None , ** kwargs , ) -> None : \"\"\" Initialize with Search Parameters Parameters ---------- search_window: Union[SearchWindow, List[SearchWindow]] Search Window tuple containing start date and End Date recreation_area: Optional[Union[List[int], int]] ID of Recreation Area (i.e. 2907 - Rocky Mountain National Park) campgrounds: Optional[Union[List[int], int]] Campground ID or List of Campground IDs campsites: Optional[Union[List[int], int]] Campsite ID or List of Campsite IDs weekends_only: bool Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights) nights: int minimum number of consecutive nights to search per campsite,defaults to 1 equipment: Optional[List[Tuple[str, Optional[int]]]] List of Tuples of Equipment to Search for. An equipment tuple array looks like this: `[(\"Tent\", None), (\"RV\", 20)]` - meaning the selected search looks for sites to accommodate any tent size and RVs less than or equal to 20 feet. Tuples contain the Equipment name and an optional equipment length, otherwise provide None. Equipment names include `Tent`, `RV`, `Trailer`, `Vehicle` and are not case-sensitive. offline_search: bool When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. offline_search_path: Optional[str] When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to `camply_campsites.json` \"\"\" self . campsite_finder : RecreationDotGov super ( SearchRecreationDotGov , self ) . __init__ ( provider = RecreationDotGov (), search_window = search_window , weekends_only = weekends_only , nights = nights , offline_search = offline_search , offline_search_path = offline_search_path , ) self . _recreation_area_id = make_list ( recreation_area ) self . _campground_object = campgrounds self . weekends_only = weekends_only assert ( any ( [ campsites not in [[], None ], campgrounds not in [[], None ], recreation_area is not None , ] ) is True ) self . campsites = make_list ( campsites ) self . campgrounds = self . _get_searchable_campgrounds () self . campsite_metadata : Optional [ pd . DataFrame ] = None self . equipment : List [ Tuple [ str , Optional [ int ]]] = [] self . equipment = self . _get_searchable_equipment ( equipment = equipment )","title":"Parameters"},{"location":"reference/search/search_recreationdotgov/#camply.search.search_recreationdotgov.SearchRecreationDotGov.filter_campsites_to_equipment","text":"Filter a Campsite DataFrame down to specified equipment","title":"filter_campsites_to_equipment()"},{"location":"reference/search/search_recreationdotgov/#camply.search.search_recreationdotgov.SearchRecreationDotGov.filter_campsites_to_equipment--parameters","text":"campsites: pd.DataFrame","title":"Parameters"},{"location":"reference/search/search_recreationdotgov/#camply.search.search_recreationdotgov.SearchRecreationDotGov.filter_campsites_to_equipment--returns","text":"pd.DataFrame Source code in camply/search/search_recreationdotgov.py 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 def filter_campsites_to_equipment ( self , campsites : pd . DataFrame ) -> pd . DataFrame : \"\"\" Filter a Campsite DataFrame down to specified equipment Parameters ---------- campsites: pd.DataFrame Returns ------- pd.DataFrame \"\"\" if self . equipment is None or len ( self . equipment ) == 0 or len ( campsites ) == 0 : return campsites column_names = [ \"campsite_id\" , \"permitted_equipment\" ] exploded_data = campsites [ column_names ] . explode ( \"permitted_equipment\" ) expanded_data = exploded_data [ \"permitted_equipment\" ] . apply ( pd . Series ) joined_data = pd . DataFrame ( pd . concat ([ exploded_data , expanded_data ], axis = 1 ), columns = column_names + [ \"equipment_name\" , \"max_length\" ], ) joined_data [ \"equipment_name_normalized\" ] = ( joined_data [ \"equipment_name\" ] . fillna ( \"\" ) . apply ( lambda x : EquipmentConfig . EQUIPMENT_REVERSE_MAPPING [ x ]) ) equipment_types = [ item [ 0 ] . lower () for item in self . equipment ] matching_equipment = joined_data [ joined_data [ \"equipment_name_normalized\" ] . isin ( equipment_types ) ] matching_ids = [] for equipment_name , equipment_length in self . equipment : matching_data = matching_equipment [ matching_equipment [ \"equipment_name_normalized\" ] == equipment_name . lower () ] . copy () if equipment_length is not None : matching_data = matching_data [ matching_data [ \"max_length\" ] >= float ( equipment_length ) ] matching_ids += list ( matching_data [ \"campsite_id\" ] . unique ()) original_campsites = campsites [ campsites [ \"campsite_id\" ] . isin ( matching_ids ) ] . copy () return original_campsites","title":"Returns"},{"location":"reference/search/search_recreationdotgov/#camply.search.search_recreationdotgov.SearchRecreationDotGov.get_all_campsites","text":"Perform the Search and Return All Monthly Availabilities","title":"get_all_campsites()"},{"location":"reference/search/search_recreationdotgov/#camply.search.search_recreationdotgov.SearchRecreationDotGov.get_all_campsites--returns","text":"List[AvailableCampsite] Source code in camply/search/search_recreationdotgov.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 def get_all_campsites ( self ) -> List [ AvailableCampsite ]: \"\"\" Perform the Search and Return All Monthly Availabilities Returns ------- List[AvailableCampsite] \"\"\" found_campsites = list () if len ( self . campgrounds ) == 0 : error_message = \"No campgrounds found to search\" logger . error ( error_message ) raise SearchError ( error_message ) logger . info ( f \"Searching across { len ( self . campgrounds ) } campgrounds\" ) if self . campsite_metadata is None : self . campsite_metadata = ( self . campsite_finder . get_internal_campsite_metadata ( facility_ids = [ facil . facility_id for facil in self . campgrounds ] ) ) logger . info ( \"Metadata fetched for %s campsites\" , len ( self . campsite_metadata ) ) for index , campground in enumerate ( self . campgrounds ): for month in self . search_months : logger . info ( f \"Searching { campground . facility_name } , { campground . recreation_area } \" f \"( { campground . facility_id } ) for availability: \" f \" { month . strftime ( '%B, %Y' ) } \" ) availabilities = self . campsite_finder . get_recdotgov_data ( campground_id = campground . facility_id , month = month ) campsites = self . campsite_finder . process_campsite_availability ( availability = availabilities , recreation_area = campground . recreation_area , recreation_area_id = campground . recreation_area_id , facility_name = campground . facility_name , facility_id = campground . facility_id , month = month , campsite_metadata = self . campsite_metadata , ) if self . campsites not in [ None , []]: campsites = [ campsite_obj for campsite_obj in campsites if int ( campsite_obj . campsite_id ) in self . campsites ] found_campsites += campsites if index + 1 < len ( self . campgrounds ): sleep ( round ( uniform ( * RecreationBookingConfig . RATE_LIMITING ), 2 )) campsite_df = self . campsites_to_df ( campsites = found_campsites ) campsite_df_validated = self . _filter_date_overlap ( campsites = campsite_df ) compiled_campsite_df = self . _consolidate_campsites ( campsite_df = campsite_df_validated , nights = self . nights ) equipment_filtered_campsites = self . filter_campsites_to_equipment ( campsites = compiled_campsite_df ) compiled_campsites = self . df_to_campsites ( campsite_df = equipment_filtered_campsites ) return compiled_campsites","title":"Returns"},{"location":"reference/search/search_yellowstone/","text":"Yellowstone Lodging Web Searching Utilities SearchYellowstone # Bases: BaseCampingSearch Camping Search Object Source code in camply/search/search_yellowstone.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 class SearchYellowstone ( BaseCampingSearch ): \"\"\" Camping Search Object \"\"\" # noinspection PyUnusedLocal def __init__ ( self , search_window : Union [ SearchWindow , List [ SearchWindow ]], weekends_only : bool = False , campgrounds : Optional [ Union [ List [ str ], str ]] = None , nights : int = 1 , offline_search : bool = False , offline_search_path : Optional [ str ] = None , ** kwargs , ) -> None : \"\"\" Initialize with Search Parameters Parameters ---------- search_window: Union[SearchWindow, List[SearchWindow]] Search Window tuple containing start date and End Date weekends_only: bool Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights) campgrounds: Optional[Union[List[str], str]] Campground ID or List of Campground IDs nights: int minimum number of consecutive nights to search per campsite,defaults to 1 offline_search: bool When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. offline_search_path: Optional[str] When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to `camply_campsites.json` \"\"\" super () . __init__ ( provider = YellowstoneLodging (), search_window = search_window , weekends_only = weekends_only , nights = nights , offline_search = offline_search , offline_search_path = offline_search_path , ) self . campgrounds = make_list ( campgrounds ) def get_all_campsites ( self ) -> List [ AvailableCampsite ]: \"\"\" Search for all matching campsites in Yellowstone. Returns ------- List[AvailableCampsite] \"\"\" all_campsites = list () searchable_campgrounds = self . _get_searchable_campgrounds () this_month = datetime . now () . date () . replace ( day = 1 ) for month in self . search_months : if month >= this_month : all_campsites += self . campsite_finder . get_monthly_campsites ( month = month , nights = None if self . nights == 1 else self . nights ) matching_campsites = self . _filter_campsites_to_campgrounds ( campsites = all_campsites , searchable_campgrounds = searchable_campgrounds ) campsite_df = self . campsites_to_df ( campsites = matching_campsites ) campsite_df_validated = self . _filter_date_overlap ( campsites = campsite_df ) time_window_end = max ( self . search_days ) + timedelta ( days = 1 ) compiled_campsite_df = campsite_df_validated [ campsite_df_validated . booking_end_date <= pd . Timestamp ( time_window_end ) ] compiled_campsites = self . df_to_campsites ( campsite_df = compiled_campsite_df ) return compiled_campsites def _get_searchable_campgrounds ( self ) -> Optional [ Set [ str ]]: \"\"\" Return the Campgrounds for the Camping Search Returns ------- Optional[Set[str]] \"\"\" if self . campgrounds in [ None , []]: return None supported_campsites = set ( YellowstoneConfig . YELLOWSTONE_CAMPGROUNDS . keys ()) selected_campsites = set ( self . campgrounds ) searchable_campgrounds = supported_campsites . intersection ( selected_campsites ) if len ( searchable_campgrounds ) == 0 : campground_ids = [ f \"` { key } ` ( { value } )\" for key , value in YellowstoneConfig . YELLOWSTONE_CAMPGROUNDS . items () ] error_message = ( \"You must supply a YellowstoneNationalParkLodges supported \" \"campground ID. Current supported Campground IDs: \" f \" { ', ' . join ( campground_ids ) } \" ) logger . error ( error_message ) raise SearchError ( error_message ) logger . info ( f \" { len ( searchable_campgrounds ) } Matching Campgrounds Found\" ) for campground in searchable_campgrounds : logger . info ( f \"\u26f0 { YellowstoneConfig . YELLOWSTONE_RECREATION_AREA_FORMAL_NAME } \" f \"(# { YellowstoneConfig . YELLOWSTONE_RECREATION_AREA_ID } ) - \ud83c\udfd5 \" f \" { YellowstoneConfig . YELLOWSTONE_CAMPGROUNDS [ campground ] } ( { campground } )\" ) return searchable_campgrounds def _filter_campsites_to_campgrounds ( self , campsites : List [ AvailableCampsite ], searchable_campgrounds : Set [ str ] ) -> List [ AvailableCampsite ]: \"\"\" Filter Campsites Down to Matching Campgrounds Parameters ---------- campsites: List[AvailableCampsite] searchable_campgrounds: Set[str] Returns ------- List[AvailableCampsite] \"\"\" if self . campgrounds in [ None , []]: return campsites matching_campsites = [ campsite for campsite in campsites if campsite . facility_id in searchable_campgrounds ] return matching_campsites @staticmethod def print_campgrounds () -> None : \"\"\" Print the Campgrounds inside of Yellowstone \"\"\" log_sorted_response ( YellowstoneConfig . YELLOWSTONE_CAMPGROUND_OBJECTS ) __init__ ( search_window , weekends_only = False , campgrounds = None , nights = 1 , offline_search = False , offline_search_path = None , ** kwargs ) # Initialize with Search Parameters Parameters # Union[SearchWindow, List[SearchWindow]] Search Window tuple containing start date and End Date bool Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights) Optional[Union[List[str], str]] Campground ID or List of Campground IDs int minimum number of consecutive nights to search per campsite,defaults to 1 bool When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. Optional[str] When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to camply_campsites.json Source code in camply/search/search_yellowstone.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def __init__ ( self , search_window : Union [ SearchWindow , List [ SearchWindow ]], weekends_only : bool = False , campgrounds : Optional [ Union [ List [ str ], str ]] = None , nights : int = 1 , offline_search : bool = False , offline_search_path : Optional [ str ] = None , ** kwargs , ) -> None : \"\"\" Initialize with Search Parameters Parameters ---------- search_window: Union[SearchWindow, List[SearchWindow]] Search Window tuple containing start date and End Date weekends_only: bool Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights) campgrounds: Optional[Union[List[str], str]] Campground ID or List of Campground IDs nights: int minimum number of consecutive nights to search per campsite,defaults to 1 offline_search: bool When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. offline_search_path: Optional[str] When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to `camply_campsites.json` \"\"\" super () . __init__ ( provider = YellowstoneLodging (), search_window = search_window , weekends_only = weekends_only , nights = nights , offline_search = offline_search , offline_search_path = offline_search_path , ) self . campgrounds = make_list ( campgrounds ) get_all_campsites () # Search for all matching campsites in Yellowstone. Returns # List[AvailableCampsite] Source code in camply/search/search_yellowstone.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def get_all_campsites ( self ) -> List [ AvailableCampsite ]: \"\"\" Search for all matching campsites in Yellowstone. Returns ------- List[AvailableCampsite] \"\"\" all_campsites = list () searchable_campgrounds = self . _get_searchable_campgrounds () this_month = datetime . now () . date () . replace ( day = 1 ) for month in self . search_months : if month >= this_month : all_campsites += self . campsite_finder . get_monthly_campsites ( month = month , nights = None if self . nights == 1 else self . nights ) matching_campsites = self . _filter_campsites_to_campgrounds ( campsites = all_campsites , searchable_campgrounds = searchable_campgrounds ) campsite_df = self . campsites_to_df ( campsites = matching_campsites ) campsite_df_validated = self . _filter_date_overlap ( campsites = campsite_df ) time_window_end = max ( self . search_days ) + timedelta ( days = 1 ) compiled_campsite_df = campsite_df_validated [ campsite_df_validated . booking_end_date <= pd . Timestamp ( time_window_end ) ] compiled_campsites = self . df_to_campsites ( campsite_df = compiled_campsite_df ) return compiled_campsites print_campgrounds () staticmethod # Print the Campgrounds inside of Yellowstone Source code in camply/search/search_yellowstone.py 155 156 157 158 159 160 @staticmethod def print_campgrounds () -> None : \"\"\" Print the Campgrounds inside of Yellowstone \"\"\" log_sorted_response ( YellowstoneConfig . YELLOWSTONE_CAMPGROUND_OBJECTS )","title":"search_yellowstone"},{"location":"reference/search/search_yellowstone/#camply.search.search_yellowstone.SearchYellowstone","text":"Bases: BaseCampingSearch Camping Search Object Source code in camply/search/search_yellowstone.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 class SearchYellowstone ( BaseCampingSearch ): \"\"\" Camping Search Object \"\"\" # noinspection PyUnusedLocal def __init__ ( self , search_window : Union [ SearchWindow , List [ SearchWindow ]], weekends_only : bool = False , campgrounds : Optional [ Union [ List [ str ], str ]] = None , nights : int = 1 , offline_search : bool = False , offline_search_path : Optional [ str ] = None , ** kwargs , ) -> None : \"\"\" Initialize with Search Parameters Parameters ---------- search_window: Union[SearchWindow, List[SearchWindow]] Search Window tuple containing start date and End Date weekends_only: bool Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights) campgrounds: Optional[Union[List[str], str]] Campground ID or List of Campground IDs nights: int minimum number of consecutive nights to search per campsite,defaults to 1 offline_search: bool When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. offline_search_path: Optional[str] When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to `camply_campsites.json` \"\"\" super () . __init__ ( provider = YellowstoneLodging (), search_window = search_window , weekends_only = weekends_only , nights = nights , offline_search = offline_search , offline_search_path = offline_search_path , ) self . campgrounds = make_list ( campgrounds ) def get_all_campsites ( self ) -> List [ AvailableCampsite ]: \"\"\" Search for all matching campsites in Yellowstone. Returns ------- List[AvailableCampsite] \"\"\" all_campsites = list () searchable_campgrounds = self . _get_searchable_campgrounds () this_month = datetime . now () . date () . replace ( day = 1 ) for month in self . search_months : if month >= this_month : all_campsites += self . campsite_finder . get_monthly_campsites ( month = month , nights = None if self . nights == 1 else self . nights ) matching_campsites = self . _filter_campsites_to_campgrounds ( campsites = all_campsites , searchable_campgrounds = searchable_campgrounds ) campsite_df = self . campsites_to_df ( campsites = matching_campsites ) campsite_df_validated = self . _filter_date_overlap ( campsites = campsite_df ) time_window_end = max ( self . search_days ) + timedelta ( days = 1 ) compiled_campsite_df = campsite_df_validated [ campsite_df_validated . booking_end_date <= pd . Timestamp ( time_window_end ) ] compiled_campsites = self . df_to_campsites ( campsite_df = compiled_campsite_df ) return compiled_campsites def _get_searchable_campgrounds ( self ) -> Optional [ Set [ str ]]: \"\"\" Return the Campgrounds for the Camping Search Returns ------- Optional[Set[str]] \"\"\" if self . campgrounds in [ None , []]: return None supported_campsites = set ( YellowstoneConfig . YELLOWSTONE_CAMPGROUNDS . keys ()) selected_campsites = set ( self . campgrounds ) searchable_campgrounds = supported_campsites . intersection ( selected_campsites ) if len ( searchable_campgrounds ) == 0 : campground_ids = [ f \"` { key } ` ( { value } )\" for key , value in YellowstoneConfig . YELLOWSTONE_CAMPGROUNDS . items () ] error_message = ( \"You must supply a YellowstoneNationalParkLodges supported \" \"campground ID. Current supported Campground IDs: \" f \" { ', ' . join ( campground_ids ) } \" ) logger . error ( error_message ) raise SearchError ( error_message ) logger . info ( f \" { len ( searchable_campgrounds ) } Matching Campgrounds Found\" ) for campground in searchable_campgrounds : logger . info ( f \"\u26f0 { YellowstoneConfig . YELLOWSTONE_RECREATION_AREA_FORMAL_NAME } \" f \"(# { YellowstoneConfig . YELLOWSTONE_RECREATION_AREA_ID } ) - \ud83c\udfd5 \" f \" { YellowstoneConfig . YELLOWSTONE_CAMPGROUNDS [ campground ] } ( { campground } )\" ) return searchable_campgrounds def _filter_campsites_to_campgrounds ( self , campsites : List [ AvailableCampsite ], searchable_campgrounds : Set [ str ] ) -> List [ AvailableCampsite ]: \"\"\" Filter Campsites Down to Matching Campgrounds Parameters ---------- campsites: List[AvailableCampsite] searchable_campgrounds: Set[str] Returns ------- List[AvailableCampsite] \"\"\" if self . campgrounds in [ None , []]: return campsites matching_campsites = [ campsite for campsite in campsites if campsite . facility_id in searchable_campgrounds ] return matching_campsites @staticmethod def print_campgrounds () -> None : \"\"\" Print the Campgrounds inside of Yellowstone \"\"\" log_sorted_response ( YellowstoneConfig . YELLOWSTONE_CAMPGROUND_OBJECTS )","title":"SearchYellowstone"},{"location":"reference/search/search_yellowstone/#camply.search.search_yellowstone.SearchYellowstone.__init__","text":"Initialize with Search Parameters","title":"__init__()"},{"location":"reference/search/search_yellowstone/#camply.search.search_yellowstone.SearchYellowstone.__init__--parameters","text":"Union[SearchWindow, List[SearchWindow]] Search Window tuple containing start date and End Date bool Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights) Optional[Union[List[str], str]] Campground ID or List of Campground IDs int minimum number of consecutive nights to search per campsite,defaults to 1 bool When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. Optional[str] When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to camply_campsites.json Source code in camply/search/search_yellowstone.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def __init__ ( self , search_window : Union [ SearchWindow , List [ SearchWindow ]], weekends_only : bool = False , campgrounds : Optional [ Union [ List [ str ], str ]] = None , nights : int = 1 , offline_search : bool = False , offline_search_path : Optional [ str ] = None , ** kwargs , ) -> None : \"\"\" Initialize with Search Parameters Parameters ---------- search_window: Union[SearchWindow, List[SearchWindow]] Search Window tuple containing start date and End Date weekends_only: bool Whether to only search for Camping availabilities on the weekends (Friday / Saturday nights) campgrounds: Optional[Union[List[str], str]] Campground ID or List of Campground IDs nights: int minimum number of consecutive nights to search per campsite,defaults to 1 offline_search: bool When set to True, the campsite search will both save the results of the campsites it's found, but also load those campsites before beginning a search for other campsites. offline_search_path: Optional[str] When offline search is set to True, this is the name of the file to be saved/loaded. When not specified, the filename will default to `camply_campsites.json` \"\"\" super () . __init__ ( provider = YellowstoneLodging (), search_window = search_window , weekends_only = weekends_only , nights = nights , offline_search = offline_search , offline_search_path = offline_search_path , ) self . campgrounds = make_list ( campgrounds )","title":"Parameters"},{"location":"reference/search/search_yellowstone/#camply.search.search_yellowstone.SearchYellowstone.get_all_campsites","text":"Search for all matching campsites in Yellowstone.","title":"get_all_campsites()"},{"location":"reference/search/search_yellowstone/#camply.search.search_yellowstone.SearchYellowstone.get_all_campsites--returns","text":"List[AvailableCampsite] Source code in camply/search/search_yellowstone.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def get_all_campsites ( self ) -> List [ AvailableCampsite ]: \"\"\" Search for all matching campsites in Yellowstone. Returns ------- List[AvailableCampsite] \"\"\" all_campsites = list () searchable_campgrounds = self . _get_searchable_campgrounds () this_month = datetime . now () . date () . replace ( day = 1 ) for month in self . search_months : if month >= this_month : all_campsites += self . campsite_finder . get_monthly_campsites ( month = month , nights = None if self . nights == 1 else self . nights ) matching_campsites = self . _filter_campsites_to_campgrounds ( campsites = all_campsites , searchable_campgrounds = searchable_campgrounds ) campsite_df = self . campsites_to_df ( campsites = matching_campsites ) campsite_df_validated = self . _filter_date_overlap ( campsites = campsite_df ) time_window_end = max ( self . search_days ) + timedelta ( days = 1 ) compiled_campsite_df = campsite_df_validated [ campsite_df_validated . booking_end_date <= pd . Timestamp ( time_window_end ) ] compiled_campsites = self . df_to_campsites ( campsite_df = compiled_campsite_df ) return compiled_campsites","title":"Returns"},{"location":"reference/search/search_yellowstone/#camply.search.search_yellowstone.SearchYellowstone.print_campgrounds","text":"Print the Campgrounds inside of Yellowstone Source code in camply/search/search_yellowstone.py 155 156 157 158 159 160 @staticmethod def print_campgrounds () -> None : \"\"\" Print the Campgrounds inside of Yellowstone \"\"\" log_sorted_response ( YellowstoneConfig . YELLOWSTONE_CAMPGROUND_OBJECTS )","title":"print_campgrounds()"},{"location":"reference/utils/","text":"Utils init file filter_json ( json , filters ) # Extension Method to Dictionaries, allows easy filtering Parameters # json filters Returns # object Resulting JSON Filtered Object Source code in camply/utils/api_utils.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 def filter_json ( json : dict , filters : Union [ str , List [ str ]]) -> object : \"\"\" Extension Method to Dictionaries, allows easy filtering Parameters ---------- json filters Returns ------- filtered_object: object Resulting JSON Filtered Object \"\"\" if not isinstance ( filters , list ): filters = [ filters ] object_layers = { 0 : json } try : for index , filter_layer in enumerate ( filters ): layer_index = index + 1 object_layers [ layer_index ] = object_layers [ index ][ filter_layer ] del object_layers [ index ] except KeyError as key_error : error_message = ( f \"Unable to find matching JSON Filtering | { key_error } | { filters } \" ) logger . error ( error_message ) raise KeyError from key_error return object_layers [ len ( filters )] generate_url ( scheme , netloc , path = '' , params = '' , query = '' , fragment = '' ) # Build a URL Parameters # str URL scheme specifier str Network location part str Hierarchical path str Query component str Fragment identifier Returns # str Compiled URL Source code in camply/utils/api_utils.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def generate_url ( scheme : str , netloc : str , path : str = \"\" , params : str = \"\" , query : str = \"\" , fragment : str = \"\" , ): \"\"\" Build a URL Parameters ---------- scheme: str URL scheme specifier netloc: str Network location part path: str Hierarchical path params: str Parameters for last path element query: str Query component fragment: str Fragment identifier Returns ------- url: str Compiled URL \"\"\" url_components = dict ( scheme = scheme , netloc = netloc , path = path , params = params , query = query , fragment = fragment , ) return parse . urlunparse ( components = tuple ( url_components . values ())) log_camply ( self , message , * args , ** kwargs ) # Custom Logging Notification Level for Pushover Logging Between logging.ERROR and logging.CRITICAL (45) Parameters # self: logging.Logger str Message String args kwargs Returns # None Source code in camply/utils/logging_utils.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def log_camply ( self : logging . Logger , message : str , * args , ** kwargs ) -> None : \"\"\" Custom Logging Notification Level for Pushover Logging Between logging.ERROR and logging.CRITICAL (45) Parameters ---------- self: logging.Logger message: str Message String args kwargs Returns ------- None \"\"\" notification_level = logging . INFO + 1 logging . addLevelName ( level = notification_level , levelName = \"CAMPLY\" ) if self . isEnabledFor ( level = notification_level ): self . _log ( level = notification_level , msg = message , args = args , ** kwargs ) make_list ( obj , coerce = None ) # Make Anything An Iterable Instance Parameters # obj: object coerce: Callable Returns # List[object] Source code in camply/utils/general_utils.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def make_list ( obj , coerce : Optional [ Callable ] = None ) -> Optional [ List ]: \"\"\" Make Anything An Iterable Instance Parameters ---------- obj: object coerce: Callable Returns ------- List[object] \"\"\" if obj is None : return None elif isinstance ( obj , CamplyModel ): return [ coerce ( obj ) if coerce is not None else obj ] elif isinstance ( obj , ( set , list , tuple )): if coerce is True : return [ coerce ( item ) for item in obj ] else : return list ( obj ) else : return [ coerce ( obj ) if coerce is not None else obj ]","title":"utils"},{"location":"reference/utils/#camply.utils.filter_json","text":"Extension Method to Dictionaries, allows easy filtering","title":"filter_json()"},{"location":"reference/utils/#camply.utils.filter_json--parameters","text":"json filters","title":"Parameters"},{"location":"reference/utils/#camply.utils.filter_json--returns","text":"object Resulting JSON Filtered Object Source code in camply/utils/api_utils.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 def filter_json ( json : dict , filters : Union [ str , List [ str ]]) -> object : \"\"\" Extension Method to Dictionaries, allows easy filtering Parameters ---------- json filters Returns ------- filtered_object: object Resulting JSON Filtered Object \"\"\" if not isinstance ( filters , list ): filters = [ filters ] object_layers = { 0 : json } try : for index , filter_layer in enumerate ( filters ): layer_index = index + 1 object_layers [ layer_index ] = object_layers [ index ][ filter_layer ] del object_layers [ index ] except KeyError as key_error : error_message = ( f \"Unable to find matching JSON Filtering | { key_error } | { filters } \" ) logger . error ( error_message ) raise KeyError from key_error return object_layers [ len ( filters )]","title":"Returns"},{"location":"reference/utils/#camply.utils.generate_url","text":"Build a URL","title":"generate_url()"},{"location":"reference/utils/#camply.utils.generate_url--parameters","text":"str URL scheme specifier str Network location part str Hierarchical path str Query component str Fragment identifier","title":"Parameters"},{"location":"reference/utils/#camply.utils.generate_url--returns","text":"str Compiled URL Source code in camply/utils/api_utils.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def generate_url ( scheme : str , netloc : str , path : str = \"\" , params : str = \"\" , query : str = \"\" , fragment : str = \"\" , ): \"\"\" Build a URL Parameters ---------- scheme: str URL scheme specifier netloc: str Network location part path: str Hierarchical path params: str Parameters for last path element query: str Query component fragment: str Fragment identifier Returns ------- url: str Compiled URL \"\"\" url_components = dict ( scheme = scheme , netloc = netloc , path = path , params = params , query = query , fragment = fragment , ) return parse . urlunparse ( components = tuple ( url_components . values ()))","title":"Returns"},{"location":"reference/utils/#camply.utils.log_camply","text":"Custom Logging Notification Level for Pushover Logging Between logging.ERROR and logging.CRITICAL (45)","title":"log_camply()"},{"location":"reference/utils/#camply.utils.log_camply--parameters","text":"self: logging.Logger str Message String args kwargs","title":"Parameters"},{"location":"reference/utils/#camply.utils.log_camply--returns","text":"None Source code in camply/utils/logging_utils.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def log_camply ( self : logging . Logger , message : str , * args , ** kwargs ) -> None : \"\"\" Custom Logging Notification Level for Pushover Logging Between logging.ERROR and logging.CRITICAL (45) Parameters ---------- self: logging.Logger message: str Message String args kwargs Returns ------- None \"\"\" notification_level = logging . INFO + 1 logging . addLevelName ( level = notification_level , levelName = \"CAMPLY\" ) if self . isEnabledFor ( level = notification_level ): self . _log ( level = notification_level , msg = message , args = args , ** kwargs )","title":"Returns"},{"location":"reference/utils/#camply.utils.make_list","text":"Make Anything An Iterable Instance","title":"make_list()"},{"location":"reference/utils/#camply.utils.make_list--parameters","text":"obj: object coerce: Callable","title":"Parameters"},{"location":"reference/utils/#camply.utils.make_list--returns","text":"List[object] Source code in camply/utils/general_utils.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def make_list ( obj , coerce : Optional [ Callable ] = None ) -> Optional [ List ]: \"\"\" Make Anything An Iterable Instance Parameters ---------- obj: object coerce: Callable Returns ------- List[object] \"\"\" if obj is None : return None elif isinstance ( obj , CamplyModel ): return [ coerce ( obj ) if coerce is not None else obj ] elif isinstance ( obj , ( set , list , tuple )): if coerce is True : return [ coerce ( item ) for item in obj ] else : return list ( obj ) else : return [ coerce ( obj ) if coerce is not None else obj ]","title":"Returns"},{"location":"reference/utils/api_utils/","text":"Recreation.gov Web Searching Utilities filter_json ( json , filters ) # Extension Method to Dictionaries, allows easy filtering Parameters # json filters Returns # object Resulting JSON Filtered Object Source code in camply/utils/api_utils.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 def filter_json ( json : dict , filters : Union [ str , List [ str ]]) -> object : \"\"\" Extension Method to Dictionaries, allows easy filtering Parameters ---------- json filters Returns ------- filtered_object: object Resulting JSON Filtered Object \"\"\" if not isinstance ( filters , list ): filters = [ filters ] object_layers = { 0 : json } try : for index , filter_layer in enumerate ( filters ): layer_index = index + 1 object_layers [ layer_index ] = object_layers [ index ][ filter_layer ] del object_layers [ index ] except KeyError as key_error : error_message = ( f \"Unable to find matching JSON Filtering | { key_error } | { filters } \" ) logger . error ( error_message ) raise KeyError from key_error return object_layers [ len ( filters )] generate_url ( scheme , netloc , path = '' , params = '' , query = '' , fragment = '' ) # Build a URL Parameters # str URL scheme specifier str Network location part str Hierarchical path str Query component str Fragment identifier Returns # str Compiled URL Source code in camply/utils/api_utils.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def generate_url ( scheme : str , netloc : str , path : str = \"\" , params : str = \"\" , query : str = \"\" , fragment : str = \"\" , ): \"\"\" Build a URL Parameters ---------- scheme: str URL scheme specifier netloc: str Network location part path: str Hierarchical path params: str Parameters for last path element query: str Query component fragment: str Fragment identifier Returns ------- url: str Compiled URL \"\"\" url_components = dict ( scheme = scheme , netloc = netloc , path = path , params = params , query = query , fragment = fragment , ) return parse . urlunparse ( components = tuple ( url_components . values ()))","title":"api_utils"},{"location":"reference/utils/api_utils/#camply.utils.api_utils.filter_json","text":"Extension Method to Dictionaries, allows easy filtering","title":"filter_json()"},{"location":"reference/utils/api_utils/#camply.utils.api_utils.filter_json--parameters","text":"json filters","title":"Parameters"},{"location":"reference/utils/api_utils/#camply.utils.api_utils.filter_json--returns","text":"object Resulting JSON Filtered Object Source code in camply/utils/api_utils.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 def filter_json ( json : dict , filters : Union [ str , List [ str ]]) -> object : \"\"\" Extension Method to Dictionaries, allows easy filtering Parameters ---------- json filters Returns ------- filtered_object: object Resulting JSON Filtered Object \"\"\" if not isinstance ( filters , list ): filters = [ filters ] object_layers = { 0 : json } try : for index , filter_layer in enumerate ( filters ): layer_index = index + 1 object_layers [ layer_index ] = object_layers [ index ][ filter_layer ] del object_layers [ index ] except KeyError as key_error : error_message = ( f \"Unable to find matching JSON Filtering | { key_error } | { filters } \" ) logger . error ( error_message ) raise KeyError from key_error return object_layers [ len ( filters )]","title":"Returns"},{"location":"reference/utils/api_utils/#camply.utils.api_utils.generate_url","text":"Build a URL","title":"generate_url()"},{"location":"reference/utils/api_utils/#camply.utils.api_utils.generate_url--parameters","text":"str URL scheme specifier str Network location part str Hierarchical path str Query component str Fragment identifier","title":"Parameters"},{"location":"reference/utils/api_utils/#camply.utils.api_utils.generate_url--returns","text":"str Compiled URL Source code in camply/utils/api_utils.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def generate_url ( scheme : str , netloc : str , path : str = \"\" , params : str = \"\" , query : str = \"\" , fragment : str = \"\" , ): \"\"\" Build a URL Parameters ---------- scheme: str URL scheme specifier netloc: str Network location part path: str Hierarchical path params: str Parameters for last path element query: str Query component fragment: str Fragment identifier Returns ------- url: str Compiled URL \"\"\" url_components = dict ( scheme = scheme , netloc = netloc , path = path , params = params , query = query , fragment = fragment , ) return parse . urlunparse ( components = tuple ( url_components . values ()))","title":"Returns"},{"location":"reference/utils/configure_camply/","text":"Camply Configuration Script check_dot_camply_file () # Check to see if the .camply file already exists Return the file existence status Returns # bool Source code in camply/utils/configure_camply.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 def check_dot_camply_file () -> bool : \"\"\" Check to see if the `.camply` file already exists Return the file existence status Returns ------- bool \"\"\" if isfile ( FileConfig . DOT_CAMPLY_FILE ) is True : logger . info ( \"Skipping configuration. `.camply` file already exists: \" f \" { FileConfig . DOT_CAMPLY_FILE } \" ) return True else : return False double_check ( message ) # Double check if a step should be taken within CLI Parameters # str Message to log in interactive shell Source code in camply/utils/configure_camply.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 def double_check ( message : str ) -> bool : \"\"\" Double check if a step should be taken within CLI Parameters ---------- message: str Message to log in interactive shell \"\"\" first_confirmation = Confirm . ask ( prompt = message ) if first_confirmation is True : second_confirmation = Confirm . ask ( prompt = \"Are you sure?\" ) return second_confirmation else : logging . info ( \"Okay, skipping\" ) return False generate_configuration () # Generate the Camply Configuration Config Returns # OrderedDict Dict of configuration values Source code in camply/utils/configure_camply.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def generate_configuration () -> OrderedDict : \"\"\" Generate the Camply Configuration Config Returns ------- OrderedDict Dict of configuration values \"\"\" config_dict = FileConfig . DOT_CAMPLY_FIELDS . copy () for field , field_dict in config_dict . items (): default_value = field_dict [ \"default\" ] field_note = field_dict [ \"notes\" ] if field_note is not None : rich . print ( f \"[bold blue] { field } :[/bold blue] \" f \"[bold green] { field_note } [/bold green]\" ) message = f \"Enter value for [bold blue] { field } [/bold blue]\" if default_value != \"\" : message += f \" (default: `[bold purple] { default_value } [/bold purple]`)\" logged_input = Prompt . ask ( prompt = message ) config_value = logged_input if logged_input != \"\" else default_value config_dict [ field ] = config_value return config_dict generate_dot_camply_file () # Perform the larger Dot Camply File Generation Source code in camply/utils/configure_camply.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 def generate_dot_camply_file (): \"\"\" Perform the larger Dot Camply File Generation \"\"\" logger . info ( \"Running camply configuration.\" ) logger . info ( \"This process generates a configuration file \" \"(https://github.com/juftin/camply/blob/main/docs/examples/example.camply)\" ) logger . info ( \"Do not include quotes around values\" ) logger . info ( \"To skip a configuration field or keep it as default, just press <Enter>.\" ) sleep ( 1.5 ) if isfile ( FileConfig . DOT_CAMPLY_FILE ): logger . warning ( f \".camply file already exists on this machine: { FileConfig . DOT_CAMPLY_FILE } \" ) overwrite = double_check ( \"Would you like to overwrite your \" \"[bold yellow].camply[/bold yellow] \" \"configuration file?\" ) if overwrite is False : exit ( 0 ) config = generate_configuration () if double_check ( \"Are you ready to publish this to a file at \" f \"[bold yellow] { FileConfig . DOT_CAMPLY_FILE } [/bold yellow]\" ): write_config_to_file ( config_dict = config ) logger . info ( f \"`.camply` file written to machine: { FileConfig . DOT_CAMPLY_FILE } \" ) write_config_to_file ( config_dict ) # Write the Configuration Object to a file Parameters # OrderedDict Configuration Object Source code in camply/utils/configure_camply.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 def write_config_to_file ( config_dict : OrderedDict ) -> None : \"\"\" Write the Configuration Object to a file Parameters ---------- config_dict : OrderedDict Configuration Object \"\"\" string_list = [ \"# CAMPLY CONFIGURATION FILE. \" , \"# SEE https://github.com/juftin/camply/blob/main/docs/examples/example.camply\" , \"\" , ] for config_key , config_value in config_dict . items (): string_list . append ( f ' { config_key } =\" { config_value } \"' ) string_list . append ( \"\" ) with open ( FileConfig . DOT_CAMPLY_FILE , \"w\" ) as file_object : file_object . write ( \" \\n \" . join ( string_list )) file_object . seek ( 0 )","title":"configure_camply"},{"location":"reference/utils/configure_camply/#camply.utils.configure_camply.check_dot_camply_file","text":"Check to see if the .camply file already exists Return the file existence status","title":"check_dot_camply_file()"},{"location":"reference/utils/configure_camply/#camply.utils.configure_camply.check_dot_camply_file--returns","text":"bool Source code in camply/utils/configure_camply.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 def check_dot_camply_file () -> bool : \"\"\" Check to see if the `.camply` file already exists Return the file existence status Returns ------- bool \"\"\" if isfile ( FileConfig . DOT_CAMPLY_FILE ) is True : logger . info ( \"Skipping configuration. `.camply` file already exists: \" f \" { FileConfig . DOT_CAMPLY_FILE } \" ) return True else : return False","title":"Returns"},{"location":"reference/utils/configure_camply/#camply.utils.configure_camply.double_check","text":"Double check if a step should be taken within CLI","title":"double_check()"},{"location":"reference/utils/configure_camply/#camply.utils.configure_camply.double_check--parameters","text":"str Message to log in interactive shell Source code in camply/utils/configure_camply.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 def double_check ( message : str ) -> bool : \"\"\" Double check if a step should be taken within CLI Parameters ---------- message: str Message to log in interactive shell \"\"\" first_confirmation = Confirm . ask ( prompt = message ) if first_confirmation is True : second_confirmation = Confirm . ask ( prompt = \"Are you sure?\" ) return second_confirmation else : logging . info ( \"Okay, skipping\" ) return False","title":"Parameters"},{"location":"reference/utils/configure_camply/#camply.utils.configure_camply.generate_configuration","text":"Generate the Camply Configuration Config","title":"generate_configuration()"},{"location":"reference/utils/configure_camply/#camply.utils.configure_camply.generate_configuration--returns","text":"OrderedDict Dict of configuration values Source code in camply/utils/configure_camply.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def generate_configuration () -> OrderedDict : \"\"\" Generate the Camply Configuration Config Returns ------- OrderedDict Dict of configuration values \"\"\" config_dict = FileConfig . DOT_CAMPLY_FIELDS . copy () for field , field_dict in config_dict . items (): default_value = field_dict [ \"default\" ] field_note = field_dict [ \"notes\" ] if field_note is not None : rich . print ( f \"[bold blue] { field } :[/bold blue] \" f \"[bold green] { field_note } [/bold green]\" ) message = f \"Enter value for [bold blue] { field } [/bold blue]\" if default_value != \"\" : message += f \" (default: `[bold purple] { default_value } [/bold purple]`)\" logged_input = Prompt . ask ( prompt = message ) config_value = logged_input if logged_input != \"\" else default_value config_dict [ field ] = config_value return config_dict","title":"Returns"},{"location":"reference/utils/configure_camply/#camply.utils.configure_camply.generate_dot_camply_file","text":"Perform the larger Dot Camply File Generation Source code in camply/utils/configure_camply.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 def generate_dot_camply_file (): \"\"\" Perform the larger Dot Camply File Generation \"\"\" logger . info ( \"Running camply configuration.\" ) logger . info ( \"This process generates a configuration file \" \"(https://github.com/juftin/camply/blob/main/docs/examples/example.camply)\" ) logger . info ( \"Do not include quotes around values\" ) logger . info ( \"To skip a configuration field or keep it as default, just press <Enter>.\" ) sleep ( 1.5 ) if isfile ( FileConfig . DOT_CAMPLY_FILE ): logger . warning ( f \".camply file already exists on this machine: { FileConfig . DOT_CAMPLY_FILE } \" ) overwrite = double_check ( \"Would you like to overwrite your \" \"[bold yellow].camply[/bold yellow] \" \"configuration file?\" ) if overwrite is False : exit ( 0 ) config = generate_configuration () if double_check ( \"Are you ready to publish this to a file at \" f \"[bold yellow] { FileConfig . DOT_CAMPLY_FILE } [/bold yellow]\" ): write_config_to_file ( config_dict = config ) logger . info ( f \"`.camply` file written to machine: { FileConfig . DOT_CAMPLY_FILE } \" )","title":"generate_dot_camply_file()"},{"location":"reference/utils/configure_camply/#camply.utils.configure_camply.write_config_to_file","text":"Write the Configuration Object to a file","title":"write_config_to_file()"},{"location":"reference/utils/configure_camply/#camply.utils.configure_camply.write_config_to_file--parameters","text":"OrderedDict Configuration Object Source code in camply/utils/configure_camply.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 def write_config_to_file ( config_dict : OrderedDict ) -> None : \"\"\" Write the Configuration Object to a file Parameters ---------- config_dict : OrderedDict Configuration Object \"\"\" string_list = [ \"# CAMPLY CONFIGURATION FILE. \" , \"# SEE https://github.com/juftin/camply/blob/main/docs/examples/example.camply\" , \"\" , ] for config_key , config_value in config_dict . items (): string_list . append ( f ' { config_key } =\" { config_value } \"' ) string_list . append ( \"\" ) with open ( FileConfig . DOT_CAMPLY_FILE , \"w\" ) as file_object : file_object . write ( \" \\n \" . join ( string_list )) file_object . seek ( 0 )","title":"Parameters"},{"location":"reference/utils/general_utils/","text":"Camply General Utilities make_list ( obj , coerce = None ) # Make Anything An Iterable Instance Parameters # obj: object coerce: Callable Returns # List[object] Source code in camply/utils/general_utils.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def make_list ( obj , coerce : Optional [ Callable ] = None ) -> Optional [ List ]: \"\"\" Make Anything An Iterable Instance Parameters ---------- obj: object coerce: Callable Returns ------- List[object] \"\"\" if obj is None : return None elif isinstance ( obj , CamplyModel ): return [ coerce ( obj ) if coerce is not None else obj ] elif isinstance ( obj , ( set , list , tuple )): if coerce is True : return [ coerce ( item ) for item in obj ] else : return list ( obj ) else : return [ coerce ( obj ) if coerce is not None else obj ]","title":"general_utils"},{"location":"reference/utils/general_utils/#camply.utils.general_utils.make_list","text":"Make Anything An Iterable Instance","title":"make_list()"},{"location":"reference/utils/general_utils/#camply.utils.general_utils.make_list--parameters","text":"obj: object coerce: Callable","title":"Parameters"},{"location":"reference/utils/general_utils/#camply.utils.general_utils.make_list--returns","text":"List[object] Source code in camply/utils/general_utils.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def make_list ( obj , coerce : Optional [ Callable ] = None ) -> Optional [ List ]: \"\"\" Make Anything An Iterable Instance Parameters ---------- obj: object coerce: Callable Returns ------- List[object] \"\"\" if obj is None : return None elif isinstance ( obj , CamplyModel ): return [ coerce ( obj ) if coerce is not None else obj ] elif isinstance ( obj , ( set , list , tuple )): if coerce is True : return [ coerce ( item ) for item in obj ] else : return list ( obj ) else : return [ coerce ( obj ) if coerce is not None else obj ]","title":"Returns"},{"location":"reference/utils/logging_utils/","text":"Logging Utilities for Pushover Variables get_emoji ( obj ) # Return the Right Emoji Parameters # obj: list Returns # str Source code in camply/utils/logging_utils.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def get_emoji ( obj : list ) -> str : \"\"\" Return the Right Emoji Parameters ---------- obj: list Returns ------- str \"\"\" assert isinstance ( obj , list ) if len ( obj ) >= 1 : return TENTMOJI else : return XMOJI log_camply ( self , message , * args , ** kwargs ) # Custom Logging Notification Level for Pushover Logging Between logging.ERROR and logging.CRITICAL (45) Parameters # self: logging.Logger str Message String args kwargs Returns # None Source code in camply/utils/logging_utils.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def log_camply ( self : logging . Logger , message : str , * args , ** kwargs ) -> None : \"\"\" Custom Logging Notification Level for Pushover Logging Between logging.ERROR and logging.CRITICAL (45) Parameters ---------- self: logging.Logger message: str Message String args kwargs Returns ------- None \"\"\" notification_level = logging . INFO + 1 logging . addLevelName ( level = notification_level , levelName = \"CAMPLY\" ) if self . isEnabledFor ( level = notification_level ): self . _log ( level = notification_level , msg = message , args = args , ** kwargs ) log_sorted_response ( response_array ) # Log Some Statements in a Nice Sorted way Parameters # response_array: List[str] Returns # None Source code in camply/utils/logging_utils.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def log_sorted_response ( response_array : List [ object ]) -> None : \"\"\" Log Some Statements in a Nice Sorted way Parameters ---------- response_array: List[str] Returns ------- None \"\"\" log_array = [ _generate_response_string ( obj ) for obj in response_array ] sorted_logs = sorted ( log_array ) for log_response in sorted_logs : logger . info ( log_response )","title":"logging_utils"},{"location":"reference/utils/logging_utils/#camply.utils.logging_utils.get_emoji","text":"Return the Right Emoji","title":"get_emoji()"},{"location":"reference/utils/logging_utils/#camply.utils.logging_utils.get_emoji--parameters","text":"obj: list","title":"Parameters"},{"location":"reference/utils/logging_utils/#camply.utils.logging_utils.get_emoji--returns","text":"str Source code in camply/utils/logging_utils.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def get_emoji ( obj : list ) -> str : \"\"\" Return the Right Emoji Parameters ---------- obj: list Returns ------- str \"\"\" assert isinstance ( obj , list ) if len ( obj ) >= 1 : return TENTMOJI else : return XMOJI","title":"Returns"},{"location":"reference/utils/logging_utils/#camply.utils.logging_utils.log_camply","text":"Custom Logging Notification Level for Pushover Logging Between logging.ERROR and logging.CRITICAL (45)","title":"log_camply()"},{"location":"reference/utils/logging_utils/#camply.utils.logging_utils.log_camply--parameters","text":"self: logging.Logger str Message String args kwargs","title":"Parameters"},{"location":"reference/utils/logging_utils/#camply.utils.logging_utils.log_camply--returns","text":"None Source code in camply/utils/logging_utils.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def log_camply ( self : logging . Logger , message : str , * args , ** kwargs ) -> None : \"\"\" Custom Logging Notification Level for Pushover Logging Between logging.ERROR and logging.CRITICAL (45) Parameters ---------- self: logging.Logger message: str Message String args kwargs Returns ------- None \"\"\" notification_level = logging . INFO + 1 logging . addLevelName ( level = notification_level , levelName = \"CAMPLY\" ) if self . isEnabledFor ( level = notification_level ): self . _log ( level = notification_level , msg = message , args = args , ** kwargs )","title":"Returns"},{"location":"reference/utils/logging_utils/#camply.utils.logging_utils.log_sorted_response","text":"Log Some Statements in a Nice Sorted way","title":"log_sorted_response()"},{"location":"reference/utils/logging_utils/#camply.utils.logging_utils.log_sorted_response--parameters","text":"response_array: List[str]","title":"Parameters"},{"location":"reference/utils/logging_utils/#camply.utils.logging_utils.log_sorted_response--returns","text":"None Source code in camply/utils/logging_utils.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def log_sorted_response ( response_array : List [ object ]) -> None : \"\"\" Log Some Statements in a Nice Sorted way Parameters ---------- response_array: List[str] Returns ------- None \"\"\" log_array = [ _generate_response_string ( obj ) for obj in response_array ] sorted_logs = sorted ( log_array ) for log_response in sorted_logs : logger . info ( log_response )","title":"Returns"},{"location":"reference/utils/yaml_utils/","text":"YAML Utilities for Camply read_yaml ( path = None ) # Read a YAML File Load a yaml configuration file_path (path) or data object (data) and resolve any environment variables. The environment variables must be in this format to be parsed: ${VAR_NAME}. Parameters # str File Path of YAML Object to Read Examples # database host: ${HOST} port: ${PORT} ${KEY}: ${VALUE} app log_path: \"/var/${LOG_PATH}\" something_else: \"${AWESOME_ENV_VAR}/var/${A_SECOND_AWESOME_VAR}\" Source code in camply/utils/yaml_utils.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 def read_yaml ( path : str = None ): \"\"\" Read a YAML File Load a yaml configuration file_path (path) or data object (data) and resolve any environment variables. The environment variables must be in this format to be parsed: ${VAR_NAME}. Parameters ---------- path: str File Path of YAML Object to Read Examples -------- database: host: ${HOST} port: ${PORT} ${KEY}: ${VALUE} app: log_path: \"/var/${LOG_PATH}\" something_else: \"${AWESOME_ENV_VAR}/var/${A_SECOND_AWESOME_VAR}\" \"\"\" path = os . path . abspath ( path ) pattern = compile ( r \".*?\\${(\\w+)}.*?\" ) safe_loader = SafeLoader safe_loader . add_implicit_resolver ( tag = None , regexp = pattern , first = None ) def env_var_constructor ( safe_loader : yaml . Loader , node : Any ) -> Any : \"\"\" Extracts the environment variable from the node's value Parameters ---------- safe_loader: yaml.Loader node: Any The current node in the yaml Returns ------- Any the parsed string that contains the value of the environment variable \"\"\" value = safe_loader . construct_scalar ( node = node ) match = pattern . findall ( string = value ) if match : full_value = value for item in match : full_value = full_value . replace ( \"${{ {key} }}\" . format ( key = item ), os . getenv ( key = item , default = item ) ) return full_value return value safe_loader . add_constructor ( tag = None , constructor = env_var_constructor ) with open ( path ) as conf_data : return load ( stream = conf_data , Loader = safe_loader ) yaml_file_to_arguments ( file_path ) # Convert YAML File into A Dictionary to be used as **kwargs Parameters # str File Path to YAML Returns # provider, provider_kwargs, search_kwargs: Tuple[str, Dict[str, object], Dict[str, object]] Tuple containing provider string, provider kwargs, and search kwargs Source code in camply/utils/yaml_utils.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 def yaml_file_to_arguments ( file_path : str , ) -> Tuple [ str , Dict [ str , object ], Dict [ str , object ]]: \"\"\" Convert YAML File into A Dictionary to be used as **kwargs Parameters ---------- file_path: str File Path to YAML Returns ------- provider, provider_kwargs, search_kwargs: Tuple[str, Dict[str, object], Dict[str, object]] Tuple containing provider string, provider **kwargs, and search **kwargs \"\"\" yaml_search = read_yaml ( path = file_path ) logger . info ( f \"YAML File Parsed: { Path ( file_path ) . name } \" ) provider = yaml_search . get ( \"provider\" , \"RecreationDotGov\" ) start_date = datetime . strptime ( str ( yaml_search [ \"start_date\" ]), \"%Y-%m- %d \" ) end_date = datetime . strptime ( str ( yaml_search [ \"end_date\" ]), \"%Y-%m- %d \" ) nights = int ( yaml_search . get ( \"nights\" , 1 )) recreation_area = yaml_search . get ( \"recreation_area\" , None ) campgrounds = yaml_search . get ( \"campgrounds\" , None ) campsites = yaml_search . get ( \"campsites\" , None ) weekends_only = yaml_search . get ( \"weekends\" , False ) continuous = yaml_search . get ( \"continuous\" , True ) polling_interval = yaml_search . get ( \"polling_interval\" , SearchConfig . RECOMMENDED_POLLING_INTERVAL ) notify_first_try = yaml_search . get ( \"notify_first_try\" , False ) notification_provider = yaml_search . get ( \"notifications\" , \"silent\" ) search_forever = yaml_search . get ( \"search_forever\" , False ) equipment = yaml_search . get ( \"equipment\" , None ) equipment = make_list ( equipment ) if isinstance ( equipment , list ): equipment = [ tuple ( equip ) for equip in equipment ] offline_search = yaml_search . get ( \"offline_search\" , False ) offline_search_path = yaml_search . get ( \"offline_search_path\" , None ) search_window = SearchWindow ( start_date = start_date , end_date = end_date ) provider_kwargs = dict ( search_window = search_window , recreation_area = recreation_area , campgrounds = campgrounds , campsites = campsites , weekends_only = weekends_only , nights = nights , equipment = equipment , offline_search = offline_search , offline_search_path = offline_search_path , ) search_kwargs = dict ( log = True , verbose = True , continuous = continuous , polling_interval = polling_interval , notify_first_try = notify_first_try , notification_provider = notification_provider , search_forever = search_forever , ) return provider , provider_kwargs , search_kwargs","title":"yaml_utils"},{"location":"reference/utils/yaml_utils/#camply.utils.yaml_utils.read_yaml","text":"Read a YAML File Load a yaml configuration file_path (path) or data object (data) and resolve any environment variables. The environment variables must be in this format to be parsed: ${VAR_NAME}.","title":"read_yaml()"},{"location":"reference/utils/yaml_utils/#camply.utils.yaml_utils.read_yaml--parameters","text":"str File Path of YAML Object to Read","title":"Parameters"},{"location":"reference/utils/yaml_utils/#camply.utils.yaml_utils.read_yaml--examples","text":"database host: ${HOST} port: ${PORT} ${KEY}: ${VALUE} app log_path: \"/var/${LOG_PATH}\" something_else: \"${AWESOME_ENV_VAR}/var/${A_SECOND_AWESOME_VAR}\" Source code in camply/utils/yaml_utils.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 def read_yaml ( path : str = None ): \"\"\" Read a YAML File Load a yaml configuration file_path (path) or data object (data) and resolve any environment variables. The environment variables must be in this format to be parsed: ${VAR_NAME}. Parameters ---------- path: str File Path of YAML Object to Read Examples -------- database: host: ${HOST} port: ${PORT} ${KEY}: ${VALUE} app: log_path: \"/var/${LOG_PATH}\" something_else: \"${AWESOME_ENV_VAR}/var/${A_SECOND_AWESOME_VAR}\" \"\"\" path = os . path . abspath ( path ) pattern = compile ( r \".*?\\${(\\w+)}.*?\" ) safe_loader = SafeLoader safe_loader . add_implicit_resolver ( tag = None , regexp = pattern , first = None ) def env_var_constructor ( safe_loader : yaml . Loader , node : Any ) -> Any : \"\"\" Extracts the environment variable from the node's value Parameters ---------- safe_loader: yaml.Loader node: Any The current node in the yaml Returns ------- Any the parsed string that contains the value of the environment variable \"\"\" value = safe_loader . construct_scalar ( node = node ) match = pattern . findall ( string = value ) if match : full_value = value for item in match : full_value = full_value . replace ( \"${{ {key} }}\" . format ( key = item ), os . getenv ( key = item , default = item ) ) return full_value return value safe_loader . add_constructor ( tag = None , constructor = env_var_constructor ) with open ( path ) as conf_data : return load ( stream = conf_data , Loader = safe_loader )","title":"Examples"},{"location":"reference/utils/yaml_utils/#camply.utils.yaml_utils.yaml_file_to_arguments","text":"Convert YAML File into A Dictionary to be used as **kwargs","title":"yaml_file_to_arguments()"},{"location":"reference/utils/yaml_utils/#camply.utils.yaml_utils.yaml_file_to_arguments--parameters","text":"str File Path to YAML","title":"Parameters"},{"location":"reference/utils/yaml_utils/#camply.utils.yaml_utils.yaml_file_to_arguments--returns","text":"provider, provider_kwargs, search_kwargs: Tuple[str, Dict[str, object], Dict[str, object]] Tuple containing provider string, provider kwargs, and search kwargs Source code in camply/utils/yaml_utils.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 def yaml_file_to_arguments ( file_path : str , ) -> Tuple [ str , Dict [ str , object ], Dict [ str , object ]]: \"\"\" Convert YAML File into A Dictionary to be used as **kwargs Parameters ---------- file_path: str File Path to YAML Returns ------- provider, provider_kwargs, search_kwargs: Tuple[str, Dict[str, object], Dict[str, object]] Tuple containing provider string, provider **kwargs, and search **kwargs \"\"\" yaml_search = read_yaml ( path = file_path ) logger . info ( f \"YAML File Parsed: { Path ( file_path ) . name } \" ) provider = yaml_search . get ( \"provider\" , \"RecreationDotGov\" ) start_date = datetime . strptime ( str ( yaml_search [ \"start_date\" ]), \"%Y-%m- %d \" ) end_date = datetime . strptime ( str ( yaml_search [ \"end_date\" ]), \"%Y-%m- %d \" ) nights = int ( yaml_search . get ( \"nights\" , 1 )) recreation_area = yaml_search . get ( \"recreation_area\" , None ) campgrounds = yaml_search . get ( \"campgrounds\" , None ) campsites = yaml_search . get ( \"campsites\" , None ) weekends_only = yaml_search . get ( \"weekends\" , False ) continuous = yaml_search . get ( \"continuous\" , True ) polling_interval = yaml_search . get ( \"polling_interval\" , SearchConfig . RECOMMENDED_POLLING_INTERVAL ) notify_first_try = yaml_search . get ( \"notify_first_try\" , False ) notification_provider = yaml_search . get ( \"notifications\" , \"silent\" ) search_forever = yaml_search . get ( \"search_forever\" , False ) equipment = yaml_search . get ( \"equipment\" , None ) equipment = make_list ( equipment ) if isinstance ( equipment , list ): equipment = [ tuple ( equip ) for equip in equipment ] offline_search = yaml_search . get ( \"offline_search\" , False ) offline_search_path = yaml_search . get ( \"offline_search_path\" , None ) search_window = SearchWindow ( start_date = start_date , end_date = end_date ) provider_kwargs = dict ( search_window = search_window , recreation_area = recreation_area , campgrounds = campgrounds , campsites = campsites , weekends_only = weekends_only , nights = nights , equipment = equipment , offline_search = offline_search , offline_search_path = offline_search_path , ) search_kwargs = dict ( log = True , verbose = True , continuous = continuous , polling_interval = polling_interval , notify_first_try = notify_first_try , notification_provider = notification_provider , search_forever = search_forever , ) return provider , provider_kwargs , search_kwargs","title":"Returns"}]}